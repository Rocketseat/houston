[
  {
    "id": "9400918e-4864-4330-8694-412acc036453",
    "title": "Componente: Comment",
    "transcription": "Nessa aula, então, a gente vai, graças a Deus, finalizar a parte estrutural, visual da nossa aplicação. Então, finalizar essa parte de comentários. Pra aí, a gente começar a adicionar funcionamento na aplicação. Porque, por enquanto, está tudo estático. A gente está criando apenas a interface, sem nenhum tipo de interação com o usuário. Hoje, a gente escreve aqui alguma coisa, clica em publicar, nada acontece. Então, a gente ainda tem que construir toda essa parte funcional, que vai ser a parte mais legal, talvez, desse primeiro conteúdo. Então, bora lá! Aqui dentro de componentes, então, eu vou começar criando um componente de comentário. E vou criar aqui um comment.module.css também. E aqui, eu vou criar um export function, comment, aquilo que a gente já está acostumado. Aqui dentro, pode ser uma div, por enquanto. E aí, aqui, eu vou importar, styles from comment.module.css. Dei um errinho aqui na importação. Isso aqui, às vezes, acontece. E aí, o que eu faço aqui, nesses casos, é dar um ctrl-shift-p. Aqui, eu leio um erro. Isso, ctrl-shift-p. Que é, basicamente, o script que fica rodando por baixo do VSCode. Ih, deu erro de novo, comment.module.css. Talvez, porque aqui não tem nada exportado. Deixa eu tentar botar um comment aqui. Hum, mesmo assim, deu erro. Então, vamos dar um reloadwindow aqui. Esse reloadwindow, ele recarrega o VSCode e reprocessa tudo do zero. Coment.module.css. Ah, eu criei o arquivo como TSX. É que eu estou acostumado, mais pra frente, inclusive, a gente vai ver, em usar TypeScript. Então, é JSX que a gente tem que criar aqui. Mais pra frente, a gente vai ver desse TSX. Eu já estava tentando me adiantar aqui, mas show. Agora que a gente já está com a estrutura aqui do nosso comentário, a gente vai começar a criar aqui a parte do HTML. Então, essa div aqui, ela recebe uma classNameStyles.comment. E agora, o HTML dessa parte do comentário vai ser bem chatinho, porque a gente tem, por exemplo, o avatar aqui na esquerda, que não entra dentro desse box aqui que tem o restante das informações. E aí, a gente tem esse botão aqui de aplaudir aqui embaixo, que também não entra nesse box. Então, a gente vai ter que fazer um monte de quebra aqui com algumas divs pra gente posicionar isso aqui da melhor forma. Por exemplo, se isso aqui estivesse dentro desse box, já ia facilitar ou qualquer outra coisa. Mas, bom, designer nunca quer facilitar a vida de quem desenvolve. Mas, vamos lá. A gente vai começar com a nossa imagem de avatar aqui. https://github.com.jegot3g.png O alt aqui pode ficar vazio. Aí eu vou ter uma div. Vou botar nela uma className chamada styles.commentBox, que é pra ser essa caixa aqui, cinza, onde vai estar todas essas informações aqui dentro. E aí... Ou melhor... Não, não é isso. O avatar tá aqui na esquerda. O commentBox vai ser tudo que tá... Deixa eu abrir aqui um app que eu consigo mostrar melhor. Tudo isso aqui, isso aqui vai ser o commentBox. E aí, dentro eu preciso disso aqui agora. Então, dentro do commentBox eu vou ter mais uma div que eu vou chamar de commentContent. Sei lá. Qualquer coisa assim. E abaixo do commentContent é onde eu preciso do nosso footer. O nosso footer eu quero que seja isso aqui. E aí dentro do footer aqui eu vou ter ali o nosso aplaudir. Por enquanto eu só vou escrever isso aqui. Depois a gente coloca o restante do conteúdo. Aqui dentro do commentContent a gente vai ter essa seção aqui, que vai ser o header, que tem ali o nome, quando que ele foi publicado e o ícone, e o conteúdo do comentário. Então aqui eu vou criar um header. E abaixo do header, como eu falei, eu vou ter um P, que vai ser o conteúdo do comentário. Então por enquanto eu vou copiar o texto aqui mesmo, que tava escrito ali dentro. Muito bom, Devon. Parabéns. E aí dentro do header agora eu vou ter uma seção que precisa ficar por volta aqui do nome e da data de publicação. E no final o nosso botão aqui para deletar. Então essa seção eu vou também colocar uma div, porque é a melhor maneira de eu conseguir organizar ali o alinhamento. Aqui eu vou chamar de author and time. E aí eu vou ter um strong com o autor do comentário, vou botar Diego Fernandes também. E eu vou ter um time aqui que eu posso até copiar lá do nosso post. Aqui ó, esse time aqui. Dentro aqui do nosso comentário. Só que não é publicado a uma hora. Fica tipo cerca... Cerca de duas... Fica meio estranho, né? Botar... Cerca de uma hora atrás. Eu acho que é importante esse atrás, senão a pessoa não consegue identificar. E agora, aqui depois dessa div, porém ainda dentro do header, nós teremos o nosso botão. Vou botar um title nele. Todo botão que ele é apenas um ícone, é interessante que ele não tem texto dentro dele, é importante a gente botar um title. Até para os leitores de tela saberem do que se trata esse botão. Porque o ícone ele é só visual, ele não diz nada. E aqui dentro então eu vou ter o ícone. E aí o ícone ele é um ícone de lixeira. E aí uma das dicas, se você dá um sinal de menor aqui, e começa a escrever, por exemplo, trash, que é o ícone que eu quero usar, ele já dá a opção de importar alguns ícones aqui de dentro da biblioteca Phosphor React. No nosso caso eu quero esse trash, aqui ó. E aí eu vou até botar aqui nele um size 20. E aí no footer que a gente tinha colocado apenas aplaudir, aqui eu também quero botar um botão. Esse aqui não precisa title, porque ele vai ter um texto dentro dele. Aí ele vai ter um ícone que é o thumbs up. Novamente ele já dá a opção de importar automaticamente. E a gente vai escrever aplaudir, espaço, colocar um span, e dentro botar, por exemplo, 20. Que seria o número de pessoas que aplaudiram o post. Por que eu coloquei dentro de um span esse número? Porque tem uma desgraça de uma bolinha ali, separando ele do aplaudir. Então a gente precisa ter alguma forma de colocar essa bolinha. Então eu coloquei um span, porque assim eu consigo estilizar o span e colocar essa bolinha ali através do CSS mesmo. Então a gente vai ver como fazer isso. Então agora que a gente já tem o nosso elemento do comentário aqui, a gente pode voltar lá no post. E a gente quer lá no nosso post colocar os comentários aqui abaixo do nosso formulário. Então aqui abaixo do formulário eu vou criar uma div. Vou botar nela uma class name escrita comment list. E aqui eu vou escrever sinal de menor, comment, e ele já vai dar a opção de importar aqui. Sempre que está na direita que mostra o caminho do arquivo, ele já dá a opção de auto importar o comentário. Ele já inclusive importou aqui em cima. Vou botar aqui uns 3 comentários iguais, só pra gente visualizar isso. E aí aqui no post module, como a gente criou esse comment list, eu vou estilizar essa comment list pra ter um margin top 2rem dentro do CSS do post. Salva isso aqui, voltamos no Chrome. Vamos lá ver como é que está ficando. Show! Isso aqui é a nossa seção de comentários por enquanto. Então a gente criou toda a estrutura aqui dos comentários, e agora o que falta realmente é a nossa estilização."
  },
  {
    "id": "a2477dd5-3a83-428e-8f57-264eac4ad513",
    "title": "Validando formulário",
    "transcription": "O que a gente vai fazer nessa aula é a validação aqui do nosso formulário, porque hoje se eu não preencho nada aqui e clico em publicar, ele até cria um comentário vazio aqui. Isso pode dar muito problema aqui no nosso app. Uma das coisas que a gente pode fazer é, aqui na nossa text area, colocar simplesmente uma propriedade required e usar a validação do próprio HTML. E essa propriedade required, ela recebe novamente, né, false ou true. Mas como eu quero que ela seja obrigatória, no React, quando uma propriedade recebe valor true, eu não preciso informar o valor, eu posso botar apenas required. Salvo isso, volto. Se eu voltar aqui no formulário e tentar publicar, ele já dá a validação aqui, please fill out this field. Então, ele não permite a gente mais enviar o formulário sem nada preenchido. Mas a gente pode melhorar isso aqui, né? Primeiro porque a mensagem está em inglês. Segundo ponto que a gente pode melhorar, será que a gente não pode bloquear o usuário de clicar no botão de publicar, caso ele não tenha preenchido nenhum texto aqui? A gente pode. Então vamos lá, vamos começar melhorando a mensagem aqui, antes de mais nada. Existe um método, uma propriedade que a gente pode passar para a text area ou para inputs que se chama onInvalid. Essa propriedade onInvalid, ela é chamada sempre que o HTML identificar que a gente tentou realizar um submit do formulário, só que o texto desse campo aqui era inválido, ou seja, estava vazio nesse caso porque a gente está validando apenas se ele é obrigatório. E aí eu posso colocar aqui uma função, por exemplo, handleNewCountry, newCountryInvalid. Vou criar essa função aqui em cima, vou criar junto com essa outra aqui. E aqui dentro, agora, dessa newCountryInvalid aqui, a gente recebe como... eu posso dentro dela colocar, por exemplo, um console.log event para a gente ver o que está chegando aqui dentro. Então eu salvo isso, venho aqui no meu Chrome, venho no especial elemento, no console, e agora quando eu clicar em publicar, olha só, ele disparou um evento aqui dentro e a gente tem algumas informações. Estrusted, bubbles, cancelBubble, cancelable, compose, tem várias e várias e várias informações aqui dentro. Uma das informações mais importantes que a gente tem aqui é o target. O target é sempre qual é o elemento que aconteceu aquele evento. Nesse caso aqui foi a nossa textArea. Se a gente for navegar aqui na textArea e ver todos os métodos e variáveis que ela tem, aqui embaixo a gente vai encontrar que ela tem um método chamado... os métodos eu acho que eles vão ficar lá embaixo, aqui no prototype, que se chama setCustomValidity, está vendo? Isso aqui é o método que a gente usa para identificar, para falar qual é a mensagem de validação que a gente quer para essa textArea. Então, se eu fizer event.target, ou seja, eu estou buscando a textArea, .setCustomValidity e passo uma mensagem, esse campo é obrigatório, salvo isso aqui agora, volto... Se eu venho aqui agora e clico, por exemplo, em publicar, esse campo é obrigatório, então a gente já conseguiu mudar o texto. Mas aqui a gente deixou um problema, se eu vier agora, depois de já ter dado o erro na validação, digitar alguma coisa e tentar publicar, ele continua dando o erro. Por quê? Porque agora, quando o usuário digitar alguma coisa no campo, ou seja, aqui, onChange, handleNewCommentChange, eu estou chamando essa função aqui, quando ele voltar a digitar alguma coisa no campo, eu preciso voltar aqui o setCustomValidity para um valor vazio. Se eu não me engano, é um valor vazio mesmo, deixa eu até garantir isso aqui, para eu não falar besteira. Isso, um valor vazio. Isso aqui, eu não sei muito por quê, sendo bem sincero, me parece um comportamento estranho, mas é o comportamento padrão dessa API do JavaScript. Quando eu anotei que aquele input estava com erro, dando esse setCustomValidity, eu preciso, em algum momento, falar, olha, não está mais com erro, o usuário já digitou alguma coisa. Então, esse aqui é o formato da gente fazer isso. Salvo isso aqui agora, volto aqui, não sei por que o meu computador está fazendo isso, mas eu venho aqui agora, vamos testar. Deu erro, se eu digito alguma coisa agora, eu publico. Pronto, já funcionou. Vamos lá, vamos testar todos os casos. Se eu digito, deu erro. Ou melhor, se eu publico, deu erro. E eu digito, só que eu tiro a digitação de novo e clico em publicar. Beleza, está funcionando em todos os casos aqui. E agora, será que tem alguma forma de eu evitar que o usuário clique no botão de publicar, caso o campo não esteja preenchido? Tem. Como que a gente pode fazer isso? Olha só, você lembra que aqui nesse componente, e aí uma das coisas que eu faço, quando eu estou dando manutenção, é fechar algumas dessas funções assim. Fica mais claro para a gente visualizar o código. Então você lembra que a gente criou aqui em cima um estado, e esse new comment text aqui, ele armazena em tempo real tudo o que é digitado dentro do campo de texto da nossa textarea. E eu não sei se você lembra que eu falei aqui que o React, toda vez que a gente muda o estado, que uma propriedade do componente muda, ou que um componente pai ao componente que eu estou criando aqui, o código, sofre uma renderização, todos esses três casos vão fazer com que o código, o conteúdo desse componente, seja recalculado, ou seja, aconteça uma nova renderização. Como que a gente pode testar isso? Olha só, se eu colocar um console.log aqui dentro do componente post, para ele fazer um console.log na variável new comment text, olha que interessante isso. A gente está falando aqui que toda vez que altera o conteúdo da textarea, eu vou aqui e eu mudo o valor da variável new comment text, ou seja, eu estou alterando o estado. E como eu falei, toda vez que a gente altera o estado, ou seja, a cada digitação, nesse caso, o código que está dentro dessa função do componente, é recalculado, é executado de novo. Ou seja, se eu vier aqui no Google Chrome, cada vez que eu digitar aqui, ele dá o console.log. Porque cada vez que eu estou digitando aqui, eu estou alterando o meu estado. E cada vez que o estado altera, o código que está dentro dessa função post é executado de novo. Isso abre para a gente muitas possibilidades novamente. Uma delas, por exemplo, é fazer o seguinte, eu posso vir aqui no meu botão de publicar e falar para ele o seguinte, olha só, eu quero que você esteja desabilitado, e aqui o disabled, ele recebe true ou false. Se eu quero que ele esteja sempre desabilitado, só passar disabled. Nesse caso, eu quero que ele esteja desabilitado somente quando o new comment text, que é o texto digitado no textarea, ponto length, ou seja, o tamanho do texto digitado na textarea, seja zero. E aqui eu posso até quebrar a linha para ficar mais fácil. Vamos testar isso aqui agora? Olha só, eu vou salvar, volto no Google Chrome, vou dar um F5, e agora, aqui no publicar, não está acontecendo nada, nem a validação, ou seja, o campo está como desabilitado. Eu posso inclusive inspecionar aqui o nosso footer e o nosso button, e eu vou ver que ele está disabled aqui. A partir do momento que eu digito qualquer coisa, por exemplo, a letra O, o disabled sumiu. Porque o React, quando ele percebeu que foi alterado, o new comment text, ele reexecutou, renderizou o componente de novo, e viu, opa, o new comment text agora não está mais vazio. E com isso, eu não preciso mais mostrar aqui o disabled. E aí a gente pode, inclusive, aqui no nosso post.module.css, onde eu estilizo aqui o nosso botão, onde é que está? Comment form, footer, button. Eu posso fazer o seguinte, quando o botão... Cara, eu não sei o que está dando com o meu teclado. Ele está dando uns bugs muito loucos, cara. Vamos lá. Quando o meu botão aqui estiver disabled, eu quero que a opacidade desse botão seja de 0.7, por exemplo. Inclusive, o hover aqui em cima, eu quero que ele só funcione caso o botão não esteja disabled. Então, o button do type submit, deixa eu até copiar esse type submit aqui também. Quando ele não estiver disabled e o usuário fizer um hover, aí sim a cor de fundo vai mudar. E aqui, quando ele estiver disabled, eu vou mudar o cursor dele para not allowed. Salvo. Volto no Chrome e agora vamos testar. Olha só, está vendo que o botão agora está com a opacidade mais baixa. Eu passo o mouse por cima, ele já dá que eu não tenho permissão de executar, de clicar nesse botão. E aqui a gente pode fazer mais uma melhoria, só para a gente finalizar essa aula com chave de ouro. Uma das coisas que eu gosto de fazer muito aqui dentro do React, quando a gente tem essas comparações, essas condicionais dentro aqui do HTML, digamos, da nossa página, eu prefiro remover isso aqui, o conteúdo do disabled, eu venho aqui em cima, antes do return, e eu crio uma variável. Por exemplo, is new comment input empty, ou apenas is new comment empty, e aí eu coloco esse valor aqui. E aí eu copio esse is new comment empty e coloco aqui dentro do disabled. O resultado é exatamente o mesmo. É exatamente o mesmo. Mas para quem está dando manutenção nesse código e chega, por exemplo, aqui nesse botão, é claro que aqui é um exemplo simples, mas poderia ser um exemplo muito mais complexo. E chega para dar manutenção aqui, a pessoa vai ler esse código e ela olha, opa, esse botão aqui pode ficar desabilitado. Quando que ele fica desabilitado? Ah, ele fica disabled quando o novo comentário está vazio. Ótimo, é muito mais fácil de entender. Isso é clean code. A gente deixar o nosso código mais fácil de dar manutenção. Por isso, criar essas variáveis auxiliares que não vão deixar o teu código nada menos performático, mas vão deixar ele muito mais legível, é altamente recomendado, não só no React, mas aqui nesse caso a gente vai aprender sempre a criar as nossas aplicações com as melhores práticas. Legendas pela comunidade Amara.org"
  },
  {
    "id": "75dbfca9-cb5a-41c1-9748-2d924c9d3fb0",
    "title": "Introdução",
    "transcription": "Fala, David! Nesse módulo a gente vai construir um projeto React conhecendo os principais fundamentos por trás dessa ferramenta. A gente vai conhecer conceitos importantes do React como componentes, propriedades, estado, imutabilidade e também falar sobre até coisas mais complexas como os React Hooks, como funciona fluxo de renderização do React, sobre como trabalhar com estilização dentro do React e também sobre TypeScript aplicado, claro, no contexto também dessa ferramenta. Claro que a gente não poderia aprender nenhum desses conceitos sem desenvolver um projeto prático. Por isso até, vamos voltar aqui, a gente vai dar uma olhadinha no projeto que a gente vai desenvolver, que é basicamente esse projeto do Ignite Feed. Esse projetinho aqui é muito simples, visualmente, digamos assim, mas ele vai ser suficiente para a gente aprender tudo o que a gente precisa para começar no React com o pé direito. Então ele é um projeto basicamente que imita uma rede social, então a gente tem vários posts aqui na nossa timeline, a gente vai poder realizar comentários dentro desses posts, através desses comentários a gente vai poder dar o like, ali no caso a gente chamou de aplaudir, a gente vai poder também remover os posts e o mais legal aqui é que esse projetinho, ele está totalmente aqui já configurado também com tudo o que a gente vai precisar de Style Guide, então o Jonas aqui já deixou pronto para a gente tudo o que a gente vai utilizar de fontes, de tamanhos, de cores, assim fica muito mais fácil também os hovers aqui nos botões, assim fica muito mais fácil também na hora da gente estar criando a nossa interface. Então agora é claro, bora codar!"
  },
  {
    "id": "33160a91-6214-4412-b71b-358ec953d666",
    "title": "Bundlers & Compilers",
    "transcription": "Algo muito comum quando a gente está começando a trabalhar com React e com essas tecnologias mais modernas de desenvolvimento com JavaScript é a gente perceber que nem sempre os browsers vão suportar a versão mais atualizada do JavaScript que a gente está utilizando. Por isso foram criadas várias ferramentas para fazer com que a gente consiga converter o nosso código que está escrito no JavaScript mais moderno para versões específicas do JavaScript que rodam em ambientes específicos. Então, por exemplo, nem sempre o código que você vai criar da sua aplicação vai conseguir rodar na versão do Internet Explorer 10, por exemplo, e na maioria das vezes até você nem quer isso, mas é só um exemplo hipotético que eu estou dando aqui. Então, por mais que os browsers, principalmente o Chrome, Firefox, eles estejam extremamente atualizados, na maioria das nossas aplicações a gente vai precisar utilizar um conceito que são os bundlers e compilers. E aí talvez alguns nomes desses aqui você já deve ter ouvido falar. Vamos começar pelos compilers. Compilers nada mais são do que compiladores de código. Compiladores de código nada mais é do que ferramentas que convertem o nosso código de um formato para outro. E o que é esse um formato para outro? Geralmente é por isso, eu quero executar o meu código React dentro do navegador, o navegador não suporta ainda algumas funcionalidades do JavaScript, então eu preciso converter esse meu código de uma versão mais atualizada do JavaScript para uma versão que o navegador entenda. E aí o compiler mais famoso que você já deve conhecer é o Babel, dentro do ecossistema do JavaScript. Então o Babel, ele pega exatamente como ele está mostrando aqui, sintaxes mais atualizadas do JavaScript e converte para alguma sintaxe que seja compatível com todos os browsers, ou com a maioria dos browsers em si. Beleza, já entendemos o que são compilers, por enquanto a gente não precisa instalar nem testar nenhum desses compilers, até porque a gente especificamente não vai estar utilizando o Babel daqui para frente, porque existem outras alternativas que são mais rápidas. E aí a gente precisa falar sobre bundlers, o que são bundlers? Uma das coisas muito comuns quando a gente está trabalhando com arquivos, com aplicações escritas em JavaScript, é a gente querer distribuir a nossa aplicação em múltiplos arquivos, então eu não quero escrever toda a minha aplicação JavaScript em um único arquivo, eu quero que eu tenha vários arquivos JavaScript, esses arquivos vão se importando, digamos assim, um referenciando o outro, e eu vou completando, criando a minha aplicação com vários arquivos JavaScript que quando somados montam a funcionalidade da minha aplicação. Isso é o mais comum, a gente tem isso em toda a linguagem, mas, pasme, isso não é algo suportado nativamente pelos browsers, ou pelo menos não era até um bom tempinho atrás. E para isso a gente precisava utilizar ferramentas que fossem capazes de pegar todos os arquivos JavaScript da minha aplicação e no final converter para um único arquivo JavaScript, porque o browser só suportava carregar arquivos JavaScript através da tag script, e esse arquivo JavaScript não poderia importar outros arquivos. Então a gente sempre teve muita limitação relacionada à parte de importação e exportação de arquivos ali dentro do browser, que a gente chama dos ECMAScript Modules. E aí para isso a gente precisava utilizar os famosos bundlers, e o bundler mais famoso aí que você deve conhecer é o Webpack. Se você não conhece também não tem nenhum problema, mas a gente pode ver aqui até a partir da própria imagem, a gente tem vários arquivos, inclusive o Webpack suporta a gente importar arquivos dos mais diferentes formatos, então veja que ele tem aqui um arquivo JavaScript, um Handlebars, e aqui um arquivo importa o outro, e no final o Webpack converte tudo isso para arquivos únicos. Então aqui é um único arquivo JavaScript, gera os assets aqui das imagens e arquivos CSS aqui da minha aplicação, então basicamente ele faz esse processo de entender as importações e exportações entre o nosso arquivo e gerar um arquivo de bundle, que é o que a gente fala. Então isso aqui é o bundler, e isso aqui é o nosso compiler. E aí, desde uns dois anos para cá, os browsers começaram a dar indícios de suporte para importação de arquivos de forma nativa, e até se a gente procurar aqui nesse site que eu gosto bastante de utilizar, que é o Can I Use, ele fala um pouquinho sobre o que os browsers já suportam ou não suportam de sintaxes do JavaScript. Se a gente procurar aqui por ES Modules, que é a forma que os browsers têm de conseguir importar e exportar arquivos, vamos dar uma olhadinha aqui para baixo. Aqui, JavaScript Modules via Script Tag. Basicamente isso que a gente tem que olhar. A gente vai ver que a grande maioria dos browsers, como por exemplo o Edge, Firefox, Chrome, Safari, Opera, Safari no iOS, os browsers de Android, Samsung, e só não o Internet Explorer, já suportam a importação de módulos, de importação e exportação entre arquivos JavaScript. E com isso a gente não precisa mais utilizar o Webpack, mantendo o nosso fluxo de desenvolvimento e o processo de construção da nossa aplicação muito mais performático, porque executar o Webpack, na grande maioria das vezes, demora bastante tempo, porque ele acaba sendo bem lento. E aí, a gente tem outras alternativas para criar o nosso projeto, como por exemplo o Vite, o Snowpack, que são as bibliotecas mais famosas. E qual é a grande diferença de utilizar um Vite, comparado a utilizar um Webpack da vida? O Vite, ele utiliza por padrão os ECMAScript Modules nativos. Ele até fala aqui, on-demand file serving over native ECMAScript Modules, ou seja, não é necessário bundling, que é o que a gente tem ali com o Webpack em si. E o próprio Vite, ele já faz o processo de compiling de forma automática, ou seja, ele não precisa do Babel também para executar. Ele tem um compilador interno do próprio Vite, então a gente não precisa utilizar uma ferramenta externa de compilação. O Snowpack é muito parecido com o Vite, mas o Vite acabou ganhando mais apreciação da comunidade, digamos assim. Então, a gente vai acabar utilizando o Vite para a construção da grande maioria das nossas aplicações React, e a gente vai ver que ele é extremamente performático. Mas essa aula especificamente era mais para você realmente entender o porquê que sempre houve a necessidade de nós utilizarmos compiladores e utilizarmos bundlers para as nossas aplicações front-end. Compiladores, porque nem todos os browsers e todos os ambientes que a gente vai executar nossa aplicação vão entender o código que a gente está colocando na sua última versão. E os bundlers, por causa do suporte, ou o não suporte, digamos assim, dos browsers, a entender importações entre arquivos JavaScript. E aí, com o Vite, a gente acaba tendo o melhor dos dois mundos utilizando os ECMAScript módulos nativos aqui dos próprios browsers, e assim a gente consegue construir as nossas aplicações front-end de uma maneira mais performática e com menos estresse durante o desenvolvimento."
  },
  {
    "id": "37bda6b3-c79d-4ad6-8cd6-9be510cca7a9",
    "title": "Entendendo closures no React",
    "transcription": "Nessa aula eu quero te mostrar um funcionamento do React que, pela primeira vez que você vê, talvez você fique... Tá, pera, o que que tá acontecendo? Mas eu quero te explicar o porquê que isso acontece. Aqui na nossa funcionalidade de like, a gente tá aumentando o número de likes usando likeCount mais 1. Ou seja, eu pego o número de likes atual e adiciono mais 1. O que que deveria acontecer com o meu número de likes se eu fizer isso aqui? Executar esse código duas vezes. O que vem na sua cabeça provavelmente é... O número de likes deve aumentar de 2 em 2. Certo? Vamos salvar isso aqui. Voltamos aqui no Google Chrome. Dom F5. Clico em Aplaudir. E aumentou 1 like. Clico de novo. Aumentou 2 likes. Não, peraí Diego, eu vou resolver isso aqui. Agora sim. Por que que o número de likes tá aumentando apenas de 1 em 1? Aqui é importante a gente entender sobre o que que tá acontecendo por baixo dos panos no React quando a gente chama a função pra alterar algum estado. Vamos lá. Vou criar um markdown aqui só pra gente falar sobre esse funcionamento de closures no React. Como essas funções e a execução das funções funciona dentro do React. Então imagine que eu tenha um componente, certo? Chamado comment, ali como eu falei. Dentro desse comment eu tenha o número de likes. Começa em 0. E eu tenho ali uma função que adiciona um like. Que faz setLikes, likes mais 1. Isso aqui você não precisa copiar. É só realmente pra gente visualizar o que que tá acontecendo. Quando eu chamo essa função setLikes aqui, passando likes mais 1, pro React, por baixo dos panos, é a mesma coisa que eu tivesse chamando a minha função comment, ou seja, executando a minha função comment, mesmo ela sendo um componente. E aqui, claro, ela recebe as propriedades. Aqui eu vou até deixar pra gente exemplificar. Então ela recebe as propriedades. Porém é como se o React passasse como um segundo parâmetro. É claro que não é isso, não é necessariamente o segundo parâmetro. Ele passa de outras formas. Mas é como se ele passasse pra execução dessa nova função um novo valor pro estado. Ou seja, opa, a pessoa chamou aqui o setLikes, likes mais 1. Antes era 0, agora é 1. Então passei o novo valor de likes aqui pro meu componente. Agora o React já sabe que esses likes aqui são 1. Ou seja, o React executou essa função num primeiro momento com o número de likes como sendo 0. Ou seja, a variável likes aqui era 0 no primeiro momento. Quando eu dou o setLikes, ele criou o componente de novo, agora com o valor 1. Correto? Se eu tenho esse código aqui duplicado, o que acontece? Num primeiro momento que eu executei o meu componente em tela, que eu renderizei o meu componente em tela, e eu executei o setLikes, likes mais 1, o likes aqui é 0. Quando eu executei essa função aqui, o React criou um outro contexto separado, onde ele cria uma nova versão do componente, com o likes sendo 1, que foi o que eu aumentei. Porém, nesse contexto anterior de execução, o likes continua sendo 0. Essa função aqui que eu estou chamando, ela está executando no mesmo contexto da função anterior, da execução anterior. Ou seja, o likes aqui vai continuar sendo 0. Inclusive se eu voltar aqui no comment, por exemplo, e aqui antes eu der um console.log likeCount, por exemplo, você vai ver que isso aqui vai retornar 0, não vai retornar 1. Deixa eu dar um F5, claro. Veja que ele retornou 0 aqui do lado. Por quê? Porque quando eu chamo a função de alterar o estado, é como se o React criasse um outro contexto para a execução desse componente, só que todo o código que eu executo aqui, logo após eu alterar o estado, eu ainda estou trabalhando com o contexto anterior. Então, uma das coisas que a gente tem que cuidar bastante é, muitas vezes, quem está iniciando, cai nesse problema de tentar utilizar o valor atualizado de uma variável do estado logo após atualizar esse valor. Só que isso sempre vai me trazer o resultado antigo, o valor antigo. Diego, quais soluções que eu tenho para lidar com esse problema? Você tem duas soluções aqui. Por exemplo, uma delas é você armazenar essa conta em uma variável. Por exemplo, new likeCount é igual a likeCount mais 1. E aí você altera aqui para new likeCount. E aí, aqui embaixo, se eu der um console.log agora em new likeCount, eu não vou ter mais 0, e sim 1. Porque agora eu estou criando uma variável, e a variável, sim, diferente do estado, ela tem esse valor atualizado ali naquele contexto. E aí, se eu chamar o set likeCount de novo, dando o new likeCount mais 1, agora sim a gente atualiza de 2 em 2. Isso aqui é uma solução. Outra solução é, o React permite que, ao invés de a gente simplesmente fazer um likeCount mais 1 aqui, passando qual que é o novo valor do nosso estado, a gente passe para esse set likeCount, ou para qualquer outra função de atualização do estado, uma função. Dessa forma. E aqui, de dentro dessa função, eu devo retornar o novo valor. No caso, likeCount mais 1. Tá, Diego, quer dizer que isso aqui vai resolver se eu chamar isso aqui duas vezes? Então, vai resolver? Vai subir para 2? Não, não é isso que vai resolver. O que o React permite pra gente quando eu coloco uma função aqui dentro, é eu acessar o valor mais recente do likeCount como um argumento dessa função. Então, eu consigo pegar o valor mais recente, aqui eu posso chamar ele de state, ou como você preferir, é porque likeCount aqui já está sendo usado, eu não vou botar mais uma vez likeCount, mas vou chamar de state. E esse state, ele vai me devolver qual que é o valor de likeCount mais atual. É como se ele criasse uma fila de atualizações. E agora, se eu usar state aqui no lugar de likeCount, e clicar em aplaudir, a gente vai de 2 em 2. Isso aqui é muito importante no React, e aqui já fica um ensinamento. Anota aí. Sempre que você for atualizar uma informação, e essa informação depende do valor que ela tinha anteriormente, ou seja, depende dela mesma, é sempre legal fazer a atualização usando esse padrão de funções. Eu vou remover isso aqui agora, porque isso aqui foi, claro, só para exemplificar. Eu vou deixar o código dessa forma, porque para atualizar o valor de likes, eu sempre preciso do valor anterior de likes. Nesse caso, é legal a gente usar esse padrão aqui de função."
  },
  {
    "id": "a8bae03e-76b9-4ab5-9468-8cf8a752a38e",
    "title": "Introdução",
    "transcription": "Olá, beleza? Bem-vindo a mais um módulo aqui do Ignite. Poxa, eu estou muito ansioso, com muita expectativa ao todo o conteúdo desse módulo, que você vai ver ao longo de várias, 30, mais de 30 aulas. Que, cara, é muito legal o que a gente vai criar aqui nas próximas aulas. A gente vai construir um Design System do total zero, entender para que serve um Design System e, claro, colocar a mão na massa construindo o nosso Design System, toda a parte de documentação com Storybook. Mas, apesar desse módulo ser sobre Design System, tem algo que você vai aprender dentro desse módulo, que é um aprendizado muito importante para toda a sua carreira como Dev, que é um conhecimento super importante, que é sobre Monorepo. A gente vai aprender tudo como utilizar todo um ferramental para a construção de Monorepo e você vai entender o que são Monorepos aqui dentro desse módulo. A gente vai utilizar ferramentas como TurboRepo, Chainset, TS-UP, a gente vai usar o próprio NPM Workspaces. A gente vai criar muita coisa legal e aprender muito conceito novo aqui dentro desse módulo. E lá no final, na última aula, você vai ver como vai ficar incrível todo o processo automatizado de publicação dentro do NPM, basicamente de cache dentro das GitHub Actions, de publicação da nossa documentação dentro do GitHub Pages. Vai ser muito massa tudo o que a gente vai construir daqui para frente. E o mais massa é que depois a gente vai usar esse Design System que a gente vai construir aqui ao longo desse módulo para construir novos projetos aqui dentro do Ignite. Então, tem muita coisa massa. A gente se vê até o final, acompanhe até o final dessas aulas. E depois não esquece, claro, de deixar um feedback lá na comunidade, me mandar lá uma mensagem do que você achou desse conteúdo. Eu vou ficando por aqui. Claro, bora para o código."
  },
  {
    "id": "56366667-8a99-46eb-bf34-b33f5be1661c",
    "title": "API routes no Next.js",
    "transcription": "Quando a gente estava aprendendo o que é Next, aqui através desse lindo diagrama, você aprendeu que uma aplicação Next é dividida em, na verdade, duas camadas. Essa terceira camada aqui, que é a nossa API, na verdade, ela pode acabar nem existindo, e na verdade nem faz parte da aplicação Next. Mas essas duas camadas aqui estão presentes em toda a aplicação Next. É um servidor Node, um serviço server-side, e a parte front-end, a parte visual, o React, tudo o que está sendo visualizado ali pelo usuário. E aí talvez, só talvez, quando você viu sobre esse diagrama e viu que sempre que a gente roda uma aplicação Next, a gente está rodando junto um servidor Node, um serviço em Node, talvez você pensou, bom, se eu estou rodando um servidor Node junto com a minha aplicação Next, será que eu posso ter rotas, assim como num back-end? Rotas que retornam dados de um banco de dados, por exemplo? Rotas que fazem ações que um back-end tradicional faria, como autenticação, lidar com banco de dados, envio de e-mail, qualquer coisa assim? Sim, a gente pode ter isso no Next. E apesar de talvez não ser o mais aconselhado para todo tipo de projeto, para muitos tipos de projetos e para alguns tipos de funcionalidades, faz sentido a gente ter rotas back-end dentro do nosso front-end. E isso se dá principalmente em casos onde ou a gente não tenha essa camada, a gente não tem uma API externa, e aí a gente pode criar algumas rotas back-end aqui para fazer funcionalidade simples, mesmo que com acesso ao banco, envio de e-mail, até autenticação, ou quando a gente tem alguma funcionalidade que a gente quer incluir na nossa aplicação, que ela precisa executar pelo lado do servidor, mas ela é algo específico da web, do aplicativo web da nossa aplicação. E aí a gente coloca aqui também, porque se a gente coloca essa funcionalidade aqui, ela acabaria atrapalhando outros clientes mobile, ou outros clientes iOS, Android, uma API pública, que não estão rodando no contexto de aplicação web. Então, por exemplo, se você vai criar autenticação com Google, OAuth, essas coisas assim, são coisas que elas... a forma de você criar isso é muito específico do ambiente onde o usuário está rodando a sua aplicação. E você vai precisar ter coisas rodando pelo server-side. Então, são coisas que, por exemplo, vale a pena colocar aqui nesse servidor Node, porque não faz sentido colocar aqui no server-side, porque não faz sentido colocar aqui na sua API, porque isso não é feito da mesma forma em outros clientes, no iOS, no Android, por aí vai. Então, são só um pouquinho de conceitos, mas eu vou te mostrar como isso funciona na prática. Para eu criar rotas na minha aplicação, que elas são acessadas, elas são disponibilizadas aqui por esse servidor Node, basta aqui na pasta Pages eu criar uma pasta API. E aqui eu posso criar uma rota, por exemplo, chamada hello.ts, e não tsx agora, porque dentro dessas rotas não vai código JSX, não vai componente React. E aqui de dentro basta eu devolver uma função que recebe rec, res, assim como é um express da vida, lá no Node, e que devolve uma resposta. Por exemplo, res.json message hello world. Fácil assim. Salvo isso aqui agora. Vamos rodar um npm run dev. E agora, se eu acesso localhost 3000 api barra hello, pronto, já está aqui a nossa message hello world. E todo o código que roda aqui dentro, ele é um código server-side. Ou seja, aqui dentro não preciso me preocupar com dados sensíveis, por exemplo. Eu posso fazer acesso ao banco, eu posso usar uma secret key da vida que dá acesso a informações confidenciais da minha conta do Stripe. Posso fazer o que eu quiser aqui dentro. Como eu estou usando TypeScript, é aconselhado que eu faça a tipagem desse rec e desse res. Então, basta eu botar dois pontos aqui. A gente vai usar o next API request. E aqui, next API response, que está aqui embaixo. E aí o meu VS Code deu uma leve enfartada novamente. Logo ele volta, eu acredito. A gente espera, não tem problema o VS Code. Tome o tempo que quiser. Tranquilo, vai na fé. Não sei o que o VS Code faz às vezes, mas é isso. Basicamente, agora duplicou, perfeito. Mas basicamente esse aqui é o código que a gente espera, o código já tipado. O VS Code morreu de novo, tranquilo. Meu computador quase não tem processamento, não tem não. Tranquilo, está acabando a memória do computador. Tenho certeza que é isso. Mas, beleza. Agora que a gente já está com esse código, a gente vai utilizar essas rotas API aqui para conseguir fazer algumas operações acontecerem pelo lado do servidor, porém operações que são baseadas em ações do usuário. Porque até então a gente viu aqui que nas páginas da nossa aplicação, a gente até consegue executar com o getStaticProps ou getDiversideProps, códigos que vão rodar pelo lado do servidor, por essa camada do Node, e que a gente pode fazer chamadas sensíveis para API e tudo mais. Só que tudo isso aqui, tanto getStaticProps quanto getDiversideProps, eles executam somente no carregamento da página, somente no primeiro loading da página. Se eu precisar executar alguma ação pelo Diverside, pelo lado do servidor, ou seja, algo sensível que venha através de uma ação do usuário, um clique de um botão, qualquer coisa assim, não tem como eu usar o método getStaticProps ou getDiversideProps. Nesse caso, eu preciso criar essa rota API que a gente chama no Next de API Roots. Então, bora lá."
  },
  {
    "id": "b92056a9-4df6-4d34-915f-168306223b3f",
    "title": "O que é um Design System?",
    "transcription": "Bora lá então para a nossa primeira aula relacionada a Design Systems aqui dentro do React. E antes de mais nada, vamos entender um pouquinho o que são Design Systems e por que eles são utilizados. Principalmente quando empresas grandes ou empresas com times grandes possuem vários projetos front-end sendo construídos por vários squads, é muito comum que o layout das aplicações acabe fugindo de padrões que a gente quer que sejam seguidos em todas as aplicações, para que o usuário no final das contas não perceba essa transição entre várias aplicações e que ele perceba que sempre o mesmo tipo de layout, os mesmos espaçamentos, fontes e cores são utilizadas entre todos esses layouts. Mas é muito comum dentro tanto da área de design quanto dentro da área de programação, como eu falei, quando a gente tem vários squads trabalhando em vários projetos, que muitas vezes esses padrões não são seguidos e a gente acaba tendo algumas mínimas alterações e diferenças entre esses vários layouts. E é aí que surge esse conceito de Design System. O Design System, na verdade, é uma documentação dos padrões que a gente segue entre o layout de várias aplicações dentro da nossa empresa. E é importante dizer o que é o Design System e o que não é um Design System. O Design System é todo e qualquer componente ou elemento visual que pode ser compartilhado entre qualquer aplicação da empresa. Então, não é basicamente uma biblioteca de UI components ou uma biblioteca de UI kit. Então, o que eu quero dizer com isso? É muito comum a gente pensar que a gente vai incluir no nosso Design System qualquer componente que a gente possa ter em mais de uma aplicação. Mas não é esse o conceito. O conceito de Design System é a gente incluir dentro desse Design System somente elementos visuais, os quais podem ser reaproveitados em qualquer aplicação da nossa empresa. E aí, se a gente tem elementos visuais que a gente entende que não podem ser compartilhados em qualquer aplicação da nossa empresa, aí a gente cria um UI kit. Então, vamos dar um exemplo aqui. Por exemplo, dentro da Rocketseat, a gente tem o nosso Design System, que é o Andromeda. No Andromeda, a gente vai encontrar, por exemplo, coisas que são muito específicas, que podem ser realmente compartilhadas entre qualquer aplicação da Rocketseat. Então, aqui a gente vai ver, por exemplo, Avatar. A gente vai ver um Dropdown, por exemplo. A gente vai ver a parte de Toe Tip, quando a gente passa o mouse aqui em cima. A gente vai ver a parte de Modal. Então, são vários elementos que podem ser compartilhados em qualquer tipo de aplicação. Concorda comigo? Esses elementos que eu te mostrei aqui, eles podem entrar em uma aplicação que é um painel de administração. Eles podem entrar em uma aplicação que é um front-end para o usuário final, uma aplicação da sala de aula ou qualquer coisa assim. Ou seja, eles podem ser compartilhados em qualquer tipo de aplicação. Existem outros elementos, se a gente abrir a aplicação da própria Rocketseat, por exemplo, que a gente pode até pensar que poderiam fazer parte do Design System, mas não fazem. Por exemplo, esse menu aqui em cima, onde tem o logo da Rocketseat, tem também a navegação aqui no meio. Aqui na direita, alguns ícones, alguns botões e tal. A gente pode até ter esse menu em duas aplicações aqui dentro da Rocketseat. Mas, se eu entendo que esse menu aqui não faz sentido para qualquer aplicação dentro da Rocketseat, não faz sentido ele estar no Design System. O Design System é uma convenção e a gente só coloca dentro do Design System elementos visuais que podem ser utilizados em qualquer aplicação dentro desse contexto. E aí, no futuro, a gente pode ter vários UI Kits menores, que são conjuntos de componentes reaproveitáveis entre aplicações. Então, se eu percebo que duas aplicações estão usando esse mesmo menu, com o logo, com a navegação no meio, com o mesmo estilo, a gente pode criar um UI Kit, por exemplo, chamado, por exemplo, Backoffice, que ele tem vários elementos visuais compartilhados em aplicações que são do tipo Backoffice, ou seja, aplicações de painel de administração. E isso eu posso ter também vários outros UI Kits compartilhados para eu instalar esses pequenos pacotes de componentes entre as minhas aplicações. Mas então, nessa primeira aula, eu queria muito te mostrar o que são Design Systems e o que não são Design Systems. E aí, é bom entender que Design System não é algo específico de código. Design System é algo que nasce por uma dor, principalmente, lá dentro de design. Assim como na programação, é muito comum a gente ter vários squads de designers trabalhando em vários projetos diferentes e a gente ter elementos visuais que são semelhantes e a gente não conseguir seguir esse padrão visual entre esses vários layouts que a gente tem na nossa aplicação. É por isso que Design System nasce dessa definição de padrão de desenho, desde design, e ele vem e toca a programação. E o que a gente vai ver aqui nesse módulo, principalmente, é como que a gente trabalha com essa parte de Design System dentro do código, especificamente, utilizando toda a parte de documentação, acessibilidade. A gente vai criar o Design System, claro, do total zero, usando bastante ferramentas legais e mostrando como que a gente aplica isso dentro do código, trazendo um layout lá do Figma para dentro de uma convenção de Design System, entendendo o que são esses componentes que a gente consegue reaproveitar em qualquer aplicação e vai ser show de bola a gente criar esse projeto. É bom entender também e usar como referência vários Design System que existem de outras empresas. Então, por exemplo, a Microsoft tem a Fluent Design System. A gente pode procurar também a Uber, tem um Design System muito legal para a gente olhar. A própria Apple também tem um Design System. Deixa eu lembrar, Uber Design System, eu não sei se o deles é aberto. BaseWeb, acho que é isso aqui. BaseWeb.design, exatamente. Aqui é Uber, como eles usam React, eles também codaram em React, mas a gente consegue ver aqui, esse aqui é o Design System do próprio Uber, mas a gente tem aqui, por exemplo, o Design System da Microsoft, que aí ele não é só puro código, ele nasce como um Design System, como eu falei, que vem desde a parte da concepção do desenho. O Design System não necessariamente é a parte codada no final das contas, são os componentes no final das contas, porque o Design System, ele precisa ser algo que viva mesmo sem a programação, que é algo que viva somente na área de design. Então, é muito comum o Design System, muitas vezes, as empresas terem Design System seguido pelos designers e não necessariamente implementado no código no final das contas, porque o Design System, no final das contas, precisa ser implementado tanto na aplicação web, quanto na aplicação mobile, quanto numa aplicação que não necessariamente vá para a web nem para a mobile. Então, tudo isso precisa ser reaproveitado entre vários elementos, por isso, como eu falei, o Design System, ele nasce no design e depois ele é convertido para código."
  },
  {
    "id": "26970725-5ab8-49e2-8775-86d7d75a9b17",
    "title": "Configuração do ESLint",
    "transcription": "O que a gente vai fazer agora é criar uma configuração do ESLint, também compartilhada aqui para todos os pacotes. Então, eu vou criar mais uma pastinha aqui dentro, chamada ESLintConfig. Aqui, eu vou acessar essa pasta novamente, npm init –y. Aqui dentro do package.json, a gente vai novamente remover algumas coisas que eu não preciso. Então, eu vou colocar aqui arroba ignite-ui –eslint-config. Não vou precisar nada disso. A licença aqui boto MIT. Private, como sendo true. E aqui, a única diferença que vai ter nesse pacote dos demais, é que esse aqui eu vou passar um main, como sendo o arquivo index.js, que eu vou configurar até aqui, que vai ser o arquivo principal da nossa configuração do ESLint. E aqui dentro desse pacote, eu vou instalar duas dependências como desenvolvimento, que é o ESLint e o rocketseat –eslint-config, ambas como dependências de desenvolvimento. Então, vamos guardar aqui agora. Eita, já fez a instalação? Por que ele não apareceu aqui? But no workspace folder present. Em filter set. Isso aqui provavelmente é por causa do próprio workspaces do npm. Bom, não sei porque ele deu esse erro. Não deveria ter dado esse erro, na verdade. Mas, tudo bem. Talvez eu não tinha salvo o arquivo? Não sei. Mas show. Rodei aqui agora, já instalou as duas dependências. E agora, dentro do arquivo index.js, a gente vai simplesmente escrever module exports extends, que é a config aqui do nosso ESLint, arroba rocketseat –eslint-config –react. Salvo aqui agora. E agora, a gente vai nos outros pacotes importando esse pacote em si. Então, aqui no pacote react, eu vou importar o eslint-config. No pacote tokens, também. No tsconfig, não precisa, porque são só arquivos JSON em si. Agora, aqui no pacote react, a gente vai criar um arquivo de configuração do eslint. E aí, você pode botar a extensão que preferir, eslint-js, JSON. Eu, particularmente, prefiro JSON, porque o VSCode acaba colocando um IntelliSense pra gente. Então, quando é JSON, ele mostra todas as opções que a gente pode botar no eslint. Ele também traz uma documentação quando a gente passa o mouse, então é legal. E aqui eu vou botar extends, e eu vou simplesmente passar o nome do projeto. Então, ignite-ui-eslint-config. Salvo aqui agora. Copiamos esse arquivo, e dentro do tokens também. A gente pode dar um paste, e pronto, já está o arquivo lá dentro. E agora, a gente pode fazer um lint geral em todo o projeto. Então, o que a gente vai fazer aqui agora? Eu vou criar, dentro do pacote react e do pacote tokens, um script de lint. Então, ele vai simplesmente executar eslint, dentro da pasta src, todos os arquivos que terminam com TS. E daí, poderia botar o X dessa forma, ou assim, também funciona. Pegaria qualquer arquivo que termina com TS, e aí pode ter qualquer coisa depois do TS, né? Como, por exemplo, um X. E aí, eu vou botar a opção fix, pra ele rodar o fix automaticamente, caso seja possível. E aí, dentro de tokens, vou fazer o mesmo processo. E agora, venho aqui no pacote de tokens, e vou rodar npm run lint. Rodou o lint aqui dentro. React version was set to detect in the slint plugin react settings, but the react package is not installed. Beleza, não tem problema, é normal, o pacote de tokens não tem react mesmo. E agora, a gente vai no pacote react, npm run lint, aqui também, e ele faz todas as alterações automaticamente. E agora, a gente pode verificar se eu tento botar um ponto e vírgula, ele já sinaliza pra mim, como eu estou usando o VS Code aqui, ele já não deixa aspas duplas, ele já evita também, então ele já está usando aqui o nosso padrão de slint que a gente usa aqui dentro da Rocket."
  },
  {
    "id": "f78c132f-092a-411d-b791-1eb0906835d7",
    "title": "Criando app em Storybook",
    "transcription": "O que a gente vai fazer nessa aula é criar nossa aplicação no Storybook. O Storybook, caso você não conheça, é uma aplicação que permite a gente documentar componentes do front-end. E esses componentes podem ser componentes de um design system, como a gente está fazendo aqui, que são componentes mais isolados, como botões, textos, ou até componentes completos que intercalam, ou melhor, que unem vários desses componentes menores, como, sei lá, cabeçalhos, formulários completos. E a ideia principal do Storybook é que pessoas que, inclusive, nem codam, pessoas, por exemplo, do time de design e produto, possam conseguir manipular os componentes e ver se eles estão funcionando da maneira com que eles eram propostos. Inclusive, dentro do Storybook, a gente consegue adicionar vários add-ons, vários plugins, para testar algumas coisas comuns que a gente precisa testar em layout, no design. Por exemplo, a parte de acessibilidade, a gente consegue fazer também testes de interação. Então, integrar o Storybook junto com o Jest ou com o Cypress, por exemplo, para simular operações e interações do usuário com aquele componente e visualizar se o retorno daquele componente traz o esperado. Então, tem muita coisa que dá para a gente fazer com o Storybook. E a gente vai, basicamente, começar criando a nossa aplicação Storybook para depois começar a integrar os nossos componentes lá dentro. E, por padrão, o Storybook, até se a gente entrar na própria documentação dele, a gente vai criar o nosso... Por padrão, quando a gente cria um projeto no Storybook, é recomendado pela documentação que a gente crie o projeto Storybook a partir de um projeto já existente. Seja esse projeto existente em React, Vue ou qualquer coisa assim. Porque assim o Storybook vai identificar automaticamente o tipo do projeto para ver se é um projeto React, Vue, Angular, Svelte ou qualquer coisa assim. E ele vai criar toda a estrutura. Porém, aqui no caso do meu design system, eu prefiro que a documentação, no caso, esse projeto do Storybook, ele fique isolado, que ele não fique junto com o código do nosso React. Assim, a gente consegue ter dois pacotes separados e um dia, caso eu queira mudar, por exemplo, a ferramenta de documentação ou queira mudar algo, por exemplo, dentro do meu pacote React, eles não estão unidos e assim fica muito mais fácil a gente fazer essa alteração. Então, o que eu vou fazer? Eu vou começar entrando aqui na pasta Packages e eu vou criar uma pasta Docs, que é onde vai ficar a nossa documentação. E aqui dentro eu vou criar o nosso projeto com o Storybook. Para criar o nosso projeto, eu vou executar o comando npsqs, sb ou Storybook, os dois vão dar na mesma, init, aqui eu vou passar uma opção, traço, traço, builder, como sendo storybook, barra, builder, vit. Por quê? Por padrão, o Storybook, ele utiliza, atualmente, pelo menos enquanto eu estou gravando esse vídeo, ele utiliza o webpack por baixo dos panos, junto com o Babel para fazer a parte de compilação do nosso código. Porém, a gente já sabe que o vit é muito mais rápido para fazer isso, então, porque ele usa o sbuild por baixo dos panos. Então, o Storybook permite a gente configurar qual que é o builder da nossa aplicação, ou seja, qual que é a ferramenta que vai ficar responsável por fazer a conversão do código do TypeScript para o JavaScript e por aí vai. Então, aqui a gente vai selecionar o builder, vit. Aqui eu vou passar também type React, para falar que eu quero, basicamente, que ele configure o Storybook para um projeto React. Aqui a gente pode ter outros types, caso a gente queira. E aí, o último ponto aqui é para eu usar o npm. Como eu tenho o yarn instalado também aqui na minha máquina, ele, por padrão, iria utilizar o yarn, mas aqui eu boto um //use npm, ele vai instalar também todas as dependências usando o npm. Short bola, a gente vai dar um Enter aqui agora e vamos aguardar a instalação. Essa instalação aqui pode demorar um pouquinho, então, a gente vai aguardar um pouquinho ela fazer. E aí, depois que o Storybook criar aqui o projeto, a gente vai, na verdade, também adicionar algumas coisas a mais aqui. Eu já vou te falar para ele conseguir rodar, porque algumas dependências que a gente precisa no nosso projeto, essa instalação não traz automaticamente. Aqui ele fez uma pergunta, ele detectou que eu estou usando uma versão do npm 8 e ele fala que o Storybook ainda não é compatível, porque o Storybook usa algo que a gente não usa nas novas versões do npm, que são as Peer Dependencies. Não tem problema esse erro aqui, então, aqui eu vou dar, simplesmente, um não, para ele não criar um arquivo ali, falando que é para usar o npm em uma versão anterior. E aí, como eu falei, aqui agora, dentro do package.json do Storybook, ele traz algumas dependências instaladas, porém, a gente vai instalar algumas dependências a mais aqui dentro da pastinha docs. Então, quais são essas dependências? Eu vou começar instalando o vit, que a gente vai precisar instalar, e aqui eu vou instalar ele como uma dependência de desenvolvimento. E eu vou instalar, também, o arroba-vitjs-plugin-react. A gente vai aguardar isso aqui ser feito a instalação. Show! Agora, com a instalação feita, dentro aqui da pasta docs, eu vou criar um arquivo de configuração do vit. Então, é legal, porque como eu estou usando o builder do vit, a gente consegue fazer as customizações do vit, assim como a gente faria em qualquer outro projeto. Aqui dentro, eu vou passar, simplesmente, //reference-types-vit-client. Isso aqui é para o TypeScript entender que eu estou usando o vit, e ele liberar para a gente algumas tipagens globais que existem dentro do contexto do vit, como, por exemplo, o import.meta, que não tem, comumente. Mas tudo bem. A gente vai importar, também, o plugin de React aqui dentro, que é o vitjs-plugin-react. E a gente vai importar, de dentro do próprio vit, o define-config. E aqui, a gente vai, simplesmente, exportar o define-config com a opção plugins. E dentro, aqui, de cochetes, a gente vai usar o plugin react, que a gente importou lá em cima. Então, faz a ordem aqui de importação. E pronto! A nossa configuração do vit, aqui, já está pronta. Além disso, no nosso pacote, aqui, de documentação, a gente vai importar, ou melhor, a gente vai instalar o react, e, também, a gente vai instalar o react-dom aqui dentro. Vou aguardar essa instalação. Vamos aguardar aqui um pouquinho. Cannot resolve dependency. React, peer, show de bola. Como eu estou usando o npm 8, o que acontece? O storybook, quando eu instalei o storybook, aqui, no storybook react, ele usa uma feature que a gente tinha nas versões antigas do npm, talvez você lembre, que eram as peer dependencies. As peer dependencies, elas eram dependências que a gente colocava dentro de um pacote, que elas não eram instaladas no momento que aquele pacote era instalado, mas, mesmo assim, elas eram obrigatórias. E aí, o usuário tinha que instalar essas dependências no projeto dele. Mas essas peer dependencies, elas não são nem mais suportadas aqui pelo próprio npm. Então, por exemplo, react, react-dom aqui, eu vou precisar instalar elas como dependências comuns aqui dentro do storybook. A gente não precisa nem se preocupar em ser dependências de desenvolvimento. E show de bola, a gente já fez toda a instalação. Aí, uma coisa que eu recomendo é que, às vezes, essa instalação do vit aqui, ela dá uma bugada quando a gente instala o vit dentro de um monorepo. Então, por causa do repositório de cache do vit, tem até uma issue aqui dentro do que eu estava acessando aqui, deixa eu ver se eu consigo achar. Aqui, tem uma issue até da instalação do vit3 dentro de um monorepo e tudo mais. Então, o que eu recomendo que vai fazer funcionar 100% das vezes? Deleta a pasta node-modules que tem aqui dentro da pasta docs, só para garantir, e deleta a pasta node-modules lá na raiz do seu projeto. E agora, vem aqui e roda um npm install novamente para ele fazer a instalação de todas as dependências do total zero e ele organizar ali o diretório de cache do vit certinho onde que ele precisa estar. Pronto. Agora, feito isso, a gente vai rodar o storybook para ver se ele está funcionando 100%. Então, o comando que a gente tem para rodar o storybook aqui, por enquanto, é storybook, e a gente tem um comando de build storybook. Eu só vou trocar esse comando aqui para ser dev e esse aqui para ser apenas build, para não ficar vários nomes diferentes. Aqui eu também vou trocar o nome do projeto para igniteui-docs e vou trocar a licença para mit. Vou salvar isso aqui agora e a gente vai rodar o npm run dev dentro do nosso projeto aqui de documentação. A porta 6006 não está available. Deve estar rodando uma outra versão do storybook. Deixa eu fechar aqui. Acho que era isso. Vamos rodar de novo. Aguardar aqui um pouquinho. Beleza. Já começou a rodar. E pronto. Já está aqui o nosso storybook rodando. Ele traz algumas páginas por padrão aqui. São até páginas bem bonitas que a gente pode utilizar mais para frente para criar uma introdução para a nossa documentação aqui do nosso design system. Mas o mais importante, na verdade, não é isso. O mais importante está aqui embaixo, que são esses componentes. Então, a gente pode começar a ver que aqui, por exemplo, já vem previamente criada uma documentação de um botão. Então, aqui dentro dessa documentação de botão já traz automaticamente alguns tipos de botão. Então, botão primário, secundário, botão large, botão small. Então, a gente pode ver que a gente consegue, dentro do storybook, criar sub-documentações, digamos assim, para vários tipos diferentes de botão. E aqui eu tenho essa aba docs, que é uma documentação geral do botão. E aí aparecem todos os tipos de botão aqui dentro. Tudo dentro da mesma documentação. Inclusive, aqui dentro do canvas, aqui embaixo em controls, eu consigo controlar propriedades do meu botão, que são propriedades, claro, do próprio componente no React. Então, o primary, por exemplo, false ou true. Consigo botar uma label diferente. Então, aqui eu consigo trocar para enviar, por exemplo. Consigo trocar a cor de fundo. Então, posso botar aqui um hexadecimal da maneira que eu preferir. O tamanho do botão. E aqui eu tenho actions, que são formas de a gente acoplar loggers, digamos assim, um console log da vida, quando o usuário fazer alguma ação com o botão. Então, aqui no caso, ele configurou apenas uma action, que é o clique do botão. Então, quando eu clico no botão, aparece exatamente o que eu fiz ali naquele botão, o evento nativo do HTML de clique. E a aba de interações é o que eu tinha falado antes. A gente consegue integrar o storybook com alguma ferramenta que provoca uma interação no componente, como Cypress ou Playwright ou qualquer coisa assim, para fazer uma interação e mostrar como esse componente funcionaria caso o usuário estivesse trabalhando com ele. É claro que no botão não tem muita coisa o que fazer, mas imagine, por exemplo, um formulário completo. Aqui a gente poderia botar dentro dessa aba de interações, por exemplo, uma interação para preencher os campos e dar um submit. Então, ele ia lá, faria todo o preenchimento automatizado, bem legal. E aqui a gente tem alguns componentes maiores, como, por exemplo, o header, que ele tem duas variações. Um header logado, logged in, e um header que a pessoa não está logada. E novamente, pela documentação, consigo visualizar tudo isso aqui dentro. E aí a gente tem também uma página completa, que aí integra o header, integra botões e integra toda a parte do conteúdo da página. E a gente também consegue visualizar a documentação. É claro que a gente não vai utilizar nada disso, a gente vai deletar tudo isso e vai usar os nossos próprios componentes, mas já é legal para a gente ter uma visão de tudo o que a gente pode fazer dentro do Storybook."
  },
  {
    "id": "4d033e2d-e589-4dce-9c36-2aca773437bd",
    "title": "Story: Button",
    "transcription": "Nessa aula o que a gente vai fazer é usar o componente que a gente criou lá dentro do pacote React, que é esse componente de botão aqui. Bom, a gente está usando esse app, na verdade eu vou até tirar esse app aqui, vou exportar apenas esse botão aqui, só pra gente utilizar esse componente dentro do Storybook. E depois que realmente o jogo vai conversar aqui, a gente vai criar todos os componentes da nossa aplicação, do nosso Design System, e documentar eles aqui dentro do Storybook. Mas, vamos lá. Aqui dentro do Storybook, como eu falei, ele tem essa pastinha Stories, que já traz, na verdade, várias coisas aqui dentro. O que eu vou fazer? Pronto. Deletei a pasta Stories inteira. Eu vou criar uma pasta Source aqui dentro. E aí agora dentro de Source eu vou criar uma pasta Stories. E aqui dentro eu vou criar a nossa primeira Story. A Story é uma documentação, a gente pode entender assim que o Storybook se chama. Então o Storybook, sendo um livro de histórias, a gente vai criar a nossa primeira Story, que é o botão ponto, a gente coloca sempre a extensão Stories.tsx, como a gente está usando aqui TypeScript, sempre com TSX. E aí o que eu vou fazer? Aqui dentro da pasta ponto Storybook, a gente tem um arquivo main.js, que ele traz algumas configurações importantes. A configuração mais importante é que ele fala pra procurar as Stories aqui dentro de ponto, ponto, barra, Stories. E agora não é mais isso, é src, barra, Stories. E aqui também src, barra, Stories. A gente está usando tudo TSX, você pode botar da maneira que preferir. Eu vou botar aqui apenas arquivos que são TSX. E pronto. A gente vai salvar. Não tem mais muita configuração pra fazer aqui dentro. E agora, no nosso botão Stories aqui, a gente vai começar configurando a nossa primeira Story do nosso botão. O que a gente vai fazer agora, né? Aqui dentro do meu package.json, a primeira coisa que eu vou fazer é aqui em independências, eu vou referenciar o meu pacote ignite-ui, barra, react. Eu já vou também colocar aqui o ignite-ui, barra, tokens, que a gente vai utilizar aqui dentro também. Eu vou utilizar também dentro o meu ignite-ui, barra, eslint-config, porque eu também vou usar o eslint aqui dentro pra fazer o linting desses arquivos TSX. Então, eu vou salvar isso aqui agora, vou cancelar a execução aqui do meu storybook, vou rodar um npm install só pra ele fazer a referência desses pacotes internos aqui dentro da minha documentação. E aí aqui, eu já vou criar dentro de docs, um arquivo eslint-rc.json. Dentro dele, a gente vai fazer mais ou menos o que a gente fez nos outros. Então, é um extends ignite-ui, barra, eslint-config. Vou salvar ele aqui agora. A gente pode ver que no vit, ele já começou a rodar o eslint. Então, agora a gente bota aspas duplas, ele já converte pra aspas simples. E agora, aqui dentro desse button stories, eu posso já importar o meu botão que vem de dentro de ignite-ui, barra, react. Aqui, se eu der um ctrl espaço, ele tá como app ainda, porque eu fiz a alteração lá no projeto react, mas eu não rodei a build. Então, o que eu vou fazer? Eu vou abrir aqui uma outra abinha, vou lá no meu projeto react, e eu vou rodar npm run dev. O dev, ele vai basicamente rodar a build e vai ficar também observando qualquer alteração que eu faça no meu pacote react e vai gerar a build de novo. Agora, se eu venho aqui e der um ctrl espaço, eu vou ter que instalar de novo, talvez. Às vezes, ele se perde um pouco aqui nas importações, mas se eu clico aqui, tá aqui o declare const button. Deixa eu ver se ele tá na exportação. Ó, button, tá certinho. É só porque, realmente, às vezes ele se perde. Mas aqui, agora, já encontrou o button. Tá certinho. E agora, o que a gente vai fazer aqui dentro? Pra eu criar minha primeira story, eu preciso importar de dentro de storybook react duas carinhas, o story object e o meta. Isso aqui são duas tipagens do TypeScript, então a gente pode trocar pra import type, caso a gente queira, ou deixar import mesmo, como é uma documentação, não tem tanta necessidade de a gente ficar cuidando disso. Mas aqui de dentro, a gente precisa exportar, como default, um objeto. E aí, primeira coisa é o título, que é o título da página desse story. E a gente vai botar como button. Aqui, a gente vai passar qual que é o nosso componente dessa story, que é o nosso button, que a gente tá importando aqui dentro do react. E aí, eu importei esse story object aqui, porque eu posso, basicamente, como isso aqui é um objeto, e eu dou um ctrl espaço, ele não traz nenhum autocomplete aqui, eu posso fazer uma tipagem desse objeto aqui como sendo meta. E agora, se eu venho aqui e dou um ctrl espaço, ele traz quais são os parâmetros que eu posso passar pra essa configuração aqui dentro. Por enquanto, eu não vou passar nada. Eu vou, simplesmente, exportar dessa forma, e vou rodar o storybook aqui pra gente ver se tá funcionando. Eu já falo sobre esse outro story object aqui que a gente vai utilizar. Beleza, deixa eu dar uma olhadinha. Ele falou que... Deixa eu ver, a gente deve ter errado alguma coisa aqui. E aí, todos os arquivos... Stories.tsx, tá certinho. Nome, Stories.tsx. O que será que eu errei aqui? Deixa eu tentar olhar com calma. Stories, tá tudo certo. Bom, ele não conseguiu identificar aqui o meu story. Então, o que eu vou fazer? Dentro da pasta node modules, eu tenho esse cache que tem dentro o storybook. Eu vou tentar apagar o cache, e vou rodar o storybook aqui de novo pra ele gerar o cache do zero. Às vezes, algum cache ali não permitiu ele encontrar o nosso story. Ah, só que não encontrou o nosso componente de novo. Strange. Isso aqui não é, provavelmente. Deixa eu tentar entender. O que eu acho que eu tenho que fazer é o seguinte, tá? Essa configuração aqui, na verdade, ela acaba não definindo o story em si. O que acontece? Isso aqui eu acho que ele funciona como uma configuração global. Eu fui tentar fazer por partes aqui, algo que eu nunca faço nos meus projetos. Mas, além da gente definir essa configuração global do nosso botão, a gente precisa exportar uma variação do nosso botão. E aí, geralmente, a gente começa com a variação primary, que é, digamos, o botão primário. Todo componente precisa ter pelo menos uma variação, mesmo que aquele componente tenha apenas um visual. E essa variação a gente vai chamar de primary. É aqui que a gente vai usar o nosso story object. Então, eu vou declarar que a tipagem desse primary aqui é story object. E aí, aqui de dentro, eu vou retornar simplesmente um objeto vazio. E aí, vamos ver. Agora sim, olha só. Já apareceu o nosso botão lá dentro com a nossa variação primary aqui dentro. E ele apareceu aqui com um background verde e tal, porque, sei lá, foi o que a gente jogou lá dentro da nossa estilização. Mas, como agora a gente está rodando o npm run dev aqui na direita, a gente pode trocar a nossa background color aqui, por exemplo, para Ignite 300, salvar, e ele já troca aqui automaticamente, porque ele roda a build de novo. Então, a gente consegue, inclusive, deixar esse botão mais bonito. Então, botar um border zero aqui, por exemplo. Aqui falta um conteúdo no botão. Então, aqui dentro do meu botão stories, eu vou criar, por exemplo, duas variantes. O primary e o secondary, para a gente começar a visualizar como que isso funciona. Então, veja que agora eu tenho primary e secondary. Dentro dos dois aqui, eu posso passar args. Os args são propriedades. Então, se eu passo aqui, por exemplo, children enviar, quando eu volto aqui para o botão primary, veja que ele tem enviar escrito dentro dele. Cada informação que eu envio aqui dentro do args é uma propriedade que vai ser enviada para aquele componente. Como eu coloquei o args apenas dentro do primary, o meu secondary não vai ter children. A menos que, como eu falei, eu coloque esses args na minha configuração global. Tudo que eu tenho nesse objeto principal aqui, que está como exported, como default, ele vai herdar em ambas, em todas as variações que eu tiver aqui dentro. Então, veja que agora os dois botões, ele tem o texto enviar ali dentro. E aí, como eu falei, eu posso ir customizando. Então, a gente poderia aqui, por exemplo, o padding. Eu achei que está muito pequeno, muito grande em cima. Então, eu boto dois em cima e quatro dos lados. Posso customizar aqui o font-weight para ser bold. A color do texto para ser white. E aqui a gente pode customizar o nosso botão. Acho que o border-radius ficou um pouquinho grande. Vou botar small aqui. E a gente pode ir customizando o nosso botão da maneira que a gente quiser. E aí, eu vou mostrar rapidinho, antes da gente finalizar essa aula, a questão de variantes, como eu falei. O stitches tem um comportamento interno que se chama de variance. Então, toda parte que a gente utiliza algum style aqui dentro, seja um botão ou qualquer coisa assim, a gente tem algo aqui dentro que a gente chama de variance. E a gente pode dar o nome que a gente quiser aqui dentro. Então, o nome da variante aqui nesse caso, eu vou chamar como variante mesmo. E não confunda, porque aqui é o nome da propriedade. Poderia ser type, só que o botão já tem type. Poderia ser color, mas só que geralmente, sei lá, color. Eu vou botar aqui para ser mais fácil, vou botar size. Então, a gente vai ter um botão de size small. Aqui não precisa das aspas. E a gente pode ter um big. O que vai mudar? No small, eu vou deixar um font-size 12. Ou melhor, vou botar um font-size 14. E vou deixar esse padding aqui. No big, eu vou aumentar o padding. Vou botar um 3 por 6 e vou aumentar o font-size para 16. Vou tirar o padding daqui de cima. O font-size já não estava sendo setado. E aqui embaixo, eu vou setar uma opção que o Stitcher permite, que é a minha default variance. Que é o seguinte, qual que é o size padrão quando ele não for informado para esse botão? Pode ter um padrão e pode não ter um padrão e ser obrigatório o usuário informar. Então, aqui eu vou falar que o size, por padrão, já vai trazer para a gente que as duas opções são big e small. Eu vou botar que o size padrão é small. Então, eu salvo isso aqui agora. E veja que legal. Agora, lá dentro do meu botão Stories, eu consigo criar, por exemplo, esse aqui é o primary. E aí eu vou criar uma variante chamada big. Então, essa variante big, eu vou passar para ela um argumento que é o meu size e ele vai ser big. Salvo aqui agora. Volto lá para dentro do meu botão. A gente pode ver que o primary está pequeninho ali. Quando eu clico em big, agora ele aumentou o botão. E eu consigo, inclusive, trocar aqui o size por volta dos controles, de big para small, por exemplo. E aqui é um texto, por enquanto, porque ele não conseguiu identificar que isso aqui são apenas duas opções. E aí uma outra coisa interessante é que quando a gente vem aqui em ARDS, por exemplo, e eu tiro o size e dou um ctrl espaço, ele não traz para a gente que o botão tem uma propriedade chamada size. Então, a gente tem que ficar adivinhando, digamos assim. Para a gente melhorar essa inteligência do editor, o que a gente pode fazer é, lá no nosso botão, a gente exportar também daqui de dentro uma tipagem chamada button props. E aí a gente pode falar, olha, esse botão aqui pode receber um size, que é small ou big. A gente pode, aqui do nosso componente, do nosso story, importar essas button props e passar aqui como um generic, tanto no meta quanto no meu story object aqui das minhas variantes. E agora, quando eu salvo aqui, pode... Tem, sim, às vezes ele dá uma bugada aqui, tá? Quando eu atualizo. Deixa eu ver se eu exportei de lá de dentro. Tá exportado, tá. É só porque realmente ele deve ter dado uma bugadinha. Deixa eu fechar aqui e abrir de novo. Tá ali, button props. Aí, ó. Às vezes ele dá uma bugada, mas não tem problema, tá? Agora, olha só. Quando eu tiro o size daqui do control espaço, ele já aparece que eu tenho size, ó. E quando eu vou botar o valor, ele já aparece que eu tenho as únicas opções big e small. Só que, como a gente está usando stitches, dá para a gente deixar isso aqui ainda mais fácil, tá? Para eu não precisar ficar falando, olha, eu tenho size, small e big, porque o stitch já sabe disso, né? Já está aqui, ó, size, small e big. O que a gente pode fazer? Eu posso usar uma funcionalidade que vem de dentro do React, chamada component props. O component props, ele basicamente pega e herda, digamos assim, ele extrai quais são as propriedades que um componente pode receber naturalmente, assim, já nativamente. Então, aqui eu vou fazer, por exemplo, export type button props é igual a component props, passando o nosso button que está declarado aqui embaixo. Aqui, ele, ah, tem que ser type of button, né? Porque button é uma variável do JavaScript, eu preciso converter ele para uma tipagem do TypeScript. Passo o mouse em cima de button, aqui ele só está reclamando que está sendo usado antes de definir, né? Então, vou pegar e vou jogar lá para baixo. Salvo aqui agora, e a gente vai ver que o comportamento aqui continua igual, né? O button props, ele continua tendo aqui o nosso size, agora ele tem o CSS também, porque todos os componentes do stitches, eles possuem a propriedade CSS, para a gente customizar aquele componente, inline, digamos assim. Mas agora, eu consigo mesmo assim ter o size, aqui a configuração, e aqui também, em cima, controle espaço, eu também consigo customizar o size e tudo mais. E aí, a gente tem o nosso primeiro componente, aqui a nossa primeira story criada no storybook, agora a gente vai começar realmente a dar vida para a nossa documentação."
  },
  {
    "id": "398db9a7-7a5a-415d-8c8a-35e07334ce5d",
    "title": "Checkout no Stripe",
    "transcription": "Agora que a gente aprendeu a criar rotas server-side dentro do Next, para que a gente vai utilizar essa rota aqui na nossa aplicação? Dentro das APIs, aqui da documentação da API do Stripe, tem uma API aqui dentro que é de Checkout. Vamos encontrar aqui, Checkout Sessions. O que acontece? O Stripe não pede que a gente tenha um controle de carrinho pelo nosso lado, pela nossa aplicação. A gente não precisa criar necessariamente... Ou melhor, a gente cria o carrinho só pela nossa aplicação caso a gente queira. Não é necessário criar, digamos, um carrinho dentro da API do Stripe. Porém, quando a gente vai finalizar a compra, que a gente quer indicar, olha, esse usuário está querendo comprar esses produtos, nessas quantidades e por aí vai, a gente precisa criar uma Checkout Session dentro do Stripe, que é uma sessão de Checkout, como o próprio nome já diz. E essa Checkout Session, quando a gente cria ela, é nela que a gente passa quais são os itens que a gente quer que estejam no carrinho, quais são os dados do cliente, caso o cliente tenha informado algum tipo de dado pela nossa aplicação, senão ele vai informar diretamente lá tudo dentro do Stripe. Ou seja, uma Checkout Session é a forma do usuário finalizar uma compra dentro do Stripe. Então, o Stripe tem o próprio Checkout dele. A gente não vai, digamos, fazer um Checkout transparente, ou seja, onde a pessoa coloca os dados de cartão dentro da nossa aplicação. Na verdade, a gente vai redirecionar a pessoa para o Checkout do Stripe, a pessoa vai finalizar o pagamento lá dentro, e quando ela finalizar o pagamento, o Stripe redireciona essa pessoa de volta para dentro da nossa aplicação, a qual vai poder finalizar e ver os dados que ela comprou, mostrar o status se deu certo ou não. E para isso, a gente vai utilizar uma API Route aqui do Next. Por quê? Porque essa Checkout Session aqui não pode ser criada client-side, ela precisa ser criada através do server-side, porque eu preciso utilizar a nossa chave, a nossa Secret Key de reprodução. Então, é algo que precisa ficar escondido dos usuários, e esse Checkout vem através de uma ação do usuário, o clique de comprar dentro da página do produto. E é por isso que eu não posso utilizar, fazer essa criação dessa Checkout Session dentro de um GetServerSideProps ou alguma coisa assim do Next. Nesses casos, a gente usa uma API Route. Show? Então, vamos lá, a gente vai fazer do modelo mais simples aqui agora, e com o tempo a gente vai otimizando. Então, para a gente conseguir criar uma API Route aqui dentro, a gente precisa basicamente de duas informações. E aí eu vou começar criando aqui o nosso, para a gente criar a nossa API Route, não, para a gente criar a nossa Checkout Session. Para criar a nossa Checkout Session, a gente vai usar a API do Stripe, que a gente já tem aqui dentro de libStripe. Para isso, eu preciso transformar isso aqui em uma função assíncrona. Checkout.Sessions.Create E aqui eu posso passar algumas informações. Primeiro, eu preciso passar qual é o Mode. E o Mode aqui eu tenho vários, está vendo? Eu tenho Subscription, Setup e Payment. Como o nosso aqui é simplesmente o usuário só vai realizar um pagamento, e não vai criar uma assinatura, não vai fazer toda uma criação de conta e tudo mais, a gente pode botar só Mode.Payment, que ele é só realmente a pessoa colocar os credenciais do cartão, o cartão, o número, essas coisas assim, que já vai finalizar. E além disso, outra informação aqui que é obrigatória é o LineItems. O LineItems é basicamente um Array que tem várias informações sobre quais produtos o usuário está comprando. E aqui a gente tem duas formas. A gente pode passar, por exemplo, o nome do produto, a descrição, tudo do zero. Passar cada detalhe do zero. E isso é válido quando a gente não cadastrou os produtos aqui dentro do Stripe. Então, digamos, eu posso criar Checkout.Sessions de produtos dinâmicos, ou seja, produtos que existem na minha aplicação, mas não existem no Stripe. E aí eu passo todas essas informações aqui dentro. Ou eu posso passar simplesmente uma informação chamada Price, que é o ID do preço. O que é esse ID do preço? Lembra que eu falei que quando a gente cadastra um produto aqui dentro do Stripe, aqui embaixo tem detalhes do preço. Ou seja, esse produto tem um relacionamento com um preço. O preço é uma entidade diferente da entidade produto. Porque eu posso adicionar aqui vários preços para o mesmo produto. Porque são preços que vão variar. Então, esse preço aqui vai ser utilizado caso o usuário estiver comprando 5 unidades. Eu consigo criar várias opções de preço aqui dentro do Stripe. E para eu fazer o Checkout e entender que esse é o produto que está no carrinho, com esse preço aqui, eu preciso passar esse Price ID aqui para dentro. Então, eu vou deixar previamente criada uma variável chamada Price ID, com o valor em branco, só para a gente guardar isso. E aí eu vou colocar o Price ID aqui dentro. E a outra informação que eu preciso botar aqui é a quantidade. Então, quantos itens desse Price ID estão sendo comprados aqui. E aí a gente vai colocar sempre um, até porque na tela de produto, o usuário vai simplesmente clicar... Ei, meu celular começou a notificar pra caramba aqui. Mas o usuário vai clicar em Comprar agora. Quando ele clicar em Comprar agora, ele já vai ser redirecionado para o Stripe. Ou seja, não vai ter um carrinho e o usuário também não vai poder colocar mais de uma quantidade desse mesmo produto no carrinho. Então, vai ser só uma quantidade e só do Price ID que ele clicou. E aqui está dando erro ainda porque, até se a gente passar o mouse por cima, ele fala que está faltando duas informações que são obrigatórias aqui. A Cancel URL e a Success URL. Eu vou passar essas duas informações aqui. O que é isso, basicamente? Isso aqui são as URLs de sucesso e de cancelamento. Ou seja, pra onde que eu devo redirecionar o usuário depois que ele finalizou a compra com sucesso. Aqui eu preciso botar o endereço. Aqui pra onde que eu vou redirecionar o usuário depois que ele não finalizou a compra. Ou seja, ele foi para o Stripe, mas clicou lá em voltar à loja, por exemplo. Ele cancelou. Então, eu preciso colocar essas duas URLs aqui. E aí, dependendo de onde a gente hospedar a nossa aplicação, talvez seja mais fácil ou mais difícil a gente pegar esse endereço, essa URL. Então, uma das coisas que eu gosto de fazer é vir aqui no nosso .env.local e criar uma variável ambiente que tem o endereço da nossa aplicação. Então, eu vou botar aqui app, só pra criar uma categorização. E eu vou chamar aqui de next URL. E eu coloco aqui a URL que a gente está rodando a nossa aplicação agora. Então, localhost 3000. E depois, em produção, a gente troca isso aqui pra outro endereço. E aqui agora eu vou criar as nossas variáveis. Então, a nossa success URL é igual proxess.env.nextURL barra success. E aqui, a nossa cancel URL, eu vou redirecionar ele por enquanto pra própria home. Então, vamos deixar assim mesmo. E agora, eu envio aqui no lugar de success URL e a nossa cancel URL. E pronto, eu já vou ter a minha checkout session. Porém, pra criar a minha checkout session, como eu falei, eu preciso desse price ID, que é o ID do preço lá relacionado com o produto. Pra daí sim eu conseguir fazer a criação dela. Hoje, lá no meu product, eu não tenho esse price ID. O único ID que eu tenho aqui, ele é o ID do produto. Mas é tranquilo a gente obter esse price ID. Então, aqui embaixo, onde a gente faz o carregamento dos dados do produto, veja que eu estou carregando, junto com os dados do produto, o default price. Então, o default price é qual que é o preço padrão desse produto. Qual que é o preço que vem setado por padrão. Mesmo que ele tenha mais de um, sempre vai existir um preço que é o padrão, que é o preço comum daquele produto. E aí, aqui no retorno de product, eu posso retornar essa informação também. Então, eu vou retornar aqui um default price ID, como sendo product.defaultprice.id. Ou melhor, como eu já tenho aqui em cima esse price, eu vou usar o price.id. Esse price aqui já era o product.defaultprice. Então, price ID e pronto. Eu já estou passando o meu ID aqui pra dentro. E aí, show. Agora dentro do product eu posso pegar o default price ID, que é uma string também. E aí, eu posso enviar agora esse default price ID lá pra minha rota de checkout, quando eu quiser fazer a compra. E aí, pra fazer um teste, o que eu vou fazer? Eu vou criar uma função aqui chamada handleByProduct, por exemplo. Só pra gente testar. E aqui eu vou dar um console.log no nosso product.defaultpriceID, pra gente ver se está chegando certinho. E eu vou chamar essa função quando o usuário clicar no botão comprar agora. Fechou? Então, vamos salvar aqui agora. Projeto rodando. Vamos acessar aqui a página de um produto. Vou abrir aqui um especial elemento. Venho no console. Clico em comprar agora. E ele retornou aqui um price ID. Eu vou copiar esse price ID e eu volto aqui na minha rota, que hoje ela está como hello, o nome ainda. Vou botar aqui no lugar da nossa variável price ID. Já vou trocar o nome da rota hello pra algo mais, talvez, checkout ou createCheckoutSession. Qualquer coisa assim, eu vou chamar de checkout mesmo, não tem problema. E agora, pra gente ver se isso aqui está funcionando, eu vou retornar daqui de dentro um status 201, porque eu criei uma checkout session. Então, usando os padrões do HTTP code, o 201 seria o melhor. Ele indica que algo foi criado. E eu vou dar um JSON aqui, retornando a nossa checkout URL, que ela vem de checkoutSession.url. Essa URL aqui vai ser basicamente a URL que a gente precisa redirecionar o usuário, que é a URL onde ele vai poder finalizar a compra dele. E aí, olha que legal agora, eu vou salvar isso aqui agora, e quando eu chamar a rota aqui em cima, barra API, barra checkout e salvar, ele demora um pouquinho, normal, porque ele está se comunicando com a API do Stripe, e ele devolve uma URL pra gente. Olha que interessante. Quando eu clico nessa URL, olha que massa, ele redireciona a gente pro Stripe, já com a imagem da camiseta que a gente está querendo comprar, o preço, o nome dela, a descrição. Se eu colocasse mais itens, ele ia mostrar todos os itens aqui, e já aparece aqui pra gente finalizar a nossa compra. Se eu passo o mouse aqui em cima do botão de voltar, eu posso ver que ele redireciona a gente pra home, localhost 3000. E agora, se eu finalizar, por exemplo, a compra, olha só que legal. Vou botar aqui uma dica que eu te dou, que é o e-mail, né? Uma dica que eu te dou, o Stripe tem vários cartões, como a gente está em modo de teste, você procura por Stripe Card Test aqui em Testing, e ele vai te indicar quais números você tem que colocar aqui no número do cartão pra fazer, digamos, de forma manual, dar certo ou dar errado uma fatura. Então, olha só. Se eu quero testar cartões que dão certo, ou seja, que a compra passe, a gente vai colocar esses números aqui pra cada tipo de bandeira. Geralmente eu acabo colocando esse número aqui que eu acho mais fácil digitar, mas poderia ser qualquer um desses aqui. Eu posso testar também com cartões que dão erro, por pagamento recusado, então eu boto esses números. E aí por todos os status codes, pra ver se a nossa aplicação está lidando certinho. Foi bloqueado por fraude, saldo indisponível, reembolso, contestação, dados inválidos, então a gente consegue testar tudo isso. Por exemplo, se eu venho aqui, cartão por bandeira mesmo, copio esse, qualquer um deles, da Visa, coloco aqui, boto uma data superior à data atual aqui no vencimento, qualquer um, qualquer código de segurança, boto o meu nome aqui, e agora, assim que eu clico em pagar, olha que interessante, ele vai redirecionar a gente de volta lá pra aplicação, só que agora na rota Success, porque foi aonde que a gente colocou a nossa Success URL, então a gente consegue já ser redirecionado de volta pra lá. Massa, né? Então agora só falta a gente fazer tudo isso se comunicar."
  },
  {
    "id": "ad8bbd44-43ec-4c8c-9a25-54dbbc6febde",
    "title": "Adicionando fonte externa",
    "transcription": "O que a gente vai fazer aqui agora é customizar uma fonte externa dentro do Storybook. Por quê? Porque aqui eu estou usando, por exemplo, esse componente de botão do nosso Design System, e esse componente de botão aqui está tentando utilizar a fonte Roboto. Porém, a fonte Roboto não está instalada, digamos assim, na nossa aplicação. A gente está usando o Design System, mas o Design System não importa a fonte Roboto. A gente tem que instalar na aplicação hospedeira que está usando o Design System, para o Design System ter acesso a essa fonte. Então, o que eu vou fazer? Eu vou procurar a fonte Roboto aqui dentro do Google. Deixa eu desselecionar todas aqui e vou selecionar de novo. Aqui embaixo eu vou em View All Styles e a gente vai selecionar os tamanhos aqui que a gente vai usar. Eu vou usar o tamanho Regular. Deixa eu lembrar os outros tamanhos que eu vou usar aqui. A gente tinha botado aqui em font-weight o Medium e o Bold. Então, a gente vai usar o Medium, que é o 500, e o Bold, que é o 700. E agora, com isso selecionado, a gente vai em... não é Download Family, não. Cadê? Por que eu não estou conseguindo visualizar? Isso aqui mudou, né, cara? Essa documentação. View Selected Families, aqui na direita. Antigamente era um pouco mais fácil. E aqui a gente vai copiar esse link e a gente vai jogar isso aqui dentro desse arquivo Preview Head. Aqui. Que é basicamente o arquivo que ele tem a nossa... a nossa... scripts adicionais pra gente colocar no Head da nossa aplicação do Storybook. Então, aqui eu posso botar, vou até botar antes desse script que ele tem aqui, as nossas fontes. E pronto. Uma coisa que eu gosto de fazer é colocar essa barrinha aqui de fechamento no final. Por causa de costume do React, mas não é necessário. Eu salvo isso aqui agora, volto, dou um npm run dev, aguardo. E agora, pra ver se isso aqui foi carregado, a gente pode vir em Inspect. E aqui dentro de Elements, a gente abre o nosso Head e a gente aguarda, a gente procura, na verdade, pra ver se o link foi parar aqui dentro. Hãããããããããããããããããããããããããããããããããããããããããããããããããããããããããããããããããããããããããããããããããããããããããããããããããããããããããããããããããããããããããããããããããããããããããããããããããããããããããããããããããããããããããããããããããããããããããããããããããããããããããããããããããããããããããããã ãããããããããããããããããããããããããããããããããããããããããããããããããããããããããããããããããããããããããããããããããããããããããããããããããããããããããããããããããããããããããããããããããããããããããããããããããããããããããããããããããããããããããããããããããããããããããããããããããããããããããããããããããããããããããããã"
  },
  {
    "id": "d1125aa6-674d-49ed-b86d-426364a52fb0",
    "title": "Documentação de tokens",
    "transcription": "O que a gente vai criar nessa aula é uma documentação para os outros tokens, que não são os tokens de cores em si. Então, a gente vai criar aqui um outro grid. Eu não vou chamar ele de ColorsGrid. Eu vou chamar ele de TokensGrid mesmo. E aqui agora, o que a gente vai fazer? Eu vou exportar uma função, TokensGrid. E aqui eu vou utilizar uma tabela. Para fazer esse grid. Então, ela vai ter um cabeçalho. Dentro do cabeçalho, eu vou ter o nome e o valor do token. Vai ser mais simples. E aqui, eu vou falar basicamente que essa TokensGrid recebe uma propriedade chamada token, que é um objeto que tem a chave sendo uma string e o valor sendo uma string também. E aí, eu vou basicamente botar aqui o nosso TokensGridProps. Vou pegar aqui tokens. E aqui agora, eu vou criar o meu tbody. E eu vou fazer um object.entries.tokens.map. Mesma coisa que eu fiz lá, botar um parênteses aqui dentro. Key.value. Aqui, eu faço isso aqui. Então, return. Numa tr. Aqui na key, eu boto aqui. E dentro, eu vou ter um td.key e um outro td.value. Salvo isso aqui agora. Vou criar uma nova página aqui dentro para a gente testar. Então, o próximo token que eu vou colocar aqui dentro, pode ser qualquer um deles. Eu vou colocar, por exemplo, o space.stories.mdx. E aqui, eu vou fazer bem parecido com o colors. Então, vou até copiar. Aqui é tokens.barra.spaces. Aqui é TokensGrid. TokensGrid. E aqui, a gente vai fazer o seguinte. Eu vou importar de dentro de ignite.ui.barra.tokens o space. E aqui, eu vou botar TokensGrid. TokensGrid. Tokens.space. E aqui, eu troco para space. Vou botar só space em vez de spaces. Vou salvar isso aqui agora. A gente volta aqui dentro, clica em space e pronto. Já está aqui nossa tabela. Só que a gente precisa colocar um CSS nisso. Para não ficar colocando um monte de CSS inline aqui dentro, assim como a gente fez aqui no colors.grid. O que eu vou fazer? Eu vou criar uma pastinha styles aqui dentro, de search. E aqui dentro, eu vou criar um TokensGrid.css. E aqui, eu vou fazer alguns CSS para essa nossa tabela de TokensGrid. Então, eu vou dar um width de 100%. Um font-family aqui, sans-serif. Color, fff. Fff. Border, collapse. Collapse. Vou pegar aqui o nosso TokensGrid.thead. Vou dar um padding de 0.75 rem em cima e embaixo. Um rem nas laterais. Text-align. Left. Vou pegar aqui o nosso tbody. Agora, o nosso td aqui. Vou dar também um padding nas laterais e em cima. Vou definir a cor do texto como sendo um CCC. Eu não vou fazer um CSS muito caprichado aqui, não é o ponto. Aqui também, eu vou pegar o first-child do nosso td. Ou seja, cada td que vem, cada começo de linha. Vou dar um border-top-left-radials de 8 pixels. E um border-bottom-left-radials de 8 pixels. E no last-child, eu vou só trocar o left por right. Então, a borda arredondada ali na direita. E aí, eu vou fazer o seguinte. Cada td que está em uma posição par. Cada td par, e os impers não. Ou melhor, cada tr par. Eu vou pegar todos os tds dentro dela. E vou botar um background 444. Agora, eu volto aqui no meu componente TokensGrid. Eu posso importar styles-tokensgrid.css. E aqui agora, eu jogo uma classe TokensGrid. Só para fazer a utilização. E pronto, já está aqui o nosso grid. Outra coisa que é legal, que eu gosto bastante. Por exemplo, na documentação do tailwind. Que a gente tem a documentação aqui dos spaces. Por exemplo, o padding. Ele mostra, geralmente. Não é aqui. Deixa eu ver. Customization. Spacing. Ele mostra aqui embaixo o nome do token. O tamanho ham. E o tamanho em pixels. Então, o que eu vou fazer? Aqui nesse TokensGrid, eu vou receber mais uma propriedade. Chamada HasHamValue. Ela é opcional. É um booleano. É um booleano. E aqui, por padrão, eu vou falar que é falsa. E aí, se essa propriedade HasHamValue existir. Eu vou colocar mais uma coluna. Chamada pixels. E aqui embaixo, eu vou botar mais uma cd. Mais uma coluna aqui embaixo. E dentro aqui, eu vou fazer o seguinte. Deixa eu até dar um parênteses, porque vai ficar um pouquinho maior. Eu vou pegar o meu value. Vou dar um replace no ham por nada. Ou seja, ele vai tirar o ham do texto. Vai sobrar só o número aqui. Por exemplo, vai sobrar só 1.25. Aí eu converto isso aqui. Ainda mais string. Converto isso aqui por um número. E multiplico por 16, que é o valor. E boto pesquisa no final. Então, salvo aqui agora. Volto lá no meu pages.tokens.space. E aqui eu passo um HasHamValue nesse caso. E ali agora já aparece o valor em pixels aqui na direita. Fica mais fácil. Quando a gente quer usar a documentação para saber o valor em pixels diretamente. Eu olhar aqui para dentro. Já está bem mais fácil de entender. E agora a gente precisa criar a documentação para os demais tokens da nossa aplicação. E é isso que a gente vai fazer. Então, eu vou copiar o conteúdo aqui do Spaces. E a gente vai criar para os demais. Então, font-sizes.stories.mdx. Troco aqui. Seleciono aqui, Space, vai ser font-sizes. Troco aqui e aqui. O font-sizes também é com ham. Então, deixo. E aqui, font-sizes. Salvo. Vamos ver. Beleza. Já está aqui dentro os font-sizes da nossa aplicação. Vamos copiar de novo. Vamos copiar de novo. A gente vai para o font-weights.stories.mdx. Troco aqui para o weights. Esse não tem o ham, então eu salvo. Pronto. Já está lá os tamanhos que a gente tem aqui. Deixa eu abrir aqui a pasta de tokens para a gente lembrar todos os tokens que tem. Vamos lá. Radiano. Então, aqui é radi. E aqui, radi também. Show. Já ficou bem legal. O que mais? Temos line-height. Stories.mdx. Line-height. Line-height. Aqui, né. Isto se conhece no final. Salvo. Vou botar no plural aqui, que eu estava usando já no plural nos outros. Então, aqui. Line-height. O que mais? Falta font-sizes. Fonts.stories.mdx. Então, aqui. Font-families, talvez. Font-families acho que fica melhor. E aqui eu troco para font-sizes. Font-sizes. Fonts. Show de bola. Eu acho que é isso. A gente já documentou todos os tokens que a gente precisava documentar. Então, já está bem legal aqui a nossa documentação. Aqui dentro, deixa eu ver o negócio. Storybook.main. Button. O button acaba ficando aqui em cima ainda porque ele não está categorizado. Mais para frente, eu consigo controlar também a ordem que eu quero que apareçam as coisas aqui no menu. Mas mais para frente, eu vou colocar o button aqui dentro. Cadê aqui o nosso story de button? Ele vai ficar dentro de uma categoria form. Então, o título dele vai ficar form.button. Então, ele vai parar em uma categoria e já vai vir aqui para baixo. E aí fica home primeiro, depois os tokens e depois o nosso button e os demais componentes aqui embaixo."
  },
  {
    "id": "7abf7e9c-a5df-46f3-8ac4-3c4ba5265c9e",
    "title": "Prefetch de links",
    "transcription": "Outra feature do Next que é muito interessante, mas ao mesmo tempo pode ser perigosa, é o prefetch de links que ele faz de forma automatizada. Então, o que isso quer dizer? Deixe-me ver se isso acontece em desenvolvimento, não tenho certeza. Mas quando eu acesso aqui, por exemplo, a Home, deixe-me abrir aqui o inspecionar elemento, venho em Network, deixe-me dar F5, aqui provavelmente ele não acontece em desenvolvimento, então vou te mostrar mais em produção mesmo. Eu vou rodar a build aqui do nosso projeto, vou rodar npm run start também, e agora vou abrir aqui a nossa Home de novo, vou dar F5, só que agora rodando a build de produção e não de dev, vou dar F5. E aqui a gente pode, se a gente olhar bem aqui na aba Network, a gente vai ver algumas coisinhas que aconteceram aqui. Além de carregar a Home, a gente pode ver que o Next fez automaticamente três chamadas, vou até escrever aqui, prod, underline, para a gente visualizar. Ele fez três chamadas, com código 200 aqui, para prod, underline, o id de cada um dos produtos que está aparecendo em tela. E conforme eu passo o mouse por cima deles, veja que o Next faz novamente uma chamada para essa rota, que termina com JSON, digamos, fazendo um prefetch, fazendo um pré-carregamento daquela página. Então, veja só, se eu clico em uma dessas requisições aqui, que deu status 200, ele traz para a gente a resposta relacionada aos produtos que estão aparecendo em tela. O que eu quero te dizer, o que eu quero te mostrar no final das contas? Para o Next, toda vez que a gente tem um link em tela, o link como a gente viu aqui na Home, como é esse link aqui, quando ele encontra esse link, e ele entende que esse link está em tela, então ele faz um intersection observer que a gente fala, não sei se você conhece, que é basicamente uma API do navegador que permite a gente observar quando elementos aparecem em tela. Ou seja, quando o Next detecta que algum link apareceu em tela, ou seja, que existe uma probabilidade do usuário clicar naquele link, ele faz automaticamente um prefetch daquela página. Para quando o usuário clicar, veja que eu vou clicar e já está carregado. Mesmo que isso aqui não foi uma página que eu passei aqui no Get Static Paths, um dos produtos que eu passei aqui, a gente pode ver que assim que eu cliquei, já estava gerado. E para mostrar que isso só carrega quando aparece em tela, olha só, quando eu vou rodar o carrossel para aparecer um novo item em tela, aí sim, viu que deu um pending e ele carregou o novo produto que não estava aparecendo em tela antes. Isso pode ser bom, porque para o usuário isso dá uma experiência incrível, mas pode ser ruim, porque se eu tenho muitos links na tela, o Next vai tentar carregar tudo isso por baixo dos panos, fazer um prefetch de tudo isso. E aí pode ser um pouquinho pesado para o nosso servidor, porque mesmo que o usuário não clique nesses links, por baixo dos panos o Next está fazendo as requisições. Então a gente tem que cuidar com isso. E aí a forma de a gente controlar isso é no link aqui usar uma propriedade chamada prefetch, que por padrão ela é true, ou seja, todo link faz prefetch automático. Porém, se eu passo essa propriedade como falsa, o Next vai parar de fazer isso de forma automática. Então eu vou rodar a build de novo aqui, senão ele não vai pegar a nossa alteração de código. E agora quando eu rodo o npm run start, dou um F5 aqui na ROM, a gente pode ver que não executou nenhuma requisição aqui com o prod underline, ele não fez prefetch de nenhum produto. E agora quando eu passo o mouse, ou melhor, quando eu clico em um dos produtos, a gente pode ver que ele já carregou, porque agora o prefetch funciona somente no hover. Então ele para de funcionar no link simplesmente aparecer na tela e passa a funcionar somente no hover, que pra mim deveria ser o comportamento mais padrão. Agora se eu pego um produto, eu vou rodar o carrossel e vou tentar clicar muito rápido pra não dar tempo de ele carregar e demorar um pouquinho pra acessar a página. Então você vai ver que a página que ele não fez prefetch demora ainda um pouquinho pra carregar. Então vamos tentar. Ai, não deu. O Next é mais rápido que eu. Ela carregou em 330 milissegundos, então eu teria que ser realmente muito rápido pra mostrar isso, ou tentar simular algum tempo de timeout ali no fetch pra gente ver. Mas é uma feature muito legal, só que a gente tem que tomar cuidado, como eu falei, porque se a gente simplesmente deixar prefetch em todos os links, a chance disso ficar muito pesado e consumir muitos recursos do nosso servidor é muito grande, principalmente em páginas que a gente tem muitos links sendo exibidos na tela."
  },
  {
    "id": "83fca4df-d4eb-4023-bee4-20f7c3ca7855",
    "title": "Componente: Button",
    "transcription": "O que a gente vai fazer nessa aula é criar o nosso componente de botão. E o componente de botão é o que mais vai ter variações aqui dentro da nossa página. Eu vou começar criando um botão.tsx aqui dentro. E eu vou simplesmente exportar daqui de dentro um button, que vai usar o styled. Button. E aqui a gente vai ter também uma interface. Button.props. Extends. Component.props. Type of button. S. Element. Type. React. E agora a gente vai criar aqui. Antes disso, deixa eu já exportar o meu botão aqui pra não esquecer. E eu também já vou criar o nosso story aqui dentro pra gente visualizar enquanto a gente vai estilizando, basicamente, a documentação. Então aqui ao invés de data display agora eu vou botar como form. E agora todo lugar que está escrito button eu troco pra button. E aqui os args eu vou colocar somente um children escrito send. A gente está mantendo o padrão em inglês, então vou botar send mesmo. E é isso. Agora aqui no storybook, dentro de form, button, eu já consigo visualizar ali o botão. Só que agora a gente vai adicionar as estilizações em si. Então no button a gente vai começar fazendo primeiramente um all and set. Isso aqui vai tirar todas as propriedades padrões que vem no botão. Borda, background, tudo. Vai tirar tudo e a gente vai fazer tudo do zero. Então aqui eu vou começar dando um border-radius. Small. Font-size. Small. Font-weight. Medium. Font-family. Default. Text-align. Text-align. Center. A gente vai dar aqui um min-width de 120. Caso o botão seja muito pequeno, ele pelo menos fica com uma largura mínima. Um box-sizing aqui. Border-box. E agora pro texto e pro ícone ficarem sempre centralizados. Display-flex. Align-item-center. Justify-content-center. E aí um gap de 2, caso tenha um ícone dentro do botão ele vai separar em 8 pixels o texto do ícone. E um cursor-pointer pra finalizar. Eu salvo. A gente já consegue ver ali. Ele ainda não tem fundo, ainda, esse botão. Mas é o que a gente vai fazer a partir de agora. Então só antes disso eu vou botar o ícone do botão. Ele sempre vai ter um width 4 e um height 4, que é 16 pixels tanto de largura quanto de altura. E agora eu vou começar a trabalhar nas variantes do meu botão. Então a primeira variante, o nome dela, o nome da propriedade vai ser Variant. O próprio nome já é também Variant. E aqui eu vou falar que a primeira variante do botão é o botão do tipo Primary. E aí esse botão vai ter a cor do texto branca e a cor do fundo, o Ignite 500, que é o verde meio-termo. E aqui ele não aplicou, então eu vou botar aqui uma Default Variant, Variant como sendo Primary. Salvo e pronto, já está lá o nosso botão. Ele ainda não está com a altura correta, porque esse botão também vai ter variações de tamanho. E aí eu vou ter uma variação Medium, por exemplo, que vai ter um Padding de 0, 4 e um Height de 46. E aqui eu vou botar que o Size padrão do botão é Medium. Agora sim, a gente já pode ver como é que ficou o nosso botão. E aí aqui eu vou ter também outras variantes de cores. Então eu vou ter a Variante Secondary, que aqui ela vai ter a cor Ignite 300. E ela não vai ter Background, ela vai ter apenas uma Border de 2 pixels, Solid, Ignite 500. Então agora a gente vai fazer o seguinte, deixa eu fechar todo o restante aqui. E aqui a gente vai voltar aqui no nosso Stories, e a gente vai criar aqui agora uma Variante Secondary dentro dos meus Stories. E aqui eu vou passar para ele Args Variant. Aqui ele não conseguiu entender automaticamente. Bom, mais Variante Secondary. Vamos salvar. E aqui já deu certinho. Aqui está dando um erro do TypeScript, porque como eu estou rodando a build do projeto do React ali em tempo real e está atualizando, o Vascode não fica nem sempre em tempo real lendo essas tipagens. Então às vezes dá bug na tipagem. Eu posso vir aqui e restartar o server do test e ele já volta a funcionar. Então botão Primary assim, botão Secondary assim. A gente vai ter uma terceira cor, que é o Tertiary, que ele vai ter apenas uma Color Gray 100. Não vai nem ter borda, nem fundo. Então Tertiary. Salvo. E pronto. É assim. É geralmente usado, vou até botar aqui, Children Cancel. Geralmente é usado para uma ação de cancelar. Então posso botar Cancel para ficar mais fácil. E o botão Secondary, ele geralmente é para ações secundárias. Então, por exemplo, talvez a gente já tenha um de Send. Talvez poderia ser um Create New. Então a gente já tem aqui os nossos três botões. E ele vai ter uma variante também, com tamanho Small. Vou até colocá-la antes do Medium aqui, para ficar hierarquicamente organizado, digamos assim. E esse Small, ele vai ter... O Padding vai ser o mesmo, então posso até botar o Padding aqui em cima. O que muda, na verdade, é o Height. E o Height desse aqui vai ser 38. E aí eu vou até copiar aqui, e vamos criar um botão Small. Ele recebe Args Size Small. E pronto, a gente já consegue ver a diferença dele do Primary para o Small. Só diminui realmente a altura. E aí agora, a gente precisa trabalhar nos Hovers aqui do nosso botão. Então aqui nos Estilos, dentro das variantes de cores, a gente vai começar pegando essa primeira variante Primary. E a gente vai falar o seguinte, olha, quando esse botão não estiver desabilitado, quando ocorrer um Hover nele, eu vou trocar o Background para Ignite 300. Então, já ficou bem massa. E aí, quando ele estiver desabilitado, eu vou dar um Background Color Gray 200, Cursor Not Allowed. Essa parte do Cursor Not Allowed, ela vai ficar sempre que ele estiver desabilitado. Então eu não preciso colocar isso nem dentro da variante. Eu vou colocar aqui na própria raiz do botão. E aí aqui eu passo apenas o Background Color em si. Aqui no Secondary, a gente vai ter algo semelhante. Então eu posso colocar aqui dentro. O que muda, na verdade, é que no Secondary a gente vai colocar a cor de fundo Ignite 500 e a cor FFF. E no Disabled a gente vai colocar Color Gray 200 e a Border Color Gray 200 também. E por último, no nosso Tertiary aqui, vamos até copiar. Quando o usuário passar o mouse por cima ele troca a cor para branco. Posso até usar a variável aqui, White. Deixa eu usar a variável White aqui em cima também, para não usar o hexadecimal direto. E aí no Disabled a gente vai trocar a cor para Gray 600 e pronto. Agora eu vou até criar aqui em cima uma variante Disabled nos Stories, passando o argumento Disabled como True para ver. Então aqui já está cinza e a gente poderia até combinar outras variantes. E aí a gente pode ver que quando a gente vem aqui na documentação do botão, a gente consegue ver todos os botões de uma vez só. Só que aqui no Canvas eu queria poder, por exemplo, nesse botão Primary, customizar, mexer aqui em todas as propriedades do botão. Então no Size, que é Small ou Medium, eu queria mexer se é Primary, se é Secondary, se está Disabled ou se não está. Só que para eu fazer isso hoje eu tenho que ir em cada uma delas e daí eu consigo controlar apenas aquilo que foi passado. Mas a gente vai ver como que a gente mexe nisso. Isso aqui são os ArgTypes dentro do Storybook. Mas por enquanto o nosso componente de botão em si a gente finalizou. Deixa eu até ver se tem alguma outra coisa que a gente vai fazer. Ah, faltou uma variante aqui do botão, WithIcon, para a gente mostrar como que fica o botão com o ícone. Então a única coisa que muda é que aqui no Args a gente vai passar Children como um JSX e aqui eu vou passar um Fragment. E aqui eu vou botar, por exemplo, próximo passo e aqui eu vou botar um ícone. E agora eu preciso vir no pacote de documentação e instalar o Phosphor React aqui dentro também. Ele estava instalado apenas no pacote React, que tem os componentes. Eu vou instalar ele também no pacote de documentação para a gente conseguir usar os ícones por dentro do Storybook. Novamente, minha internet se representando. Enquanto isso, aquele guarinágua. Já terminou. E agora então, eu vou botar aqui o Arrow Write. Ele, show, já deu o import aqui dentro. E eu vou botar Wait Bolt para ele ficar um pouquinho mais negrito dentro do botão. WithIcon está lá, como fica o botão com o ícone, fica bem massa. Bom, é basicamente isso. Aqui o nosso exemplo de todos os Stories aqui do nosso botão."
  },
  {
    "id": "fa855f44-150f-4250-90ec-78083b6b1405",
    "title": "Componente: Checkbox",
    "transcription": "O que a gente vai fazer nessa aula é criar o nosso componente de checkbox aqui dentro. E o checkbox, assim como a gente fez no avatar, eu vou utilizar o próprio RadixUI, que ele tem um componente de checkbox aqui dentro. Ele é muito semelhante ao checkbox do próprio HTML nativo, ele suporta toda a parte de navegação pelo teclado, a parte de acessibilidade, então ele funciona exatamente igual como um checkbox nativo, porém a gente consegue customizar o CSS desse checkbox completamente. Então, eu vou começar criando aqui uma pasta, checkbox, e aqui dentro eu vou começar criando um index.txt, style.cs, eu vou instalar aqui o react-checkbox, então a gente acessa o pacote react, roda o npm install, enquanto ele vai instalando, a gente já vai deixar aqui uma função checkbox, o componente exportado daqui de dentro. Aqui nos meus styles, eu vou criar um checkbox container, e agora como ele já terminou de instalar, eu vou basicamente fazer a importação aqui dentro, e o checkbox container vai usar o checkbox-root aqui como elemento, e o style precisa ser importado aqui do . . . . styles. E aqui agora eu vou usar o meu checkbox container, e dentro do checkbox container eu vou ter um outro carinha aqui que se chama checkbox-indicator, o checkbox-indicator é basicamente um componente que vem aqui do Radix, que ele exibe ou não o conteúdo dele, com base se o checkbox estiver selecionado ou não. Bom, a gente vai colocar esse checkbox-indicator aqui dentro do próprio . . . opa, importou do react-checkbox, mas não é, eu quero que importe dos styles, agora sim. Aqui dentro, o que eu vou colocar é um elemento check, que é um componente, um ícone do fosfor-react, e eu vou colocar ele negrito, porque o ícone do check aqui é muito fininho, ainda mais o tamanho que a gente vai mostrar ele, então eu boto ele com um peso em negrito aqui que vai dar uma exibida melhor na tela. E agora eu vou também exportar daqui de dentro, interface, checkbox-props, extends, component-props, type of checkbox, checkbox não, checkbox-container. Eu salvo isso aqui agora, e aqui agora a gente vai receber todas as propriedades, e essas propriedades serão repassadas ao meu checkbox-container, que é ele que recebe as propriedades, todos os outros elementos aqui não tem muitas propriedades. E aí, tem uma coisa legal no Radix, que a grande maioria dos elementos, eles tem essa propriedade chamada as-child aqui, tá vendo? Então o que essa propriedade quer dizer? Quando eu coloco um elemento em tela, por exemplo esse checkbox-indicator aqui, com o Radix eu posso falar, peraí, tu quer que esse checkbox-indicator aqui crie uma div nova digamos no HTML, ou que ele funcione como um fragment do React, que ele não crie nada na tela, ele só tenha a funcionalidade, e na verdade o componente em si seja o que está como filho dele. Então nesse caso aqui, por exemplo, eu posso não querer que isso aqui crie uma div nova dentro do meu checkbox, então se eu passo a propriedade as-child, isso aqui não vai ser criado em tela, ele vai só repassar, digamos, as propriedades de estar visível ou não para o elemento abaixo dele, para o filho, por isso as-child, ele vai funcionar como o filho e não como um novo elemento na tela. Isso é bem legal, funciona super bem, eu vou te mostrar como funciona na prática daqui a pouquinho. E os styles aqui, a gente vai então começar pegando aqui o nosso root, e isso aqui é uma div, então eu vou começar aqui, width 6, height 6, background-color, vamos colocar aqui um gray 900, border-radius, vou botar o xs aqui que é o menor que tem, aqui a gente bota um line-height 0, porque o checkbox eu acho que ele é um botão, então até por ele ser um botão, eu vou botar aqui um all-unset, como ele é um botão, o all-unset vai tirar a borda e o background, aquelas propriedades padrões que vem no botão, e o line-height 0 vai fazer com que o botão não tenha um tamanho base, porque o tamanho base de um botão no html é definido pelo tamanho da linha, do texto daquele botão, e a gente não vai ter texto nesse botão, então o line-height 0 vai forçar com que o botão não tenha um tamanho, uma altura base, aqui a gente vai dar um cursor-pointer, overflow-hidden, box-sizing, border-box, display-flex, justify-content-center e align-items-center também. E aqui, quando eu tiver com o focus, eu vou colocar aqui uma border, 2px, solid, ignite 300. Eu posso já deixar essa borda pré-setada, porém com a mesma cor de fundo, aqui em cima, no checkbox container, pra depois não mudar nada no tamanho. E o nosso checkbox indicator, ele vai ter uma cor white, width 4 e height 4. Vou salvar isso aqui agora, a gente volta agora lá nos meus stories, antes, na verdade, eu preciso aqui no index exportar o meu checkbox. E agora eu volto aqui nos stories, checkbox, stories, psx, a gente vai colocar aqui checkbox, a gente vai selecionar todos os lugares que estejam text-input, e vamos colocar checkbox. Aqui agora, o que muda é que eu vou botar o texto depois do story, vou trocar o flex-direction pra row, o gap pode deixar, e aqui eu vou botar alguma coisa, por exemplo, accept terms of use. E aqui, beleza, primary, a gente não precisa nem placeholder, vou tirar o resto aqui só pra gente visualizar como que tá em tela, volto no chrome, checkbox, beleza, deu um bugzinho aqui dentro do storybook, às vezes ele buga. Agora voltamos no checkbox, tá ali, checkbox, já carregou, tá aqui, quando eu clico ele coloca o iconezinho aqui dentro, só que dá pra gente melhorar ainda, primeiro porque olha só, quando eu dou focus ele fica com a bordinha verde, mas quando eu tiro ele não tá mais selecionado, então uma das coisas legais do Radix é que todos os elementos que eles têm interação, por exemplo, o checkbox, o Radix adiciona esses data, aqui por exemplo, data-state unchecked, e quando eu checo ele troca pra checked, então eu consigo fazer estilizações nesses meus elementos com base nessa informação, então por exemplo aqui no caso do checkbox eu posso fazer o seguinte, se eu tiver uma propriedade data-state igual a checked, eu consigo adicionar um background-color, por exemplo, nele de Ignite 300, olha que legal, então agora quando eu seleciono, não tem dois pontos ali, então agora quando eu seleciono ele fica verdinho, e aí no checkbox indicator a gente consegue fazer algo bem legal também, olha só, dentro do Radix eu consigo importar um caninha chamado keyframes, keyframes pra fazer animações no CSS, e aí aqui dentro eu vou criar uma animação chamada slideIn, que é igual a keyframes, e aqui a gente passa uma propriedade from e uma propriedade to, eu quero animar de para, a animação sempre vai de um lugar para o outro, então eu quero animar do transformTranslateY menos 100% para o transformTranslateY zero, e aí eu vou criar uma outra propriedade chamada slideOut que vai fazer o caminho inverso, então ele vai sair do transformTranslateZero e vai para o transformTranslateY menos 100%, ou seja, ele vai sair da tela, e aí agora, dentro do meu checkbox indicator, eu consigo fazer essa mesma seleção, porque o elemento também vai receber o dataStateChecked aqui dentro, e eu consigo fazer o seguinte, Animation, aqui eu passo com acrase, com acento grave, e slideIn, 200 milissegundos, e slideOut, aqui a gente pode botar a animação que a gente preferir, e aí, quando ele estiver com unchecked, eu vou fazer o slideOut, vou tirar ele da tela, então olha só que legal, vou salvar, Google Chrome, salvo, e olha só agora que interessante, vou até dar um zoom, quando eu clico, o ícone vem de cima, e quando eu clico de volta, quando eu tiro ele, o ícone sai para cima ali também, e assim a gente terminou mais um componente aqui do nosso Design System, que é o checkbox."
  },
  {
    "id": "445e2bed-dbb4-4ad6-badf-a8c0488f4a89",
    "title": "Log de ações no componente",
    "transcription": "Uma outra coisa legal que a gente consegue fazer aqui no Storybook é um log de ações. Então, imagine qualquer componente que o usuário consiga interagir. Por exemplo, o botão é um dos componentes que o usuário consegue interagir. Então, o que a gente pode fazer é o seguinte. Aqui dentro do botão, até dando uma olhada, o que eu fiz? Eu simplesmente exportei um botão estilizado, então todas as propriedades que eu passo para esse botão aqui são repassadas diretamente para a tagButton. Então, se eu passo uma propriedade para esse botão aqui, por exemplo, um onClick, ele vai passar para a tagButton do HTML, a tag nativa, e eu vou conseguir ouvir uma ação de clique dentro desse botão. E aí, no Storybook, a gente consegue ter um funcionamento de log de actions. Então, quando eu venho aqui em storage, por exemplo, dentro do botão, eu consigo, aqui em cima, dentro de arg, fazer o seguinte. Eu passo uma função, uma propriedade chamada argTypes, aqui dentro, onClick, e aqui eu falo que ela é uma action, e eu dou um nome para ela, por exemplo, click. Salvo aqui, volto aqui no Google Chrome, e agora aqui dentro de Canvas, dentro do botão, eu vou ver que eu tenho uma linha aqui, actions, e quando eu clico no botão, veja que ele dá um log da action realizada. É claro que aqui eu usei uma action nativa, digamos assim, por isso que ele traz vários logs do próprio HTML, do JavaScript nativo aqui. Mas eu poderia utilizar isso para os meus eventos que eu criasse dentro de um componente do React, eventos não nativos, digamos assim. E aí eu teria informações do log aqui, das informações que o usuário inseria. E essa função de actions aqui do Storybook, ela não serve somente para clique, ela serve para qualquer tipo de ação que a gente possa realizar dentro de um componente."
  },
  {
    "id": "79fc20e0-d12c-4d52-ac74-0815b784594b",
    "title": "Controles nos componentes",
    "transcription": "Uma das coisas mais legais do Storybook é que a gente oferecer para o usuário que está mexendo aqui nos componentes, ele poder trabalhar com a parte de variações desse componente. Então dentro do Storybook a gente chama isso de ArgTypes, que são basicamente os controles que a gente permite para o usuário. E essa questão de ArgTypes é bem completa, digamos assim, talvez nem eu mostrando todos os ArgTypes que eu vou mostrar aqui, a gente cubra todos eles, porque a gente consegue trabalhar com vários tipos de argumentos aqui dentro dos nossos controles. Mas vamos começar trabalhando com alguns aqui para você já ter uma ideia do que é possível fazer. Por exemplo, o botão aqui a gente tem, digamos, uma propriedade que ela se chama Variant. E essa propriedade aqui, por mais que hoje ela esteja como um texto aqui dentro do nosso botão, isso aqui não é legal porque o usuário pode acabar colocando qualquer texto aqui e nem todo texto, na verdade, ele vai satisfazer as nossas Variants aqui dentro. Por isso a gente pode trabalhar aqui dentro de ArgTypes com a nossa, com cada componente, digamos assim, e quais são as opções possíveis para cada propriedade, digamos assim, para não componente, na verdade. Então por exemplo, o nosso botão, deixa eu até fechar aqui os outros elementos para a gente trabalhar somente no nosso botão, ele tem aqui uma propriedade chamada Variant. E aí a gente pode falar, olha o botão, ele tem uma propriedade chamada Variant e as opções possíveis para essa Variant são Primary, Secondary e Tertiary. E eu vou falar que a forma de controle para o usuário trocar entre essas opções é um InlineRadial. E eu salvo aqui agora, olha que interessante, eu volto no Chrome e já está aparecendo aqui as minhas Variants, Primary, Secondary e Tertiary. E agora ele aparece inclusive em todas as variações do botão. E eu consigo simplesmente mudar isso. Aqui no Secondary, por exemplo, se eu troco para Primary, veja só lá em cima, ele já troca para Tertiary, eu consigo variar aqui por dentro dos próprios controles aqui do nosso botão. Além disso, o nosso botão tem também um controle de tamanho, Small ou Medium, a gente vai fazer a mesma coisa aqui, Size, falando que as opções são Small e Medium, salvo aqui agora e veja que agora eu também consigo variar aqui entre as opções do nosso botão. E aí uma das coisas legais de fazer é aqui dentro dos argumentos, como a gente pode ver aqui em Primary, por exemplo, que ele não vem nada selecionado, eu posso falar que por padrão é a nossa Variante, ela é Primary, e por padrão o nosso Size aqui, ele é Medium. Assim ele vem selecionado, até quando não está selecionado, ele já vem selecionado e a gente consegue ir alterando aqui dentro. E aí outras coisas que a gente pode fazer, por exemplo, o botão pode ter um estado de Disable, uma propriedade de Disable. Eu posso falar que essa propriedade aqui existe e passar para ela um control, type boolean, e agora eu salvo e veja que ele tem aqui uma propriedade Disable, que por padrão eu vou falar que ela é False, e agora eu posso trocar para True e ele já troca o nosso botão para Disable. Isso é legal também porque a gente consegue ver como que fica a nossa variação Secondary, por exemplo, Disabilitada, como que fica a Tertiary, Disabilitada, que fica um cinza escuro, aqui não dá para ver muito porque o fundo é dessa mesma cor, mas a gente consegue então trabalhar com essas propriedades. E aqui tem muitas outras coisas que a gente pode fazer, é que o nosso botão aqui realmente não tem outras propriedades para a gente ficar alterando. Então vamos ver o nosso componente, vamos dar uma olhadinha nos outros componentes aqui. O nosso componente de Text não tem muitas variações para a gente fazer, o nosso componente de Heading aqui também, ele teria só a questão do tamanho que a gente poderia fazer em ambos esses componentes, então vamos fazer essa variação aqui pelo menos para a gente ver. Então eu vou copiar esse Variant aqui dentro, a gente vai lá para dentro do Text e vamos colocar aqui dentro então, Rtypes, e agora a gente pode dar uma olhada aqui no nosso Text, no nosso componente, para a gente ver as propriedades de tamanho que ele pode receber. E aí o que eu vou fazer? Eu vou selecionar todos os dólares aqui e vou copiar os tamanhos que vem depois do dólar aqui, deixa eu colocar eles tudo em uma linha só, então aqui eles precisam ser separados como um Array, então vírgula, opa, e vírgula, pronto, agora eu tenho todos eles separados aqui como um Array, eu coloco aqui nas nossas opções e deixo ele como Inline Radial, então agora quando eu volto em Text, veja que ele já está com todos os tamanhos aqui, eu vou só colocar aqui por padrão, e aqui não é Variant, é Size, eu vou falar que o Size padrão dele é Median, e aí ele já vem selecionado, e eu posso ir alterando aqui para ver como que se comporta o nosso Text, ele tem muitos tamanhos aqui né, e já ficou bem legal. E aí a gente pode fazer mais ou menos a mesma coisa para o nosso Heading aqui, então a gente vem aqui no Heading, vamos selecionar aqui Rtypes, e o Heading ele tem um pouco menos de opções, ele vai do Small até o 6XL, então aqui e aqui, e aí pronto, e a gente vai falar que por padrão o Size dele é Median, então agora a gente vai no Heading e veja que eu consigo também alterar aqui, até descobri que o XL aqui ó, ele está com um tamanho errado, interessante a gente fazer isso porque a gente descobre também essas coisas, então, ah, o XL não tem, ele vai direto para o 2XL, por isso que está com o tamanho errado, então eu tiro aqui o XL, e pronto, a gente trabalha aqui então agora com todos os tamanhos de Heading possíveis. Ah, o que mais, o meu Checkbox aqui, ele não tem muitas variações, é mais a variação se está selecionado ou não, mas isso eu não acho que precisa ser alguma opção de controle aqui dentro, a minha TextArea, a única variação que ela tem aqui é o Disabled, então também não tem muita opção, o meu TextInput, deixa eu ver se ele tem alguma variação que eu possa colocar, ele não tem nenhuma opção aqui muito que eu poderia estar colocando, então também não tem muito controle para se colocar dentro desse TextInput, o Box, ele tem esse Children aqui que está meio feio, mostrar aqui dentro, então o que a gente pode fazer, aqui no nosso componente Box Stories, a gente pode fazer um Rtypes, e aqui eu falo que Children, posso colocar aqui um, deixa eu ver se eu posso passar o Disabled, Rtypes, Rtables.Block, deixa eu ver se eu consigo, Disabled, aqui ele não vai mostrar exatamente, mas eu consigo tirar esse controle dali de dentro, então, eu acho que eu posso passar um Control, Type NULL talvez, e eu salvo e volto aqui dentro e pronto, ele já tira para eu não conseguir controlar, tem algumas propriedades, por exemplo, quando a gente recebe como propriedade algum componente do React, alguma coisa mais complexa, é melhor a gente não permitir que o usuário controle essa informação aqui por dentro, senão fica estranho. Aqui no avatar, está show de bola, eu acho que tanto o source quanto o texto está legal dessa forma, beleza. Aqui no caso, o src acabou setando como um object, e aí eu teria que escrever um objeto aqui dentro, a gente vai trocar isso por um texto no caso do avatar, então a gente vem aqui em avatar, args, src, Control, Type, Text, a gente salva isso aqui e pronto, ele já vem como um texto para a gente fazer essa alteração. E assim a gente criou aqui os controles possíveis para a nossa documentação no Storybook, mas como eu falei, a gente consegue fazer vários tipos de controle aqui dentro, inclusive a gente consegue colocar descrições, como se fossem documentações aqui para a nossa Arttable. Então, se eu coloco aqui, por exemplo, dentro de src, uma description, na verdade, não é aqui que a gente coloca, é dentro, é que tem algumas que elas não aparecem, é só para alguns tipos possíveis que a gente consegue colocar, mas a gente consegue também colocar descrições específicas para indicar para o usuário o que cada uma dessas opções aqui representa dentro da nossa documentação."
  },
  {
    "id": "163c0af1-21a2-418e-8ea8-275be2e306f9",
    "title": "Configurando Changesets",
    "transcription": "O que a gente vai fazer nessa aula é configurar uma nova ferramenta dentro do nosso Monorepo, aqui dentro do nosso Design System, que é o Changesets. O Changesets é uma ferramenta muito legal para a gente utilizar principalmente quando a gente tem pacotes públicos que vão ser servidos através do NPM. Essa ferramenta ajuda a gente a controlar o versionamento do nosso Monorepo, porque a gente tem vários pacotes dentro do nosso Monorepo, como por exemplo React, Tokens, e cada um deles vai ser servido como um pacote separado dentro do NPM. E esses pacotes podem ter versões diferentes e até ter changelogs diferentes, ou seja, mudanças diferentes que vão acontecendo ao longo do tempo em cada um desses pacotes. E controlar isso tudo dentro do mesmo repositório do GitHub não é tão simples, até porque dentro do GitHub a gente acaba controlando a versão, digamos assim, do nosso pacote, do nosso Monorepo como um todo, do nosso Design System. Então o Changesets vem para ajudar a gente nesse momento. E aí, dentro do próprio TurboRepo aqui tem uma documentação em Publishing Packages, que é aqui Versioning and Publishing, que ele mostra como a gente faz a utilização do Changesets, mas antes disso a gente precisa instalar ele em si. Então aqui a gente vai começar instalando o Changesets CLI. E aqui precisa ser dentro da raiz do nosso Design System. Então eu vou começar instalando ele como uma dependência de desenvolvimento. A gente vai guardar aqui um pouquinho. E logo depois de instalar a gente vai rodar o nosso comando de init aqui do Changeset. Então vamos guardar aqui a instalação. E agora npcs changeset init. A gente vai guardar um pouquinho e pronto. Ele já criou para a gente algumas configurações automatizadas. Primeiro, aqui ele criou uma pasta .changeset, que a gente pode ver. Dentro tem um readme, que é criado automaticamente. Não tem porque a gente deletar esse arquivo, ele não quer dizer nada. E aqui no config.json é onde estão realmente as nossas configurações do Changeset. E aqui a gente pode ver que algumas coisas a gente vai precisar mudar aqui. Primeira delas, aqui dentro de Access, ao invés de Restricted, a gente vai trocar para Public. Porque como esse pacote vai ser publicado no npm, é um pacote que realmente vai ser público. E aí, aqui dentro de Ignore, eu vou colocar o igniteui-docs. Por quê? Porque a nossa documentação aqui é um pacote que a gente não quer publicar dentro do npm. Ou seja, vai ser um pacote que não vai ser monitorado pelo Changeset em si. E agora que a gente já configurou isso aqui, deixa eu fechar os outros arquivos aqui que tinha aberto, fechar todas as pastas. Aqui dentro do package.json da nossa aplicação, a gente vai basicamente configurar três scripts novos aqui dentro. O primeiro deles é o Changeset, que ele vai simplesmente rodar o Changeset sem nenhum parâmetro. O segundo script é o VersionPackages, que ele vai basicamente rodar o ChangesetVersion. E o último é o Release. O Release vai fazer o seguinte. Ele vai executar o TurboRunBuild, ou seja, vai executar a build de todos os pacotes. Porém, eu vou filtrar o pacote de documentação. Então, aqui, quando a gente... deixa eu ver se eu consigo mostrar essa documentação. Aqui, Filter. Eu consigo basicamente filtrar pelo nome do pacote ou pela pasta. Então, aqui, eu vou filtrar igny-ui-docs. Não quero fazer o build desse pacote. E vou executar o comando ChangesetPublish, que vai publicar isso aqui no npm. E aí, uma das coisas importantes daqui pra frente é que você tenha uma conta no npm. A minha aqui já está criada. E que você execute no seu terminal npm login e faça o login com a sua conta. Eu já estou logado. Então, eu acho que eu consigo ver npm whoami. Pronto, ele vai mostrar que eu estou logado aqui com a minha conta de USF. E aqui dentro, como a gente vai publicar os repositórios dentro de uma organização. Então, veja que todos eles têm esse prefixo arroba igny-ui. Eu preciso aqui em Organizations ter a organização igny-ui. É claro que você não vai conseguir publicar também como igny-ui. É preciso que você crie a sua própria organização e troque aqui no nome dos pacotes de igny-ui pro nome do seu design system. Então, aqui você pode criar a organização. E aí, sei lá, se o seu nome é Claudio, você pode criar, sei lá, Claudio igny-ui, ou como você preferir. Você pode colocar o nome. Esse nome precisa ser único, é por isso que você não vai conseguir utilizar também igny-ui. E agora, a gente vai, pra testar, rodar npm run Changeset. A gente vai aguardar um pouquinho. E aí... Minha garganta deu uma bugada aqui. O tempo do sul aqui tá um pouco estranho, então a gripe vem forte. Mas aqui a gente pode ver que quando eu rodei o npm... Aqui ficou um pouco ruim dentro desse terminal do Vast Code. Deixa eu cancelar aqui e vamos rodar ele pelo iTerm aqui. Deixa eu entrar aqui em 05 Design System. E eu vou rodar novamente npm Changeset. Quando eu rodo o Changeset, o Changeset é um comando que vai poder ser executado por qualquer pessoa que tá mantendo o repositório, que tá fazendo alterações no repositório. E a ideia desse comando é basicamente falar, olha, eu fiz uma alteração no repositório. Eu adicionei algo, eu mudei alguma coisa que já existia. E aqui, como eu ainda não tenho nenhuma versão publicada desse slint-config e tal, ele acabou dando alguns pontos aqui, mas não tem problema. Aqui dentro de slint-config, eu não tenho version. Então aqui eu vou colocar uma versão 1.0.0, só pra ele não dar esse erro, e vou executar de novo. E agora, olha só, ele falou pra mim quais foram os pacotes que eu mudei desde o último commit. Então eu fiz alterações no ignite-ui-react desde o meu último commit. Então aqui as alterações que a gente fez nas últimas aulas, adicionar o display name e tudo mais, isso eu não tinha colocado no commit anterior. E ele falou também que eu não fiz alterações em alguns pacotes, mas eu posso, digamos, manualmente, de forma forçada, falar que aqueles pacotes mudaram também, mesmo sem ter mudado. Mas aqui eu vou simplesmente apertar o espaço e selecionar o ignite-ui-react, que foi o único que realmente teve alterações mesmo. Eu vou dar um Enter. E aí ele pergunta, quais pacotes desses que você selecionou devem ter um bump na versão? Ou seja, eu devo incrementar a versão pra que quando eles subam pro npm eles subam com uma nova versão. E aqui, claro, o ignite-ui-react eu vou selecionar, ou eu seleciono all packages, dou um Enter. E aqui ele pede qual que é o resumo das alterações que eu fiz. Então aqui eu vou botar, por exemplo, add display name to all components. Aqui eu vou dar um Enter. E aqui ele dá o resumo do meu change set. Ele fala que foi uma alteração major aqui, e não tem problema, calma, depois a gente vai ver isso. E pronto, ele cria aqui um resuminho, e aí ele pergunta se é isso mesmo. Eu dou um Enter, e show, ele criou o nosso change set. E agora o que acontece? Aqui dentro de change set a gente vai ver que ele criou um arquivo markdown. Tá vendo? Esse proudtomatojokes, ele cria um nome automático. E olha só, ele criou basicamente aqui ignite-ui-react major, ou seja, ele vai fazer um bump de versão major aqui dentro do nosso componente. E calma, não é um problema, logo a gente vai ver isso. A gente consegue fazer tanto major, quanto minor, quanto patch. E aqui um resumo. Se eu quero adicionar mais informações pro meu change set, como markdown mesmo, basta eu vir aqui e começar a adicionar toda a descrição das alterações que eu fiz no meu componente. E aí agora, depois de eu fazer várias alterações, e eu quero, digamos, criar uma nova versão pro meu pacote, eu posso rodar o npm run. Deixa eu até lembrar, a gente criou como version packages. Eu dou um Enter aqui agora. E agora, o que ele fez? Ele foi lá no package.json dos meus componentes e fez a alteração da versão. Tá vendo que ele trocou de 1.0 para 2.0 aqui? E ele criou também um arquivo changelog-markdown dentro dos componentes que mudaram, falando quais foram as alterações, basicamente o changelog que aconteceu nessa versão. E aí, depois da gente finalizar tudo isso, eu posso publicar o meu pacote usando o release. Então, npm run release. A gente vai dar um Enter. Aguarda um pouquinho, ele vai fazer a build dos pacotes. Peraí, ele tá rodando aqui o docs. Não deveria estar rodando. Então, filter.ignite.ui.docs. Vamos ver se a gente consegue fazer por pasta, talvez. Packages.docs. Deixa eu ver se assim funciona. Show. Agora... Ah, ele conseguiu fazer certinho a build. E ele já fez o deploy, na verdade. E agora, com esse deploy, a gente pode ver que o npm, lá dentro da nossa organização, vamos dar uma olhadinha lá. Ele já publicou agora as novas versões. Olha só, o ignite-ui-tokens na versão 1.0, ignite-ui-react na versão 2.0, ignite-ui-docs na versão 1.0. Então, isso aqui é o básico do change sets. É claro que a gente ainda tem que automatizar muita coisa pra que esse processo fique muito mais fácil, principalmente quando a gente tem mais mantedores do nosso projeto."
  },
  {
    "id": "cdb7254f-f828-40d6-b718-f8d06215cc68",
    "title": "Cache na Github Actions",
    "transcription": "Antes da gente continuar e criar os workflows do GitHub aqui para fazer a publicação dos nossos pacotes no NPM, uma das coisas que ficou pendente a gente fazer, que é super interessante a gente fazer antes de começar esses workflows, é a parte de remote caching do TurboRep. Então, hoje quando a gente vai rodar as actions aqui para fazer o workflow de publicação, por exemplo, da nossa documentação, está levando cerca de dois minutos aqui para fazer a parte de build dos pacotes e mais um minuto para fazer a parte da publicação no GitHub Pages, que isso aqui é do próprio GitHub. Isso aqui não vai ter muito como a gente mexer, alterar, mas essa parte aqui de dois minutos, sim, a gente consegue reduzir bastante até. Então, aqui no próprio site da Version, na documentação, a gente tem a opção aqui na esquerda em Monorepos, Remote Caching, e a gente tem uma opção aqui que é Use Remote Caching from External CICD, que é o que a gente quer porque a gente não está usando o CICD da Version, a gente está usando o GitHub Actions, ou seja, é external, é fora da Version em si. Primeira coisa que a gente tem que fazer para conseguir usar o TurboRep com a Version para um external remote caching, é criar um access token da Version, então vou começar clicando aqui em Version Access Token, e aqui ele basicamente mostra que a gente pode vir aqui em Account Settings, aqui em Tokens, e aqui pode ver que eu tenho vários tokens aqui dentro. Eu vou criar um novo, e eu vou chamar de Ignite UI CICD, para eu lembrar dele. Aqui ele fala, basicamente, vamos dar uma olhadinha aqui. Aqui no escopo, a gente pode selecionar simplesmente aonde que a gente vai colocar a nossa documentação, então quais times, aqui no caso eu tenho acesso ao time da Rocketseat, e a inspiração. Aqui eu vou botar no expiration, então aqui eu vou dar um create token, aqui depois eu vou deletar esse token, até para você não ter gente aí que use errado, mas aqui dentro agora, dentro do nosso projeto GitHub Workflow Deploy Docs, aqui no npm run build, eu preciso passar, como a própria documentação fala, duas variáveis ambiente, então aqui eu vou colocar env, e aqui a primeira delas é Turbo Underline Token, e aqui a gente vai basicamente jogar o nosso token. E a próxima é Turbo Team, que é o slug do time da Verso, para eu colocar os artefatos. Então, aqui dentro eu tenho Rocketseat, o slug é basicamente Rocketseat, que é o que vem aqui, depois do team URL. E eu vou colocar aqui Rocketseat. E agora, o que eu vou fazer? Eu vou salvar isso aqui agora, e a gente vai publicar uma nova versão do nosso pacote. Então, a gente vai dar um git add, git commit, vou botar aqui como CI, turbo repo cache on deploy build, e a gente vai dar um git push origin main. Vamos aguardar aqui um pouquinho, eu não sei se aqui por dentro a gente consegue, no painel da Verso, visualizar os caches criados, que não são projetos aqui dentro. Mas logo a gente dá uma olhadinha, talvez aqui em activity. Bom, a gente vai olhar daqui a pouco. Mas, por enquanto, aqui a gente pode ver que ele já começou a rodar nossa action. A primeira vez que ele rodar, não vai ser mais rápido, porque ele ainda não criou o cache. O cache que a gente tinha localmente antes, ele não vai servir para esse cache da Verso. Então, a gente vai aguardar ele rodar essa primeira vez. E aí, na segunda vez que a gente rodar, é quando ele já vai estar com o cache, e aí vai ser muito mais rápido. Então, bora aguardar aqui juntos. Aqui, agora que ele está finalizando, a gente pode ver que no comando npm run build, ele mostrou aqui o remote caching enabled, e ele deu cache miss. Ou seja, ele não encontrou um cache dentro da Verso ainda. Ou seja, ele vai criar esse cache do zero. E aqui, agora que ele está criando a build, a gente tem que aguardar mais um pouquinho. Agora que ele terminou aqui o processo de build, deixa eu ver até se ele mostrou alguma coisa aqui. Tá, writing to cache. Isso aqui é importante, ele escreveu no cache. E aí, eu não encontrei aqui na Verso algum lugar que mostre exatamente o nosso cache. Mas aqui embaixo, na parte de usage, eu tenho essa opção aqui de number of remote cache artifacts. E aí, ele falou que eu fiz upload de três artefatos. Provavelmente são os meus três pacotes ali, hoje. Então, provavelmente isso aqui já indica que deu certo o processo de upload. Agora, pra gente ver que realmente deu certo, a gente tem que fazer a build rodar de novo. Então, uma das opções legais aqui do GitHub Actions é que eu consigo executar aqui os jobs de novo. E, teoricamente, a gente tem que ver eles agora executando de uma maneira muito mais rápido por causa do cache. Então, bora aguardar aqui um pouquinho o processo pra gente visualizar. Olha só que interessante, agora. O nosso comando npm run build, aqui, ele executou muito rápido. A gente pôde ver que ele deu cache hit, aqui. E ele vai mostrar aqui embaixo o full turbo. Então, ele demorou agora um segundo pra rodar o comando de build. E assim, de dois minutos, a gente passou para o nosso script, aqui, demorando, basicamente, 52 segundos pra executar. Mas, a gente ainda consegue reduzir um pouco mais. Uma forma da gente melhorar mais ainda esse processo é fazendo o cache, também, das nossas dependências aqui do npm. Então, hoje, se a gente for ver, uma das coisas que mais está levando tempo pra executar aqui dentro do nosso processo de build é a instalação das nossas dependências em si. Então, deixa eu pegar aqui até pra mostrar. Aqui é o npm run ci. Está demorando 30 segundos. Isso que a gente tem poucas dependências, poderia demorar ainda mais num projeto maior. Então, o GitHub Actions, ele traz um cache, digamos, automatizado. Basta que dentro desse width, dentro do setup node, a gente passar cache npm e, aqui, cache dependency path. E, aqui, a gente passa asterisco, asterisco, ou a gente pode passar direto packages, barra, asterisco, asterisco, barra, opa, barra, package, lock, ponto, json. Aqui, eu nem preciso colocar esse packages. Eu vou deixar só asterisco, asterisco, porque o que pode acontecer é, um dia, eu ter outra pasta. É comum a gente ter outra pasta pra, também, ter mais monorepo, mais um monorepo aqui dentro, digamos assim, mais repositórios aqui dentro. Alguns projetos tem packages e também uma pasta apps, por exemplo. Então, eu vou deixar assim que fica mais wildcard, digamos assim, mais aberto a alterações futuras. Eu vou salvar isso aqui, agora. Vou dar um git add, git commit, ci, e, npm, cache. A gente vai dar, novamente, um git push origin main. Vem aqui em actions. Vou ver que o processo, agora, vai executar, aqui, do zero. Vou ver se ele mostra algum log, aqui, senão, a gente pausa até finalizar o build, mas, se mostrar um log, vai ser melhor pra gente visualizar que ele tá fazendo o cache. Vou aguardar, aqui, alguns segundinhos. Setup node. Vamos ver se ele mostrou algum log, aqui, de cache. Npm cache is not found. Beleza? Ele não conseguiu achar o cache. Então, ele vai criar o cache, agora, teoricamente, com esse npm ci. Vamos aguardar um pouco, aqui, ele rodar. Já deve estar terminando, porque, geralmente, tá demorando 30 segundos, aí, pra rodar o nosso npm ci. Bom, vou pausar, aqui, a gente volta quando terminar. Pronto, ele terminou de rodar. No npm run ci, ele acaba não dando nenhum log, aqui, do cache, em si, mas, aqui, nesse post setup node, a gente vai ver que, aqui, dentro, ele falou que ele salvou um cache size de 73 MB, e que ele foi salvo com sucesso, e essa, aqui, é a nossa key, digamos assim, a chave do cache. E, agora, olha só, se eu venho, aqui, nas actions, venho, aqui, no meu add npm, e dou um rerun all jobs, aguardo, aqui, agora, um pouquinho, a gente vai ver o quão rápido está o nosso processo de build, agora, com todos os caches possíveis ativados, né. Então, vamos lá, olha só. Ele fez o cache, fez o setup node, tá rodando o npm run ci, e, basicamente, vai só baixar o cache, se tudo deu certo. Deixa eu ver, cache size, ó, ele achou o cache. Então, ele tá só baixando o cache, ó, e, agora, o processo de npm run ci demorou 13 segundos. Então, não é 1 segundo, também, né, porque ele tem um processo de fazer o download, ali, dos 70 MB de cache, aqui dentro, e verificar que aquele cache está válido, né, para conseguir rodar a build, mas, meu Deus, muito mais rápido. A gente está conseguindo rodar o nosso processo, agora, de build, aqui, em questão de 30 segundos. E, aí, só publicar o nosso pacote, aqui, dentro do site do GitHub Pages, a gente está com um processo muito legal de ci, aqui dentro."
  },
  {
    "id": "e8b2e892-8873-4243-b08f-87dbf50bcd0d",
    "title": "CI/CD dos pacotes NPM",
    "transcription": "Nessa aula, a gente vai configurar uma das últimas coisas que falta aqui no nosso monorepo, que é a parte de publicação automatizada dentro do NPM. Então, aqui na própria documentação do TurboRepo, dentro de Versioning and Publishing, a gente tem aqui essa opção de Change Sets GitHub Action. O Change Sets tem uma GitHub Action, o que a gente pode utilizar para fazer a execução desses comandos do Change Sets. E aqui, o que a gente vai fazer então? Eu vou copiar aqui embaixo essa opção do With Publishing, que ele vai basicamente dar uma opção para a gente de uma GitHub Action que publica automaticamente no NPM. Aqui, agora, eu vou criar um Workflow chamado Release.yaml. A gente vai colar isso aqui aqui dentro. E aqui ele vai fazer o Release toda vez que a gente fazer um Push para a Branch Main. Mas eu poderia mudar isso aqui, por exemplo, para fazer o Release somente quando a gente criar uma Release lá dentro do GitHub. Até seria legal, como a gente está criando um pacote. E aqui a gente só vai mudar o SetupNode aqui. Eu vou trocar para a versão 16. Aqui eu posso usar a versão 3. A gente vai copiar algumas coisas aqui que a gente faz. Eu vou copiar, na verdade, tudo isso aqui, todos os Steps que a gente tem até a instalação das dependências. E aqui, o npm run build vai executar junto com o comando de Release. Então, eu vou tirar essas duas variáveis ambientes daqui. E eu vou colocar aqui embaixo, junto com essas outras demais variáveis ambientes. Por quê? Porque aqui eu vou executar o npm run release. E o npm run release é quem vai rodar o npm run build, aqui que vai precisar do nosso cache. Aqui ele vai usar o changeSetActionV1 mesmo, createRelease, aqui eu vou botar createRelease, ou melhor, publishToNpm. E aqui, ele tem uma opção também de enviar uma notificação para o Slack, caso você use o Slack, você pode botar isso aqui, mas aqui eu vou tirar essa parte. E aqui agora, a gente já tem o GitHub token, uma variável presente em todos os workflows, que a gente não precisa criar, mas a gente precisa do npm token. Então, agora o que eu vou fazer? Eu vou abrir aqui o npm, eu venho aqui dentro em Access Tokens, Generate New Token, preciso colocar minha senha aqui, deixa eu ver se eu lembro da minha senha. Deixa eu ver aqui. Aqui eu dou um nome para o token, então eu vou chamar de IgniUI CICD, aqui eu vou selecionar a opção Automation, que é o token que a gente usa para usar dentro do ambiente de CICD. Agora, pronto, copio esse token aqui, e o nome agora é npm token, então eu volto no meu projeto, deixa eu abrir aqui o projeto no GitHub, venho em Settings, aqui na esquerda venho em Secrets, New Repository Secret, npm token, e coloco o nosso token aqui dentro. Pronto, agora a gente vai testar se isso aqui está funcionando, mas para o change set conseguir fazer a publicação, a gente precisa criar um novo change set, uma nova alteração em algum pacote, senão ele não vai publicar nada. Então, o que eu vou fazer? Eu venho aqui no meu pacote, pode ser no pacote tokens, só para a gente realmente testar. Aqui em Color, eu vou criar uma nova cor, só para a gente fazer o teste realmente. Então, Test, vou botar como a cor branca mesmo, e agora a gente vai rodar primeiramente. Vamos rodar aqui no terminal, que fica mais fácil de visualizar. Npm Run Change Set, ele detectou aqui, então só os pacotes que eu mudei, Ignite UI Tokens, vou dar um Enter. Aqui ele vai fazer um Bump do nosso pacote de tokens, e aqui Add New Test Color, que é o nome da nossa Summary, e pronto, Yes. Aqui a gente pode ver então que dentro de Change Set, ele criou agora essa Wise Carrots Flash, e aqui ele colocou como Major, mas como eu falei, a gente pode trocar. Então aqui, por exemplo, eu vou usar como Minor, não precisa ser necessariamente uma alteração Major. E agora, a gente pode usar o Npm Run, Npm Run Version Packages, e pronto, ele vai fazer aqui dentro de Tokens, um Change Log, veja que agora ele não fez uma alteração Major, ele trocou para a versão 1.1, e já trocou aqui no pacote, e agora a gente vai enviar isso aqui, eu não vou rodar o Release aqui, vou deixar o nosso CI rodar o Release em si. Então, Git Add, Git Commit, Core, Add New Test Color to Tokens. A gente vai dar um Git Push, Origin Main, é claro que isso aqui poderia ser também uma Pull Request, inclusive o próprio Turbo Repo recomenda aqui que a gente use esse Change Set GitHub Bot, que ele é basicamente um bot do GitHub, que ele vai lendo as suas Pull Requests, e avisando caso você tenha esquecido de fazer o Change Set antes de enviar o Pull Request, que é esse processo de criar o arquivo de Change Set, aqui o Markdown. Então, a gente aguarda aqui mais um pouquinho, deixa eu abrir aqui o nosso repositório, Actions, e aqui a gente pode ver que ele está rodando o nosso Release aqui dentro. Então, vamos abrir aqui o nosso Release. Ele conseguiu usar o mesmo cache que a gente tinha da parte do Npm lá do Node, então ele reaproveita o cache, e agora ele está rodando o Push para o Npm, publicou o Tokens na versão 1.1.0, aguardamos um pouquinho e pronto, show de bola, já finalizou a publicação. Se eu venho aqui no Npm, dentro de Ignite UI, eu vou ver que meu pacote Tokens já está na versão 1.1.0, e assim a gente finalizou todo o processo de CI e CD aqui do nosso Monorepo. E aqui um processo só que eu acabei esquecendo, mas é importante, não é legal a gente deixar aqui hardcoded dentro da nossa aplicação, o Token da versão, até porque nosso repositório pode estar público. Então, uma das coisas legais é tirar isso aqui, e a gente vem aqui em Settings no nosso repositório, Secrets, Actions, a gente vai criar um repositório Secret, eu vou chamar de Versal Token, a gente vai colocar aqui, e pronto. Agora aqui dentro, ao invés de a gente utilizar o Token diretamente, a gente vai colocar uma variável, Versal Token, dentro aqui do Turbo Token. Tanto no nosso Deploy Docs, quanto no nosso Release, aqui a gente vai jogar, então, o nosso Token da versão. E aí, novamente, a gente pode dar um git add, aqui nesse caso, um git commit, um CI, e git push origin, bem, agora sim, a gente realmente finalizou."
  },
  {
    "id": "4dabf2b8-3c70-40f2-8c24-e07b8799ada1",
    "title": "Publicando Storybook",
    "transcription": "Nessa aula, a gente vai começar o processo de publicação do nosso design system na web. Então, de uma forma pública para que as outras pessoas possam ver. E a gente vai começar com a nossa documentação. E a gente vai utilizar um pacote chamado Storybook Deployer. Que ele é basicamente uma CLI que facilita a gente publicar a nossa documentação. Tanto no GitHub Pages, que para mim é o local melhor para se postar. Porque é público, é gratuito e geralmente o nosso projeto já vai estar no GitHub. Ou na WS, no S3, no bucket lá, também funciona sem problemas nenhum. A gente vai começar instalando o Storybook Deployer. Então, é importante, deixa eu dar um Collapse All aqui. A gente acessar a pasta Docs. E deixa eu parar de rodar o Storybook aqui. Meu Deus, eu fechei o meu VSCode, nem sei como. Deixa eu acessar de novo aqui, Package Docs. Vou rodar o npm install storybook deployer. E aqui em Docs, dentro do package.json, a gente vai aguardar aqui ele fazer a instalação. E aí, a gente vai, aqui dentro de scripts, criar um carinha chamado deploy storybook. Que ele vai basicamente usar essa CLI que vem junto, que é o storybook-to-gh-pages. Vou salvar isso aqui agora. E agora, o que a gente vai fazer antes de mais nada? Eu vou criar o nosso repositório no GitHub. Então, aqui eu vou dar um git add-all, um git commit, como eu já tenho criado o meu repositório. git add-core-components, que foi o que a gente fez, adicionou os componentes aqui no design system. Na verdade, eu preciso fazer o git commit na raiz. Então, eu vou dar um git commit amend aqui para refazer o commit, porém adicionando tudo o que está na raiz. E eu vou criar o repositório aqui a partir da raiz. Então, repo create push-an-existing-local-repository-to-github. O nome do repositório, eu vou botar, deixa eu ver aqui, github-rocketseat-education. Eu acho que eu já tinha colocado um projeto, eu tinha botado como ignite-ui. Então, eu vou botar 05, design system mesmo. Description não precisa. Vou botar como público já. Vou aguardar um pouquinho. Sim, sim, sim. E pronto. Ele vai fazer a publicação, posso dar um git, eu vou jogar a repoview aqui, web. E pronto, está aqui o nosso repositório. E agora, o que eu vou fazer? O nosso repositório estando ali dentro, eu vou agora criar aqui dentro uma pastinha .github. Dentro eu vou criar uma pasta workflows e dentro eu vou criar um arquivo chamado deploy-docs.yml que vai ser o nosso workflow de publicação da nossa documentação. E aqui eu vou dar um nome para ela, deploy-docs. Ela vai executar toda vez que houver um push na minha branch main. Aqui você poderia fazer por release. Eu vou fazer direto com o push na branch main mesmo. Jobs, aqui eu vou chamar de build and deploy. Runs on Ubuntu latest. E aqui, os nossos passos. Primeiro, a gente vai dar um checkout no repositório, que é basicamente pegar o código. Então, isso aqui usa a actions.checkout. Essa actions.checkout, deixa eu ver que versão que ela está. V3, então, arroba, V3. A próxima é fazer o setup do node. Então, setup node.js, user, actions, setup, node, arroba, V3 também. E aqui eu posso passar width, que é uma variável. Node version, a versão LTS, por enquanto, é a 16. Aqui a gente vai rodar um npm-ci, que ele vai fazer a instalação dos pacotes do npm. Porém, esse npm-ci é um npm-install feito para um ambiente de CI. Então, ele não mexe no package lock. Então, isso é super importante. E ele vai instalar também só as dependências de produção. Aí depois eu vou rodar um npm-run-build. Isso aqui são scripts. Esse npm-run-build é o que a gente configurou aqui do turbo. Então, ele vai rodar a build de todos os pacotes ali dentro. E aqui eu vou dar um name deploy-storybook. E aqui eu vou passar um working directory para ./.packages/.docs. Então, ele vai entrar na pasta packages.docs e vai executar npm-run-deploy-storybook. Traço, traço. Traço, traço. CI. Traço, traço. Existing output... Deixa eu até ver isso aqui. Vou pegar aqui. Existing output dir. If you have previously built your storybook output through a different CISAP and just need to publish it, specify the directory like this. Sim, a gente já fez o build. A gente não quer fazer o build de novo. Então, nesse caso... A gente vai fazer o seguinte. Hoje ele está criando uma pasta aqui dentro. Build-storybook. Ele cria uma pasta storybook-static, se eu não me engano. Deixa eu até rodar o build aqui. Aguardar um pouquinho. É, storybook-static. É essa pasta aqui que a gente precisa jogar lá dentro. Então, aqui existing output, a gente vai botar como sendo o nosso output dir igual storybook-static, que é a pasta que vai ter o nosso projeto. E aqui eu preciso passar uma variável ambiente. gh-token, dois pontos. E aqui a gente vai passar basicamente o seguinte. Ele até mostra aqui pra gente um exemplo, que é isso aqui. gh-token, github-actor e secret-github-token. Esse exemplo aqui até do YAML, ele está aqui dentro do próprio repositório do storybook-actions. Ele já mostra aqui. Então, a gente só está seguindo mais ou menos a própria documentação. Perfeito. Agora a gente vai salvar isso aqui. Eu vou dar um git status, git add, git commit, ci add docs-workflow, git push, origin main. Aguardamos um pouquinho. Feito. E agora a gente vai abrir aqui o projeto. Alguém já deu start. E ele já começou a rodar a nossa action, add docs-workflow. Vamos monitorar aqui. Então, ele está instalando as dependências. Por enquanto, ele vai demorar um pouquinho mais para executar. Até porque, lembra que a gente configurou o turbo repo na nossa máquina. Só que o nosso turbo repo aqui está configurado somente local. Ele não está com cache online. Então, a gente pode otimizar ainda. Fazer esse cache online, que é algo que a gente vai fazer mais para frente, para otimizar a build. E aí a build fica extremamente rápida. Porque a gente consegue fazer o cache das dependências do npm e consegue fazer o cache da build. Fica muito rápido essa build e o deploy aqui da nossa documentação e do nosso projeto no npm. Leva questão de 10, 15 segundos. Então, é um negócio que mantém um fluxo muito rápido de deploy. E não fica usando as nossas horas ali do GitHub, de GitHub Actions, que a gente tem gratuitamente, principalmente se o seu repositório for privado. Beleza, a gente pode ver que ele está criando a build agora. Já foi a build do React, já foi a build do Tokens. Ele está criando a build da parte de documentação. Começou a rodar a build do Storybook usando o Vite. A gente vai aguardar um pouquinho isso aqui finalizar para ver se funciona. Enquanto isso, mais um gole no café. Beleza, terminou a build. Como eu falei, ela vai demorar um pouquinho mais, um minuto, porque o TurboRepo não está funcionando em produção. A gente vai usar esse carinha aqui. Depois é o RemoteCaching do TurboRepo. Que ele vai fazer o cache do TurboRepo. Ele vai fazer basicamente o RemoteCaching na versão, mas depois a gente fala sobre isso. Não tem muito o que a gente ficar antecipando. Perfeito, terminou o DeployStorybook. Agora que ele terminou, o que ele faz? Quando ele termina o Deploy, ele cria basicamente uma branch chamada gh-pages. E essa gh-pages tem o nosso site do Storybook aqui dentro. Legal, né? Agora, o que a gente vai fazer? Eu venho em Settings. Venho em Pages. Aqui, em Source, eu seleciono Deploy from a Branch. E na Branch, eu seleciono gh-pages. E eu dou um Save. E aqui eu posso selecionar um custom domain, caso eu queira. Mas eu vou deixar o próprio domínio do Storybook. Um ponto que eu lembrei aqui agora é que, como a gente não vai configurar um domínio nosso, que ele não vai ficar, digamos, na raiz, toda vez que a gente faz o Deploy do Storybook e ele vai funcionar dentro de um subdiretório, um subpath, que eu tenho que ter, por exemplo, domínio.com barra alguma coisa para daí mostrar o Storybook, eu preciso configurar aqui dentro desse main do meu Storybook. Eu preciso configurar aqui embaixo uma propriedade, aqui embaixo de Features, chamada byte final. E, basicamente, eu vou receber a config do byte. E aqui, config type. E eu vou fazer o seguinte, se a minha config type for igual a production, se eu estiver no processo de Deploy aqui do Vite, eu vou fazer um config.base igual, igual que é, basicamente, o subdiretório que o meu projeto vai estar. E como a gente está fazendo o Deploy no GitHub, o subdiretório sempre é o nome do repositório. Então, nesse caso, é 05. É 05.design.system. E aí, eu posso botar a barra aqui, e no final, eu só retorno a minha config. E agora, eu vou dar um git add de novo. fix add subpath to storybook on production. A gente vai dar um git push, origin main. E agora, para a gente mostrar o fluxo completo, ele vai começar a rodar a action de novo, aqui, do add subpath to storybook on production. E o mais legal é que agora, quando ele terminar de rodar essa action, ele vai rodar automaticamente a próxima action, que é criada pelo próprio GitHub, aqui, a by.github.pages, que é a de build in deployment do GitHub Pages, que ele rodou ali quando a gente configurou a nossa GitHub Pages. Ele já, inclusive, fez a publicação. Só que aqui, a gente pode ver que ele não está conseguindo carregar os tokens. Então, isso aqui é basicamente esse probleminha que eu falei de subpath aqui do storybook. Então, por isso, a gente precisa aguardar ele fazer o carregamento. E aí, a gente já vai visualizar que, teoricamente, funcionou assim, eu espero. Senão, a gente vai ter que rever aqui alguma coisa. Mas eu acho que vai funcionar assim. Vamos acompanhar aqui, então. Ele está rodando o processo de build de novo, como eu falo. Processo que vai demorar um pouquinho, porque a gente não está com o nosso remote caching. E, aproveitando o tempo, o remote caching, como é que ele funciona? Ele funciona assim como o cache local, porém, o remote caching, essa nossa pasta de cache, ela vai ficar em algum ambiente online. E aí, a gente pode fazer esse remote caching funcionar dentro de uma Amazon da vida, por exemplo. Em qualquer servidor, a gente pode passar aqui a nossa API de cache. Só que uma das coisas legais é que a Versa, ela oferece essa parte de remote caching de maneira gratuita. Então, a gente consegue utilizar lá dentro também. Mas, depois a gente configura isso. Depois a gente configura isso ali dentro do nosso repositório. Beleza, aguardando aqui, 1 minuto e 22. Tantarantã, tantarã. Finalizou. Fez o deploy, fez aqui o post. E agora, aqui em actions, ele começou a rodar o pages, build and deployment. A gente vai aguardar aqui um pouquinho ele rodar esses jobs. Então, fez o pull, puxou os repositórios. Vou aguardar um pouquinho. Ele faz o deploy usando o Jekyll. Se você não sabe o que é o Jekyll, é uma ferramenta criada em Ruby, bem antiguinha. Ela é um static site generator, assim como a gente tem hoje um Gatsby da vida, só que um pouco mais das antigas. E aqui agora, a gente tem que aguardar essa action aqui finalizar, que é o deploy. E pronto. Deploy feito. A gente pode acessar agora o nosso design system. E aí... Show, já está aqui a home. A gente já consegue agora navegar no nosso design system de forma pública. Inclusive, a gente consegue enviar isso aqui para outras pessoas acessarem. Dá para ver toda a documentação aqui por dentro. Então, já está tudo online, publicado para quem quiser visualizar."
  },
  {
    "id": "5ee4f674-dbac-4e9b-83cf-4f1f19b0c067",
    "title": "Fallback do SSG",
    "transcription": "Quando a gente passa alguns caminhos aqui, alguns parâmetros dentro desse getStaticPaths aqui, tudo o que a gente retorna aqui dentro de paths, a gente está dizendo para o Next que quando a gente rodar a build, quando o processo de build da nossa aplicação for executado, deve ser esses parâmetros aqui que ele vai utilizar na hora de executar o método getStaticProps. Então ele vai executar o método getStaticProps repetidas vezes para cada um desses itens que a gente passa aqui nesse array, e assim ele vai gerar todas as páginas estáticas. Até aí tudo bem, mas existem alguns casos que é um pouco complicado, como eu falei. Existem casos que a gente tem muitos produtos. Eu posso ter 10 mil produtos na minha loja. Faz sentido eu colocar os 10 mil produtos aqui dentro? Não, não faz muito sentido. Além disso, tem casos onde eu vou ter coisas que são incrementais. Então, por exemplo, eu tenho um e-commerce. Novamente, podemos utilizar o mesmo caso que a gente tem aqui. E eu adiciono novas camisas todas as semanas. Não faz sentido eu vir aqui e ter que ficar colocando as novas camisas aqui dentro, ou não faz sentido eu gerar, por exemplo, de forma estática 10 camisas, e aí a nova que adicionar vai ter que esperar o próximo deploy. Então é um pouco complexo, porque esse método, por mais que ele ajude a gente com algumas coisas, ele tem que permitir que a gente possa ter mais produtos com o tempo. E é aí que vem essa questão do fallback. Então, o que acontece? Vamos pensar nesse caso de um e-commerce, vamos tratar caso a caso. Vamos começar com esse e-commerce que tem 10 mil produtos. O que é o recomendado fazer aqui? Primeiro, esse path, tudo que a gente passar aqui dentro, é o que vai ser criado estaticamente no momento da build. Ou seja, a gente tem que cuidar para tentar manter isso aqui enxuto, porque senão a nossa build vai ficar muito pesada, vai demorar muito para executar. Então, no caso do e-commerce que tem 5 mil produtos, das duas uma. Ou eu vou pegar aqui e buscar os produtos mais vendidos ou mais acessados. Aqui com o Stripe a gente não vai conseguir fazer isso. Então estou te mostrando um pouquinho mais o que eu faria, só para você ter em mente. E aí eu passaria aqui dentro de paths somente os produtos mais acessados barra mais vendidos. Porque assim quando a gente rodar o deploy do nosso projeto, a página desses produtos já está gerada estática. E aí como eles são os mais acessados, vai ter uma experiência ótima para o usuário que está acessando ali, já ter essa página carregando de forma muito rápida. E aí você me pergunta, tá Diego, e para o resto dos produtos? O que eu não passar aqui? Vai dar 404? Vai, mas por isso que a gente tem a opção fallback. Como é que funciona essa opção fallback? Quando a gente passa fallback falso, que é o que a gente falou aqui, o que acontece é, quando a gente tentar acessar a página de um produto, o qual a gente não passou aqui dentro dos paths, com o fallback falso ele vai dar 404. Com o fallback true, o que vai acontecer é, quando eu acessar uma página de um produto, o qual eu não passei aqui dentro dos paths, o que o Next vai fazer é, ele vai tentar pegar o ID desse produto que a gente passou aqui, que a gente está tentando acessar, e ele vai tentar executar esse método getAestheticProps para buscar os dados desse novo produto e aí gerar a versão estática dele. O único ponto aqui do fallback true, que é importante a gente entender, inclusive eu vou salvar aqui para a gente ver qual vai ser essa experiência. Eu salvei com o fallback true, venho agora aqui e dou um F5 na página. Beleza, não estava rodando o servidor de desenvolvimento, vou rodar de novo aqui. Deu erro, mas por que deu erro? Porque quando a gente roda com o fallback como sendo true, uma coisa importante da gente entender é que o Next vai mostrar o HTML da nossa página e ele vai tentar carregar os dados do produto por baixo dos panos, digamos assim. E quando ele terminar de carregar os dados desse produto, ele vai mostrar em tela. Então o que acontece? Se eu der um console.log aqui nesse produto que está vindo aqui dentro, olha só, eu salvo isso aqui agora, venho no console, não mostrou nada. Se eu venho aqui no meu terminal, que é onde está rodando o nosso back-end. Deixa eu ver se ele mostrou aqui dentro. Ai meu Deus, tem muito log aqui que não dá nem para eu me encontrar aqui dentro. Deixa eu rodar de novo aqui e ver se facilita encontrar. Aqui, undefined. Por que undefined? Porque o Next, quando eu tenho o fallback true, ele vai carregar a nossa página sem a informação do produto e vai executar esse método getStaticProps assincronamente. E aí quando ele terminar de carregar os dados do produto, ele vai preencher aqui dentro. E aí eu teria que criar um estado de loading aqui dentro. E aí o pessoal geralmente faz aquelas skeleton screens, não sei se você já ouviu falar, que é basicamente criar aquelas versões da página, tipo assim, só um quadrado cinza que tem uma animação percorrendo. Pode dar uma procurada, eu acho que talvez no image.google skeleton screens, você talvez encontre, por exemplo, essas telas assim. E aí como é que eu faço para detectar que está acontecendo um loading? O Next permite para a gente, através do hook useRotor, obter uma informação chamada isFallback. Quando o isFallback estiver como true, quer dizer que eu estou fazendo um loading. Então vou até escrever aqui, loading, e aqui no caso a gente renderizaria em tela uma versão da nossa tela com um loading. Aqui eu não vou criar, mas é mais para você conhecer. Então eu salvo agora isso aqui, volto para a nossa página, e olha só, viu? Vou dar mais cinco de novo, loading, e aí aparece a página. Apesar do fallback true fazer o papel que a gente esperava, de carregar os produtos que ainda não tinham sido carregados através dos paths, existe uma outra opção, que ela foi introduzida mais à frente, que ela pode ser válida também, caso você não queira criar esse estado de loading, que na maioria das vezes é o recomendado, mas existe uma opção chamada fallback blocking. O fallback blocking, como o nome já diz, ele vai bloquear, digamos assim, não vai mostrar nada em tela, ou seja, não tem nem como o product vir como undefined, como é o caso aqui, ele não vai mostrar nada em tela, ele vai deixar a tela em branco até ter alguma coisa para mostrar. E apesar disso resolver o problema de você não precisar verificar o fallback, para o usuário final é uma experiência pior. Geralmente com certeza o usuário prefere ver uma tela carregando aos poucos do que não ver nada e só depois de um tempo ver a tela inteira. Então sempre prefira por usar o fallback como true aqui. Mas vou mostrar o efeito aqui, então rodando, vou dar um npm run dev, abrimos a página, e aí acessando aqui a página do produto, ele demora pra caramba, e aí quando está pronto ele renderiza. Então é um efeito diferente, ele não tem aquele loading nem nada disso. Então são duas opções, na verdade três opções de fallback, na maioria das vezes você vai usar o fallback true, ou até o falso para alguma situação específica, mas na maioria das vezes o fallback true mesmo, e aqui dentro dos passes você vai carregar ou nada, que pode ser uma opção válida também, e aí você vai deixar que as páginas estáticas sejam geradas conforme os produtos vão sendo acessados em produção, ou você carrega aqui só o essencial, os 5, 10 produtos mais acessados, ou 5, 10 posts mais acessados do seu blog, e por aí vai."
  },
  {
    "id": "d62edec3-02e3-4f0c-98d3-be59b3d58d82",
    "title": "Trabalhando com SEO",
    "transcription": "Para finalizar aqui na nossa aplicação, uma das coisas que a gente pode perceber é que todas as páginas da nossa aplicação estão aqui com localhost 3000. Uma das coisas legais do Next é que a gente consegue customizar essas informações que vão no head da nossa página, não só o title, mas por exemplo, metatags, até tags de descrição, keywords, open graph do Facebook, do Twitter, todas essas metatags que servem para indexação, para os crawlers, para os embeds e tudo mais, a gente consegue customizar isso por página. Isso funciona de uma maneira muito legal. Por exemplo, aqui na nossa home, uma das coisas que a gente pode fazer é importar head de dentro de next barra head. Cuidado porque tem o head também que existe dentro de next document. Quando a gente importa de next document, pode vir o head. Não pode ser esse, não vai funcionar. Tem que ser o head que vem de next barra head. E aqui a gente pode colocar em qualquer lugar, literalmente. Pode ser, por exemplo, dentro da home container. A gente coloca head e tudo que a gente colocar dentro desse head aqui vai ser transportado para o head lá do nosso document, aqui para dentro. Então, meio que transporta de forma automática. Então, se eu boto um título aqui, por exemplo, ignite shop e salvo, olha só, já aparece ignite shop lá dentro. Eu não gosto muito de colocar esse head dentro do container porque eu acho que confunde na hora de dar manutenção porque a gente pode achar que isso aqui é um elemento visual. Então, geralmente o que eu gosto de fazer é criar um fragment, que é uma div que não aparece no HTML, então eu só crio um sinal de abre e fecha menor e maior, menor barra e maior. E eu coloco aqui, antes do container, o nosso head. Então, fica separadinho o head e aí sim o conteúdo da página. E aqui eu posso colocar assim, fica aberto para você. Tem até um plugin muito legal que se chama Next SEO, provavelmente a gente vai utilizar ele mais para frente, que ele serve para a gente trabalhar com SEO. Então, ele é um componente chamado Next SEO que a gente coloca na página e ele gera todas as metatags, o title, a description para a gente, baseado em algumas informações que a gente passa para ele. Mas, por enquanto, a gente não vai fazer um SEO muito complexo aqui nesse site, por isso a gente nem vai entrar muito a fundo. Então, aqui eu vou escrever apenas, por exemplo, home, Ignite Shop, e a gente vai fazer algo parecido com as outras páginas. Então, na página de produto, eu venho aqui, por volta do nosso product container, coloco aqui também o meu fragment, coloco aqui o meu head, importo ele de next barra head. E aqui a gente vai colocar, ao invés de colocar home, na verdade, a gente vai colocar o nome do produto. Então, eu venho aqui e coloco product.name, salvo, a gente pode ver que quando eu clico no produto, já fica lá em cima, camiseta, Maratona Explorer. Então, fica bem legal. E o último que a gente vai modificar aqui é na própria página de sucesso. Na página de sucesso, a gente vai fazer uma coisinha a mais aqui. Então, além de eu colocar aqui o nosso head, e aqui eu vou colocar algo como, pode ser, compra efetuada. Além disso, eu vou colocar aqui uma meta, name, robots, content, noindex. Não sei se você sabe o que é isso, mas, basicamente, a gente está pedindo para os crawlers não indexarem essa página. Então, ela fica fora de qualquer indexação do Google e por aí vai. A gente só coloca o título mesmo para o usuário ver um nome bonitinho quando ele finaliza a compra. Show de bola! A gente finalizou tudo o que a gente precisava finalizar."
  },
  {
    "id": "ea827fb9-69b8-4744-9ca0-b462c3b2d991",
    "title": "Configurando Monorepo",
    "transcription": "Nessa aula, a gente vai conhecer o conceito de monorepo e como que a gente faz para configurar aqui dentro da nossa aplicação. Monorepo é um conceito introduzido principalmente dentro do JavaScript, que é basicamente a prática da gente colocar vários projetos dentro de um único repositório de código. E quando eu falo repositório, não necessariamente isso significa um repositório no Git, no GitHub, não é isso, na verdade, é um repositório que a gente pode pensar uma mesma pasta, um espaço de trabalho, e ali dentro tem vários projetos. E o grande ponto de monorepo não está simplesmente em alocar vários projetos dentro de uma mesma pasta e pronto, e aí já está tudo funcionando. A questão de trabalhar com monorepo é principalmente, a gente usa essa estratégia, quando a gente tem projetos que são dependentes, e não independentes, são dependentes entre si. Então o que eu quero dizer? Imagine que, por exemplo, eu esteja construindo aqui algum tipo de aplicação, como o próprio Design System, e aí eu estou trabalhando aqui, por exemplo, nesse pacote de tokens, e daqui a pouco, aqui dentro, eu tenho um outro pacote, por exemplo, um pacote chamado React. E esse pacote React, ele tem como dependência, vamos dizer assim, o pacote de tokens. E é muito comum eu ter que trabalhar e fazer alterações tanto no pacote React quanto no pacote de tokens ao mesmo tempo. Só que seria muito ruim esses dois pacotes aqui estarem em projetos totalmente separados, porque eu teria que fazer uma atualização no pacote de tokens, publicar ele no NPM, aí teria que ir lá no pacote React, baixar essa nova atualização, para daí poder usar as alterações. Quando a gente trabalha com monorepo aqui dentro do JavaScript, e monorepo é um conceito, não necessariamente é uma ferramenta específica, a gente consegue trabalhar em vários projetos diferentes, digamos assim, dentro da mesma estrutura e ao mesmo tempo. E a gente consegue, inclusive, fazer importações, por exemplo, falar que o pacote React tem uma dependência, que é o pacote tokens, fazer importações de arquivos aqui do pacote tokens direto dentro do projeto React, e vice-versa, sem precisar publicar nenhum desses projetos aqui dentro do NPM para conseguir fazer essas alterações. E aí, como é que a gente faz para começar a trabalhar com monorepo? Então, vamos lá. A primeira coisa que eu vou fazer aqui, eu vou entrar nesse pacote React que a gente criou, e eu vou também dar um NPM init dentro dele, a gente também vai instalar aqui dentro o TypeScript, como uma dependência de desenvolvimento, aqui dentro eu também vou precisar do testup para fazer o processo de build, como dependência de desenvolvimento, vamos aguardar aqui um pouquinho. E aqui no pacote React, por enquanto, eu nem vou adicionar muita coisa, é só para eu mostrar realmente como que o monorepo funciona, então a gente vai simplesmente aqui no package.json do pacote React, o nome aqui do pacote eu vou trocar para arroba.ignyui.react, vou salvar isso aqui agora, e agora a gente vai copiar do package do tokens os dois scripts que a gente tem aqui de build e de dev, eu vou colocar eles aqui dentro, salvo, e agora vou criar também aqui um src e um arquivo index.js, por enquanto aqui eu vou dar apenas um console.log ok, para a gente ver que está funcionando. Então agora, aqui dentro do pacote React, quando eu rodo nqm run build, ele vai simplesmente criar para a gente aqui uma build dentro de dist com arquivo index.js, você viu que eu nem criei ainda um arquivo test.config.json, mais para frente a gente vai criar um arquivo com essas configurações, por enquanto eu quero apenas mostrar como que funciona a importação entre esses dois pacotes. Uma vez que a gente fez esse processo, o que eu vou fazer aqui agora é o seguinte, eu vou voltar para a pasta root, ou seja, a pasta que está, a outra pasta packages, que é a mesma pasta que está esse readme aqui, e aqui dentro eu também vou dar um npm init ou seja, eu vou ter um package.json global do meu design system que não é o package.json do React ou o package.json do Tokens, porque eles são dois projetos separados e eu vou ter um projeto global, digamos assim, que engloba esses dois outros pacotes. E aí o nome aqui desse projeto, na verdade ele não tem tanta importância, ele nem vai ser utilizado, aqui dentro tudo isso aqui na verdade nem vai ser utilizado, porque a gente não vai ficar, a gente não vai publicar esse pacote global, os únicos pacotes que vão ser publicados no npm vão ser os pacotes que estão dentro aqui de packages, então eu posso remover aqui praticamente tudo, tá? Eu vou deixar somente aqui esse scripts que mais pra frente eu vou precisar, ah, por enquanto eu posso deletar também, mais pra frente a gente configura ele, show? Então aqui a gente vai começar configurando algumas coisas, a primeira coisa é que eu vou botar uma opção chamada private como sendo true, tá? Esse private true, ele basicamente diz que esse pacote aqui, ele não vai ser publicado no npm, ele é um pacote privado, diferente dos outros pacotes lá do react e do tokens ali que depois eles vão ser públicos, mas a gente não precisa colocar o private falso no caso deles. Então aqui depois desse private true eu vou além disso colocar uma opção chamada workspaces e aqui dentro de workspaces eu vou passar basicamente um array e eu passo o nome da pasta onde vão estar os meus pacotes, digamos os pacotes do meu monorepo, os meus subrepositórios digamos assim, e aí eu boto barra asterisco pra ele entender que todas as pastas que estão dentro da pasta packages são os repositórios aqui do meu monorepo. Agora, olha que interessante, eu vou salvar isso aqui agora, venho na pastinha tokens e vou deletar a pasta node modules e aqui na pasta react eu também vou deletar a pasta node modules. E agora, aqui no meu pacote react, dentro do package.json eu vou falar que esse pacote aqui ele tem uma dependência de desenvolvimento que é o meu outro pacote, então eu vou botar aqui arroba igniteui barra tokens e aqui eu boto asterisco porque como eu estou utilizando uma versão local eu não quero especificar uma versão específica, porque enquanto a gente está desenvolvendo o pacote tokens eu quero que ele já reflita no pacote react qualquer alteração que tenha, se eu colocar alguma versão fixa aqui ele vai usar uma versão estática daquele pacote e aí não vai refletir as alterações que eu fizer no pacote em si. Então, olha que interessante agora, quando eu salvo isso aqui e venho no meu design system e dou um npm install, a gente aguarda aqui um pouquinho, ele vai fazer as instalações, mas agora quero que você perceba algo muito interessante que aconteceu aqui dentro. Primeiro, a gente tem um package.lock.json agora que está aqui na raiz, inclusive esses outros package.lock aqui eu não sei se a gente precisa, deixa eu ver, eu vou tentar remover eles, vou dar um npm install de novo, é, a gente não precisa deles, os package.lock.json que estão dentro dos pacotes, e agora uma das coisas, uma das vantagens da gente utilizar Monorepo é que todas as dependências dos nossos pacotes, elas são gerenciadas de uma forma global. Veja que agora eu tenho uma única pasta NodeModules, que está na raiz do meu projeto, e essa pasta NodeModules, por exemplo, como os meus dois pacotes, tanto o react quanto o tokens, dependem de bibliotecas comuns, como é o tsup e o typescript, eu não preciso agora ter duas vezes essas bibliotecas, o tsup e o typescript, instalada individualmente em cada um desses pacotes. Então eu tenho um único NodeModules aqui, que tem o typescript, que tem o tsup também, e esses pacotes são compartilhados entre os demais subrepositórios aqui do meu Monorepo. E além disso, agora o meu pacote react, ele tem instalado uma versão local do meu pacote tokens. Inclusive aqui dentro de NodeModules, eu consigo ver que tem uma pastinha chamada arroba.igny.ui que foi o nome que eu botei aqui no pacote, e dentro eu tenho um symbolic link, tá vendo que ele até tem essa flechinha aqui, um symbolic link, na verdade, dentro do Unix, não sei se no Windows tem também, mas ele é basicamente uma referência para uma pasta que está em outro local do seu computador. Não quer dizer que a pasta react e a pasta tokens, elas realmente estão alocadas aqui dentro da pasta igny.ui, na verdade é apenas uma referência para essa pasta que está em outro caminho. E qual que é esse outro caminho, é basicamente o diretório que está aqui dentro da pasta packages. E agora, para a gente conseguir fazer uma importação, por exemplo, de algum arquivo que está aqui dentro de tokens, dentro do nosso projeto react, a gente precisa aqui no nosso package json, falar qual que é o script main aqui, e passar algumas instruções para outros projetos que forem importar esse token, saberem como importar esse token em si. Além disso também, eu vou botar que o arquivo principal está dentro de dist-index.js. Além disso, eu vou passar uma outra opção aqui que se chama module, que é qual que é o arquivo principal quando você usa o ECMAScript modules, então eu vou botar dist-index.mjs. Eu gosto também de botar aqui o ponto barra na frente, não é obrigatório, mas eu gosto de colocar. E aqui a gente vai passar uma última opção que é types, que é basicamente uma opção usada apenas pelo typescript para falar quais são as tipagens desse projeto aqui, que é o nosso arquivo de definição de tipos do typescript. Então a gente já passou esses três arquivos aqui agora, a gente pode salvar, e a gente vai copiar esse mesmo processo aqui, e a gente vai fazer agora lá dentro do package do react em si. Agora, o que eu vou fazer? Vou rodar um npm install só para garantir que está tudo certinho, vou entrar dentro do pacote de tokens, e para garantir, vou rodar o processo de build, para ele criar aqui a nossa build novamente, só para ver se está tudo certinho, e agora, teoricamente, dentro do nosso projeto react, eu já consigo importar coisas que são relativas ao projeto de tokens, mesmo sendo um projeto separado. Então olha só, eu posso escrever agora import from ignite-ui-tokens, e aqui agora, dando um ctrl espaço, eu vou ver que ele traz todas as variáveis que a gente tem lá no projeto de tokens, colors, font-sizes, e por aí vai, se eu botar aqui colors, e der um console.log aqui dentro em colors, salvo isso aqui agora, vou rodar dentro da pasta react o processo de build, e aqui, ele deu um errinho, vamos dar uma olhadinha, cannot find module ignite-ui-tokens, did you mean to set module resolution option to node? O que que acontece, né? Como a gente não criou a configuração do typescript, ele ainda não vai permitir a gente fazer certinho essa parte do build, mas a gente vai criar a configuração do typescript na próxima aula, e aí o build vai funcionar. Mas por enquanto a gente já percebeu que a gente consegue referenciar coisas do pacote de tokens aqui nas importações e exportações do nosso projeto, e com o tempo a gente vai otimizando aqui o processo."
  },
  {
    "id": "404c527d-74c0-4166-9ad5-47eac31a754e",
    "title": "Configuração do TypeScript",
    "transcription": "O que a gente vai fazer nessa aula é criar uma configuração do TypeScript que pode ser compartilhável entre vários pacotes. Por enquanto, a gente só tem um pacote Tokens e um pacote React. Mas, mais pra frente, a gente pode ter vários pacotes aqui dentro. E não é legal a gente criar uma configuração de TypeScript pra cada um. Até porque, na grande maioria das vezes, a configuração vai ser exatamente igual pra todos os pacotes. E aí, o que eu gosto de fazer, né? Como a gente está trabalhando com um monorepo, eu gosto aqui de criar um pacote chamado, por exemplo, tsconfig. E aí, eu vou acessar essa pasta tsconfig. Vou também dar um npm init menos y aqui dentro. E aqui a gente não vai precisar instalar nada. A única coisa que eu vou fazer aqui dentro do package.json é colocar aqui arroba igniteui barra tsconfig. Aqui não vai ter arquivo main, não precisa de description. A version pode ficar esse aí. Scripts a gente não vai utilizar. Keywords também não. Author também não. E o license a gente vai colocar MIT, que inclusive é o que eu vou utilizar para todos os demais projetos. Então, eu já vou trocando aqui. E aí, dependendo do seu projeto, você pode usar outra licença. MIT aqui a gente vai usar como é um projeto open source aberto para todo mundo poder customizar da maneira que quiser. Ele vai ser MIT. E aqui, esse pacote, eu vou botar ele como private true, porque eu não quero publicar ele no npm. Isso aqui é um pacote que a gente vai usar apenas internamente para configuração do TypeScript. Então, não faz muito sentido a gente publicar ele no npm. Mas a gente pode ver no futuro se fizer sentido. E aqui dentro, a gente vai simplesmente criar dentro desse pacote tsconfig um arquivo com a configuração do tsconfig em si. Então, aqui dentro eu vou criar um arquivo chamado base.json, que é a configuração base do TypeScript. E aqui, novamente, eu vou deixar as opções que eu vou utilizar para esse projeto. Aí, como download, você pode baixar. A gente pode passar rapidinho por cada uma delas, mas é uma configuração muito básica do TypeScript que a gente vai estar utilizando aqui nesse projeto. E aí, aqui, uma outra coisa que eu vou fazer é o seguinte, eu vou criar uma outra configuração do TypeScript chamada react.json. Essa configuração do react.json, o que ela vai fazer? Eu vou utilizar a opção extends do tsconfig para estender a configuração base que eu já tenho aqui nessa pasta. Porém, adicionando algumas opções a mais aqui dentro do compiler options, que são as opções para o TypeScript entender código react. Então, a gente vai ter dois arquivos de configuração do TypeScript. O arquivo base, que vai servir para qualquer pacote que não use react. Então, o pacote tokens, por exemplo. E o react, que é para qualquer outro pacote que use react. Então, aqui, a gente vai passar react.jsx. Vamos passar aqui lib. E aqui, a gente vai passar um array com dom. E es2015. Vamos passar aqui module. Esnext. E aqui, target.es6. A gente vai salvar isso aqui agora. E aí, novamente, digo, nossa, de onde você tirou tudo isso? Cara, isso aqui é muito copiar e colar de outros projetos que a gente acaba já utilizando aqui dentro da Rocket, o próprio Design System. Então, cada opção aqui tem, claro, o seu motivo. E caso você queira entender essas opções, você pode também entrar na própria documentação do TypeScript. Ou, o que você pode fazer é botar isso aqui dentro de um arquivo tsconfig. E quando você bota isso dentro do arquivo tsconfig, você passa o mouse por cima e ele fala o que cada uma dessas opções aqui significa. Fechou? Mas, vamos lá. Agora, o que eu vou fazer? Esse pacote tsconfig, agora que ele já foi criado, a gente pode referenciar ele dentro do package.json dos nossos outros pacotes. Então, aqui dentro do pacote tokens, por exemplo, em dev dependencies, eu vou colocar igniteui-tsconfig qualquer versão, da mesma forma que eu fiz lá com o pacote tokens. Salvo isso aqui agora, volto no pacote react, faço a mesma coisa aqui dentro, salvo. E agora, a gente vem aqui, volta na raiz do nosso monorep, e dá um npm install pra ele fazer a referência aqui dos pacotes. E agora, dentro do tsconfig aqui do nosso pacote de tokens, eu vou fazer simplesmente o seguinte. Eu vou dar um extends, arroba igniteui-tsconfig-base.json, porque como a gente não está usando o react nesse pacote de tokens, a gente pode importar o base, porque ele não vai ficar fazendo checagens de react, fica mais rápido. Aqui eu vou passar simplesmente include, falando onde que estão os arquivos que eu vou fazer checagem do typescript. Então, a gente vai passar aqui source, que é onde vão estar meus arquivos. E aqui, eu posso passar inclusive uma opção exclude, por exemplo, se eu quero eliminar alguma pasta. Como eu já botei o include, eu não preciso botar o exclude, que não vai ter efeito nenhum. Salvo isso aqui agora, vou copiar, a gente vai fazer a mesma coisa para o pacote react. A única diferença é que agora, aqui, eu vou utilizar react.json e não base.json. Vou salvar isso aqui agora, vou dar um npm install, só pra garantir que está tudo show. E agora eu vou testar se o processo de build está funcionando nos demais pacotes. Vamos começar pelo tokens, npm run build, show, tudo certo. E agora a gente vai no pacote react, npm run build, e pronto, tudo certo também. Inclusive agora, o nosso processo de build aqui no pacote react, inclusive, já conseguiu importar as cores do nosso outro pacote, do pacote de tokens, e colocou aqui dentro. Muito legal. E pronto, a gente conseguiu fazer a nossa configuração do typescript, e tem mais algumas coisas que a gente ainda pode configurar nesse monorepo."
  },
  {
    "id": "0ea59a56-3da6-4b6b-a61b-8d56c123d3ac",
    "title": "Criando pacote de tokens",
    "transcription": "O que a gente vai fazer nessa aula é começar a criar o nosso primeiro pacote aqui do Design System e a estrutura base do nosso projeto aqui, que vai utilizar React no final. Mas uma das coisas que é importante a gente entender de um Design System é que, como eu falei antes, o Design System precisa ser agnóstico de tecnologia até quanto possível, digamos assim. Por mais que os componentes da nossa aplicação não conseguem ser totalmente agnósticos, ao menos que a gente utilize, por exemplo, um SolidJS, ele é um framework basicamente, uma biblioteca, que a gente consegue escrever um formato de componente e a gente consegue usar esses componentes tanto no React, quanto no Vue, quanto no Svelte, quanto em qualquer outro lugar. Mas não vem o caso, a gente não vai utilizar ele. A gente precisa entender que tem algumas coisas do Design System que não são específicas do nosso pacote para React. Elas são coisas globais. Então, por exemplo, os próprios tokens, as cores, os tamanhos de fonte, a grossura da fonte, tudo isso são coisas que, na verdade, são independentes do React em si. Os componentes em si a gente só consegue escrever com o uso de alguma biblioteca, o React, o Vue ou até o Web Components ali na web. Mas os tokens podem ser facilmente compartilhados entre todos esses projetos, entre todas essas frentes. Então, é comum a gente dividir o nosso projeto entre vários pacotes menores. E um desses pacotes é o pacote de token, que é o pacote onde vai ficar todas as variáveis compartilhadas entre os projetos. As variáveis de cores, como eu falei, tamanhos de fonte, espaçamento e por aí vai. Então, o que eu vou fazer? Eu vou começar criando o nosso projeto. Então, eu vou dar aqui um mkdir e eu vou chamar o nosso projeto aqui de... Deixa eu ver como é que eu estava chamando os outros. Então, esse aqui vai ser o 05-design-system. Vou entrar, 05-design-system, a gente vai abrir isso aqui no Vascode. Vou copiar isso aqui só para eu não perder os meus componentes que eu tinha detalhado antes. E eu vou fechar essa outra abinha do Vascode. E aqui, show de bola, eu vou começar criando um readme.md e eu vou salvar isso aqui só para eu não perder. E eu vou trocar esses carinhas aqui na frente por checkbox do markdown, que é basicamente esses dois colchetes. E aí a gente vai colocando um X aqui depois nos componentes que a gente já terminou de codar. E aí, como eu falei, o nosso design system aqui vai estar dividido entre vários pacotes. Para isso, eu vou criar uma pastinha chamada packages e dentro eu vou criar uma pasta chamada tokens. Eu vou entrar agora na pasta packages, na pasta tokens, e aqui dentro a gente vai começar a criar a estrutura do nosso primeiro projeto. Eu vou dar um npm init menos y, show de bola, ele já criou aqui um package json para a gente. E aqui, agora, o que eu gosto de fazer é colocar aqui no nome do pacote o seguinte. Como a gente vai publicar isso aqui no npm depois, eu gosto sempre de colocar o nome da organização do meu design system. Então, pensando que eu vou ter vários pacotes e todos esses pacotes vão ser publicados no npm, eu preciso unir eles dentro de uma mesma organização. Então, no Andromeda da Rocket, que é o nosso design system, a gente faz, por exemplo, arroba andromeda barra tokens, que é o nome do pacote. Nesse caso aqui, a gente pode botar, por exemplo, arroba ignite ui barra tokens, que é o nome aqui do nosso pacote. Fechou? A gente vai salvar. Aqui tem várias informações que não necessariamente a gente vai utilizar agora. O que eu vou fazer aqui agora, por enquanto, é criar uma pasta source aqui dentro de tokens e a gente vai criar os nossos arquivos de tokens em si. Então, por exemplo, nós vamos ter aqui um arquivo colors, que ele vai armazenar todas as cores que a gente vai ter aqui no nosso design system. E essas cores vão ser armazenadas simplesmente dentro de um objeto, uma estrutura mais simples possível para eu conseguir reaproveitar isso em qualquer tecnologia depois. E aqui eu vou jogar basicamente todas as cores que a gente vai estar utilizando aqui no nosso projeto. Dando uma olhada aqui no figma, é claro, eu poderia, se eu tivesse um figma focado no design system, essas cores já estariam dentro desse figma. Como eu não tenho, o que eu fiz aqui foi gerar essas cores aqui dentro do próprio figma, separadas aqui entre vários tons. Então, eu vou ter todos esses tons aqui de cinza dentro do nosso design system e também esses tons aqui do ignite. O que eu vou fazer aqui agora é já deixar para você conseguir fazer o download dessas cores e de todos os demais tokens. Eu vou deixar o link do repositório aqui nessa aula e aí você pode copiar esses tokens aqui e colocar dentro do seu projeto. Mas eu vou começar copiando apenas os tokens de cores aqui dentro e aí a gente vai ter tokens da cor branca, cor preta, todos os tokens aqui de cores cinza e também alguns tons de verde que a gente vai estar utilizando aqui, que são as cores específicas do ignite aqui dentro que vai ser o nosso design system. E aí com esses tokens de cores aqui configurados, outra coisa que eu vou fazer, como isso aqui se trata de um pacote, uma das coisas legais de fazer nesse caso é criar um arquivo index que ele re-exporta o que tem dentro dos nossos tokens, que no caso aqui, por enquanto, são apenas as cores em si. Então, a gente vai simplesmente re-exportar. Por quê? Porque num futuro, quando eu precisar fazer uma importação, ao invés de eu importar, por exemplo, colors de dentro de ignite.ui.tokens.colors, se eu não fizesse esse arquivo, com esse arquivo index aqui re-exportando, a gente pode exportar simplesmente dessa forma. A gente não precisa repetir colors aqui no final do arquivo na hora de fazer a importação. Show de bola! Como isso aqui se trata de um projeto em TypeScript, a gente vai precisar criar a nossa configuração do TypeScript aqui dentro. Então, no pacote de tokens, eu vou instalar, como uma dependência de desenvolvimento, o TypeScript em si. E a gente vai rodar aqui um npxtsc-init, e ele vai criar um arquivo de tsconfig.json aqui dentro. Logo, a gente vai customizar essas configurações, mas, basicamente, para eu verificar que isso aqui está funcionando, que isso aqui está rodando, se eu rodar npxtsc, ele deve converter o nosso código TypeScript para JavaScript. Veja que agora, clicando aqui nos arquivos JavaScript, eu consigo ver que ele converteu os arquivos certinho. Eu vou deletar esses arquivos JavaScript, porque a gente não vai utilizar eles, foi apenas para fazer um teste aqui, e logo a gente vai customizar e vai configurar isso aqui de uma maneira melhor. Mas, vamos continuar agora, porque a gente precisa criar todos os tokens que a gente vai usar aqui no nosso design system, e fazer o setup do projeto certinho."
  },
  {
    "id": "74907114-bd00-40eb-abb3-cd7bb53ac411",
    "title": "Tema dark no Storybook",
    "transcription": "Uma coisa que a gente vai ter que configurar agora, porque não dá mais pra conviver assim, é o tema Dark aqui no Storybook, porque por padrão ele vem com esse tema Light, mas a gente consegue facilmente trocar isso. Então, aqui no VS Code, dentro de Storybook, dentro de Manager, que é um arquivo que a gente vai criar aqui, manager.js, a gente vai fazer o seguinte. Deixa eu ver se a gente está com o plugin já instalado, senão a gente vai ter que instalar aqui. É, a gente vai ter que instalar. Nós vamos instalar, na verdade eu acho que ele vem automático, a gente não vai precisar instalar, não. Eu acho que ele já vem dentro do... é uma dependência de outra dependência do Storybook. A gente vai importar de dentro de storybook-addons e de dentro de storybook-theming, esses dois pacotos. De addons a gente vai importar addons e de theming a gente vai importar themes. E aí a gente vai dar um addons.setconfig theme themes.dark. Vou salvar isso aqui agora, para de rodar o Storybook, rodo de novo. Tá aqui, ele já fez um loading custom-manager-config e olha só, pronto. A gente já consegue ver que o Storybook agora já está com o tema dark aqui configuradinho. Pronto, não precisamos mexer em mais nada, para ser bem sincero. E é isso. Bom, essa aula é super curta, então eu vou aproveitar que a aula foi super curta e falar, bebam água, se alimentem bem, façam exercícios. Tchau."
  },
  {
    "id": "7dada0c3-aae0-48ac-bf49-9179ec8a5e18",
    "title": "Conceitos do Next.js",
    "transcription": "Nessa aula a gente vai falar um pouquinho sobre o Next, que é um framework que a gente vai estar utilizando ao longo de várias aplicações que a gente desenvolveu aqui no Ignite daqui pra frente. E assim como qualquer outro framework, o propósito do Next é trazer uma série de funcionalidades que estão comuns em aplicações front-end e utilizando React, de uma maneira mais fácil de serem aplicadas sem muita configuração, digamos assim. E assim também trazer um pouco de opinião, padronização em como você escreve o seu código de uma maneira mais manutenível, digamos assim. E a ideia por trás do Next hoje, claro, é trazer, como eu falei, todas essas funcionalidades pra dentro do seu projeto React, que não são poucas, a gente vai falar sobre elas ao longo de todo esse módulo, mas o propósito do Next ter nascido, na verdade, foi outro. Esse foi um problema que a gente sempre teve com a construção de aplicações com React, ou os famosos SPAs, Single Page Applications, e a gente vai falar um pouquinho sobre isso, e como o Next funciona por baixo dos panos. Então, eu já deixei previamente criado aqui um wireframe, um flowchart, dentro do FigmaGem, pra gente discutir um pouquinho sobre o que é o Next e por que o Next nasceu. Quando a gente não tinha o Next ou qualquer outra solução parecida, hoje existem vários frameworks que fazem quase que um trabalho muito semelhante, quando a gente não tinha essas opções, as aplicações que a gente desenvolvia com o back-end e o front-end separado, as aplicações SPAs, como a gente vem falando até então, elas sempre tiveram um problema, que é a parte de indexação, a parte de SEO, beleza? Então, vamos partir, porque esse foi o problema que originou o Next e outros vários frameworks e outras várias bibliotecas, apesar de que hoje esse nem, na verdade, é o grande problema por trás de por que essas ferramentas existem. Mas vamos entender de tudo, de onde que isso surgiu. Quando a gente desenvolve uma aplicação no formato SPA tradicional, imagina que a gente tem um front-end, e o front-end tem lá uma página com uma listagem de usuários. E aqui o texto vai ficar um pouquinho grande, deixa eu ver se eu consigo diminuir ele um pouquinho, para talvez não ficar tão grande aqui. Imagine que a gente tenha, então, uma página de usuários, quando o usuário acessa aqui no front-end a página de usuários, ele faz uma requisição para a nossa API na rota Users, imaginando que a nossa API seja uma API REST, certo? Essa API vai buscar os dados no banco de dados, certo? E vai devolver uma resposta em JSON para o nosso front-end. Essa resposta em JSON, que vai ser ali o array de usuários, vai ser interpretada pelo nosso front-end e vai ser convertida em HTML no fim das contas. Se o nosso front-end, no caso, o nosso front-end estiver utilizando React, esse JSON aqui vai ser basicamente algo que a gente vai jogar lá dentro do nosso render e vai fazer lá um map, vai percorrer cada item que foi retornado aqui do back-end e vai mostrar em tela, certo? Qual que é o problema, digamos assim, disso tudo, né? Se a gente for perceber, o front-end e o back-end são coisas totalmente separadas, certo? E quando o usuário acessa o nosso front-end, somente no momento que o front-end é carregado, que o mínimo de código JavaScript do front-end é carregado, que o processo de buscar as informações do back-end e trazer o JSON começa a acontecer. Diferente de aplicações que a gente tinha mais tradicionais ainda, antes do SPA, onde o back-end tinha toda a responsabilidade, desde interface, quanto acesso ao banco, e tudo isso já vinha carregado no acesso do usuário. Então, apesar de SPAs resolverem um problema de falta de interatividade, falta de flexibilidade e até essa falta e a problemática da gente não conseguir ter vários front-ends com clientes diferentes, iOS, Android, web, apesar de eles resolverem esses problemas, o SPA acabou trazendo essa dor de a gente não ter um formato, uma maneira simples da gente trabalhar com indexação dentro do Google e outros crawlers, digamos assim. Por quê? Quando o Google, e hoje o Google na verdade já consegue fazer indexação de SPAs na sua grande maioria, mas alguns outros bots e crawlers e até aqueles bots que fazem embeds dentro do Twitter, Discord, Facebook ou qualquer outra rede social, quando esses bots vão acessar a nossa aplicação, seja pelo motivo que for, esses bots na grande maioria das vezes, ou eles acessam a nossa aplicação com o JavaScript desabilitado, para ser mais rápido, para ser mais performático e para apenas consumir o conteúdo que tem naquela página, como título, descrição e imagens relevantes, e assim ele vai executar um código muito mais leve, sem JavaScript, ou até esses bots muitas vezes, eles têm um time-out muito curto, ou seja, quando eles acessam o nosso front-end, a nossa página, do nosso blog ou qualquer coisa assim, eles não vão ficar aguardando por requisições HTTP finalizarem ou pela interface da sua aplicação finalizar, ser exibida em tela, para eles entenderem que o conteúdo que está ali foi finalizado, é o conteúdo que está em página. Então isso aqui é um problema muito comum que a gente tem em grande parte das aplicações que a gente vai trabalhar com SPA. E aí o Next introduziu um conceito muito interessante, que você já deve ter ouvido falar, que é o SSR, que basicamente traduzindo a sigla, é um conceito chamado de Server Side Rendering. E aí o que é Server Side Rendering? Imagine novamente o mesmo contexto, a gente tem um front-end e um back-end separado. Quando o usuário acessa o nosso front-end, o que vai acontecer aqui é algo muito interessante, que é o seguinte, ao invés do usuário acessar diretamente o front-end da nossa aplicação, quando a gente tem uma aplicação Next, na verdade ele vai acessar um back-end da nossa aplicação e não diretamente o código front-end. Porém esse back-end que o usuário vai acessar, esse servidor, esse serviço que o usuário vai acessar, não é o nosso back-end, a nossa API tradicional em REST. É um terceiro serviço, um terceiro pontinho aqui, que eu chamo de Next. E ele nada mais é do que um servidor escrito em Node.js. Então esse servidor em Node.js é o Next. Então eu vou jogar o front-end aqui pra cima e eu vou colocar o Next como sendo a ponta final que o usuário entra em contato. Então olha só que interessante, o que acontece? Quando o usuário bate na nossa aplicação que está rodando em Next, o Next é um servidor Node. E o mais interessante da gente falar o porquê que ele é um servidor em Node é que o seguinte, código React, no fim das contas, nada mais é do que código JavaScript. E o Node é uma plataforma para executar código JavaScript. Se o React, no fim das contas, é apenas código JavaScript, quer dizer que o Node consegue entender código React mesmo pelo lado do servidor, mesmo pelo lado do back-end. E é aí que a coisa começa a ficar interessante. Porque quando o usuário acessa a nossa aplicação Next, o que vai acontecer é, o servidor Next vai disparar então uma requisição lá pro nosso back-end, por exemplo, buscando a lista de usuários, o nosso back-end vai devolver a resposta aqui pra esse servidor Next contendo o JSON, o servidor Next ainda estando numa camada back-end, digamos assim, vai montar o HTML da nossa página, o HTML ali da página que precisa ser exibida pro usuário, e aí isso aqui vai ser devolvido pro usuário ali no front-end. Ou seja, a gente pode ver que com o Next, usando o conceito de server-side rendering, a gente tem uma camada a mais que intermedia o front-end e o back-end da nossa aplicação, e essa camada a mais nada mais é do que um servidor em Node. E o que isso vai fazer é que quando tanto o usuário quanto crawlers, bots ou indexadores acessarem, baterem na nossa aplicação front-end, é que a nossa aplicação front-end não vai, digamos assim, carregar parte do código, carregar um código JavaScript e aí começar a fazer a requisição de users. Não. Ela vai ficar, digamos, em estado de network idle, basicamente que é aguardando uma resposta de servidor até ela ter algo visual pra ser exibida em tela. Ou seja, o momento que o nosso front-end carregar a primeira informação da tela, ele já vai ter disponível as informações mais importantes que a gente precisa pra aquela tela. Se a gente está falando de um blog, de um post, por exemplo, já vai ter o título, já vai ter a descrição, já vai ter o conteúdo, todas as informações necessárias. Então, isso aqui é basicamente como funciona o conceito de server-side rendering dentro do Next e é o que fez o Next ficar muito famoso. Só que o Next hoje tem várias e várias outras funcionalidades, como eu falei, que tornam todo esse processo aqui mais interessante. Uma das funcionalidades mais legais do Next que foi introduzido, na verdade, nem lembro mais quando foi introduzido, é o conceito de SSD ou Static Site Generation. Static Site Generation nada mais é do que o seguinte, imagina que a gente tenha um site que é um portal de notícias, assim como um portal da Globo, por exemplo. E essas notícias, na verdade, elas não saem, elas não são atualizadas a cada minuto. Geralmente uma nova notícia é adicionada a cada 10 minutos no site, imagine assim. Só que o nosso site tem tanto acesso que no intervalo desses 10 minutos, onde nenhuma notícia mudou, ele recebeu 1 bilhão de acessos. Eu estou jogando um número aqui muito alto só para você ver a magnitude que a gente pode resolver de problemas utilizando essa funcionalidade de SSD do NextJS. E esse 1 bilhão de acessos, se a gente pensar nessa estrutura tanto tradicional quanto essa estrutura de SSR aqui do Next, 1 bilhão de acessos vão gerar 1 bilhão de requisições para o nosso back-end, 1 bilhão de acessos ao banco de dados na tabela de notícias, 1 bilhão de retornos de respostas em JSON, ou seja, todo o processo vai se repetir 1 bilhão de vezes. Porém, quando a gente usa o conceito de Static Site Generation do Next, o que a gente consegue fazer é o seguinte, imagina que o usuário está acessando a ROM da nossa aplicação, e aqui eu vou puxar um quadradinho a mais só para a gente entender o que é isso aqui, então o usuário vai lá, acessa a ROM da nossa aplicação, deixa eu ver, o texto está ficando grande de novo, não sei porque, mas ele acessa a ROM, e aí quando o usuário acessa a ROM da nossa aplicação, a gente pode fazer com que essa página ROM fique num cache, ou seja, gerada de forma estática, o HTML puro, estático, sem nenhum carregamento back-end, por um intervalo de tempo. Então eu falo, olha, por 10 minutos, a cada 10 minutos, eu quero que a página ROM seja gerada do total 0, ou seja, que esse processo aqui se repita por completo, porém, no intervalo desses 10 minutos, todo mundo que acessar a página ROM vai consumir um HTML estático, sem precisar carregar todas essas informações do 0. Então ele vai fazer o seguinte, a partir do momento que o usuário acessou o front-end, bateu na página ROM, ele vai procurar no cache do nosso servidor, geralmente isso aqui é um CDN, um Content Delivered Network, e ele vai procurar lá pelo arquivo, por exemplo, o nosso ROM.html. Se esse arquivo aqui existir, pronto, todo o processo não precisa ser gerado do total 0. Se o arquivo não existir, ele faz o processo inteiro do 0, e aí quando ele termina esse processo, ele vai lá e salva o arquivo ROM.html no CDN, e depois de 10 minutos, esse processo vai acontecer novamente, e aí a gente chama isso aqui de Static Site Generation. É basicamente uma versão estática de cada página da nossa aplicação, ou das páginas que a gente escolher, para que a gente evite ficar chamando o nosso servidor de forma desnecessária, múltiplas vezes, e isso aqui é basicamente o que fez o Next ficar tão famoso. E é claro que aqui eu dei um pouco de acelerada na explicação, porque todos esses conceitos vão ficar muito mais claros conforme a gente for criando, for desenvolvendo uma aplicação, e for vendo quais são os problemas reais que a gente está mitigando conforme a gente vai optando por utilizar Server-side Rendering, Static Site Generation, e até outros conceitos que a gente tem ali do Next. Então, claro, bora desenvolver a nossa aplicação, porque aí sim tudo isso aqui vai ficar muito claro pra você."
  },
  {
    "id": "f76654b7-423b-44d8-a4d9-ffcd4d70bc46",
    "title": "Criando projeto com Next.js",
    "transcription": "Agora que a gente já entendeu o que é um projeto Next, a gente vai começar criando o nosso primeiro projeto. Pra isso, aqui na própria documentação do Next, eu posso vir em Docs, e dentro do Getting Started, a gente vai dar uma olhadinha aqui. E aqui tem basicamente a forma da gente criar o projeto utilizando ou o NPM com o NPX, o YARN ou o PNPM. E aqui eu vou estar utilizando o NPM, mas você pode estar utilizando o que você preferir. Eu copio aqui o código, venho no terminal, e rodo NPX, Create Next App Latest, aceito aqui pra ele instalar o Create Next App globalmente, e aqui eu dou um nome pro meu projeto. Esse projeto aqui eu vou chamar 04-IGNITE-SHOP, aguardamos aqui um pouquinho, e pronto, ele já vai fazer a instalação das dependências. Uma das coisas ruins aqui que eu acho do Next comparado ao Vite, é que ele faz o processo de instalação das dependências aqui já no momento que eu crio o projeto. Só que isso é ruim porque ele identificou que eu tenho o YARN instalado na minha máquina e já saiu utilizando o YARN pra fazer a instalação, mas eu não queria utilizar o YARN, eu queria usar o NPM, então na verdade foi um erro, digamos assim, do Next. Mas como ele usou o YARN aqui, eu vou deletar o YARN lock, e pra utilizar o NPM eu vou simplesmente voltar aqui a pasta do projeto, ele não deletou o YARN lock, vou deletar por aqui mesmo, e vou dar um NPM install, e pronto, ele já fez a instalação agora das dependências, porém utilizando o NPM, até por isso ele criou o package lock.json aqui. Eu vou deletar esse arquivo readme aqui que a gente não vai estar utilizando, e dentro do package.json eu posso ver que ele já deixou previamente criado pra gente alguns scripts. O primeiro script, que é o mais importante aqui, é o dev. Rodando o NPM run dev, ele vai, assim como o VIT ou qualquer outra ferramenta, fornecer pra gente um endereço pra gente ver a nossa aplicação funcionando. Então, eu venho aqui, por exemplo, clico aqui em localhost 3000, e eu já posso ver o meu projeto Next rodando aqui. Esse projeto Next, ele é um projeto React, como qualquer outro, isso é super importante dizer. Não é porque eu estou utilizando o Next que eu deixo de utilizar o React. O React está rodando por baixo dos panos, e a gente vai construir a nossa aplicação com o React tradicional, da mesma maneira que a gente vem construindo qualquer aplicação. Agora, se eu for dar uma olhada aqui dentro do restante dos arquivos que foram gerados pelo Next, eu posso ver algumas coisas que são super importantes da gente entender. Primeiro, o Next tem um local específico pra gente colocar todas as páginas da nossa aplicação. Então, toda vez que a gente for criar uma página, imagine a página como uma rota que o usuário precisa acessar, esse componente da página, ele vai ser criado sempre dentro do diretório Pages. E aqui ele vem também alguns outros arquivos e pastas que não são necessários a gente ver agora, por isso eu vou deletar a pasta API, e o componente, esse app e esse index, eu posso deixar aí, eles não são, digamos, necessariamente importantes que a gente mude algo neles agora, mas se a gente acessar esses arquivos, a gente vai ver que eles são arquivos React, componentes React tradicionais, assim como esse componente aqui. Ele vem também com uma pasta public, dentro dessa pasta public a gente pode ver apenas arquivos que são públicos, como a pasta mesmo já diz, então arquivos de fav com arquivos que a gente vai utilizar publicamente na nossa aplicação, eu vou deletar esses arquivos que a gente não vai precisar deles agora, e na pasta styles a gente tem arquivos de estilização. Para a gente partir de um ponto mais inicial ainda, eu vou remover a pasta styles, dentro da pasta pages eu vou trocar os dois arquivos index e app para tsx, porque eu quero utilizar typescript, dentro do arquivo index eu vou remover todas as importações e vou fazer com que ele retorne aqui dentro do arquivo apenas um h1, hello world, aqui ele deu um errinho, React refers to a UMD global, but the current file is a module considering adding import instead. Por enquanto a gente não precisa mexer nisso aqui, aqui no app eu vou tirar essa importação de tsx, até porque a gente deletou esse arquivo, e agora ele está dando alguns errinhos de typescript, mas isso é basicamente porque a gente não tem um arquivo de configuração do typescript, mas o Next ele gera um arquivo automático para a gente, basta a gente instalar no projeto o próprio typescript, a gente vai instalar também o types React, e a gente vai instalar o types Node também, todos como dependência de desenvolvimento. Depois de instalar essas três bibliotecas, eu vou rodar npm run dev novamente, ele vai identificar que eu estou usando typescript e criar um arquivo de configuração do typescript para mim. E aí voltando aos arquivos index e app, a gente pode ver que os erros aqui não existem E a nossa aplicação continua funcionando, porém a gente tem apenas um hello world agora aqui dentro. Outra coisa que eu gosto de fazer é que o Next ele obriga que o nome aqui do diretório para as páginas da nossa aplicação seja pages, porém esse diretório pode estar dentro de uma pasta source, então eu vou criar essa pasta source, src, e eu movo a pasta pages aqui para dentro. A pasta public eu não vou mover, ela precisa estar fora aqui da pasta source, perfeito? E agora a gente vai rodar npm run dev de novo, e eu posso ver que todo o nosso código ainda continua funcionando. Uma das coisas que é importante entender do Next é que esse arquivo index que está dentro da pasta pages, ele sempre vai ser a nossa home, então tudo o que a gente colocar aqui dentro desse arquivo é o que vai aparecer aqui no React quando a gente acessar localhost 3000 sem colocar qualquer endereço aqui, porém se a gente colocar qualquer outro endereço aqui, por exemplo, test, ele vai redirecionar a gente para uma página 404, porque por padrão o Next faz essa tratativa, se a gente digitar aqui algum endereço que a gente não esteja tratando na nossa aplicação, que a gente não tenha criado alguma rota na nossa aplicação, ele cria automaticamente uma página de 404, que inclusive é configurável e no futuro a gente pode mexer nela, mas é basicamente isso que a gente precisa entender da estrutura do Next antes da gente dar continuidade e começar a criar aqui a nossa aplicação."
  },
  {
    "id": "090d5065-f875-4550-ba27-f0bce16832c4",
    "title": "O hook useEffect",
    "transcription": "Nessa aula, a gente vai falar sobre um conceito, uma funcionalidade do React que é super importante, e se você estiver vendo aqui, eu até criei um projeto novo pra gente falar sobre essa funcionalidade, porque o que eu quero que você faça aqui é preste muita atenção no que eu vou construir aqui, e não tente copiar código nem nada disso. A ideia é que esse projeto que a gente vai construir aqui nessa aula, ele seja descartado depois, deletado, a gente não vai reutilizar ele, porque a ideia aqui é que eu pegue um projeto limpo, para a gente entender com mais facilidade essa funcionalidade, que é uma função exatamente que vem de dentro do React, chamada UseEffect. E o UseEffect, assim como o UseState, que a gente já viu anteriormente, são hooks do React. E hooks no React são funções que começam com o prefixo use, e elas têm como intuito adicionar algum funcionamento, acoplar algum funcionamento a algum componente da nossa aplicação. Então o UseState, a gente já conheceu que é um hook, que a gente consegue armazenar variáveis, que quando tem o seu valor alterado, provocam uma nova renderização no componente. Assim a gente consegue exibir em tempo real uma informação conforme ela for atualizada por alguma funcionalidade, algum clique do usuário, ou qualquer coisa assim. E hoje a gente vai conhecer mais sobre o hook UseEffect, que é um hook que eu também importo de dentro do React, e o UseEffect, de onde vem esse nome dele, de onde vem Effect? O Use a gente já sabe que são todos os hooks do React, mas Effect vem de SideEffect, que se a gente for traduzir para o português, é Efeito Colateral. Efeito Colateral, você já sabe o que é Efeito Colateral, é uma ação que é desmembrada, ela acontece por causa de uma ação anterior. Então Efeito Colateral nada mais é do que se eu fiz alguma ação, isso tem um Efeito Colateral. Então se eu pegar uma marreta e dar em cima do meu carro, o Efeito Colateral é o carro amassar. Então é uma ação que vem pós uma outra ação que eu já executei. E aqui no React, se a gente for traduzir isso aqui para código, o que acontece? Imagina que a gente tem aqui na nossa aplicação um botão. Eu vou começar com um exemplo muito simples e depois a gente vai aumentando. Esse botão aqui, ele tem como intuito adicionar um item numa lista existente. Então eu vou dar um nome aqui, addToList. Eu vou criar aqui um estado, que vai armazenar essa minha lista. E aqui ela vai ser um array, porque é uma lista. E aqui eu vou falar que ela é uma lista de strings. Então toda vez que eu clicar nesse botão aqui, ele vai adicionar uma nova informação nessa lista. Então eu vou criar até uma função aqui, addToList. E aqui eu vou dar simplesmente um setList. E aqui a gente já viu sobre mutabilidade. Sempre que eu quero adicionar uma nova informação a uma lista no meu estado, a um objeto, eu preciso copiar toda a lista que eu já tenho e adicionar um novo item no final. Como a gente está atualizando um estado que depende dele mesmo, atualizando uma lista, e essa lista depende do valor anterior, é legal a gente utilizar sempre uma arrow function pra respeitar as closures aí no React. Mas tudo bem. Agora, quando eu clicar aqui nesse botão, eu vou chamar a função addToList. E agora, pra ficar mais claro ainda, eu vou criar uma lista. E aqui dentro eu vou percorrer cada item da minha lista. E eu vou mostrar aqui um li. E aqui dentro eu vou colocar o meu item. Vou salvar isso aqui agora, meu projeto já está rodando. Se eu for no Chrome, está aqui a minha lista. E toda vez que eu clicar em addToList, eu tenho um novo item sendo adicionado. Se a gente for no console da nossa aplicação, é claro que a gente está tendo um erro aqui, porque eu não estou passando nenhuma key pra esse item. Mas tudo bem, a gente vai deixar isso de lado porque não é um intuito a gente falar sobre isso agora. Tudo bem, agora imagine que eu queira fazer o seguinte. Toda vez que eu tiver um item adicionado na minha lista, ou a minha lista seja modificada por qualquer motivo, seja um item foi adicionado, um item foi removido, ou um item foi atualizado, imagine que eu precise, toda vez que isso acontecer, avisar um sistema terceiro. Por exemplo, a minha API. Então, uma das formas que a gente tem de fazer isso, imagina que eu tenha uma função aqui que se chama avisarAPI. Isso aqui seria uma função, por exemplo, que ela pegaria a minha lista e enviaria lá pro meu back-end pra salvar, por exemplo. Então eu vou dar um console.log lista salva só pra gente entender. Claro que isso aqui é totalmente hipotético. Uma das formas de eu fazer isso seria eu vir aqui no final do addToList e chamar o método avisarAPI. Então se eu salvar isso aqui agora, toda vez que eu clico em addToList, ele executa aqui e dá um lista salva. Tudo bem, só que um dos problemas que a gente já viu em fazer isso aqui é que se eu der um console.log na minha lista aqui, logo depois de eu atualizar ela, eu vou ter no meu console.log o valor anterior à atualização. A gente já falou sobre isso aqui, o porquê que isso aqui acontece. Isso aqui é por causa de um funcionamento de closures dentro do próprio React. E aí eu teria que, pra ter acesso ao valor da lista real, salvar, por exemplo, uma variável, newList, esse valor aqui. Tudo bem, daria bastante problema. E qual que é o outro problema de fazer isso aqui? Imagine que daqui a pouco, dentro da minha aplicação, eu tenha um método também pra remover o item da lista. Meu teclado bugou de novo. Peraí que eu vou desbugar meu teclado aqui. Prontinho. Imagina que agora eu tenha uma função removeFromList, que agora essa função vai remover um item da lista. Ela vai remover um item da lista. E aqui eu não vou criar a funcionalidade. É só pra gente realmente imaginar isso acontecendo. E aí, novamente, depois de eu remover um item da lista, eu preciso também avisar a minha API. Então, tá vendo que eu começo a ter que repetir essas chamadas do método avisarAPI toda vez que a minha lista mudar? Então, pra isso, a gente tem o hook useEffect. O useEffect permite eu ficar monitorando mudanças em uma variável, e toda vez que essa variável mudar, independente de qual o motivo e qual a origem, quem alterou essa variável, eu quero que alguma função seja disparada. Então, o useEffect é muito simples. Eu passo useEffect aqui dentro mesmo, eu não assino ele a nenhuma variável, e dentro do useEffect ele recebe dois parâmetros. O primeiro parâmetro é qual função vai ser executada, e o segundo parâmetro é quando. Ou seja, o segundo parâmetro é um array. E dentro desse array eu passo, basicamente, qual variável que eu quero ficar monitorando. Então, nesse caso, eu vou monitorar a variável list. Toda vez que essa variável mudar, eu quero executar o método avisarApi. Se eu salvar isso aqui agora, veja que aqui no Chrome, toda vez que eu clicar em add to list, ele já dá o console.log aqui, lista salvo. E o melhor disso tudo é que se eu der um console.log no list aqui dentro, a gente vai ver que o meu console.log já vem com o valor do novo item aqui dentro. Perfeito? Então, a gente entendeu como que funciona o useEffect aqui, mas a gente tem que entender mais algumas coisas importantes aqui dentro antes da gente continuar. Pra gente continuar entendendo aqui sobre o useEffect, tem algumas coisas que é sempre importante a gente reforçar sobre o React em si. Então, olha só. Se eu colocar um console.log aqui na raiz do componente, tá vendo que ele não tá nem dentro do useEffect, nem dentro dessa função. Ele tá aqui na raiz, pode ser em qualquer lugar. E nesse console.log eu fazer um log do meu list, e aí eu vou até comentar aqui o meu useEffect. Veja que toda vez que eu adiciono um item na lista, esse console.log também aparece aqui. E aqui ele tá aparecendo duas vezes porque o React, nas suas versões mais recentes, o Vit, aqui dentro do main, ele tá vindo com esse strictMode, que faz com que em desenvolvimento tudo execute duas vezes. Mas se você quiser desabilitar isso aqui por enquanto pra não prejudicar o entendimento, isso aqui não vai piorar a performance do seu app em produção, e até é melhor deixar, mas por enquanto eu vou tirar só pra gente não se perder. Eu vou salvar, vou voltar e vou fazer de novo. Veja que quando eu clico em Add to List, ele dá o log também do meu novo item. Então, o porquê que isso tá acontecendo? A gente já viu que o React, toda vez que eu mudo alguma variável do state, que é o que eu tô fazendo aqui, eu tô dando um setList, mudando esse valor da variável list, esse componente aqui renderiza de novo, ou seja, é como se essa função aqui fosse executada de novo. Ou seja, tudo que tá dentro dela é reprocessado. Se eu tiver algum console.log aqui na raiz dessa função, esse console.log vai ser executado de novo. Tá, Diego, então... Ih, aí chegou o interfone, pera aí. De volta aqui, e uma das perguntas que você pode ter, beleza, se esse console.log aqui ele executa toda vez que eu tô mudando a lista, por que que eu vou utilizar, então, o UseEffect? Por que que aqui eu não chamo direto o Avisar API? Porque a gente tem que entender que no UseEffect eu posso falar exatamente quais variáveis eu quero monitorar. Enquanto quando eu coloco um código aqui na raiz do meu componente, não interessa como esse componente renderizou, ele vai chamar esse código de novo. Ou seja, muitas vezes a gente vai executar códigos desnecessariamente. Então a gente tem que evitar ao máximo, principalmente realizar ações que são onerosas, pesadas, aqui no nosso componente. Mas show, vamos continuar aqui, porque a gente pode entender como que a gente pode aprimorar ainda mais o nosso entendimento sobre o UseEffect. A gente já aprendeu que o UseEffect ele vai executar toda vez que a minha lista mudar. Mas tem mais duas coisas super importantes sobre esse hook. O UseEffect, ele executa também no início, assim que esse componente for exibido em tela. Então aqui se a gente for no Chrome e der um F5, a gente vai ver que ele deu aqui o console.log lista salva, porque o nosso UseEffect, ele vai executar no início e depois toda vez que a minha lista for alterada. Então todo o UseEffect, por padrão, ele executa também assim que o componente é exibido em tela uma primeira vez. A gente tem que ter isso em mente. E se a gente não quer executar nesse momento, a gente vai ter que colocar um if aqui dentro, validando. Por exemplo, se a lista aqui for vazia, aí eu não quero executar. Ou melhor, se ela for diferente de vazia, aí sim eu quero chamar o método avisar API, por exemplo. E aí nesse caso, ele já não executa mais no início, e aí quando eu adiciono a lista, aí sim ele executa. Ou seja, a gente pode fazer condicionais aqui dentro do nosso UseEffect em si. Fechou? E outra coisa que é muito importante, a gente tem que sempre lembrar de colocar aqui as dependências, a gente chama esse array aqui de dependências do UseEffect, que são as variáveis que ele fica monitorando. E outro detalhe do UseEffect que é muito importante. Muitas vezes, durante a construção da nossa aplicação, a gente vai querer executar algum código uma única vez assim que o componente for exibido em tela. Por exemplo, uma chamada para uma API para buscar dados do GitHub ou qualquer coisa assim. E nesses casos, a gente também pode utilizar do UseEffect. Lembra que eu falei que o UseEffect vai executar duas vezes em dois momentos na nossa aplicação. Primeiro momento, sempre que o componente for exibido em tela. Então todo o UseEffect, ele executa assim que o componente for exibido em tela. E o segundo momento é toda vez que alguma das variáveis que a gente passar aqui nesse array de dependências mudarem. Só que se eu não passar nada aqui no array de dependências, quer dizer que ele vai executar apenas em um momento, que é quando o componente aparecer em tela. Então, se eu quero que algum código seja executado somente na primeira renderização, que é a primeira vez que esse componente aparece em tela, basta eu criar um UseEffect com o array de dependências vazio. E aí a gente pode ver que ele mostra que é na primeira renderização, mas quando eu adiciono novos itens na lista, ele não executa mais. Ou seja, isso aqui executa uma única vez apenas. Isso aqui é ótimo quando eu quero, por exemplo, fazer uma chamada para uma API. Então aqui eu posso, por exemplo, para demonstrar, fazer uma chamada para a API do GitHub, pegar aqui todos os repositórios do meu usuário, e aí com a resposta eu posso fazer o seguinte, por exemplo, venho aqui... Ai, dei um soco no microfone aqui. E atualizo a minha lista, por exemplo, que está aqui em cima, com base nos valores que eu puxei lá dos repositórios. Então eu vou percorrer os repositórios aqui e vou pegar o nome deles, que eu acho que é fullname. Esse item aqui vai dar erro porque eu não tipei ele, então eu vou botar só um N aqui só para desencargo. E vou salvar e olha só, agora ele puxou e preencheu aqui a nossa lista com todos os repositórios, ou melhor, os 20 primeiros repositórios, porque a API do GitHub tem paginação, que tem lá do GitHub. E esse código aqui de puxar os dados vai executar uma única vez dentro da nossa aplicação, porque o meu UseEffect está com a rede de dependências vazia. Show? Então, beleza, a gente já aprendeu muita coisa sobre o UseEffect. Essa aula é bem conceitual, apesar de ser prática, a gente não está desenvolvendo a aplicação. Mas aqui eu quero passar mais uma informação super importante sobre o uso do UseEffect. E essa aqui eu quero que você anote, que é muito importante. É muito comum, quando as pessoas começam a utilizar o UseEffect e perceber que o UseEffect pode ser utilizado para muitas coisas, a gente até começar a usar o UseEffect de uma maneira errada. Então, o que eu quero dizer com isso? Imagine que a gente cria algum input aqui dentro do nosso HTML e toda vez que a pessoa digitar nesse input aqui, eu quero realizar um filtro. Então, handleFilter, por exemplo. Ou melhor, eu vou fazer o seguinte, eu vou criar um estado chamado filter, que é a maneira que a gente já viu anteriormente de como a gente pode fazer um input, salvar informações aqui no estado, controlar o valor do input. E aí eu vou falar, toda vez que nós digitarmos dentro aqui do nosso input, eu vou pegar o evento e vou dar um setFilter e .target.value e vou colocar o value aqui do input como sendo também o meu filter. E agora, o que eu quero fazer? Eu vou criar um UseEffect aqui em cima, e aí eu quero fazer o seguinte, toda vez que o valor aqui de filter mudar, eu quero criar uma lista dos dados aqui filtrada. Veja só, se a pessoa preencher alguma coisa nesse filtro, eu estou usando o UseEffect, monitorando o valor aqui de filter, e aí eu vou fazer o seguinte, eu vou criar um novo estado chamado filteredList, setFilteredList, e aqui eu vou fazer o seguinte, setFilteredList, como sendo a minha lista original, porém eu vou filtrar ela, eu quero apenas os itens que dentro do texto incluem o que eu digitei no meu filtro. Fechou? Então a gente fez um códigozinho aqui, e agora aqui no meu list aqui embaixo, na verdade eu vou duplicar essa ul, eu vou ter uma ul com a lista, e uma ul com a minha filteredList. Então são duas listas diferentes. E agora, deixa eu tirar um pouquinho o zoom, a gente vai ver aqui a nossa lista gigante, e agora se eu digitar aqui, por exemplo, next, a minha segunda lista aqui, que é a minha lista filtrada, a gente pode ver que ela mostrou todos os repositórios que tem next no nome. E aqui a gente poderia, por exemplo, até ir mais a fundo, digitar, por exemplo, gemstack, e eu posso ver que eu tenho aqui agora só o repositório gemstack. Só que se eu te falar que aqui a gente cometeu um dos maiores erros de quem utiliza o useEffect, o que acontece? Vamos entender o fluxo que a nossa aplicação percorreu aqui. O que está acontecendo aqui dentro? Assim que o componente foi exibido em tela, a gente executou esse useEffect, que buscou os dados da nossa API, os repositórios do meu GitHub, e salvou dentro do estado da lista. Até aí, perfeito. Esse useEffect aqui em cima a gente nem usou nesse exemplo, então nem vou falar sobre ele. Depois disso, nós temos um input, e toda vez que o usuário digitou alguma coisa dentro desse input, esse useEffect foi disparado, porque a gente está atualizando o estado, e aí é importante a gente entender o seguinte. Eu chamei o setFilter, nós tivemos uma atualização no estado. Quando eu atualizo o estado, o meu componente renderiza de novo, ou seja, tudo que está aqui dentro executa de novo. Com isso, o meu useEffect aqui foi disparado, porque ele viu que tinha uma mudança no filter, e ele atualizou um novo estado com a minha lista filtrada. E aí eu tive duas renderizações do componente, porque eu atualizei o estado duas vezes. Qual é o erro que a gente cometeu aqui? Sempre que eu vou criar uma informação, por exemplo, essa filteredList, originada a partir de outras informações do meu componente, isso aqui não precisa ser um estado. Eu não preciso criar isso aqui, e eu vou simplesmente pegar o conteúdo que eu estou colocando aqui do meu filteredList, e vou colocar numa variável const filteredList igual o filtro da minha lista em si. Se eu salvar isso aqui agora, veja que digitando jamstack eu tenho o mesmo resultado, só que eu evitei uma renderização dentro do React, porque agora quando eu digito no input, eu estou executando a atualização do estado aqui, o setFilter, ou seja, eu tenho uma alteração do estado. Quando o código chega nesse ponto aqui, ele só calcula o novo valor da variável filteredList. Ele não precisa salvar no estado de novo. Ou seja, a gente só tem uma renderização, e assim o nosso código é mais performático. Então, a dica final que eu quero te deixar nesse vídeo, e esse vídeo foi bem longo porque o UseEffect parece simples, mas muita gente faz muita besteira com o UseEffect, é que a gente dificilmente utiliza o UseEffect para atualizar o nosso estado. Se o nosso UseEffect está precisando muitas vezes atualizar o estado de forma síncrona, sem precisar fazer uma requisição, como a gente está fazendo, ou esperar alguma coisa, provavelmente a gente pode estar cometendo algum erro. Então cuida com isso. E esse aqui é o UseEffect do React. Tudo o que a gente viu aqui é tudo o que você precisa saber sobre o UseEffect no React, e mais pra frente a gente vai aprender mais casos de uso desse hook."
  },
  {
    "id": "8083e0f3-3b52-4112-b562-60fc305c6d06",
    "title": "Criando reducer de ciclos",
    "transcription": "Nessa aula a gente vai conhecer uma nova funcionalidade do React que a gente não viu ainda, que é o UseReducer, que na verdade são os reducers. O Use daqui é só para indicar que isso aqui é mais um hook do React. E o reducer, assim como o state, ele serve para a gente armazenar uma informação, assim como a gente está fazendo com essas informações aqui de ciclos, do id do ciclo ativo, e alterar essa informação no futuro. Geralmente a gente vai preferir utilizar o UseReducer para armazenar informações que são mais complexas, principalmente na hora que a gente precisa alterar essas informações. Então imagina, por exemplo, aqui o nosso array de ciclos. Se você for perceber, aqui embaixo, muitas das vezes que a gente vai alterar esse array de ciclos, geralmente é um processo um pouco custoso, digamos assim. Então se a gente for ver aqui a parte de interromper um ciclo, a gente vai ver que para interromper um ciclo eu preciso dar um setCycles, pegar o estado atual de ciclos, percorrer esse estado atual, verificar se o id do ciclo é igual ao id que eu estou querendo alterar. Se sim, eu faço uma alteração, ou seja, quando eu percebo que algum estado da minha aplicação, as alterações que eu faço nesse estado, geralmente dependem do estado na sua versão anterior. E essas alterações são geralmente onerosas, custosas, com bastante código e com cálculos e tudo mais. Nesses casos, faz sentido sim a gente criar um reducer, porque ele vai conseguir abstrair um pouco desse código para ficar mais simples na hora de utilizar e principalmente ele vai conseguir desacoplar um pouquinho essa lógica, por exemplo, de interromper um ciclo que no futuro pode ser chamada a partir de mais ações do usuário dentro de um único local. Ou seja, se a gente precisar interromper o ciclo do usuário, o ciclo ativo, que hoje a gente está fazendo esse código todo aqui em mais lugares da aplicação, hoje a gente vai ter que copiar esse código aqui e colocar em vários locais da aplicação. Mas com o reducer, é como se a gente tivesse um local fixo para todas as alterações que podem acontecer dentro de um estado do nosso componente, o estado que a gente selecionar. E para isso a gente vai começar criando um reducer para essa parte aqui dos ciclos da nossa aplicação. E por enquanto eu vou criar esse meu reducer aqui dentro do próprio provider, do contexto, mas mais pra frente a gente vai mover isso para um outro arquivo até para ficar mais simples. E vamos lá, o que a gente vai fazer aqui agora? É claro que vai dar um monte de bug, a gente vai corrigir isso com o tempo, mas eu vou começar removendo aqui o meu useState e eu vou trocar isso aqui para useReducer. E o meu useReducer recebe dois parâmetros. O primeiro parâmetro é uma função. O segundo parâmetro é qual o valor inicial da minha variável aqui dos meus ciclos. E eu vou chamar esse valor inicial aqui. O valor inicial na verdade vai ser um array vazio, certo? E aqui a gente já vai ver que ele está dando vários erros aqui dentro, mas não tem problema nenhum. E aí a gente vai continuar escrevendo aqui o nosso reducer em si. Então, bora lá. Agora, aqui dentro dessa função, essa função recebe dois parâmetros. E calma que no começo vai ficar um pouco confuso, mas depois que a gente terminar tudo, tudo vai se encaixar e vai ficar claro para você. Essa função aqui dentro sempre recebe dois parâmetros. O state, que digamos que é o valor atual, em tempo real, da nossa variável de ciclos. E uma action. A action é qual ação o usuário está querendo realizar de alteração dentro da nossa variável. Então, essa action aqui vai ser algo único, digamos assim, para indicar uma ação que o usuário está querendo fazer para alterar o nosso estado. Então, essa action pode ser, por exemplo, a gente pode chamar ela de interrupt. Para eu saber que eu estou querendo realizar uma interrupção do ciclo ativo. Ela pode ser uma action chamada add. Por exemplo, eu saber que eu estou querendo adicionar um novo ciclo. E por aí vai. São actions, são ações que o usuário pode realizar para modificar o nosso estado. Seja adicionar uma nova informação, remover e por aí vai. Isso já vai ficar mais claro com o tempo. E aqui dentro desse código, desse nosso useReducer, uma das primeiras coisas que a gente vai fazer aqui dentro é dar um return state. Então, a gente vai ver que com isso, alguns erros aqui já param de acontecer. E para a gente continuar aqui, uma das coisas que a gente vai fazer é começar tipando esse state. Falando qual vai ser o formato dos dados que eu vou armazenar dentro do meu reducer aqui. Então, aqui no state, eu vou dar dois pontos. Falando que a minha lista de ciclos aqui, eu vou armazenar um array de ciclos. Eu já tinha uma interface previamente criada para indicar um ciclo. E agora a gente pode ver que passando o mouse aqui em cycles, ele já sabe que isso aqui é um array de ciclos. E a minha action aqui, por enquanto, eu não vou ter uma tipagem para ela. Então, nesse caso, eu vou simplesmente falar que essa action aqui é N. Até para a gente não se preocupar com isso agora e entender mais como o useReducer funciona para depois a gente ir aprimorando a tipagem em si. E aí outra coisa que pode acontecer, lembra que eu falei que aqui agora a gente vai receber uma action que indica qual ação eu estou querendo fazer para atualizar esse estado. Aqui no nosso caso vai ser adicionar um novo ciclo, interromper o ciclo atual e por aí vai. Eu posso dar o nome que eu quiser para essa action. Ou seja, esse método aqui, ele vai ser um método para eu disparar essa ação. Ele não vai ser mais um método para eu alterar diretamente o valor aqui de ciclos. Então eu vou trocar o nome desse método para dispatch, que é geralmente o nome que a gente dá para uma variável, para uma função que eu quero disparar algum funcionamento. E olha só que legal, aqui dentro agora eu vou dar um console.log nos meus ciclos e também vou dar um console.log logo abaixo na minha action. Agora eu vou pegar esse código aqui do dispatch e a gente vai sobrescrever os lugares que eu estou utilizando esse setCycles, vou comentar. E eu vou trocar para utilizar o nosso dispatch. Dentro do nosso dispatch eu preciso enviar de alguma forma, alguma informação que lá dentro do meu reducer eu consiga distinguir uma action da outra. Ou seja, o que eu estou querendo dizer com isso? Quando eu chamo essa função dispatch, essa função aqui vai ser executada. E o valor que eu passei como argumento aqui do dispatch vai vir aqui no lugar de action. E aí aqui dentro eu posso fazer as alterações que eu quiser nesse estado. Ou seja, se aqui dentro eu enviar apenas o novo ciclo que eu quero adicionar, por exemplo, dentro aqui dessa action eu vou ter o novo ciclo que eu quero adicionar, certo? Porém, se lá embaixo na hora que eu interromper aqui o ciclo ativo, eu enviar, por exemplo, o id do ciclo que eu quero interromper, aqui dentro dessa função eu não vou conseguir distinguir quando eu estou fazendo uma ação de inserir um novo ciclo ou uma ação de interromper o ciclo, porque eu estou enviando uma informação aqui que não diz muito, digamos assim. Então quando a gente usa reducers dentro do React, é muito comum que ao invés da gente enviar a informação crua, eu envie um objeto, dentro desse objeto eu mando um type, e aqui nesse type eu falo qual que é a ação que eu quero realizar. E aqui eu posso dar o nome que eu quiser, por exemplo, add new cycle. Vou colocar tudo em letra caixa alta aqui pra ficar mais fácil, mas você pode dar o nome que quiser. E aí eu envio dentro de um outro objeto chamado payload os dados do meu novo ciclo. E aqui novamente, tudo isso aqui você pode dar o nome que você quiser. Eu estou te mostrando os padrões utilizados na comunidade, que é type e payload. E aqui dentro do payload eu envio o que eu quiser lá pra dentro do meu reducer. E agora eu vou copiar aqui embaixo, esse outro dispatch vai ser interruptCurrentCycle. E eu vou enviar aqui o meu ActiveCycleId. Aqui nesse payload também eu vou enviar o newCycle até pra ficar mais fácil, eu não vou chamar de data, porque data é muito genérico. E agora olha só que interessante, eu acho que eu já evitei todos os... Ah, tem mais um aqui, MarkCurrentCycleAsFinished. Vou comentar também, vou copiar o mesmo dispatch e aqui eu vou trocar pra MarkCurrentCycleAsFinished. E aqui eu vou enviar o meu ActiveCycleId. Beleza, essa função aqui eu não uso, então a gente já substituiu todos os lugares que a gente estava utilizando o setCycles. Vou deixar eles comentados, porque eu não quero perder esse código. E agora, se eu rodar aqui a minha aplicação e for aqui no especial elemento, dentro do meu console, olha só que interessante. Quando eu criar um novo ciclo, por exemplo o projeto 1, durando 20 minutos, quando eu clicar em começar, Create new cycle is not a function. Deixa eu ver isso aqui. Create new cycle. Aqui está enviando pelo meu provider. E eu estou usando essa função lá na minha home. UseCyclesContext.createNewCycle. Meu contexto está aqui. HandleCreateNewCycle. Vamos entender como é que está dando esse erro aqui. Então ele está falando que CreateNewCycle não é uma function. Então será que ele não está conseguindo utilizar aqui do nosso contexto? CreateNewCycle está certinho aqui. Então deixa eu fazer o seguinte. Aqui dentro, deixa eu dar um console.log no CreateNewCycle. Boto o projeto 1, 20 minutos, começar. Agora ele acessou. Não foi esse o erro. Mas ele deu aqui um CannotAccessCyclesBeforeInitialization. Isso aqui deu no nosso console.log. Esse console.log aqui, esse primeiro aqui eu posso tirar do CreateNewCycle. Mas esse console.log que eu dei aqui no Cycles, eu vou trocar ele para state. Que no final das contas vai ser a mesma coisa, porém dentro aqui da função a gente acessa sempre state. Esse state é o valor da variável Cycles. É o valor que a gente está armazenando no estado. Vamos lá, vamos de novo aqui no console. Projeto 1, 20 minutos. Vamos começar. Show. Deu certo. O que a gente pode ver que aconteceu aqui? O primeiro log, que é esse aqui no state, ele retornou um array em branco. Porque o array em branco é o valor do nosso estado, da nossa informação. É o valor do nosso estado, da nossa informação que a gente está armazenando. Ou seja, o valor de array de Cycles no primeiro momento. E aí, o segundo log da nossa action, a gente vai ver que veio exatamente o conteúdo que a gente passou aqui para o nosso dispatch. Então aqui, Type, AddNewCycle, PayloadNewCycle. Então se eu for ver aqui, PayloadNewCycle, eu tenho os dados do novo ciclo que eu quero adicionar. E aí, aqui dentro do meu reducer, eu posso fazer o seguinte. Se o action.type for igual a AddNewCycle, ao invés de eu retornar o state sem nenhuma alteração, eu vou retornar um novo array copiando o meu state e adicionando no final o action.payload.newcycle. Vou tirar esses console logs agora. E veja que agora, quando eu der um F5 aqui, projeto um 20 minutos, e eu der um Começar, o nosso ciclo começou normalmente. Então, o que acontece? Você vai ver que agora, aqui dentro do meu useReducer, eu tenho uma função que ela vai agregar, digamos assim, ser a função que recebe todas as ações de modificações nesse estado. Então, se eu quero adicionar um novo item, interromper o ciclo, marcar como finalizado, qualquer coisa assim, eu vou ter um ponto central para todas as alterações que precisam acontecer. E a gente identifica cada uma dessas alterações, a gente distingue elas através do type que eu envio aqui dentro do meu dispatch. E aí, eu posso realizar qualquer alteração que eu queira nesse estado. Lembrando que o retorno que eu faço dessa função aqui é o novo valor que esse estado vai receber sempre que uma action for disparada. E conforme a gente for dando sequência aqui, isso vai ficando mais claro, a gente vai fazendo com calma aqui, eu estou tentando ir com calma para você entender, mas lembrando que nem sempre a gente vai utilizar o useReducer. A gente vai utilizar ele mais nessas situações em que a gente tem um estado complexo, armazena informações complexas dentro de um estado, e essas informações precisam mudar constantemente com alterações provindas de várias fontes diferentes, de vários componentes diferentes e por aí vai, como é o que a gente está fazendo aqui com os ciclos em si da nossa aplicação."
  },
  {
    "id": "cdf2b47c-17d2-43bb-92e6-7e96fbbf7f5a",
    "title": "Configurando documento HTML",
    "transcription": "Nessa aula a gente vai estar configurando a fonte que a gente vai estar utilizando dentro do projeto, que é a fonte Roboto. Até vindo aqui em Assets, no projeto do Figma, a gente pode ver que está aqui a fonte Roboto, no tamanho Regular e Bold. E pra isso, claro, eu vou utilizar o fontes do Google. Eu já posso cair direto aqui que eu já tenho o link da fonte Roboto. E o meu já está até selecionado, Regular e Bold, mas vou fazer o processo inteiro caso você não conheça. Então a gente vem aqui em View All Styles, selecionamos Regular aqui na direita e Bold também, 700 aqui na direita. E agora aqui, depois de selecionar, nós copiamos esses três links aqui. Mas no Next, é um pouco diferente o processo da gente adicionar essa fonte aqui dentro. Por que? Lá nos outros criadores de projetos, digamos assim, como o próprio Vite ou o Create React App, independente de qual você esteja acostumado, existe um arquivo index.html disponível aqui na estrutura de pastas. Geralmente ele está dentro ou da pasta public ou aqui até na raiz do projeto. Mas no caso do Next, a gente não tem um acesso direto a esse arquivo index.html. Para a gente conseguir modificar coisas no documento global do HTML, no Next a gente precisa criar um arquivo dentro da pasta Pages, chamado underline-document.tsx. Esse arquivo document também vai ser um componente. Então uma coisa muito importante de entender é que no Next, ainda mais, tudo são componentes. Inclusive o HTML da página como um todo. E aqui dentro desse componente a gente vai retornar, digamos assim, o HTML, a estrutura global do documento da nossa página. Porém a gente não vai utilizar tags tradicionais do próprio HTML, como é propriamente o HTML, o HEAD e por aí vai. A gente vai importar, na verdade, alguns componentes de dentro de uma biblioteca, next-document. E aqui de dentro eu vou importar HTML com H, HEAD. O body não precisa, a gente vai importar o main com M e next-script. Já vou te falar o que é cada um desses carinhas aqui. O HTML, claro, é o que vem por volta de tudo. Dentro do HTML eu vou ter o HEAD com H e eu vou ter o body. E aqui o body vai ser a tag original do HTML. O body não existe um componente, digamos assim, que a gente importe de dentro do next-document. E agora aqui dentro do HEAD eu vou colar aquelas importações que eu fiz de fontes lá do roboto. E aqui agora eu vou colocar essa barrinha aqui no final para ele parar de dar alguns erros. Aqui também. E aqui também. E aqui no cross-origin ele não aceita que eu passe uma propriedade sem nenhum valor. E também, no caso do React, esse cross-origin, esse atributo, como são duas palavras juntas, cross-origin, o origin precisa começar com letra maiúscula e ele precisa ter um valor. Então aqui a gente vai colocar o valor de anonymous. E pronto. Assim as nossas fontes agora já estão configuradas. E agora aqui dentro do body a gente vai colocar a nossa tag main. O que é esse main aqui? Lembra que lá no Vite, ou até em outras aplicações que você já tenha construído, a gente tem aquele div com id, root, por exemplo, ou app. O main seria mais ou menos a mesma coisa. O main serve para a gente indicar para o next em qual lugar do HTML, do documento da nossa aplicação, vão os conteúdos das páginas que são carregadas sob demanda, de acordo com qual rota o usuário está acessando. E aqui no final a gente vai colocar o next script. O que é esse next script? O next script é basicamente em qual local do nosso HTML a gente quer carregar o JavaScript da página. Lá no Vite, por exemplo, se você abrir o index.html, você vai ver que tem lá script, type, text, JavaScript, e ele dá um source aqui, por exemplo, no main.ts, que está dentro da pasta source. No nosso caso a gente não escreve isso aqui inteiro, a gente escreve apenas next script. E a ideia é sempre colocar o next script no final da tag body. Hoje em dia não tem mais tanta necessidade disso, porque a gente já consegue trabalhar com propriedades na tag script, falando em qualquer momento que a gente quer que ela carregue o script. Você pode dar uma olhadinha no defer. Mas é recomendado pela própria documentação do next a gente colocar sempre aqui no final da tag body. E assim o nosso documento está finalizado. Aqui dentro agora eu posso salvar esse código. Venho aqui, vou reiniciar o meu servidor next. Uma das coisas importantes de dizer é que toda vez que eu modificar alguma coisa no document da minha aplicação, eu preciso reiniciar o servidor de desenvolvimento, porque o next só lê esse arquivo document uma única vez assim que a gente está rodando o servidor de desenvolvimento. Depois ele não fica monitorando esse arquivo. Abrindo agora o localhost 3000, vindo aqui em inspect, vindo aqui em elements e abrindo a tag head, a gente vai ver que aqui dentro teoricamente eu deveria ter a minha fonte roboto. Que não foi carregada? Será? Deixa eu dar uma olhadinha aqui. Bom, dando uma olhada aqui agora que eu já consegui fazer funcionar, eu não sei porque ele estava com um cache meio difícil de tirar aqui dentro. Então o que eu fiz aqui foi deletar essa pasta .next, na verdade, que ela é gerada junto com o next, que ela tem aqui dentro um cache, digamos assim, do nosso projeto. E isso corrigiu. Então eu vim aqui, deletei a pasta, rodei npm run dev de novo, e aí agora já está aparecendo aqui dentro do head os links que a gente fez para fonte roboto. Então a gente já pode começar a utilizar essa fonte aí no nosso projeto. E é importante a gente entender que o document, ele é o documento HTML como eu falei, ele é aquele index HTML do nosso projeto. E nele a gente vai colocar somente códigos que a gente quer que estejam disponíveis em todas as páginas do nosso projeto. Lembrando que qualquer importação ou qualquer código que a gente colocar dentro desse arquivo document, ele vai ser carregado em todas as páginas da nossa aplicação. E isso a gente tem que tomar um leve cuidado, porque se a gente coloca, por exemplo, a importação de um arquivo CSS aqui dentro desse document, ou qualquer coisa parecida, mas a gente entende que esse é um código que ele deveria estar disponível somente para algumas páginas da nossa aplicação, com certeza o document não é o melhor lugar para a gente fazer esse tipo de importação. Então o document, ele geralmente vai se manter o mais simples possível. A gente não vai colocar importações aqui dentro de CSS ou qualquer coisa assim. E para isso a gente vai descobrir, na verdade, depois, como que a gente vai fazer esse tipo de importação dentro de outros arquivos, inclusive do arquivo app, que logo a gente vai conhecer para que ele serve."
  },
  {
    "id": "632a3ecd-2e5b-4ca7-9c91-b4eb57a3dc83",
    "title": "Prop Drilling no React",
    "transcription": "Show! Continuando mexendo aqui no nosso código. Tem alguns erros aqui porque eu tirei alguns componentes aqui da ROM. Então eu posso inclusive remover essas importações aqui dos estilos. Mas não é muito sobre isso que a gente vai falar nessa aula especificamente aqui. É mais sobre o seguinte. A gente separou visualmente os nossos componentes. Então aqui na parte do HTML, digamos assim, eles estão separados. Mas a parte do JavaScript, a parte funcional dos componentes, ela ainda está tudo concentrada aqui na ROM. Mesmo que a gente tenha algumas dessas funcionalidades aqui, que a gente consegue perceber que elas são específicas de um componente. Do Countdown ou do New Cycle Form. Por exemplo, esse estado que controla quantos segundos se passaram desde que o Countdown iniciou. Isso aqui é totalmente específico do Countdown. Então eu posso pegar isso aqui, por exemplo, e mover para dentro do Countdown. Eu venho aqui, importo o UseState. Volto aqui para o meu index e vou olhando aqui para as outras coisas. Eu tenho essa parte aqui do UseForm. Isso aqui também me parece específico do nosso New Cycle Form. Então eu venho aqui e jogo aqui para dentro. E aí trago também junto tudo que é específico. Por exemplo, essa parte de validação aqui. Jogo aqui para dentro do New Cycle Form. Faço a importação do Zod aqui dentro. Faço a importação do UseForm, que vem do ReactForm. Do ZodResolver. E esse aqui, beleza, já conseguiu entender a importação aqui também. Show de bola. Então a gente já está movendo as coisas aqui para dentro. O Register já parou de dar erro. Vou continuar lá na minha Home. Tem mais algumas coisas aqui que a gente pode ir percebendo. Aqui eu tenho o total de segundos. Isso aqui é totalmente relacionado ao Countdown. Porque eu só crio essa variável aqui para eu conseguir reduzir o Countdown de segundos e segundos. Então eu posso mover essa variável aqui para dentro do Countdown, por exemplo. E aqui a gente não está se preocupando com os erros ainda. Eu venho aqui no Index. Eu tenho esse UseEffect todo aqui. Ele só serve para reduzir o Countdown de 1 em 1 com o segundo se passando. Então eu vou jogar esse UseEffect todo. Cuidado para copiar ele certinho até a próxima função dentro do nosso componente de Countdown. Faço a importação aqui do UseEffect. Faço a importação aqui do Difference in Seconds, do DateFns. Então fiz todas as importações aqui necessárias. Mas uma coisa que a gente pode perceber que é um pouco de problema. É que o seguinte, conforme a gente começou a separar as coisas, o que começou a acontecer aqui? O nosso componente de Countdown começou a precisar de informações como, por exemplo, o ActiveCycle. Que eu não posso pegar essa variável ActiveCycle e mover lá para dentro. Por que não? Porque essa variável ActiveCycle é usada também aqui no componente Home. Aqui, por exemplo, para definir se eu mostro o botão de começar ou o botão de interromper. Então se eu mover esse ActiveCycle lá para dentro do Countdown, eu perco acesso a essa variável aqui fora. E não só isso. E não só isso. Se eu mover a variável ActiveCycle lá para dentro, ela depende do nosso estado de Cycles. Então eu teria que mover esse estado também lá para dentro. Mas se eu mover esse estado de Cycles lá para dentro, esse SetCycles aqui, por exemplo, que eu uso quando eu crio um novo Cycle, não vai funcionar aqui fora. Eu não vou ter acesso a essa variável aqui fora. Ou seja, tem informações que eu não posso mover para dentro do Countdown, porque elas precisam ser utilizadas fora do Countdown também. E tem outro caso aqui que também está uma problemática. Tem coisas, por exemplo, aqui no new CycleForm, eu movi aqui para dentro o nosso UseForm. E o nosso UseForm aqui que eu estou usando dentro do new CycleForm, ele me devolve as funções HandleSubmit, Watch, Reset, que são funções que eu preciso usar lá no componente Home. Aqui, o HandleSubmit aqui embaixo, Watch, Reset. Está vendo que está ficando confuso como que os componentes vão se conversar? E aí se você lembra aqui das aulas, se você lembra quando a gente começou a falar sobre propriedades, a gente falou que a principal forma de a gente fazer comunicação entre componentes é utilizando propriedades. Então, por exemplo, se o meu Countdown precisa ter acesso ao ActiveCycle, eu posso receber o ActiveCycle aqui como uma propriedade. Aqui eu vou deixar como Any por enquanto, porque eu não quero adicionar o TypeScript por enquanto. Então eu posso receber de dentro das minhas propriedades o meu ActiveCycle e aí eu venho lá na minha Home e envio aqui para o meu Countdown o meu ActiveCycle. Perfeito, funciona. Só que se eu for olhar lá para o Countdown, ele precisa também acessar a função SetCycles. Show, vamos lá, a gente pode enviar para o Countdown a função SetCycles para ele utilizar lá dentro também como uma propriedade. Venho aqui, declaro ela aqui também. Vou deixar como Any por enquanto, já explico o porquê disso. Show, agora a gente tem acesso também à função SetCycles para usar aqui dentro. Beleza. Só que o Countdown, ele precisa também da informação do ActiveCycleId aqui. Vamos lá, a gente pode enviar para o Countdown também o ActiveCycleId, que é uma informação que também está aqui nesse componente. Vou lá no Countdown, ActiveCycleId e uso aqui dentro. Show, está dando tudo certo, a gente está evitando todos os erros. Está vendo que está ficando estranho isso que a gente está fazendo? Porque, teoricamente, a gente separou os componentes em componentes menores, o Countdown e o NewCycleForm, para que as coisas ficassem mais simples de dar manutenção, mais performáticas. Mas com o tanto de propriedades que a gente está tendo que passar de um componente para o outro, da Home para o Countdown e depois da Home para o NewCycleForm, só para fazerem eles se comunicarem, terem acesso às mesmas informações, isso aqui deixa o nosso código muito mais complexo do que se tivesse tudo num componente só, sendo bem sincero. Isso, na verdade, é um problema bem comum. No React, a gente chama isso de PropDrilling. PropDrilling nada mais é do que a propriedade de um componente, PropDrilling nada mais é do que quando a gente tem muitas propriedades apenas para comunicação entre componentes, que é o que a gente está fazendo aqui agora. Quando a gente precisa passar muitas, e a gente nem terminou, teria que ser pelo menos mais umas três aqui dentro, quando a gente tem muitas propriedades sendo repassadas para componentes filhos da árvore, aqui do nosso componente pai, nesse caso aqui da Home, só para ficar fazendo a comunicação entre esses componentes, isso pode ser bem trabalhoso e prejudicar bastante a manutenção da nossa aplicação. E aí, quando a gente conheceu o conceito de propriedades no React, eu falei que propriedades é a principal forma de a gente comunicar, de fazer comunicação entre componentes. Então, se esse componente CountDown aqui precisasse de uma ou duas propriedades para ele saber sobre o seu componente pai, para ele receber, se ele só precisasse, sei lá, o ActiveCycle, show, propriedades está tranquilo, resolve lindamente e fica muito bom. Mas a partir que eu tenho três, quatro, cinco, seis propriedades sendo repassadas, e não só para um, mas para dois componentes, para três, quatro, isso começa a ficar um pé no saco para dar manutenção. E aí, a gente tem outra forma de resolver isso, que é utilizando um conceito do React chamado Context API. A Context API permite compartilharmos informações entre vários componentes ao mesmo tempo. E o mais legal da Context API é que ela não precisa utilizar de propriedades, é como se fossem informações globais, que todos os componentes podem ter acesso, todos os componentes podem modificar essas informações, e que quando modificadas, independente de quem modificou essas informações, todos os componentes que dependiam e dependem dessa informação são atualizados. É como se a gente conseguisse falar ao mesmo tempo, se comunicar ao mesmo tempo com várias componentes da nossa aplicação. Dentro da Context API, a gente pode colocar o que a gente quiser. Estados, por exemplo. Então, se eu quero que esse meu estado de ciclos seja acessado por qualquer componente da minha aplicação, eu consigo com a Context API. E assim vale para qualquer outra informação do nosso app. Então, a notícia boa é que a gente vai resolver isso aqui da melhor forma, e sem precisar ficar passando propriedades. A notícia ruim é que todo o código que a gente fez nessa aula, se você estava me acompanhando aí, a gente não vai utilizar. Todo esse código que eu passei aqui para dentro do new cycle form, do countdown, essa interface, a gente vai deletar isso, mas é importante a gente ter passado por isso para entender o porquê da Context API. Que nem sempre a gente vai precisar utilizar ela, que as propriedades podem sim resolver problemas simples de comunicação entre componentes, mas que quando a gente chega no momento de ter muitas informações que precisam ser compartilhadas com vários componentes, aí sim a Context API é o que resolve melhor para a gente."
  },
  {
    "id": "857fba60-ae0c-4b23-be27-8985c39c0431",
    "title": "Estrutura da página de produto",
    "transcription": "Nessa aula a gente vai criar a estrutura visual da página de produto aqui dentro do nosso projeto. Ela é uma página simples, mas vai envolver um pouquinho de HTML e CSS. Por isso a gente vai dar um foco nisso agora pra já matar e depois vamos ficar se preocupando com isso. Então, o que eu vou fazer aqui agora? Vou começar como eu sempre começo, HTML, e depois vou pro resto. Vou criar aqui dentro da pasta Pages um arquivo chamado Product.ts E aqui eu já vou deixar exportados alguns componentes que eu vou usar lá dentro. Então, o ProductContainer, vou usar aqui StyledMain. Eu vou criar também aqui um ImageContainer, que eu vou precisar. Que vai ser esse box aqui, que tem o gradiente por volta da imagem. Porque a imagem em si eu não consigo... até daria, mas ficaria uma gambiarra desgraçada. A ideia é ter uma div por volta e a imagem dentro. Então a div vai ser esse cara aqui que tem o background. Eu vou criar mais uma, pode ser uma div mesmo também, chamada ProductDetails. Essa ProductDetails na verdade vai ser essa div aqui que fica por volta de toda a parte de título, preço, descrição e o botão de comprar. Vamos lá então, eu vou salvar. E agora aqui dentro, vamos começar colocando o nosso ProductContainer. Dentro do ProductContainer vem o ImageContainer. Dentro do ImageContainer vem a nossa imagem em si. Eu não tenho o endereço dela ainda aqui. Então o que eu vou fazer para dar uma... Talvez... O que eu posso fazer, só para a gente não ficar sem nenhuma imagem em si. Eu vou vir aqui e vou copiar o endereço desta imagem aqui. Deixa eu ver só aqui, inspecionar. O problema é que ele está vindo ao endereço da imagem interna do Next. Eu vou fazer o seguinte, eu vou deixar sem imagem e depois a gente coloca. Porque eu quero pegar o link verdadeiro da imagem lá de dentro do Stripe. E aqui no ProductDetails eu vou começar colocando o H1, a camiseta X. Por enquanto eu não vou colocar os valores corretos, porque eu não fiz a requisição ainda para dentro do Stripe. Aqui a gente pode colocar um LoadingY. O Emmet aqui do Vascode traz para a gente uma descriçãozinha de LoadingY caso a gente queira. E eu vou ter um botão de Comprar aqui no final, escrito Comprar Agora. É isso. Vou salvar isso aqui agora. Voltamos aqui no CSS. Deixa eu abrir aqui a página de produto. Já podemos ver aqui como que ela está. Linda, né? Perfeito. Vamos lá. ProductContainer. A gente vai começar colocando aqui os nossos estilos agora. Deixa eu pegar minha colinha aqui, porque é óbvio que eu não sei isso aqui de cabeça. Show. Vamos começar colocando um DisplayGrid. Aqui eu vou colocar um Grid, porque são basicamente duas colunas, né? E as duas praticamente do mesmo tamanho, não tem muito o que a gente ficar se preocupando. Então, GridTemplateColumns. Aqui eu posso botar 1fr, 1fr. Poderia colocar com Repeat também, mas são só duas, não tem tanta necessidade. Eu vou colocar um AlignItems aqui. Stretch. Esse AlignItemsStretch vai fazer com que as duas colunas do Grid, elas estiquem para ter o mesmo tamanho verticalmente. Vou colocar aqui um Gap de 4rem, que é a separação entre os dois. Um MaxWidth de 1180. E um Margin zero alto, porque eu quero que centralize na tela. Então, se a gente for ver já como que está ficando. Já ficou mais legal. Aqui vai ficar a imagem, aqui vai ficar a descrição. Tá show. No ImageContainer, eu vou colocar aqui um Width 100%. Um MaxWidth de 576. Um Height aqui, eu vou fazer um cálculo. E a gente já vai entender o porquê, tá? Mas deixa eu deixar comentado, eu já te explico esse cálculo aqui. Vou colocar aquele BackgroundLinearGradient, como a gente tinha lá na Home. Então, deixa eu até copiar aqui. Vamos ter um BorderRadius 8. Um Padding 0.25rem. Um DisplayFlex. AlignItemsCenter, para a imagem ficar centralizada. JustifyContentCenter. E o Image, eu vou botar um ObjectFitCover, como a gente fez lá na Home. Para ele não distorcer a imagem quando a gente carregar essa imagem, às vezes com uma resolução um pouco diferente. E aqui no Height, como a gente vai salvar aqui, ele ficou pequenininho porque não tem nenhuma imagem dentro. Então, aqui no Height, eu vou fazer o seguinte. Eu vou colocar uma altura de 656, menos 0.5rem. Por quê? Porque eu quero que a altura seja 656. Se eu for aqui na imagem, a altura é 656. Só que eu diminui em 0.5rem, só para diminuir o tanto de Padding que a gente já tem em cima e embaixo. Poderia resolver isso aqui com um BoxSizing também. Daria na mesma, mas eu salvo isso. A gente já pode ver agora que a gente já tem aqui a nossa imagem. Ou poderia vir aqui no Global, tacar um BoxSizing. BorderBox. Vamos ver se não vai quebrar outras coisas. E aí eu coloco apenas Height 656. Salvo. E o resultado deve ser o mesmo. Vamos voltar lá na Home só para ver se não quebrou nada lá. Show. Não quebrou nada aqui. Então, a gente vai continuar dessa forma. E aqui no ProductDetails, que vai ser o CSS um pouquinho maior. Nem tanto, na verdade. Vou dar um DisplayFlex, um FlexDirectionColumn. E aqui agora a gente vai começar a estilizar cada um dos títulos e textos aqui. Esse primeiro H1 aqui, eu quero o FontSize dele de 32. Então a gente lembra que lá no nosso tema, a gente criou esse 2XL, que representa 2Hem. Então a gente vai jogar aqui um 2XL. E vamos colocar aqui uma cor Gray 300. Aqui a gente vai pegar o nosso Span, que é o preço. Vamos botar aqui um MarginTop 1Hem, um DisplayBlock. Um FontSize aqui também 2XL. E um Color Green 300. Podemos salvar e já podemos ver como é que está ficando. Está ficando bem legal. Bora pegar o nosso parágrafo da descrição. E aqui, MarginTop 2.5Hem. O FontSize aqui agora, eu vou colocar esse Median. LineHeight, a gente vai aumentar um pouquinho. Eu vou colocar 1.6, que é muito bom para textos escorridos. E aqui a Color, ele vai ser o Gray 300 também. Posso copiar até do próprio H1. Show! Já está ficando bem legal. Só falta o nosso botãozinho. O nosso botão, primeiramente eu quero que ele fique lá embaixo. Então posso usar um MarginTop alto. Ele já vai jogar o botão lá para baixo. Isso é legal. A gente vai colocar aqui também um BackgroundColor de Green 500. Um Border 0. Um Color White. Já dá para ver como é que está ficando. Vamos colocar aqui também um BorderRadius 8. Um Padding de 1.25Hem. Um CursorPointer. FontWeight Bold. E está pronto o nosso botão. Só o texto ficou um pouquinho pequeno. Talvez aumentar um pouquinho aqui. Jogando o FontSize Median. Agora precisamos fazer um Hover. Deixa eu dar uma vírgula aqui. Hover. A gente pode pegar aqui o BackgroundColor. Green 300. Show! Pronto! Nossa página aqui do produto. A estrutura dela já está pronta. Claro que a gente ainda não carregou as informações. Mas é isso que a gente vai fazer agora."
  },
  {
    "id": "af3d9408-3f4f-46a2-bce8-be9fc4a0d520",
    "title": "Utilizando SSG",
    "transcription": "Uma pergunta que eu quero te fazer agora, pra você pensar comigo, é o seguinte. A gente pode dar F5 várias vezes nessa página, concorda comigo? Estou dando F5, um F5 atrás do outro. As camisas que estão aqui, mudaram entre esses 5, 6 F5 que eu dei? Não. Qual é a chance delas mudarem? Pensa que isso aqui é um projeto real mesmo, um e-commerce que tem uma home ali com os produtos mais vendidos, sei lá. Qual é a chance disso aqui mudar? É muito baixo, concorda comigo? Deve mudar uma vez por dia e olha lá, às vezes nem isso. E aí que entra outra funcionalidade muito legal do Next, que a gente vai falar nessa aula. O problema de simplesmente a gente fazer essa requisição como a gente está fazendo hoje é que, como eu falei, as camisas aqui não estão mudando. Porém, toda vez que a gente dá um F5, toda vez que o usuário acessa a home da nossa página, a gente faz uma chamada pro Stripe. A gente executa um código aqui no server-side do Node. Isso aqui consome, digamos, memória, consome processamento. Tudo isso aqui leva um tempo e também acaba deixando a página mais lenta, né? Porque a gente pode ver que dando F5 aqui, demora pelo menos uns 300 milissegundos, 400 milissegundos pra página ser exibida em tela. Vamos até dar uma olhada aqui. Inspecionar, Network, vou dar um F5. Aqui ó, 367 milissegundos pra página ser exibida. Por quê? Porque precisou ser carregado toda essa requisição aqui da API. Só que existe um outro funcionamento no Next, não sei se você lembra da gente falando sobre isso, que é o comportamento de SSG, ou Static Site Generation. O que que acontece? Quando a gente tem uma página que ela não muda com tanta frequência, que a gente consegue, digamos, ter um cache daquela página pra ser exibida entre todos os usuários, uma mesma versão, como é uma home de um site, por exemplo, a gente pode usar esse conceito. E é muito fácil usar esse conceito, eu vou te mostrar aqui. Basta a gente vir aqui e trocar o nome de GetServerSideProps pra GetStaticProps. E aqui também pra GetStaticProps, que vem do Next. Remover essa importação que eu não tô usando aqui em cima. Vou salvar aqui agora, volto aqui na nossa página, dou um F5, e na verdade a gente pode ver que nada mudou. Isso porque em desenvolvimento, o Next, enquanto eu tô em ambiente de desenvolvimento, ele trata esse GetStaticProps exatamente como um GetServerSideProps. Ele não cria qualquer tipo de cache, qualquer tipo de otimização, até porque atrapalharia o desenvolvimento, a gente modifica alguma coisa da página e não muda, a gente fica p da vida. Então, pra evitar esses tipos de situação, o Next não permite que isso aqui funcione em ambiente de desenvolvimento. Ele vai funcionar exatamente como o GetServerSideProps. Porém, pra gente testar isso aqui funcionando, a gente teria que colocar o nosso projeto em produção ou executar o nosso projeto como se ele estivesse em produção, que é o que eu vou te mostrar agora. Mas antes de fazer isso, uma coisa importante de entender é que é o seguinte, o método GetServerSideProps que a gente estava executando aqui antes, ele era um método que ele executava em toda requisição que a gente fazia pra página da ROM. Ou seja, a cada vez que a página ROM era aberta, aquele método era executado. Concorda comigo? Ou seja, no método GetServerSideProps, como a gente está executando ele a cada requisição, a gente consegue ter acesso ao contexto da requisição. Então, por exemplo, se eu voltar aqui o que eu tinha antes, dentro do GetServerSideProps, aqui do parâmetro, eu consigo ter acesso aos dados da requisição, da resposta, consigo ter acesso aos dados dos query params que vêm ali, os próprios parâmetros, consigo ter acesso a várias informações que são específicas do contexto daquela requisição. Porém, quando eu migro isso pra um GetStaticProps, eu vou ver que agora eu não tenho mais acesso ao REC, ao REST, por exemplo, a requisição, a resposta, o contexto da requisição, porque o método GetStaticProps não roda a cada requisição feita pra página. Ele vai rodar somente no momento que o Next estiver criando uma versão estática, uma versão de cache daquela página. E quando que é isso? Então, o primeiro momento é quando a gente roda um build da nossa aplicação. Quando a gente coloca a nossa aplicação em produção, ele vai e procura por todas as páginas que precisam ser estáticas, que tem o método GetStaticProps, e gera uma versão estática delas. Então, olha só, eu vou cancelar o nosso servidor de desenvolvimento e vou rodar npm run build e não mais dev agora. Vou abrir um pouquinho mais pra gente visualizar o retorno. É só aguardar um pouquinho e a gente vai ver o que o Next vai criar aqui. Olha que legal. Veja só o que aconteceu aqui agora. Se a gente procurar aqui a nossa página home, que é essa aqui, que tem só a barrinha, a gente vai ver que tem uma bolinha branca do lado dela. A bolinha branca, se a gente for lá na legenda lá embaixo, olha só, SSD. Ele gerou, de forma automática, uma página HTML mais JSON. O que é esse JSON? JSON é isso aqui que a gente está retornando pra ele, as props. Porque ela tem o método GetStaticProps. As outras páginas que são bolinhas que não são preenchidas, como a Product, a Success, o Next também criou uma versão estática delas. Porém, sem nenhum JSON, sem nenhuma informação, porque elas são páginas que não têm o GetStaticProps. Ou seja, o Next também criou uma versão otimizada em cache dessas páginas, porque elas não têm nenhum tipo de informação dinâmica, elas são realmente só puro HTML, então é muito mais fácil criar um cache de HTML puro. Porém, sem o JSON, sem nenhuma resposta de API, nenhum GetStaticProps. E aí pra rodar agora esse nosso projeto, eu vou dar um npm run start. A gente aguarda um pouquinho. E olha só que interessante, quando eu entro agora na página localhost 3000, que é onde ele está rodando agora, veja só. Você viu a velocidade que ele abriu essa página? Vou fazer de novo aqui, dando um Ctrl Shift F5, olha só. Ele abriu a nossa página em míseros 5 milissegundos agora. Por quê? Porque essa página agora não está fazendo mais nenhuma chamada para API. Eu poderia ter colocado um console.log aqui dentro, e eu ia ver que o console.log não ia executar. Porque a partir do momento que eu crio a versão estática de uma página, esse GetStaticProps nunca mais é executado. E aí você vai falar, tá Diego, então é meio estranho, né? Porque se eu criar uma versão estática da minha página, quer dizer então que ela vai ficar estática para sempre? Ela nunca mais vai alterar? Só quando eu fizer um novo deploy, uma nova build do meu projeto? Então, quando a gente cria um GetStaticProps, uma página estática no Next, além das props aqui embaixo, a gente pode devolver também uma informação aqui chamada Revalidate, que é um número. O Revalidate é um número em segundos, que eu quero que essa página, digamos, seja recriada. Então o que vai acontecer? Se eu colocar aqui um Revalidate, por exemplo, de 5 segundos, ou melhor, de 10 segundos, o que vai acontecer é, essa página, ela vai ser gerada uma versão estática dela no momento que eu dou a build, o npm run build, e depois, a cada 10 segundos que uma pessoa acessar essa página, o Next, por baixo dos panos, vai criar uma nova versão dessa página. E todos os usuários que acessarem nesse intervalo de 10 segundos, eles vão consumir um cache estático, uma versão estática do HTML dessa página, que já foi criada previamente por um acesso de outro usuário. Isso é muito legal. A gente vai ver isso também com mais calma e mais profundidade ao longo das próximas aulas. Mas, por enquanto, eu vou pensar, poxa, os produtos aqui da minha home, será que eles vão alterar de quanto em quanto tempo? Eu não preciso colocar um tempo muito alto, nem muito baixo, até porque uma chamada API não é tão custosa para o nosso back-end. Eu vou falar que, bom, 60 segundos, vezes 60 dá 1 hora, vezes 2. Então, eu vou botar aqui, a cada 2 horas, eu vou revalidar essa página, ou seja, gerar a home de novo. Isso já vai dar um efeito bem legal e a performance fica sensacional. Vou remover essas importações que eu não estou mais utilizando, GetServerSideProps também não, Assets e Camisetas. O único ponto que fica aqui, que é super importante a gente lembrar, é que quando a gente usa GetStaticProps, a gente não tem acesso ao contexto da requisição, nem o REC, nem o REST. O que eu quero dizer com isso? Quando a gente usa GetStaticProps, a gente não consegue, aqui dentro, obter acesso, como por exemplo, a informações do usuário logado, cookies, ou qualquer coisa assim. Porque o GetStaticProps é executado no momento que eu dou a build da minha aplicação. E nesse momento aqui, você tem que concordar comigo que quando eu estou executando o npm run build, não existe um usuário logado, não existe uma requisição, nada, isso aqui não é, é um comando de build no meu terminal. Por isso, aqui dentro, eu não tenho acesso a cookies, não tenho acesso a headers, eu não tenho acesso a nada que vem do contexto de requisição. Ou seja, se em algum momento, essa requisição para API aqui, ela precisar de algum cookie, de alguma informação do usuário logado, aí, infelizmente, não tem como ser uma página estática. Porque páginas estáticas, são aquelas páginas que vão ser iguais para todos os usuários que acessarem elas. Se a minha página, ela tem alguma informação, que precisa vir aqui do server-side, que é dinâmica, que precisa de um ID de um usuário, ou alguma informação do usuário logado, por exemplo, já não vai funcionar. Eu já não posso criar uma versão estática daquela página, senão, todos os usuários, eles acabariam vendo informações iguais, informações de outros usuários, ficaria muito estranho. Então, é importante a gente entender quando que a gente usa static-side generation, que é o SSD que a gente falou aqui, server-side rendering, ou quando a gente faz um fetch de dados, aqui utilizando o useEffect ou outra alternativa, que geralmente vai ser a maioria das requisições que a gente vai fazer, ainda vão ser requisições que a gente faz aqui no próprio componente. Porque todas essas requisições que a gente faz no getServerSideProps, getStaticProps e tudo mais, elas são condicionais, a gente não pode fazê-las em todos os momentos. Então, é isso."
  },
  {
    "id": "9c0bae52-75b8-4b59-a5a2-7f70e2d9102b",
    "title": "Navegação via Link",
    "transcription": "Nessa aula a gente vai falar sobre uma das coisas que são mais importantes no ecossistema Next e que é muito importante você prestar muita atenção no que a gente vai fazer nessa aula. Então, já dá um golão d'água aí ou no café, dependendo do horário do dia, já presta muita atenção porque essa aula é super importante. A gente vai falar sobre navegação dentro do Next. A gente criou esse componente Product, que foi criado lá no Stitches, e esse Product é uma âncora. Se a gente clicar aqui, a gente vai ver que ele criou ele como uma tag A, uma anchor. E, sendo uma tag A, a gente pode adicionar um href. E isso vai direcionar o usuário, quando ele clicar nesse produto, para uma outra página. E aí, beleza. O que a gente pode fazer aqui agora? A gente tem o id do produto, até porque a gente está percorrendo os produtos aqui, e nós temos uma página específica para o produto. Então, aqui no href, eu poderia colocar algo como barra product, barra, e coloco aqui o nosso id, product.id. Acabou ficando um pouco grande aqui, então, nesses casos, eu gosto de quebrar as linhas. Show de bola. Salvo aqui agora. E o que a gente vai fazer agora é abrir aqui o nosso navegador. Vou dar um F5. E eu posso ver que, quando eu clico aqui, agora ficou o texto em azul, porque a gente colocou um href no product. Então, vamos voltar aqui no A. Aqui dentro do footer, a gente tem esse nosso strong. Vamos colocar aqui uma color nele, de gray. 100. Beleza. Quando eu clico agora em um dos produtos, veja que eu sou redirecionado para a página desse produto especificamente. Mas o ponto não é isso, o redirecionamento está funcionando, o link está funcionando. O problema é o seguinte, vamos aqui abrir agora o expressionar-elemento. Eu vou botar ele do lado direito aqui da tela. Vou abrir a aba Network. E agora, vou dar um F5. A gente pode ver aqui na página Home o que aconteceu. Ele carregou a página Home completamente. Então aqui, demorou 394 milissegundos para carregar essa página. E aqui, ele carregou também todos os assets do total zero. Carregou todos os assets do zero. Aqui a fonte roboto. E a fonte roboto acaba levando um tempinho para carregar. No caso, ela estava em cache, mas eu dou um Ctrl Shift F5. Demorou 78 milissegundos para carregar. Carregou todo o Webpack do zero, o React Refresh, o main.js, app. Está vendo que carregou tudo do zero. Claro, porque a gente deu um F5. Tudo precisou ser carregado do total zero. Quando eu clico aqui para abrir a página de um desses produtos, veja o que acontece aqui na aba Network. Olha só, ele carregou tudo do total zero de novo. Então ele carregou a página do produto. Carregou a fonte roboto de novo. Webpack, React Refresh, main, app. Tudo do zero de novo. Ou seja, toda aquela base da aplicação, que não muda de uma página para outra, foi recarregada do total zero. E isso é um problema. Porque por mais que a nossa aplicação agora esteja muito simples, e a gente esteja rodando essa aplicação aqui no nosso ambiente, na nossa máquina, fazer isso aqui no ambiente de produção pode deixar a nossa aplicação muito mais lenta. E aí, o Next oferece para a gente um componente que a gente consegue importar de dentro do pacote next-link, e o nome dele é link. E a gente pode utilizar esse componente por volta da nossa âncora. Veja só, então o product é uma âncora, certo? Por volta dele a gente vai colocar o link. E agora, como o link é o primeiro elemento que vem dentro do map, é ele que precisa receber aqui, e não o product. E também a gente vai colocar o href no próprio link, e não no product. Agora a gente vai salvar isso aqui agora, e a gente vai ver o resultado diferente. Veja, eu vou dar um CTRL SHIFT F5 aqui na ROM. Podemos ver que ele carregou tudo do zero, como eu falei. Porém, agora quando eu clicar em um dos produtos, veja que esses carregamentos aqui, eles são lá da ROM. Ele não fez um refresh na página. Ele redirecionou o usuário para a página de produto, sem precisar fazer um recarregamento todo. Ou seja, seguindo o conceito que você já aprendeu do React, de SPA. A página, o Next, é muito importante a gente entender que o Next, apesar dele oferecer esse funcionamento de server-side rendering, da gente poder renderizar as coisas pelo lado do servidor, de SSD também, ele não deixa de ser um SPA para a maioria dos casos. Ou seja, quando a gente faz uma navegação de uma tela para outra, utilizando um link da vida, o Next se comporta como uma aplicação React tradicional, como um SPA. A gente pode ver que as requisições que o Next precisou fazer para carregar essa nova página, na verdade, foram só essas pequenas requisições aqui embaixo. Isso vai ficando mais claro também conforme a gente vai desenvolvendo. Eu quero te mostrar alguns hacks, algumas coisas que acontecem por baixo dos panos, nesse tipo de link entre uma página e outra. Mas vamos continuando aqui, que a gente vai aprendendo aos poucos."
  },
  {
    "id": "dee1fbac-f289-41cd-9cae-4efee80a9ddb",
    "title": "SSG com parâmetro dinâmico",
    "transcription": "Se a gente mudasse esse método getStaticProps aqui para um método getServerSideProps e aí trocasse essa tipagem aqui também para getServerSideProps do next, e aí não precisaria desse revalidate, mas acho que nem tem problema retornar ele. A gente salva isso aqui agora e olha só, a gente volta para a página do produto, dá um F5. Additional keys were returned. A gente realmente não pode retornar isso aqui. Salva, dá um F5. Olha só, funcionou. Que lindo, né? Nossa página está funcionando. Então resolvemos, Diego? É isso? Acabou? Não, né? Porque agora que a gente fez um getServerSideProps, na verdade a nossa página não foi gerada estática. Se um milhão de pessoas acessarem essa página aqui no intervalo de um minuto, ele vai um milhão de vezes executar esse código todo aqui, que pode ser que em algum momento não seja um problema para você, mas aqui para a gente com certeza seria um problema, porque na verdade os dados do produto dificilmente vão mudar, como a gente já falou e é por isso que a gente está usando geração estática. Mas por que eu fiz isso? Por que eu troquei para um getServerSideProps aqui e mostrei para você que funciona? Porque o getServerSideProps ele roda quando? Quando que esse método aqui executa? Cada vez que o usuário dá F5, certo? Cada vez que alguém acessar essa página, esse método aqui executa. Agora vou fazer uma pergunta para você, que eu quero que você responda para mim antes da gente ir para a resposta. Quando que o método getStaticProps executa? Está na sua cabeça aí a resposta? A gente já falou sobre isso. A gente informou aqui que esse método vai executar uma vez a cada uma hora. Então conforme a nossa aplicação estiver no ar e os usuários forem acessando, sempre que passar uma hora, isso aqui vai executar de novo para recarregar os dados aqui do nosso produto. Mas existe um momento que esse método aqui executa também, que é no momento da build. Ou seja, quando a gente executa o comando npm run build, ou seja, quando a gente faz o deploy da nossa aplicação para qualquer hospedagem, esse comando aqui vai ser executado, porque é ele que gera uma versão de produção da nossa aplicação. Quando esse comando aqui executa, ele também executa todos os métodos getStaticProps das páginas para gerar versões estáticas dessas páginas. Ou seja, nesse momento aqui, que é a primeira versão estática de todas as páginas que tem o método getStaticProps, são geradas. E aí a gente pode ver que aqui ele deu também aquele erro. getStaticPaths is required for dynamic SSG pages and is missing. Por quê? Porque se no momento da build eu estou tentando gerar a versão estática de todas as páginas da minha aplicação que possuem o método getStaticProps, na ROM é super tranquilo, porque na ROM o método não tem nenhum parâmetro. É só ele executar esse código, não precisa passar nenhuma informação e esse código vai funcionar. Mas na página de produto, a gente tem um parâmetro vindo aqui, que é o id do produto. Porém, quando eu estou executando a build, da onde vai sair esse id do produto? Que id que é esse? Não existe, eu não estou acessando uma URL. Isso aqui, esse script que eu estou executando no terminal, ele não está enviando id de produto nenhum. Ou seja, quando ele vem aqui na página do produto para tentar gerar uma versão estática dessa página, não existe id. Esse parâmetro, é impossível ele saber da onde vem isso. E é por isso que para quando a gente tem páginas estáticas que possuem parâmetros, que possuem informações dinâmicas, a gente precisa retornar daqui de dentro um getStaticPaths, e aí a gente também tem uma tipagem para isso, que é basicamente um método que devolve esses e desses. E aí como é que esse método tem que retornar as informações? Ele precisa retornar um array. Esse array precisa ter vários objetos dentro deles, e cada um desses objetos aqui retorna basicamente os parâmetros que eu quero, os parâmetros dos produtos que eu quero gerar essa versão estática. Então, dentro do objeto eu preciso ter... Ah não, é diretamente um objeto, aqui dentro eu preciso ter paths, é um array, e aí aqui dentro vários objetos, por exemplo, o meu parms id, e aqui eu passo o id do produto. Então se eu copiar esse id do produto e colocar aqui, e agora ele ainda está dando um errinho, porque além do paths eu preciso retornar uma outra informação que se chama fallback, que por enquanto eu vou passar como false, logo a gente vai falar sobre isso aqui. Agora eu salvo isso aqui agora. Quando eu executo npm run build, veja só o que vai acontecer. Ele vai criar uma página estática para esse produto aqui, chamado prod m1wm, que é esse id que eu passei aqui dentro, que foi retornado dos paths. E se eu volto lá na minha página e dou um F5, ou melhor, não vai estar funcionando porque eu não estou rodando o projeto, mas se eu venho aqui e dou um npm run start, que agora não é o dev, eu estou rodando a build de produção, e agora eu venho aqui e dou um F5 na página de produto, olha só, ela já foi renderizada e está carregando muito rápido porque isso aqui foi gerado de forma estática. Porém, se eu volto aqui para a home da nossa aplicação e tento acessar agora um outro produto, veja só, agora eu vou tentar acessar a camiseta Ignite Lab, deu erro, 404. Por quê? Porque eu não passei o id dessa camiseta Ignite Lab aqui dentro. E aí o que acontece é que para essa camiseta do Ignite Lab, o Next não gerou uma página estática, ou seja, é como se isso nem existisse. Isso aqui só volta a funcionar se eu rodar o npm run dev, ou seja, rodar a nossa aplicação em desenvolvimento. Porque se a gente lembrar muito bem, ou melhor, nem em desenvolvimento está rodando? É, eu acho que nem em desenvolvimento vai rodar, deixa eu ver aqui. Deixa eu dar F5 aqui. Maratona Explorer, show. No caso do Ignite Lab, também não funciona. É porque ele percebe que, na verdade, esse id dessa camiseta do Ignite Lab, ele não está disponível aqui entre os produtos que a gente retornou aqui no pass, e aí ele não permite o método getStaticProps aqui rodar. Então o método getStaticPaths a gente vai sempre usar para dizer para o Next quais são as páginas, os parâmetros que a gente quer gerar versões estáticas dessa página aqui. Mas por mais que a descrição desse método aqui seja simples, na verdade dá para a gente fazer muita coisa aqui. Porque se a gente parar para pensar, a gente tem o e-commerce, né? E aí imagina que o seu e-commerce tenha 5.000 produtos. Será que eu vou jogar o id dos 5.000 produtos aqui dentro de paths? Porque aí quando eu rodar a npm runBuild na minha aplicação, meu Deus, se ele tiver que gerar a versão estática aqui de 5.000 produtos, e joga até números maiores, imagina só, 20.000 produtos. Cara, isso aqui, olha só, demorou um segundo para gerar essa aqui. A gente vai demorar 20.000 segundos, que daria aí praticamente 333 horas. Não, 333 minutos, que daria aí 5 horas. E a gente não vai aguardar 5 horas o nosso deploy para executar. Então esse método getStaticPaths, apesar de ele permitir a gente dizer aqui quais são os produtos que a gente quer que gere versões estáticas no momento da build, do next, a gente consegue ainda dizer para ele, cara, se houver outros produtos que eu não passei aqui, eu quero que você se comporte de uma forma diferente. A gente vai ver isso na prática, vai ficar muito mais claro e muito mais simples como utilizar esse método aqui."
  },
  {
    "id": "d0e5dc00-3c62-41db-bbd4-e5e1254ced4f",
    "title": "Dados da compra no sucesso",
    "transcription": "O que a gente vai fazer nessa aula é inserir os dados relacionados à compra que o usuário fez dentro da página de sucesso. Porém hoje a gente pode notar que quando o usuário chega aqui na página de sucesso, não tem nada nessa página que diga qual que é a compra do usuário, ou seja, não tenho nenhuma informação para obter relacionada à compra do usuário. Então até indo pela própria documentação do Stripe e procurando por Success, URL, qualquer coisa assim, a gente vai cair nessa documentação aqui do Checkout e aqui eles falam que a gente pode colocar na URL essa variável, digamos assim, e o Stripe vai preencher essa variável com o ID da Checkout Session que foi criada para o usuário. Então bora testar isso juntos. Aqui na Success, então vamos até ver como é que ele faz aqui, ele envia Session ID igual e coloca esse Checkout Session ID aqui, exatamente dessa forma. Teoricamente agora quando ele redirecionar para o Success vai ser enviado esse parâmetro junto. Bora testar. Então viemos aqui no produto, comprar agora, botamos os dados aqui certinho. Aguardamos um pouquinho e a gente pode ver agora que a página de Sucesso foi chamada com o Session ID sendo enviado aqui no parâmetro. E aí a gente vem então agora aqui na nossa página de Sucesso e a gente pode usar desse parâmetro aqui para preencher os dados aqui dentro. E aí novamente a gente pode escolher a forma de fetch de dados de três formas. A gente pode fazer o fetch totalmente pelo Client-Site, usando o EasyFetch da vida, alguma coisa assim, ou com Axios, qualquer coisa assim, é o melhor API do Stripe. Nós podemos usar o GetServerSiteProps ou podemos usar o GetStaticProps. Vamos por eliminação aqui dentro. GetStaticProps faz sentido nessa página? Não faz, por quê? Porque eu tenho uma informação que ela é dinâmica e ela vem dar URL aqui como um parâmetro GET, ou seja, se eu gerar uma versão estática da página de sucesso, ela vai ser a mesma página de sucesso para todos os clientes possíveis. E página de sucesso, vamos combinar que não faz muito sentido eu ter uma versão estática dela, porque ela não é uma página que o usuário vai ver milhões de vezes ou que os usuários vão precisar ficar acessando milhões de vezes enquanto eles estão utilizando. Então a gente geralmente deixa as páginas estáticas aquelas que a gente busca mais performance. Aqui eu posso fazer um UseFetch da vida, por exemplo? Posso fazer a requisição pelo Client-Site, buscar os dados e preencher? Sim, só que isso tem duas problemáticas só. Uma, na verdade, é um problema e a outra seria, digamos, uma necessidade que eu teria. Se eu fizer o Fetch pelo Client-Site, fazer o UseFetch, fazer o Fetch de dados aqui, primeiro eu vou ter que pensar em uma tela de loading aqui, como eu tinha falado, uma skeleton screen, alguma coisa para simbolizar até os dados serem carregados, mostrar alguma coisa em tela. E o único problema, na verdade, maior, é que a API do Stripe, que a gente está utilizando, ela não permite a gente fazer chamadas, por exemplo, para buscar os dados de uma checkout session pelo Client-Site. Isso não seria seguro, porque eu estaria expondo a minha chave secreta do Stripe aqui no Client-Site e isso seria altamente sensível e muito inseguro aqui para a nossa aplicação. Então por isso eu vou optar por fazer o Fetch dos dados aqui, utilizando o GetServerSideProps. Então a gente vai aqui importar do Next, a gente faz aqui um Async, e aí a primeira coisa que a gente precisa fazer é pegar esse parâmetro que está vindo aqui em cima, SessionID. E aí eu consigo buscar isso de dentro aqui de Query. E aqui eu posso fazer const SessionID é igual a Query. E aqui eu posso ver que ele vem também String ou StringMultiple aqui. E aí, o que a gente pode fazer aqui dentro é o seguinte, deixa eu só ver rapidinho aqui o negocinho, Props, Promise, deixa eu só ver, Context, Hack, Query, ParsedUrlQuery. Bom deixa eu ver, porque eu acho que talvez isso possa vir de Parms também. Então faz tempo que eu não pego isso aqui, deixa eu dar um Query. Eu acho que vem de Query, mas talvez o Next jogue isso dentro de Parms para a gente também, porque ele acaba não deixando eu tipar o Query. Então fica aí essa ideia. Então aqui eu preciso retornar Props, senão ele fica dando erro. O último retorno sempre precisa ser um retorno válido aqui para o GetServerSideProps. E agora vamos salvar isso aqui agora. E nós vamos abrir aqui o nosso terminal, e eu vou dar um F5 nessa página, beleza? Olha só, ele trouxe dentro de Query, de Parms não, a Parms veio Undefined, mas dentro de Query veio o nosso SessionID. Lembrando que o console.log nesse caso vai ficar aqui dentro desse terminal, porque quando a gente usa um GetServerSideProps ou GetStaticProps, o nosso método, o nosso fetch, ele tá acontecendo nesta camada aqui, e não na camada do front-end. Essa aqui só acontece caso a gente faça o fetch de dados, usando ali o UseEffect, escrevendo realmente o fetch aqui dentro do componente. Mas show, agora que eu já sei que tá dentro de Query, a gente vai fazer o seguinte. const, aqui eu vou pegar o nosso SessionID, vou até renomear ele aqui para SessionID, quando eu tô trabalhando com essa variável dentro do JavaScript, porque eu prefiro que é o meu case, igual a Query. E aqui, na verdade, eu vou fazer de outra forma, vou fazer const SessionID igual a Query.SessionID, e eu vou colocar string aqui por volta, pra forçar que isso aqui seja uma string, senão ele fala que isso aqui pode ser uma string ou um array de strings, porque eu posso enviar o mesmo parâmetro aqui várias vezes, e aí ele converte num array. Mas eu vou forçar pra que ele seja uma string em si. Agora que eu tenho o SessionID, eu preciso buscar os dados dessa Session lá dentro do Stripe. Então a gente vai fazer o seguinte, const Session igual a WaitStripe, importamos aqui, .checkout, .sessions, .retrieve, e aqui a gente vai passar a nossa SessionID. Se eu der um console.log aqui na nossa Session, salvo isso aqui, voltamos aqui, dou um F5, e agora a gente pode ver que trouxe todos os dados da nossa Session aqui dentro. E dela a gente consegue pegar várias informações, tá vendo? Consigo pegar o total, consigo pegar dados do cliente, aqui email, consigo pegar se ela foi paga ou não aqui no PaymentStatus, se ele tiver como paid quer dizer que deu tudo certo, que foi pago, se não, não foi. Então tem várias informações que eu consigo pegar daqui de dentro, mas tem algumas informações que estão faltando. Por exemplo, se você for ver, não tá aparecendo aqui em nenhum lugar os dados do produto que foi comprado. Se a gente for ver aqui, não tem em nenhum lugar dados do produto, em nenhum lugar. E aí, até se a gente for na documentação do Stripe, e a gente for aqui na nossa CheckoutSession, eu vou ver aqui dentro de Retrieve a Session, ou melhor, the SessionObject, aqui a gente vai, lembra que eu posso encontrar quais itens aqui dentro são Expendables, que eu posso pegar informações de relacionamento. Então olha só, eu posso pegar Customer, expandir o Customer, ou seja, pegar informações do usuário. E eu posso expandir LineItems também, que são os produtos comprados nessa CheckoutSession. Então é isso que eu quero expandir. Então eu venho aqui, dou um Expand, passo LineItems, perfeito? Vamos salvar e vamos ver se agora veio os dados que eu queria. Então deixa eu dar um F5 aqui agora, voltamos, vamos aqui pra baixo. Já posso ver aqui que tem LineItems, aqui dentro tem Data. Não dá pra ver muito bem o que está ali dentro, então vamos fazer o seguinte, CheckoutSession.LineItems.Data, pra ver se está vindo o que a gente quer. Agora isso aqui que ele retornou, vamos lá, vamos ver tudo o que veio aqui. Então ele veio um ID, só que esse ID aqui é do LineItem, tem a descrição aqui que é o nome do produto, tem o preço, no preço aqui tem o preço em si, mas não tem imagem do produto, na verdade está faltando bastante informações do produto aqui. Então veja só, isso é legal, porque se eu for aqui em cima, o que a gente fez? A gente expandiu o LineItems, desculpa, o LineItems ele retornou pra gente um objeto e dentro desse objeto tem Price. Se aqui dentro eu for procurar por Price e vir aqui no PriceObject, eu vou ver que do PriceObject eu também consigo expandir outras informações, por exemplo, o produto. Então eu consigo trazer informações do produto relacionadas àquele preço. Então olha que legal, eu venho aqui e escrevo LineItems.Data, porque é um Array, então sempre que tem um Array eu preciso colocar o Data, .Price, porque é o Price que está aqui dentro, o nome do objeto, e eu quero expandir o Product. Agora olha só, eu salvo isso aqui, rodo de novo, e agora aqui dentro tem Product, ele trouxe os detalhes do produto que antes aqui em cima só tinha o ID, agora eu tenho um objeto com todos os dados do produto. E agora a partir disso eu vou fazer o seguinte, eu vou pegar dessa Session as informações que eu preciso. Então para montar a página de sucesso eu preciso nome do cliente, nome do produto, imagem do produto, só isso. Então vamos lá, nome do cliente eu vou pegar de Session.CustomerDetails.Name, dados do produto eu vou pegar de Session.LineItems.Data, o Data agora é um Array, porque uma compra pode ter vários produtos, mas hoje o nosso e-commerce não está permitindo isso, porque o usuário clica no Comprar e não tem um carrinho, ele vai direto para o Checkout. Então aqui eu vou pegar o primeiro item, porque só vai ter um, e aqui eu pego .Product. Esse Product pode ser apenas uma String, porque no começo ele é apenas um ID. Quando a gente expande ele, é que ele vira um objeto de produto, então aí que ele vira um Stripe Product, por isso que o tipo dele aqui é várias coisas. Então aqui eu vou só fazer um S, Stripe, preciso importar aqui a biblioteca, .Product, pra falar que eu expandi ele, então eu tenho todas as informações do produto aqui. E agora aqui na Props eu vou retornar CustomerName, e do meu Product eu vou retornar só as informações que eu preciso, o nome, Product.Name, e a imagem, Product.Images.0, e é isso, a String já vem direto ao URL. Vamos testar agora. Aqui agora eu vou criar uma interface, Success Props, CustomerName, que é a String, e Product, eu tenho o nome, que é uma String, e eu tenho a image, URL, que é uma String também. Vou pegar essas informações aqui, das minhas propriedades, pego CustomerName e Product, e agora eu vou preenchendo. Então aqui no lugar de Diego Fernandes vai o CustomerName, e aqui no lugar do nome do produto vai o Product.Name, e aqui dentro do ImageContainer eu vou colocar uma image que vem de NextFutureImage, o Source.Product.Image.URL, e aqui eu preciso colocar uma altura e uma largura, vou botar uma largura de 120, uma altura de 110, texto alternativo em branco. Salvo isso aqui agora, voltamos a página, dou um F5, e deu erro. Cannot read properties of undefined reading name. ProductDataSession, vamos ver o que está vindo nisso aqui. Ele está dando um erro nisso aqui, então vamos dar uma olhada. O que está vindo? Aqui em Product, beleza. Está vindo Undefined, Data0, deixa eu dar um F5 aqui. Está vindo tudo certinho, Data.Price.Product. Ah, Data.Price.Product. Agora sim, a gente salva isso aqui agora, voltamos, dá um F5, beleza. Já está lá, nome do cliente, nome da camiseta, temos também a imagem da camiseta. Então, nossa página de sucesso está finalizada."
  },
  {
    "id": "277b9f78-df64-434a-9424-fcb120a58489",
    "title": "Configurando ESLint",
    "transcription": "O que a gente vai fazer agora é configurar uma ferramenta nova aqui dentro da nossa aplicação, que é o S-Lint. E se você nunca ouviu falar o que o S-Lint faz, o nome vem de ECMAScript Linting. E Linting nada mais é do que um processo de validar que o teu código está seguindo padrões estipulados pelos criadores do projeto. Então imagina que você está trabalhando num time e várias pessoas gostam de codar, escrever código de maneiras diferentes. Algumas pessoas gostam do ponto e vírgula no final da linha, que ele é facultativo no JavaScript, outras pessoas não gostam. Outras gostam de aspas simples, outras duplas. A gente configura o S-Lint para que as pessoas não precisam ficar se preocupando em lembrar de colocar aspas simples, porque é o padrão da equipe. O que acontece é que eu coloco aspas duplas e o S-Lint se vira em falar pra mim que aquilo lá, primeiramente, está errado, e também de corrigir de forma automática aquilo, trocar as aspas para aspas simples. Então ele permite a gente definir padrões de código e a gente não se preocupar em simplesmente esquecer disso quando a gente for trabalhar com times. E aí dentro do VS Code é importante que a gente tenha a extensão do S-Lint instalada. Então você precisa ter essa extensão aqui instalada, do S-Lint. E aí a gente vai configurar o S-Lint. Tem várias formas de configurar o S-Lint. Inclusive eu vou deixar um documento aqui pra você ler dentro desse vídeo, que ele vai falar especificamente mais a fundo sobre o S-Lint, sobre as suas regras e tudo mais. Mas como o S-Lint não é uma ferramenta core, digamos assim, a gente vai instalar da maneira mais simples possível. Eu vou começar instalando o ESLint como uma dependência de desenvolvimento. E aí a gente vai instalar aqui dentro também um pacote chamado arroba-rocketseat-eslint-config-d, que é como uma dependência de desenvolvimento. Esse rocketseat-eslint-config é basicamente uma configuração do S-Lint criada por a gente aqui na Rocketseat, por nós. E ela traz alguns padrões de escrita de código para JavaScript, claro. E você pode criar sua própria configuração do S-Lint. Então, se você rodar nfts-eslint-init, você vai, ao invés de usar uma configuração já existente, que é o que a gente está fazendo, como por exemplo usando a configuração da Rocket, você vai criar a sua própria. Ele vai fazer várias perguntas pra você sobre o seu projeto, se você quer manter ponto e vírgula ou não quer. Então ele vai fazer várias perguntas e no final ele vai gerar uma configuração pra você. Aqui a gente vai usar uma configuração pronta dos projetos que a gente usa aqui na própria Rocket. E aí com isso o que a gente vai fazer? Cria um arquivo chamado .eslintrc.json ou .js, tanto faz, os dois funcionam. Aqui vamos usar .json, eu prefiro porque ele coloca autocomplete nesse arquivo. E aqui dentro a gente vai simplesmente escrever extends e o nome do pacote, rocketseat-eslint-config. E aí como esse pacote aqui tem configuração não só pra React, a gente vai usar a configuração do React. Então é .react, ele vai pegar as configurações do .eslint pra React. Tem pra Node também, pra outros projetos. A gente vai salvar aqui agora e pronto, o .eslint já está configurado. Como que a gente faz pra testar? Uma boa forma da gente testar é o seguinte, a gente pode rodar aqui no nosso terminal o código npx eslint, passa o nome da pasta onde está o nosso código, então aqui a gente passa search, por exemplo, \"-e\", que é a extensão dos arquivos que a gente quer procurar por problemas de código, e no caso a gente usa arquivos .ts e arquivos .tsx, então .ts, .tsx. Aqui é o traço-traço-ext, acho. Perfeito? Olha só, ele deu um monte de errinhos aqui nos nossos arquivos. Por quê? Clicando aqui nos nossos arquivos, vamos abrir o app. Aqui ele trouxe, ele já começou a ficar até vermelho aqui, se o seu editor não ficou vermelhinho aqui embaixo das linhas, tenta dar um reload aqui, ou fechar e abrir o Vast Code, e aí com a extensão do .eslint já deve estar começando a aparecer isso aqui. Olha só, tá vendo que aqui teve um componente que eu importei com aspas duplas, o outro com aspas simples, então ele já fala, opa, pera aí, usa aspas simples em tudo, então passa o mouse aqui, replace aspas duplas por aspas simples, ponto e vírgula no final, a gente não usa no padrão aqui da Rocket, então ele fala pra gente tirar. E aí o que acontece? A gente pode vir aqui e uma por uma ir removendo, mas o Vast Code tem uma configuração que a gente pode colocar, que é essa configuração aqui, editor.codeactionsonsave, ou seja, toda vez que eu salvar um arquivo, eu quero fixar automaticamente todos os erros do .eslint, então source.fixall.eslint true. Agora se eu venho aqui nesse arquivo e salvar, ele arrumou todos os erros de lint de forma totalmente automática. E aí eu posso rodar o comando o npx.eslint de novo, a gente pode ver que o app já não aparece mais aqui. Tá, e se eu quero corrigir todos os erros de todo o projeto de uma porrada só? Não tem problema, é só a gente rodar esse comando aqui, que a gente já tá rodando, porém com o traço-traço fix. No final, ele vai automaticamente fixar todos os erros que ele conseguiu corrigir de forma automática. E pronto, já corrigiu todos os erros que tinha. Se eu rodar esse comando de novo sem o fix, olha só, não vai aparecer mais nada, porque não tem mais nenhum erro de lint no nosso projeto. Até pra gente não perder esse comando, uma coisa que eu gosto de fazer é copiar aqui, eslint src ext ts ts x, sem o npx porque não precisa, e criar um script no package.json chamado lint. Aí sempre que a gente precisar rodar o lint, basta a gente rodar npm run lint. E pronto, ele vai rodar e a gente pode ver. Se eu quero fixar os erros, npm run lint, traço-traço fix, e ele vai realizar o fix aqui de todos os nossos códigos. Então, show de bola, já tá aqui tudo funcional, a gente já aprendeu a usar o slint. E como eu falei, tem um documento aqui embaixo nessa aula, se você quiser entrar mais a fundo e entender o que está se passando por trás do rocket-seat-slint-config-react, o que essa config aqui está validando no fim das contas, porque não é só ponto e vírgula, não é só aspas, não é nada disso, tem mais coisas ali por trás, mas também não é algo pra gente entrar muito a fundo agora."
  },
  {
    "id": "a15f9c88-36f2-41b3-8ad7-bcccbc2205b8",
    "title": "CSS global",
    "transcription": "O que a gente vai fazer aqui agora, antes da gente criar o nosso componente de redditor aqui e fazer a estilização, é criar alguns estilos globais aqui pra nossa página, né? Então, por exemplo, customizar a fonte, algumas cores ali, variáveis, basicamente aquelas estilizações que a gente sabe que sim, a gente quer compartilhar com todos os elementos de tela. Então, eu já tinha criado esse styles.css, eu só vou renomear ele pra global.css pra ficar mais claro que são estilos globais, e eu posso só trocar aqui na importação também pra global.css. Salvo aqui, agora a gente vai começar a colocar alguns estilos aqui dentro, né? Primeira coisa que eu faço é, de todos os elementos, eu acabo removendo o margin, o padding e setando um box-size em border-box, isso faz com que o padding, margin e o border do elemento nunca aumentem a sua largura e altura, e sim, exprimam o elemento pra dentro. Isso aqui é muito legal, caso você nunca tenha ouvido falar, vale você estudar sobre box-model dentro do CSS, o Maikão tem ótimos conteúdos sobre isso também. E aqui, o que a gente vai fazer? Eu vou começar pegando o body da minha aplicação, e eu quero aplicar uma cor de fundo padrão e uma cor de texto também padrão. E pra isso, uma das coisas que eu vou fazer aqui agora é definir algumas variáveis CSS, que são as cores que a gente vai utilizar aqui na nossa aplicação. E aí eu já fiz uma varredura aqui do Figma, pra você não ter que fazer isso, e fiz uma varredura de todas as cores que foram utilizadas aqui nesse layout pra gente criar como variáveis CSS. Então, a primeira cor é branca, e não se assuste, eu gosto de criar uma variável também pra cor branca, por quê? Porque um dia, se a gente precisar em algum momento trocar isso, vai ficar muito mais fácil achar do que a gente simplesmente procurar por todos fff, ou ffff, ou white, sei lá, que a pessoa possa também colocar. Então, eu gosto de criar uma variável até pra cor branca aqui dentro, tá? Todas as cores eu crio variáveis. E aí, como essa aplicação tem vários tons de cinza, eu particularmente gosto de manter a seguinte ideia, quando eu tenho uma cor, que ela vai ter várias tonalidades. Isso foi algo até que eu tirei de dentro do próprio Tailwind CSS, que é uma biblioteca pra lidar com CSS. Se a gente vier aqui nas documentações do Tailwind e eu procurar aqui por Colors, Customizing Colors, Default Color Palette, ele tem pra cada tom de cor, por exemplo, vermelho, verde, tem vários níveis, que vai de 50 até 900, do mais claro pro mais escuro. Isso é algo que eu adotei também nos meus layouts, então, por exemplo, se eu vou utilizar uma cor cinza e ela tem várias tonalidades, eu começo, por exemplo, da tonalidade 100 e vou até a 900, aumentando o quão a cor é escura. E aí eu até me perdi. A luminosidade? É isso? Pode ser. Mas, por exemplo, aqui a gente vai ter um tom de cinza bem claro, que ele é E1, E1, E6, utilizado muito pros textos da aplicação, a gente vai ter um tom de cinza, que aqui eu botei Gray 300, porque ele... Veja que eu não necessariamente preciso botar 100, 200, 300, eu posso, às vezes, pular. Se eu não tenho tons de cores suficientes, eu posso pular alguns tons, até pra deixar brechas entre eles, pra depois eu colocar outras tonalidades. Então, o 300 aqui vai ser C4, C4, CC, a gente vai botar aqui Gray 400, 8D, 8D, 9, 9, Gray 500, vamos usar aqui, ou melhor, 500 não, 600, a gente vai utilizar o 32, 32, 32, 38, Gray 700, a gente vai tá utilizando o 29, 29, 2E, Gray 800, vamos utilizar o 20, 20, 24, e por último, Gray 900, que é o mais escuro, nós vamos utilizar 12, 12, 14. Além disso, a gente vai ter aqui uma cor verde, eu vou botar Green 500, ela não vai ter outras tonalidades, 00875F, e nós vamos ter, na verdade, são só essas cores aqui que a gente vai tá utilizando. Aí, aqui no corpo da minha aplicação, eu vou aplicar por padrão uma cor de fundo com a variável Gray 900, e por padrão, a cor de texto da aplicação vai ser Gray 300. E aqui, eu também vou aplicar algo que eu gosto de colocar nos meus projetos, que é o traço WebKit font-smoothing-anti-aliased, anti-aliased, faltou um A aqui no meio, basicamente isso aqui aplica nos navegadores que são baseados no WebKit, como o Chrome, o Edge, o Brave, e até outros navegadores famosos, uma padronização para as fontes, elas ficarem, elas ficam mais fininhas, assim, elas ficam mais detalhadas, sabe? Isso aqui principalmente quando eu tô utilizando fontes que não são padrão do sistema, que é o que a gente vai fazer aqui, a gente não vai utilizar fontes que são padrão do sistema, como Arial, Helvetica, ou qualquer coisa assim. Beleza, além disso, agora o que eu vou fazer aqui é utilizar uma fonte externa, como eu falei, então eu vou utilizar a fonte Roboto, então eu posso procurar aqui por Roboto no Google, eu vou cair no fonts.google, que é o site que tem as fontes aqui gratuitas para a gente estar utilizando, aqui do lado, quando a gente seleciona o Roboto aqui, a gente precisa vir aqui, procurar pelo tamanho 400, que é o regular, vou clicar em select this style, e eu vou também no bold 700, aqui ó, e select this style. E aí aqui do lado já estão os dois estilos selecionados, e ele dá pra gente o código que a gente precisa colocar no nosso html para importar a fonte. Então copio esse código, venho no html, index.html, e agora eu vou colocar esse código aqui em cima. E aí, uma das coisas que eu digo pra você tomar cuidado aqui quando estiver utilizando fontes externas, tá vendo esses dois links aqui de pre-connect? São esses links aqui que eles vão, digamos, estabelecer a conexão do nosso servidor com o servidor da Google para buscar as fontes. E é muito importante que esses links aqui sejam a primeira coisa a executar no seu html, então eu vou mover especificamente esses dois links para o primeiro link que tem na página, antes do favicon aqui ó, eu vou botar aqui em cima. Então eu só deixo o metacharset, que não carrega nada, e depois já vem esses dois links de conexão. Inclusive outra coisa que eu gosto de fazer no html, é as tags que elas não têm conteúdo aqui, eu gosto de, na própria tag, botar uma barra aqui no final, isso aqui é uma padronização que eu sigo, e aí eu vou fazer isso aqui nos três links que a gente importou lá de dentro. Show, salvo isso aqui agora, podemos voltar aqui para o nosso CSS, e agora aqui embaixo eu vou botar uma instrução, o body, o input, o textarea e o button, eu quero que eles tenham a font-family roboto, se a fonte não conseguir ser carregada, eu vou escolher a fonte padrão do sistema que não tenha serifa. No Windows vai ser uma Arial da Vida, no Mac uma Helvetica, e no Linux vai ser a Ubuntu, acho que tem uma fonte Ubuntu. Aqui eu vou botar um font-weight de 400 por padrão, ou seja, eu quero que todas as fontes por padrão elas usam a espessura 400, o peso 400, e por padrão eu vou definir um font-size de 1 rem, ou seja, eu quero que todos os elementos, tanto body, input, textarea e button, e porque que eu botei em todos esses elementos aqui e não só no body, porque por padrão esses elementos não herdam a fonte do body, eles tem a sua própria customização de fonte. Uma loucura, mas é isso aí. E aí eu seto para que todos esses elementos tenham o mesmo tamanho de fonte também. E aqui é importante você, quando estiver trabalhando com CSS, sempre lembrar de utilizar unidades de medidas relativas, assim a gente melhora a acessibilidade da nossa aplicação. Se alguma pessoa configura no dispositivo dela, seja no computador ou no celular, para aumentar o tamanho da fonte, como você já deve ter visto pessoas da sua própria família às vezes com a fonte maior, a fonte menor, o nosso site vai se comportar de acordo com essas preferências de acessibilidade do usuário. Se a gente usar uma fonte fixa, como pixel aqui, não interessa se o usuário aumenta ou diminuir a fonte no dispositivo dele, a fonte vai continuar do mesmo tamanho. Então quando eu escrevo 1rem, isso quer dizer que eu estou utilizando uma unidade relativa do tamanho de fonte padrão do HTML, que é 16 pixels já por padrão. Então quando eu boto 1rem, quer dizer 16 pixels, caso o usuário nem aumente nem diminua essa fonte pelo sistema dele. Então a gente sempre tem que calcular dessa forma, cada 1rem é 16 pixels no tamanho padrão. Depois o usuário pode aumentar ou diminuir isso, caso ele prefira. E aí é muito importante a gente utilizar esse padrão de unidade relativa, não só para o tamanho das fontes, mas também para o tamanho de botões, espaçamentos, porque assim a nossa interface sempre vai aumentar ou diminuir de uma forma totalitária, de uma forma por igual, digamos assim, entre todos os elementos, caso o usuário escolha aumentar o tamanho da fonte do seu dispositivo ou diminuir. Mas a gente vai ver como isso funciona melhor até durante as próximas aulas. E assim a gente já tem os nossos estilos padrões que a gente vai ter na nossa página."
  },
  {
    "id": "5430099e-8d49-44ce-bba0-4aa3117a1038",
    "title": "Iterando no JSX",
    "transcription": "O que a gente vai começar a fazer agora é dar vida pra nossa aplicação. Começar a utilizar funcionamento dinâmico e nem tudo ser apenas estático na nossa tela. A primeira coisa que a gente pode fazer aqui, até... Vamos fechar os arquivos aqui, tudo que estão abertos. Se a gente for aqui no nosso app.jsx, hoje a gente vai ver que os posts aqui... Eles estão, na verdade, hoje a gente estava enviando essas propriedades, author e content, mas... Nada disso, na verdade, está sendo utilizado lá pelo componente de post. Então, essa é a primeira coisa que a gente vai arrumar aqui dentro da nossa aplicação. Então, hoje o post aqui precisa de algumas informações aqui pra que ele seja exibido. Ele precisa das informações do autor. Vamos começar a anotar isso aqui. Então, eu vou botar aqui em inglês, tá? Ele precisa das informações do autor, ou author. Precisa da URL de avatar, no caso. Então, que vai ser uma string. O nome. E aqui, o cargo. Que... Cargo. Precisa da data que o post foi publicado. Então, aqui eu estou pensando quais são todas as informações que variam de um post pro outro. Então, aqui... PublishedAt. Qual que é a data de publicação. Isso aqui eu quero que seja uma data mesmo, um date. Pra eu conseguir trabalhar com ela de diferentes formatos. Porque aqui a gente precisa da data. Num formato... Isso aqui é ISO. Sei lá qual que é o formato. Aqui eu preciso de uma distância, né? Ah, então isso aconteceu há tanto tempo. E aqui eu preciso de uma outra formatação em português. Então, a mesma data, vários formatos. Então, é bem melhor eu receber essa informação como um date pra trabalhar. E aqui embaixo eu preciso do conteúdo do post. Então, vou chamar de... Content mesmo. Que aqui, nesse caso, é uma string. Aqui embaixo, depois tem os comentários. Mas... Por enquanto... Não vamos mexer em nada disso. Show! Então agora, que eu já sei... Vou até remover isso daqui. Eu vou lá no meu app, colo aqui em cima, pra gente lembrar disso aqui. E agora o que eu vou fazer? Eu vou criar aqui em cima um array de posts. Então, eu vou chamar const posts. Com todos os posts que a nossa aplicação vai ter. Como o post tem várias informações dentro dele... Cada posição aqui dentro desse array vai ser um objeto. Então, a gente tem um array de objetos. Um array com vários posts. Aí, pra ficar mais real... Como se isso aqui realmente estivesse vindo de um back-end, de uma API... Claro, o melhor seria, né? Inclusive, fica aí um baita desafio pra você fazer. Conforme você for tendo novos aprendizados aqui no Ignite. Mas, a gente vai colocar um id. Cada post tem um id único. Então, eu vou botar 1, 2, 3, 4... Como, sei lá... Tanto faz. E aqui, nós vamos então agora colocar os dados do autor do post. E aqui, pra gente não ficar botando, por exemplo... Author avatar é tal. Author name é tal. A gente vai fazer o seguinte... Eu vou botar aqui author, um objeto. E dentro, eu boto tudo o que a gente vai precisar. Então, como eu tô colocando com camel case aqui... Aqui eu tinha botado com ifim. Vamos botar tudo com camel case aqui também, tá? Então, avatar url... Botar aqui https... github.com barra diego3g.png O nome... Diego Fernandes E role... CTO Rocketseat Rocketseat... Agora sim. Agora eu preciso do conteúdo do nosso post em si. Então... Content... E aqui o conteúdo... É... Do back-end, bem provavelmente... Ele viria isso aqui como on markdown pra eu editar. No nosso caso aqui, como a gente tem quebra de linha... Uma das coisas que é importante... Tá? Isso aqui já pra você cuidar desde o começo, quando você estiver desenvolvendo não só aplicações como React. Mas uma das coisas importantes é você evitar a todo custo que o back-end retorne HTML pra você. Como nesse caso aqui... Eu poderia falar, ah não, o conteúdo eu vou botar isso aqui, né? Jogo aqui dentro de string e boto o conteúdo inteiro. Só que isso aqui é muito ruim. Porque se o teu back-end tá retornando HTML e você vai mostrar esse HTML em tela, fica muito mais fácil você deixar o seu site aberto pra vulnerabilidades. Porque se de alguma forma algum usuário mal intencionado conseguir jogar uma tag script, por exemplo, dentro do conteúdo do post e você mostra isso em tela, você tá executando um script dentro do seu site, que foi outro usuário que jogou ali no post. E aí ele pode fazer algumas coisas maliciosas com quem tá acessando o seu site. Então aqui é importante a gente ter o conteúdo bruto, sem HTML. E pra isso a gente geralmente usa algumas estruturas de formatação. E aqui, como a gente tá... não tá trabalhando com alguma estrutura de formatação de texto, Markdown acho que é a mais famosa, existem outras. Eu vou botar cada linha do post como sendo um... como sendo uma posição no array aqui. Então eu vou colocar aquele texto aqui, vou pegar todos os parágrafos aqui e vou remover. Aqui também o fechamento de tag de parágrafo, vou selecionar todos e vou remover. E aí pra cada linha eu vou colocar aqui só uma string por volta. Então aqui também. Deixa eu tirar aqui minha cara da frente. Aqui é um link. Aí no caso, as linhas que são um link, um... a gente pode fazer de outra forma. Vou fazer de uma forma bem legal, tá? Existem algumas... alguns softwares que eu já vi fazendo dessa forma e a gente pode fazer aqui pra ficar legal. Então olha só, ao invés de botar somente o texto, cada linha aqui do nosso conteúdo eu vou colocar como objeto. Aí esse objeto tem um tipo, nesse caso eu vou chamar de parágrafo. Tá certo, parágrafo? Ai meu Deus, eu escrevi errado. Parágrafo, agora sim. E aqui eu vou botar o conteúdo. Então eu boto dessa forma assim. Aqui embaixo a gente vai fazer a mesma coisa, então tipo, parágrafo, content e lá no final fecha as chaves aqui no final. Dou uma vírgula lá no final. Deixa eu tirar meu rosto que tá atrapalhando pra caramba. Aqui embaixo a gente vai colocar outro type, só que agora aqui eu vou chamar de link. Ah... E aqui, esses outros, eles estão na mesma linha, então a gente teria que fazer de outra forma. Eu não quero trazer muita complexidade pra agora, porque isso aqui não é o importante. Então eu vou arrancar essas hashtags aqui, a gente vai deixar assim que é mais fácil e todo mundo fica feliz. Fechou? Todo mundo fica feliz assim. Deu boa. E agora eu preciso da data de publicação do post. Então, published at. E aqui como eu falei, eu quero realmente que seja uma data. E aí eu posso fazer da seguinte forma, new, date, e aqui eu passo como uma string mesmo, uma data, por exemplo, 2022, 05, dia 3, por exemplo, de maio, às 20 horas em ponto. Beleza? Então eu posso fazer assim, a gente já tem um post. E agora pra não ficar um post só, eu vou criar mais um aqui embaixo, duplicando tudo. Porém, esse aqui vai ter id2, vou falar aqui mikebrito educator, aqui deixar o arroba junto com a rocketseat, aqui é mikebrito, o texto eu vou deixar o mesmo, e a data de publicação eu vou botar uma data dia 10 lá, vou mudar um pouquinho. Aqui quando você for colocar a data, tenta colocar uma data que seja próxima à data que você tá vendo esse vídeo, pra ficar mais legal ali e você ver coisas semelhantes às que eu tô vendo. E agora que eu já tenho os meus posts aqui, eu preciso mostrar esses posts em tela, porque os meus posts aqui embaixo, eles continuam na verdade mostrando qualquer coisa, digamos assim. E aí a gente vai aprender uma das coisas mais importantes do React aqui, que é sobre iteração. Aí você já deve ter ouvido falar sobre essa palavra iteração. Iteração, dentro da programação, nada mais é do que a gente repetir alguma coisa, a gente criar uma estrutura de repetição. Eu vou iterar sobre um array, eu vou percorrer o array e pra cada posição do array eu vou fazer alguma coisa. Então é isso que a gente quer fazer aqui. Então eu vou tirar esses posts da tela, e olha só, o que a gente vai fazer aqui agora é, nós vamos colocar chaves aqui dentro, e eu vou escrever posts, que é a minha variável que tá armazenando os meus posts aqui em cima, vou até minimizar ela pra não atrapalhar. E aqui eu quero percorrer os posts. E aí, se eu falar, olha só, eu quero percorrer os posts, provavelmente você vai me falar, tá, então usa aqui um for it, por exemplo. Pra cada post eu quero fazer alguma coisa. Tudo bem, a gente pode usar o for it aqui. Então, ou melhor, a gente não pode, mas a gente pode, a gente só não deve, mas logo eu vou explicar o porquê que a gente não deve. Mas vamos continuar usando o for it, e a gente já fala sobre isso. Então, pra cada post, aqui eu recebo o post, uso uma arrow function, eu quero mostrar um componente post em tela, certo? Então será que eu posso fazer assim? Vamos testar, a gente tá aqui pra isso. Então eu coloco o post aqui, e por enquanto eu não vou passar nenhuma propriedade, tá, eu vou deixar o post dessa maneira só pra gente ver se tá funcionando. Se isso aqui tiver funcionando, ele tem que mostrar dois posts em tela. Então salvo aqui, voltamos pro Chrome, tem nada em tela. Vamos entender o porquê que não tem nada em tela. Primeira coisa, o que que o método for it faz? O método for it, ele percorre um array, só que o método for it, ele não tem nenhum retorno. Ou seja, se eu fizer, por exemplo, const algo igual a post.for it, esse algo sempre vai ser undefined. Void, no caso, nem undefined. Porque o for it, ele não tem retorno. Ou seja, quando eu estou percorrendo aqui a minha lista de posts, usando o for it, nada vai ser exibido em tela, porque o for it, ele não tá retornando nada de dentro dele. Então, nesses casos, qual método do JavaScript a gente tem que é semelhante ao for it, porém, ele retorna algo de dentro dele? O map. Se eu boto o map aqui agora, a gente já vai ver que nesse caso aqui, se eu retornar, por exemplo, olha só que legal, se eu retornar daqui de dentro o número 1, eu passo o mouse por cima do algo, olha só, ele já identifica que isso aqui vai me devolver um array de números. Se aqui dentro do for it, eu retorno 1 e passo o mouse em cima do algo, void, não tem retorno. Então, sempre que a gente for fazer uma iteração dentro do JSX, aqui dentro do HTML, no JavaScript, a gente vai usar o map, porque o map tem retorno, ele devolve algo, o for it não. Então aqui, a gente vai trocar pra map, e novamente, se eu tentar salvar, não vai aparecer nada, por quê? Porque aqui dentro, eu preciso retornar alguma coisa, então eu preciso desse return aqui dentro do map, porque senão ele não vai ter retorno nenhum. Salvo isso aqui, e agora sim a gente pode ver que tem dois posts em tela, porém, esses dois posts em tela ainda não estão utilizando aqui as informações das nossas propriedades. E aí, pra gente finalizar isso aqui, a gente vai fazer o seguinte, aqui no nosso post, eu quero enviar propriedades, e aqui como ele quebrou em mais de uma linha, sempre que tem um return mais de uma linha, coloca um parênteses por volta, e eu quebro geralmente dessa forma aqui, até uma indentada, e boto parênteses, opa, dou enter, boto parênteses aqui, na mesma linha do return, e o post fica aqui. Agora eu vou enviar as informações pro post. Então, vamos lá, eu vou enviar as informações do autor, que é post.author, vou enviar também as informações do conteúdo do post, que é post.content, e a data de publicação do post, que é o post.publishedAt. Aqui, a única informação que ficaria faltando é o id. O id, ele não é importante pra gente lá dentro do post, tá, porque a gente não tá usando o id aqui em nenhum lugar, então, sendo bem sincero, nem vou precisar passar o id aqui pra dentro, mas agora aqui no app eu vou salvar esse conteúdo, agora a gente volta aqui no post, consegue acessar as nossas propriedades, e agora, se eu der um console.log aqui nas nossas propriedades, olha só, inspeciono aqui, venho no console, deixa eu tirar esse responsivo, dou um F5, e olha só, já tá passando aqui as propriedades do primeiro post, aqui ó, publicado o Diego Fernandes, inclusive o autor aqui é um objeto, tá vendo, eu consigo acessar várias informações do author, e também tem as informações aqui do segundo post. O que a gente precisa agora é pegar essas informações aqui e exibir elas no lugar das informações que a gente tem hoje aqui dentro do nosso componente de post. Então, vamos fazer isso aí."
  },
  {
    "id": "cf81f64c-79de-4357-a2af-23150dd8c5f1",
    "title": "Propriedades do Post",
    "transcription": "Agora que a gente está recebendo as informações aqui do post no componente, a gente precisa botar essas informações em tela. Então, eu vou remover esse console.log aqui. E vamos lá. Vamos começar aqui com o source da image, que hoje ele está fixo. Vou botar aqui chaves no lugar, porque a gente quer colocar uma variável JavaScript. E agora, a gente props. A gente está enviando como author. Então, author. E dentro do author, a gente está enviando avatar.url, que está aqui. Então, isso aqui deve ser suficiente. Vamos salvar. Voltamos lá no nosso... está aqui. A primeira foto é do Diego e a segunda tem que ser do Mike, porque um post é diferente do outro. Vamos lá. Para o nome, mesma coisa. A gente bota chaves no lugar. props.author.name E aqui embaixo, a gente bota props.author.role Uma das coisas que a gente já aprendeu, e que particularmente eu gosto de fazer em todos os meus componentes, é que eu acho chato ficar repetindo props.props.props.props. Para mim é chato. Então, eu faço a desestruturação aqui em cima, para buscar apenas as propriedades que eu vou utilizar aqui embaixo. Nesse caso, por exemplo, eu só utilizei o author, que está dentro de props. Aqui eu pego o author e posso tirar esses props aqui da frente. E tudo vai continuar funcionando normalmente. Agora, a gente vai para a data de publicação, que é outra propriedade, que não é o author. É a propriedade publishedAt. E aqui agora, se eu pegar e mostrar o publishedAt aqui da maneira que ele está dentro da tagTime, ele até deu erro. Deixa eu ver o erro que ele deu aqui no nosso console. Isso aqui, o que está acontecendo? O publishedAt aqui não é uma string. Ele é, na verdade, uma data. Ele é um date aqui. E eu não posso mostrar um date diretamente aqui na tela. Eu tenho que converter ele para uma string. Então, aqui eu posso até, por exemplo, fazer um toString, que eu acho que ele vai converter. Ele converteu aqui para um formato de texto da data, que, pelo amor de Deus, é muito ruim. Então, aqui, quando a gente precisa trabalhar com datas, o JavaScript é bem precário nisso. A gente tem o INTL, que é o que a gente vai utilizar aqui para fazer a formatação. Por isso, eu vou até procurar aqui. MDN, INTL, DateTimeFormat, que é o que a gente quer utilizar aqui. Então, o JavaScript, eu digo recentemente, porque por mais que já faça mais de ano que já tem essa API, isso ainda continua sendo algo recente. Então, esse INTL aqui permite a gente fazer formatação de datas, de números, de pluralização, de listas, de várias coisas que a gente vai utilizar na nossa aplicação, que são coisas que mudam de acordo com o idioma, o país que a pessoa está acessando o nosso app. Então, vamos lá. A primeira coisa que eu quero fazer, eu quero mostrar essa data nesse formato aqui. Como que a gente vai fazer isso? Então, primeiro, eu vou chamar isso aqui de DatePublishedDateFormated. Vamos chamar assim. Como é que eu vou fazer? Aqui a gente pode até dar uma olhadinha. Eu vou fazer um new INTL.DateTimeFormat, passo o idioma, no meu caso é o PT-BR. Aqui a gente pode passar algumas opções, e aqui as opções que eu posso passar é, por exemplo, o dia eu quero que ele seja de dois dígitos. O mês eu quero que ele seja por extenso. Então, eu vou botar aqui long. O ano eu quero que, na verdade, ele nem apareça. Então, eu acho que eu não preciso colocar o year. Aqui a gente vai testando como que a gente pode colocar. E aqui a gente pode passar o timeStyle como sendo o full. Vamos testar isso aqui. Então, agora eu vou pegar esse PublishedDateFormated, e eu vou colocar aqui, só pra ser mais fácil de visualização, no lugar aqui do conteúdo do time, e não aqui no title, porque senão tem que ficar passando o mouse por cima pra ver se deu certo. Então, salva aqui agora. Vamos lá ver. E deu erro, porque eu acho que eu tenho aqui no final chamar o .format passando a nossa DataPublishedAt aqui. Agora sim. Salva. Vamos dar F5. E ainda deu erro. Vamos ver o que eu fiz aqui de errado. Can't set option month when timeStyle is used. Então, aqui, ao invés de usar o timeStyle, eu vou botar o hour, dois dígitos, e minute, dois dígitos. Vamos testar assim. Salva. F5 aqui. Fechar. Beleza, ali já apareceu. 3 de maio, 20 horas. Então, ele acabou não criando aqui uma separação. Então, eu acho que a gente consegue colocar prefixos e tudo mais, mas eu particularmente, por mais que essa INTL do JavaScript seja bem robusta, eu particularmente prefiro utilizar outras bibliotecas de manipulação de data, porque eu sou muito mais produtivo com elas, e é muito mais fácil a gente fazer. Por exemplo, eu gosto aqui, e eu vou instalar uma das bibliotecas que eu mais uso para trabalhar com datas, que é o DateFns. Eu vou instalar essa biblioteca aqui dentro da nossa aplicação. Vou tirar tudo isso aqui. A gente vai importar, agora, de dentro do DateFns, algumas funções. A função que eu quero aqui é a nossa função format. Essa função format aqui, se eu passo o mouse por cima, ela recebe uma data, e o segundo parâmetro é o formato que eu quero colocar essa data. Então, o primeiro parâmetro é o PublishedAt, e o segundo é o formato. Se eu procurar aqui DateFnsFormat dentro do navegador, na documentação, vamos procurar o método aqui, format, aqui ele vai falar para a gente todos os formatos que a gente pode colocar numa data. E aí a data, se a gente for lembrar, eu quero que ela fique nesse formato aqui. Então, eu vou até copiar isso aqui, e vou jogar aqui dentro de uma string. E eu vou botar isso aqui com uma string de aspas duplas, e eu já te falo o porquê, e não com aspas simples. Vamos lá. Agora, no format, o que a gente faz? Primeiro, a gente procura aqui pelo dia. Então, o dia está aqui, dia do mês. Se eu quero com o zero na frente, eu boto dd. Se eu aceito que não tem o zero na frente, apenas d. Então, no lugar do dia, eu escrevo apenas d. O mês, por extenso, está aqui. LLLLL, com ele por extenso. Então, troco aqui. A hora, a gente vai procurar aqui, de 1 a 12, ou de 0 a 24. Eu vou botar de 0 a 24, porque é o horário que a gente usa no Brasil. Então, HH, maiúsculo. E o minuto, eu vou botar MM, minúsculo, que está aqui. E ele tinha esse H no final. A gente tem que cuidar, deixar o H no final. E agora, essas outras letras que sobraram aqui, por exemplo, esse AS, esse H, esse D, eles não podem continuar aqui. A gente precisa fazer o que a gente chama de escapar essas strings, para que o DateFNS não entenda que aquelas strings ali são coisas para formatar. E para isso, a gente bota aspas simples por volta delas. Por isso que eu deixei aspas duplas antes por volta. Então, aspas simples por volta do H, aspas simples por volta do AS, e aspas simples por volta do D. Agora sim, se eu salvar isso aqui, voltar no Chrome, a gente volta lá, e olha só, ele fica 3DMEI, porque é o mês em inglês, às 20 horas. Agora eu só preciso desse mês aqui em português. Para isso é fácil, tá? O próprio DateFNS, a gente consegue importar aqui de dentro dele, de uma pastinha chamada Locale, os idiomas. E aqui tem todos os idiomas. No nosso caso aqui, a gente quer o PTBR. E aqui eu importo ele simplesmente dessa forma aqui, PTBR, ou PTBR maiúsculo, tanto faz. E aqui agora, na função Format, no terceiro parâmetro, eu mando um objeto, e aqui dentro eu tenho Locale. E eu só preciso enviar aqui o nosso PTBR. Salvo isso aqui agora, e olha só, já está ali, 3DMEI, às 20 horas. Então a gente já está com a nossa data formatada, porém essa data aqui, ela ia aqui no nosso Title, e não no conteúdo do Time. No conteúdo do Time, eu quero que tenha, por exemplo, publicado há tanto tempo. Então a gente vai criar uma nova data aqui, que vai ser PublishedDateRelativeToNow. Então se a gente for ler o nome dessa variável, essa variável agora vai armazenar a data de publicação do post relativa ao agora, relativa à data atual. Então é publicado há tanto tempo da data atual. E aqui a gente vai usar uma outra função do DateFns, ela se chama FormatDistanceToNow. E essa FormatDistanceToNow aqui, ela recebe uma data, no caso o PublishedAt, e ele vai comparar essa data com o agora. E aqui a gente pode passar, inclusive, uma Locale, PTBR, e ele tem uma outra opção aqui que se chama AddSuffix. A gente já vai ver como é que ela funciona. Então a gente vai botar esse PublishedDateRelativeToNow aqui dentro do Time, salvo. E olha só, ele mostrou agora 8 dias, ou seja, qual que é a distância de hoje pra data que esse post foi publicado, são 8 dias. Só que ele não mostrou algo na frente, né? Então, nesse caso, a gente pode usar essa opção aqui, chamada AddSuffix, como sendo True. E agora ele vai botar a 8 dias, e assim fica bem melhor. Então esse aqui foi publicado há 8 dias, esse aqui há cerca de 19 horas. Então ele gera pra gente esse prefixo aqui de forma automática. Aqui ele fala sufixo, porque no inglês isso viria depois, mas no português é prefixo, né? Mas o nome continua sendo AddSuffix. E agora, a última que falta é essa data que a gente tem aqui. Essa data que a gente tem aqui, se eu não me engano, está no próprio JavaScript. Então, toIsostring, ele bota nesse formato aqui, com o T no meio. E pode ser, tá? Então aqui a gente vai mostrar, publishedAt.toiso, com o iso maiúsculo, string com S maiúsculo. Salvo aqui, volto lá no nosso projeto, e agora vou até dar um especial elemento pra ver se ficou certinho. Já tá ali, o dateTime já tá completo, o title já tá completo, e o 8 dias aqui também já tá completo. Então agora a gente finalizou de mostrar a data aqui dentro. A última coisa que falta a gente mostrar aqui dentro é o nosso conteúdo do post. Então vamos lá. Pro conteúdo do post, a gente tá enviando ele hoje como um array. Dentro desse array tem os types e os conteúdos. E agora a gente precisa percorrer esse array e mostrar isso em tela. A gente já sabe percorrer arrays aqui dentro do JavaScript, então a gente vai fazer. Vou pegar primeiramente aqui em cima o nosso conteúdo, das propriedades. Dentro do conteúdo eu vou realizar um map, porque eu quero percorrer e retornar alguma coisa. E pra cada linha desse array, item, chame do que você preferir, eu vou fazer alguma coisa. Então boto chaves aqui por volta. O que eu vou fazer? Se a linha for do tipo parágrafo, e aqui eu sempre erro o H no começo, aqui de dentro eu vou retornar um parágrafo, com P minúsculo, e dentro desse parágrafo eu vou colocar o line. Que a gente tava enviando content. Então line.content. Se não, se a linha for do tipo link, eu vou copiar aqui o mesmo return, porém eu vou colocar o parágrafo, porém dentro do parágrafo eu vou colocar uma âncora, e aí aqui dentro da âncora eu vou jogar o line.content. E o href aqui eu vou deixar em branco mesmo. Vamos testar agora, eu vou salvar isso aqui, a gente volta lá e olha que legal. Já tá aqui, ele criou automaticamente, cada linha ele criou um parágrafo, e na linha que tem o link ele criou o parágrafo com o link dentro. Então a gente aprendeu muita coisa nessa aula de trabalhar com datas, e também como trabalhar aqui com o map. Isso aqui daria pra fazer com if, daria pra fazer com switch também, fazer um switch case aqui dentro do line.type, daria de resolver de diversas formas, fica aí na sua criatividade."
  },
  {
    "id": "eeb3f6e7-7f2e-4ff1-95bd-7a66381a44a0",
    "title": "Estado (useState)",
    "transcription": "O que a gente vai fazer nessa aula é, aqui dentro do post, hoje a gente permite que o usuário, ou deveria permitir que o usuário, acionasse múltiplos comentários, porém hoje os comentários também estão fixos assim como a gente tem nos posts. E aí agora, uma das coisas importantes que eu quero mostrar aqui pra você é um novo conceito que é um conceito super importante no React, que é o conceito de estado. Mas antes, vamos lá. Assim como a gente fez pros posts, vamos criar aqui dentro, no arquivo de post, um array de comentários. Esse array de comentários, só pra gente exemplificar agora, tá? Eu vou iniciar ele só com 1, 2 e 3 dentro dele, como se fossem 3 comentários. E agora, da mesma forma que a gente fez no post, lá embaixo, na lista de comentários, eu vou percorrer aqui os nossos comentários com um map, e pra cada comentário eu vou retornar um componente comentário. Feito isso, como o meu array de comentários aqui tem 1, 2 e 3 na frente, se eu salvar e voltar lá no Google Chrome, já tá mostrando aqui 3 comentários e 3 comentários. Se eu diminuir aqui pra 2, ele mostra 2 e aqui 2. Beleza. Isso aqui a gente já sabe fazer. Mas, como que eu adiciono um novo comentário? Vamos testar isso aqui. Primeira coisa, eu não vou usar o texto que a pessoa digitou ainda na textarea aqui pra adicionar nos comentários, eu quero só adicionar mais um número aqui nesse array pra ver se ele aparece ali em tela, o novo comentário. Então, ainda não é a funcionalidade real, digamos assim. Então eu vou fazer o seguinte, quando o usuário enviar esse formulário, quando ele clicar aqui no botãozinho de submit ou dar um enter aqui na textarea, e pra isso eu não vou usar o onclick aqui no botão, eu preciso usar o evento de submit do formulário, porque o submit pode vir através do enter, do click no botão, qualquer coisa assim. Aqui no React, como que a gente faz pra ouvir eventos do usuário, seja um click, um submit, um hover, blur, qualquer coisa assim, eu uso os atributos que existem do próprio HTML, como por exemplo, onclick, no HTML a gente tem o onclick, só que aqui no React a gente bota com o C maiúsculo, porque são duas palavras, a gente já conversou sobre isso. E aqui no onclick, eu coloco uma função, ou melhor, no formulário não é onclick, é onsubmit, quando o usuário realizar o envio aqui do formulário. Aqui, eu vou criar uma nova função aqui dentro desse post, ou pode ser fora, nesse caso eu vou criar aqui dentro, a gente já vai falar o porquê disso. Function handleCreateNewComment, e isso aqui é um pouco de um padrão meu, sempre que eu estou criando uma função aqui em cima, e essa função está sendo disparada através de uma ação do usuário, um click no botão, ou submit de um formulário, eu geralmente começo essa função com handle, beleza? Isso aqui é um padrão meu, você pode criar o seu padrão, como você preferir. Aqui dentro dessa função, eu vou escrever console.log, oi, e agora eu copio o nome dessa função, e aqui embaixo, dentro do onsubmit, eu jogo o nome da função, salvo isso aqui agora, se eu voltar no Google Chrome, abrir o inspecionar elementos, deixa eu limpar aqui o nosso console, digito qualquer coisa aqui dentro, dou um publicar, e agora se você percebeu e foi muito rápido ou rápida, o oi até apareceu, mas depois sumiu tudo, porque? Porque por padrão, quando a gente faz um submit num formulário no HTML, o comportamento padrão do HTML é redirecionar o usuário para alguma página, e no React, como a gente não quer fazer isso, a gente quer manter o usuário na mesma página que ele está, vocês já devem ver aí o conceito single page application, é como se a nossa aplicação tivesse uma única página, eu geralmente não faço redirecionamentos assim, eu preciso evitar o comportamento padrão do HTML de redirecionar o usuário para outro lugar, como que a gente faz isso? Basta na função de submit, eu escrever dentro dela event.preventDefault, event isDeprecated, não tem problema, deixa aqui mesmo com deprecated, depois a gente vai falar sobre isso, salva aqui agora, volta lá para o Google Chrome, vamos lá dar um F5, limpa aqui o console, digito aqui qualquer coisa, clico em publicar, e agora olha só, ele apareceu oi, ali no console, então a nossa função foi chamada, agora eu quero adicionar um novo comentário, então eu vou pegar o meu array de comentários, vou dar um push, eu quero adicionar uma nova informação no array, eu vou adicionar aqui o comentário 3, isso aqui ele vai transformar esse array de comentários, posso até dar um console.log no array de comentários aqui ó, para ver como que isso vai ficar, vamos salvar isso aqui, limpamos aqui a tela, vou clicar em publicar de novo, olha só o que vai acontecer agora, show, a array de comentários agora está 1, 2 e 3, só que se eu for aqui na minha lista de comentários, só tem 2, não está aparecendo o terceiro aqui, por que disso? O React, ele não vai ficar observando o valor da variável comentários para quando ela mudar, ele mostrar os novos comentários em tela, isso seria extremamente não performático porque o React ia ter que ficar ouvindo o valor de todas as variáveis da nossa aplicação, de todas as variáveis que o componente usa, e pensando nisso, no React a gente tem um conceito chamado estado, o estado são basicamente variáveis que eu quero que o componente monitore, ou seja, sempre que eu for criar uma variável, como é esse caso aqui dos comentários, que eu quero que quando o valor dessa variável mude, o React mostre as novas informações de acordo com aquela mudança de valor, eu crio um estado, e como é que eu crio um estado aqui dentro do React? Aqui dentro do componente, dentro do post, eu vou escrever o seguinte, const, qual que é o nome da minha variável, comments, é igual a useState, esse método ele vem de dentro aqui do React, ele até fez a importação automática aqui para mim, e dentro dos parênteses eu passo qual que é o valor inicial dessa variável, no nosso caso aqui a gente estava iniciando ela com 1 e 2, certo? Vou até apagar aqui essa variável agora, show, é isso, Diego? Não, ainda não, por quê? Quando eu crio uma variável utilizando essa funcionalidade de estado no React, o useState aqui, ele não retorna somente o valor daquela variável, ele retorna duas coisas dentro de um array, então até se eu passar o mouse aqui por cima do useState, eu vou ver que o retorno dele, depois dos dois pontos, é um array, e nesse array tem duas posições, a primeira posição, que é um array numérico, e a segunda posição aqui que é um negócio muito louco, que na verdade é uma função. Aqui então, o que a gente geralmente faz quando a gente está criando estados no React, é usar o conceito de desestruturação, como o useState me retorna um array, um vetor, eu posso desse lado aqui da operação também, escrever um array, escrever um vetor, e aí, na primeira posição eu vou ter a minha variável comments, que é aquela variável que eu vou usar para mostrar os comentários em tela, inclusive se eu salvar aqui agora o código, e dar um F5 na nossa página, normal, está listando os comentários, se eu botar mais um comentário aqui, 3 por exemplo, 3, mas eu vou deixar com 2 aqui por enquanto. Tá Diego, e o que a gente vai ter aqui então nessa segunda posição do array, como eu falei, o useState sempre retorna um array com duas posições. Na segunda posição, a gente recebe uma função para eu alterar o valor da minha variável de comentários, e agora talvez ficou confuso para você, tá Diego, peraí, como assim uma função para eu alterar o valor de comentários, porque que eu só não altero o valor de comentários? Porque se você só alterar o valor de comentários, como que o React vai saber que o valor foi alterado? Novamente, ele vai ter que ficar ali, monitorando, e aí, teve alteração? Não teve, tá, então vou esperar, e aí, teve? Não, não teve, tá, então vou esperar, teve agora? Não, não teve, então vou esperar, agora, se eu uso a função que o React me deu para alterar o valor dessa variável, ao invés de eu simplesmente pegar a variável e alterar, essa função, ela tanto altera o valor da minha lista de comentários, quanto avisa para o React, ô, eu avisei, eu alterei a lista de comentários, gera aí a nova lista para mim, mostra aí na interface o novo comentário, então a gente usa essa função aqui do React, para que assim o React não precise ficar monitorando, e sim, ele é avisado quando acontecem as alterações. Então agora, ao invés de fazer aqui um comments.push 3, eu vou usar set comments, e eu preciso passar agora, para dentro dessa função, qual que é o novo valor do nosso estado de comentários, dessa nossa variável de comentários, então hoje o valor é 1 e 2, o novo valor agora é um array com 1, 2 e 3, ou seja, eu não passo somente o que eu quero inserir, eu passo qual é o novo valor, isso a gente chama de imutabilidade, e mais pra frente a gente vai falar sobre isso, entrar mais a fundo. Vamos testar agora? Eu vou até tirar esse console.log aqui agora, a gente vai salvar, voltamos aqui no Google Chrome, e olha só, eu vou digitar qualquer coisa, e quando eu clicar em publicar, apareceu o terceiro comentário, então a gente aprendeu agora como que a gente trabalha com estado aqui dentro do React. Beleza Diego, só que agora se eu tentar cadastrar mais um comentário, não vai funcionar, porque eu estou sempre, de forma fixa, colocando aqui apenas 3 comentários, o 1, 2 e o 3, como que eu faço pra sempre adicionar mais um no final? E aí, a gente pode fazer o seguinte, olha, eu quero copiar todos os comentários que eu já tenho, usando o Spread Operator, o que que o Spread Operator faz? Ele lê o valor da variável comentários, que no caso é um array, e ele copia, então 1, 2, isso aqui é a mesma coisa que eu escrever 1 e 2, ele vai lá e copia os valores que já existem na variável de comentários, então o ponto ponto ponto faz isso, e aqui no final eu posso adicionar mais uma posição, se eu colocar 3 aqui, a gente vai funcionar, mas eu estaria adicionando, eu estaria com o comentário 1, 2, e toda vez que eu adicionasse um novo, eu teria aí 1, 2, 3, 3, 3, 3, 3, 3, 3, porque eu estou sempre 3. Então o que que eu posso fazer aqui? Eu posso, na verdade, ao invés de botar 3, eu posso usar o comments.length, que eu pego o tamanho do array de comentários, ou seja, quantos comentários eu tenho até agora, mais 1, porque como o array começa do 0, eu quero botar 1, 2 e 3, não 1, 2 e 2. Eu boto aqui agora e olha só que legal, a gente volta no Chrome, cada vez que eu clico em publicar agora, ele está adicionando um comentário novo, então eu posso ir clicando quantas vezes eu quiser, e isso funciona para todos os posts, porque como a gente criou essa funcionalidade dentro do componente de post, aqui no segundo post do maicão, eu clico aqui e ele adiciona também, e o mais legal é que quando a gente cria um estado dentro do componente, esse estado fica no escopo daquele componente, ou seja, esse componente aqui não compartilha as informações do estado com esse outro componente, por mais que ambos sejam o post, eles têm informações diferentes, então o React controla isso aí para a gente."
  },
  {
    "id": "bf67a81c-7e5b-44a5-b4a7-2a05f5320c24",
    "title": "Inserindo comentários (Programação declarativa)",
    "transcription": "O que a gente vai fazer agora é armazenar o texto dos comentários digitado aqui dentro da textarea pelo usuário, ao invés de armazenar simplesmente números. Então, o que eu vou fazer aqui agora é iniciar esse array de comentários daqui. Eu vou começar ele com um comentário só. Então, um post muito bacana, hein? Só isso. É o único comentário, então ele vai ser um array, claro. Cada posição no array é um comentário deixado. E eu vou iniciar ele já com esse comentário aqui, post muito bacana, hein? E aí, aqui embaixo, onde a gente lista os comentários, hoje a gente não está fazendo nada com o comentário em si, né? Então, eu vou passar como uma propriedade chamada content aqui pra dentro do meu componente de comentário. Então, eu estou mandando aqui o texto do comentário pra dentro dessa propriedade aqui. E aqui dentro do comentário, eu posso pegar as minhas propriedades e aqui no lugar do conteúdo do parágrafo do comentário, props.content. Ou eu faço a desestruturação, pego apenas o content aqui e mostro o content aqui embaixo. Os dois funcionam, no fim das contas, tanto faz. Se eu voltar agora aqui na nossa aplicação, está ali, post muito bacana, hein? Uma das coisas que eu aviso desde agora, você vai ver que aqui no console da sua aplicação está dando vários erros. Descarta isso aqui por enquanto. Não tem problema, a gente vai ver isso aqui mais pra frente, tá? Show! Agora que a gente já tem aqui o texto dos comentários aqui dentro, a gente pode ver que nos dois posts os comentários são iguais, né? A gente vai adicionar novos comentários. E aí, primeira coisa, a gente precisa pegar o texto digitado pela pessoa aqui dentro dessa textarea pra colocar aqui no final ao invés de colocar esse comments.length mais um aqui, né? Porque hoje se a gente der um enviar aqui, ele vai botar dois, porque a gente está adicionando aqui como a gente estava fazendo antes, né? Dois, três, quatro e não o texto. Pra eu pegar o texto, então eu vou chamar aqui de new comment text, eu consigo de dentro do meu evento, vamos até fazer um console.log aqui antes, tá? Vou comentar essa linha, console.log event.target. Se eu faço event.target, ele vai me retornar o formulário, porque o evento de submit está no formulário, então event.target sempre retorna qual que é o elemento que está recebendo aquele evento. E aí, no caso do formulário especificamente, quando eu adiciono no input ou numa textarea um nome, por exemplo, que eu chamo de comment, eu consigo acessar esse elemento através do próprio comment aqui dentro. Só editar o mesmo nome do campo que eu coloquei na textarea, ele vai acessar, podendo ser input também. Se eu salvo isso aqui agora, volto no Chrome, dou um inspecionar, venho no console, limpo o console, clico em publicar, ele vai me retornar aqui a textarea. Pra eu pegar o valor dessa textarea, basta eu colocar value no final, salvo, clico agora em publicar de novo e ele me retorna aqui asd, que é o texto que eu digitei. Se eu trocar o texto, ele me retorna o texto exatamente digitado. Com isso eu posso salvar esse valor aqui na nossa variável new comment text e botar isso aqui no final. Se eu salvo isso aqui agora e eu venho aqui e dou um publicar, a gente vai ver que aqui no final agora apareceu o texto que a gente comentou. Vou até dar um F5 que está cheio de sujeira aqui. Vamos botar aqui, outro comentário, clico aqui em publicar e já aparece o outro comentário aqui. Claro que alguns campos a gente ainda não tem como colocar, estão fixos o autor, a data, a gente só está botando o texto por enquanto, mas por enquanto está ótimo. E agora o que eu quero fazer? Eu quero que ao terminar de colocar o comentário, eu quero limpar a nossa textarea. Então eu posso fazer o seguinte, eu posso fazer isso aqui igual a string vazia, ou seja, ele vai pegar o valor da nossa textarea e colocar como uma string vazia. Salvo aqui agora, se eu clicar aqui agora em publicar, posso até botar um comentário diferente, eu dou um publicar, ele limpou a textarea, porém ele adicionou um novo comentário aqui no estado. Isso aqui funciona? Funciona. É a maneira que a gente faz quando a gente trabalha em aplicações React? Na maioria das vezes não. Por quê? Dentro do React, ou melhor, não só dentro do React, dentro da programação no geral, existem duas formas da gente programar. Existe a programação imperativa e existe a programação declarativa. Na programação imperativa, que é uma forma da gente escrever o nosso código, nós dizemos para o nosso software o que deve ser feito. Isso quer dizer, imagine que, quando a gente vai aprender lá os famosos algoritmos, a gente cai na famosa, escreva um algoritmo de uma receita de bolo. Vamos voltar para a receita de bolo, eu acho importante isso. Imagina uma receita de bolo. Quando a gente está usando programação imperativa, a gente fala exatamente passo a passo o que deve ser feito. Então, para eu fazer um bolo, eu preciso, por exemplo, ligar o forno a 180 graus. Abrir a porta do forno. Por aí vai. Eu nunca fiz um bolo na minha vida. Eu ia falar que comprar a massa pronta no mercado. Mas, bom, vocês entenderam. Na programação imperativa, eu falo exatamente o passo a passo e é o tipo de programação mais comum. E, novamente, aqui não existe errado ou certo. A gente só está falando sobre os diferentes tipos da gente escrever código nas nossas aplicações. Aqui no nosso post, quando a gente faz esse tipo de código aqui, a gente fala que isso aqui é imperativo. Eu estou dizendo que eu preciso limpar o valor da minha textarea do meu comentário. Só que dentro do React, a gente geralmente evita utilizar a programação imperativa para usar a programação declarativa. Na programação declarativa, ao invés de falar como eu espero atingir o meu resultado final, o passo a passo, eu só declaro qual é o resultado que eu espero. Então, ao invés de eu ter um passo a passo, eu falo quais as condições para eu ter o resultado final, digamos assim. Se eu for trazer isso aqui, novamente, para a receita de bolo, é como se eu falasse condições para que essa receita de bolo possa acontecer e não o passo a passo dessa receita. Ou seja, para a receita de bolo acontecer, o forno precisa estar a 180 graus. Após o forno, ou melhor, quando o forno estiver quente, eu posso colocar a massa para assar. Quando a massa estiver pronta, eu posso retirá-la do forno. Diferente de na programação imperativa, onde eu tenho que falar abrir a porta do forno, colocar a massa dentro do forno. Ou melhor, já errei. Colocar a massa numa tigela, num prato, numa forma. Colocar a forma com a massa dentro do forno. Por que eu estou fazendo essa aula que parece uma aula de introdução a algoritmos? Porque é importante entender isso aqui. Porque, como eu falei, dentro do React, na maioria das vezes, a gente vai escrever a programação de forma declarativa. Na programação de forma declarativa, no React, eu basicamente falo quais são as condições para as coisas acontecerem. Mas eu não executo elas de forma imperativa. E agora, é claro que a gente vai aplicar isso aqui na nossa sessão de comentários, vai ficar mais claro. O que a gente vai fazer para entender isso aqui como que funciona? Primeira coisa que a gente vai fazer. Eu não vou mais acessar o valor, o texto dessa nossa textarea, da forma que eu estava acessando ali, pelo evento. Eu vou fazer da seguinte forma aqui, um pouquinho diferente. Eu vou criar um novo estado aqui dentro do React. Vou chamar ele de newCommentText. E aqui a função sempre começa com set, e o mesmo nome do estado, porém, que é meu case. Então, set newCommentText. Aqui você pode dar outro nome, tanto faz, mas esse é o padrão que usa-se na comunidade React. Aqui eu dou um useState. Dentro desse estado, eu vou armazenar o texto digitado no input. Como é um texto, eu começo ele como uma string vazia. Sempre é importante inicializar o estado aqui do React com uma informação que tem o mesmo formato, o mesmo tipo da informação que a gente vai armazenar posteriormente. Então, se eu vou armazenar um texto aqui, é importante eu começar esse estado com um texto vazio. Se eu vou armazenar um array de comentários aqui nesse estado de comentários, é importante eu inicializar esse estado com, pelo menos, um array vazio. E por aí vai. Agora, aqui embaixo, na nossa textarea, eu vou fazer o seguinte. onChange, ou seja, eu vou monitorar toda vez que houver uma mudança no conteúdo dessa textarea. Eu vou chamar uma função handleComment, ou melhor, newCommentChange. Vou criar essa função aqui em cima. E agora, aqui dentro dela, se eu der um console.log test, olha só. Se eu digito qualquer coisa agora, cada vez que eu digito, ele mostra um novo log do teste. E agora, o que eu vou fazer? Aqui dentro, eu tenho acesso também ao event.target, que nesse caso aqui, me retorna a textarea diretamente e não mais o formulário, porque agora o evento foi adicionado na textarea e não no formulário. Se eu quero o valor da textarea, eu pego o value, certo? Então, tem o valor ali. Se eu quero salvar agora esse valor aqui dentro do meu estado, eu dou um set newCommentText passando o meu event.target.value. Show! Agora que eu tenho o valor digitado na minha textarea armazenado no meu estado dentro dessa variável, eu posso utilizar essa variável newCommentText aqui, que tem armazenado o valor mais recente digitado dentro daquela textarea, pra adicionar um novo comentário no final. Vamos testar? Salvo aqui agora, olha que legal. Vou dar um F5 aqui até pra gente visualizar do zero. Top! Clico em publicar, aparece o top aqui, porque foi o texto que eu digitei aqui dentro. Porém, agora a nossa textarea não limpou. Se a gente estivesse utilizando programação imperativa, a gente viria aqui no final e, novamente, faria aquele event e tiraria o value. Mas na programação declarativa, o que eu vou fazer? Aqui na minha textarea, eu vou falar o seguinte. Olha, o valor dessa textarea aqui é o valor desse estado aqui, armazenado dentro desse estado newCommentText. Isso vai fazer com que, toda vez que o valor desse estado aqui mudar, a textarea vai refletir essa alteração. E aí, aqui no final, quando eu crio um novo comentário, depois de eu criar esse novo comentário, eu vou dar um set newCommentText, que é o estado que armazena o conteúdo da nossa textarea. Eu vou voltar ele pro valor original, que é um valor em branco. Se eu salvo isso aqui agora e volto lá no Google Chrome, olha que legal. Nós vamos escrever top aqui agora. Se eu clico em publicar, ele publicou o top e apagou a nossa textarea. Ou seja, veja que em nenhum momento eu fui diretamente no elemento textarea, a partir da nossa função que cria um comentário, e setei o valor dessa textarea pra um valor em branco, um valor vazio. Ou seja, eu não usei a programação imperativa. Pelo contrário, eu falei, olha, a minha textarea, o valor dela é sempre o valor desse estado. Ou seja, a partir de agora, independente de onde venha essa alteração no valor do newCommentText, essa textarea sempre vai refletir o valor dessa variável que está no estado. Isso é muito importante entender, da programação imperativa pra programação declarativa. E isso vai refletir, inclusive, em várias outras operações que a gente vai executar dentro da nossa aplicação ao longo do tempo."
  },
  {
    "id": "2d4ec9e2-5d3f-4237-9867-2dcb2953d5f9",
    "title": "Comunicação entre componentes",
    "transcription": "Nessa aula, a gente vai construir uma feature aqui para deletar os comentários de cada post. Então, hoje aqui no post, a gente pode criar novos comentários. Então, eu posso vir aqui na aplicação e botar opa, legal. Digito aqui e pronto, já está o comentário. E eu tenho esse botãozinho aqui na direita, porém, se eu clico nele, nada acontece. Mas eu quero realmente deletar o comentário. E aí vamos entender como que acontece isso e como que a gente faz para isso funcionar. Então, vamos lá. Aqui dentro do meu comentário, um componente de comentário, eu tenho um botão, deletar comentário. Beleza. Aqui eu posso adicionar um evento. Então, quando eu clicar nesse botão aqui, eu vou chamar uma função. Como essa função vem através da ação do usuário de clicar, eu gosto de sempre botar um prefixo handle. E aí alguma coisa que identifique a ação que está sendo feita. Handle, delete, comment, por exemplo. Vou criar essa função aqui em cima. Show. Função criada. Posso até testar. Console.log, deletar. Salvo. Venho aqui no inspecionar. Console. Clico aqui no botão de deletar de qualquer comentário. E aparece lá, ó, deletar. Tá, show. Agora, pra eu conseguir deletar esse comentário da minha lista de comentários, eu preciso remover ele aqui do meu estado de comentários. Porque esse estado de comentários é quem controla quais comentários o post tem. Só que o meu comentário aqui, o componente de comentário, o comment, ele não tem acesso àquele estado. Eu não posso vir aqui dentro do comment, por exemplo, e tentar chamar a função setComments aqui. Ela não existe nesse contexto. O comment não tem acesso a essa função. E é aí que a gente cai em um dos ensinamentos mais importantes do React. E eu já falei isso aqui antes, como um spoiler, em outra aula. E eu falei a seguinte frase. E eu falei a seguinte frase. Sempre, ou melhor, a única forma de eu comunicar um componente com outro é através das suas propriedades. E aí, peraí, Diego, beleza, das minhas propriedades. Mas como, ainda não entendi. Como que eu vou fazer para o componente de comentário remover algo que está lá no post, que é um componente pai dele. Olha só que legal. Aqui no componente post, você concorda que nós temos a lista de comentários e uma função setComments. Eu vou começar criando mais uma função aqui, chamada deleteComment. Essa função deleteComment aqui, ela vai receber qual comentário eu quero remover e vai fazer alguma coisa com esse comentário. Então aqui eu vou só dar um console.log, por enquanto, escrito deletar comentário, colocando o nosso comentário aqui dentro. Então aqui eu utilizei o nosso acento grave, ou a crase, para botar deletar comentário e o nome do comentário que a pessoa passou aqui no parâmetro. Agora vem uma das partes mais incríveis, eita, caso você nunca tenha trabalhado com React. Nós não precisamos passar por propriedade aqui para os nossos componentes, somente números, strings, objetos. A gente pode também passar funções, e é assim que a gente comunica um componente com o outro dentro do React. Ou seja, eu posso pegar o meu deleteComment aqui, olha que interessante. E aqui no meu componente comment, eu vou passar essa função como uma propriedade. E eu posso simplesmente dar o mesmo nome aqui, e eu passo a função aqui como propriedade. Agora aqui no meu comentário, eu posso pegar das minhas propriedades o deleteComment. E se eu chamar essa função agora, deleteComment, aqui dentro, passando para ela como parâmetro o conteúdo do meu comentário, que é a única informação que eu tenho do comentário, como eu não tenho um id que seria o melhor nesses casos, eu passo o conteúdo mesmo, melhor seria se a gente tivesse um id. Olha o que vai acontecer, porque eu chamei essa função aqui. A gente volta lá no Chrome, vou dar um F5, vou até limpar aqui o meu console. Quando eu clicar aqui para deletar esse comentário post muito bacana, olha só. Deletar comentário post muito bacana. Olha o que é interessante então, aqui no post, que é quem tem a informação do estado, ou seja, o componente que armazena o estado é o componente que precisa enviar as funções para os outros, geralmente para os seus componentes filhos conseguirem se comunicar com ele. Eu criei uma função deleteComment, que vai ser a função que vai conseguir deletar os comentários aqui dentro, e essa função aqui eu enviei como uma propriedade para o meu componente comment. Até aqui ficou meio grande, eu gosto nesses casos, eu dou um parênteses no começo, um parênteses no final, quebro a linha, tab, quebro a linha, tab, quebro a linha, quebro a linha, aqui, shift tab, enter, shift tab. Só para organizar direitinho aqui e ficar tudo mais ou menos dentro de 80 caracteres por linha. E agora eu envio essa função deleteComment aqui para o meu componente de comentário, e agora o componente de comentário tem uma forma de se comunicar com o componente pai dele, chamando essa função. Isso a gente pode usar para tudo, ou seja, eu consigo enviar funções do meu componente pai para o meu componente filho, para que o componente filho avise, execute essa função para mudar alguma coisa no componente pai. Isso aqui abre muitas portas para a gente fazer muita coisa dentro do React. E aí antes da gente continuar, eu gosto de compartilhar sempre padrões de boas práticas no React, e não só simplesmente compartilhar aqui código. Quando eu envio funções para um componente, como propriedades, que são funções que vão ser disparadas a partir de alguma ação que acontece, ah, então, quando o usuário solicitar para deletar o comentário, aí eu vou executar essa função. Nesses casos, eu gosto de começar o nome da propriedade aqui com onDeleteComment, ou seja, quando acontecer a remoção de um comentário, eu executo a função deleteComment. Nessa aqui eu não boto o on, porque ela pode ser utilizada em outros contextos que não são necessariamente a ação de um usuário deletar o comentário. E aí eu só preciso mudá-la aqui no meu comentário também, aqui para ser onDeleteComment, e aqui onDeleteComment também. E aí a gente salva, e a gente já tem aqui então um componente filho se comunicando com o outro, mas é claro que o comentário ainda não está sendo deletado."
  },
  {
    "id": "5d53c391-a31c-4a28-a1c2-082e7addfbd0",
    "title": "Removendo comentários (imutabilidade)",
    "transcription": "Nessa aula, a gente vai, de fato, remover os comentários conforme a gente clica aqui no botão. Porque hoje a gente está apenas dando um console.log aqui na tela. Mas, nessa aula, então, vamos lá. Aqui dentro do post, a gente criou essa função deleteComment, que ela apenas dá o console.log. E dentro dela, a gente tem acesso, como argumento aqui, ao comentário que a gente quer remover. O texto do comentário, né? Porque hoje a gente está apenas salvando uma lista de textos dos comentários, o melhor, realmente, seria ter um id. Assim, a gente conseguiria referenciar, unicamente, cada comentário, de uma maneira realmente única. Aqui, a gente vai procurar remover, aqui dessa lista, o comentário que tem o mesmo texto. Então, se a pessoa comentar duas vezes o mesmo texto, já vai bugar a nossa aplicação. Mas, para esse caso aqui, está ótimo. Não tem muito o que a gente se preocupar. Beleza. A gente já viu que, toda vez que a gente quer atualizar a lista de comentários, eu preciso chamar ao nosso método setComments. Então, se eu quero, por exemplo, remover um comentário aqui da nossa lista, a única maneira de eu conseguir atualizar o valor da lista é utilizando a função setComments. Eu nunca posso ir direto aqui nos comentários, procurar pelo comentário que tem e remover. Não, não existe isso. No React, a gente chama a função setComments. Porém, a função setComments aqui, e aí eu não tinha colocado meu rosto, mas como você não consegue ficar sem me ver, vou botar aqui de novo. Mas, como a função setComments aqui, como a gente já tinha visto, inclusive, anteriormente, essa função, ela precisa receber o valor, qual que é o valor que eu espero que esteja contido na variável de comentários, no estado de comentários, após a remoção do comentário, que eu não quero que esteja mais lá. Ou seja, essa função setComments, ela não recebe, ah, eu quero adicionar alguma coisa, eu quero remover alguma coisa, eu quero mudar alguma coisa. Não. Eu estou atualizando o valor da lista de comentários para um novo valor. Isso é um conceito chamado de imutabilidade. Eu não sei se você já ouviu falar. Na imutabilidade, a gente prega que as coisas não sofrem mutação, ou melhor, as variáveis sofrem mutação. Se a gente for traduzir aqui para o português, na imutabilidade, nós nunca alteramos uma variável na memória. Nós não alteramos um valor de uma variável na memória da nossa aplicação. Nós criamos um novo valor, ou melhor, um novo espaço na memória. E o que isso quer dizer, no fim das contas? Quando a gente chama a função setComments, no final das contas, a gente não está atualizando o valor da variável comentários. A gente está criando um novo valor para a variável comentários. Tá, Diego. Beleza, entendi o que é imutabilidade, entendi o que acontece por baixo dos panos, mas por quê? E aí existem muitos porquês, mas, no geral, a imutabilidade permite a gente ser mais performático. Principalmente dentro do React, que precisa ficar comparando muitas vezes as variáveis para ver se elas mudaram de valor ou não. Criar um novo valor na memória é mais rápido para o React fazer a comparação se aquilo mudou ou não, do que eu alterar um valor que já está na memória. E aí ele tem que ficar monitorando o espaço na memória para ver se mudou, se não mudou, qual que era o valor antigo, qual que é o valor novo. Então, dessa forma, a gente criando um novo valor na memória do nosso software, o React tem duas versões da nossa variável para comparar e entender o que mudou e o que não mudou. Diferente de alterar diretamente aquele valor na posição que está na memória, sendo que daí eu não tenho mais uma fonte de comparação. Nesse caso aqui, como eu quero remover um comentário de dentro da minha lista, para eu conseguir fazer isso, então, eu preciso criar uma nova lista de comentários sem o comentário que eu não quero mais. Como é que a gente pode fazer isso? Então, vou criar aqui uma nova lista de comentários e aqui é legal dar um nome mais legal. Por exemplo, commentsWithoutDeletedOne. Então, eu estou querendo criar uma lista de comentários sem o que eu deletei. É super importante a gente dar nomes altamente descritivos para as nossas variáveis. Isso é regra de Clean Code básica. A gente vai falar muito sobre Clean Code ao longo do desenvolvimento das nossas aplicações. E aqui, como eu faço para criar uma lista a partir de uma lista de comentários que eu já tenho, porém, removendo algum item. E aí, se você estudou os métodos do JavaScript, a gente tem um método lá dentro do JavaScript chamado filter. O filter nada mais é do que um método que ele percorre cada comentário e aí, daqui de dentro, se eu retornar true, ele vai manter na lista. Se eu retornar false, ele remove da lista aquele item. Ou seja, eu quero filtrar para manter na lista apenas os comentários que forem diferentes e aqui está com o mesmo nome. Então, aqui eu vou dar um outro nome, commentToDelete. Eu quero manter na lista apenas os comentários que tiverem um texto diferente. Então, aqui, diferente do comentário que eu quero deletar. Isso aqui vai me gerar uma nova lista com o comentário, melhor, sem o comentário que eu deletei. E agora, eu uso essa variável dentro do setComments para eu atualizar a minha lista de comentários removendo aquele que eu deletei. Então, eu volto lá no Google Chrome, vou botar aqui top1, top2. Se eu clico aqui agora para deletar o top1, ele tem que sair daqui, pronto. A gente já ficou com o top2 e esse outro aqui é um post muito bacana. Então, a gente aprendeu como que a gente remove coisas da lista e do estado do React. E aqui a gente aprendeu muito mais do que remover um comentário se você for olhar no fim das contas. A gente aprendeu sobre o conceito de mutabilidade e a gente fixou na sua cabeça que o React, a gente nunca altera uma informação. Nós estamos sempre criando uma nova informação e salvando aquilo dentro do estado. Essa é a maneira que a gente faz atualização de valores que estão no estado aqui dentro do React."
  },
  {
    "id": "305bebe6-6587-4fd7-b801-01d175209e6a",
    "title": "TypeScript no React",
    "transcription": "O que a gente vai fazer agora é instalar ou usar o TypeScript na aplicação que a gente veio desenvolvendo até agora. E dá pra adicionar o TypeScript numa aplicação criada previamente com o JavaScript, mas tem muita configuraçãozinha chata e a gente pode acabar esquecendo de alguma coisa. Então, nesse caso, eu prefiro criar um novo projeto com o TypeScript já e repassar o nosso código desse projeto pro outro. Fica mais fácil na minha visão. Pra isso, a gente vai vir aqui no nosso terminal e aqui tá o meu projeto executando. Na verdade, eu vou até parar de executar ele e cancelar o servidor do React. E a gente tem aqui o 01-fundamentos-react.js. Eu vou voltar na pasta aulas e eu vou dar um npm create novamente, vit-latest, pra criar um novo projeto. Agora aqui o nome do projeto eu vou dar 01-fundamentos-react.js-ts, que é TypeScript. Vou dar um enter, seleciono React e aqui antes a gente tinha selecionado a opção React. Agora eu vou selecionar React-ts, que é TypeScript. Dou um enter, projeto criado. Acesso aqui agora o projeto, lembrando que tem que acessar com o traço ts aqui no final, porque é o novo projeto. Instalo as dependências com npm install. Aguardo aqui as dependências serem instaladas. E aí eu vou tirar minha câmera da tela aqui por enquanto e eu vou fazer o seguinte, eu vou abrir aqui os projetos lado a lado. Então eu vou deixar esse projeto aqui do lado, deixa eu até fechar o terminal. E vou aqui abrir o projeto novo em TypeScript aqui desse lado. Perfeito. E agora a gente vai começar a passar as coisas aqui pra dentro. Primeira coisa que a gente pode ver é que ele trouxe alguns arquivos novos que a gente não tinha no nosso projeto em JavaScript, que é o ts-config.json, o ts-config.node.json e aqui dentro da pasta source ele tem um arquivo adicional que é esse vit-env.d.ts, que a gente não vai precisar mexer nele. Então agora o que eu vou fazer? Eu vou remover todos os arquivos da pasta source, que não são o vit-env.d.ts, vou deixar somente ele. Perfeito. Agora eu venho aqui no meu package.json, a gente vai migrar as dependências, então copio aqui das dependências o date-fns e o phosphor-react. Vamos colocar aqui, só cuida com as vírgulas aqui no final da linha, pra não ficar sobrando uma vírgula aqui ou faltando uma vírgula. E das dev-dependencies aqui não precisa nada, não precisa passar nada, o resto já tá tudo certinho, beleza, não precisamos mudar mais nada aqui. Agora aqui no index.html, opa, deixa eu salvar isso aqui, vou fechar. No index.html a gente tem a parte de fontes aqui, então vamos copiar aqui esses dois links aqui em cima de pre-connect, passar aqui pra nossa aplicação e aqui embaixo esse outro link pra importar a fonte roboto. Copio ela também e jogo aqui antes do nosso title. Fechou? Salvo isso aqui agora. Última coisa que a gente precisa fazer é copiar os arquivos da pasta src aqui pra dentro desse projeto. Então eu clico aqui no main e vou com o shift clicando nos outros arquivos, na pasta components também, no assets também, clico com o botão direito, copy, venho aqui na pasta src, paste. Todos os arquivos aqui dentro já, posso agora inclusive fechar esse projeto anterior, a gente vai trabalhar somente no projeto typescript. O que a gente vai fazer aqui agora é renomear a extensão dos arquivos .jsx pra .tsx, porque agora não é mais javascript e sim typescript, então todas as extensões de .jsx pra .tsx. Eu vou fazer isso manualmente, dá pra fazer via terminal, mas como eu sei que tem gente que vai estar no Windows, eu não vou saber o comando pra executar no Windows, então vou fazer na mão aqui, mesmo, em todos os componentes. Trabalhinho manual aqui, mas tá tranquilo. Aqui no assets não tem nada, só tem a nossa logo que não muda nada, e agora a gente vai arquivo por arquivo vendo os erros que podem estar acontecendo e a gente vai corrigindo. Vamos aqui no main, o único erro que está acontecendo é esse document.getElementByIdRoot, o que é o erro que está acontecendo, o que o typescript está falando pra gente? Olha, você está passando um elemento que pode não existir, e realmente, se eu for lá no index e remover o root, ele não existe mais, e aí o typescript está falando que tem chance desse elemento não existir. Mas aqui, é claro que eu não vou remover o root do meu HTML, então eu preciso ter alguma forma de falar pro typescript, ô amiguinho, calma aí, pode ficar tranquilo, o elemento vai estar em tela, confia em mim. Como que a gente faz isso? A gente pode colocar esse ponto de exclamação no final. Sempre que eu quero que o typescript fala, opa, isso aqui pode ser nulo, pode não existir, e eu estou falando, não, existe sim, confia, eu posso botar esse ponto de exclamação. Mas tenta evitar isso, na maioria das vezes, essa solução não é a ideal, isso aqui é só pra esse caso. Aqui no app.tsx, vamos ver se tem algum erro aqui, nenhum erro, como eu falei, a gente não vai precisar mudar muito do nosso código por estarmos utilizando o próprio typescript. Os arquivos de CSS não vão dar erro, porque eles não tem nada a ver com o typescript em si. Vamos agora para os nossos componentes. Primeiro componente, vamos aqui no nosso post. Agora sim já começou a dar alguns erros aqui, que a gente vai ter que resolver. Primeiro erro aqui em cima no date.fns. Aqui a gente vai ver que o erro está escrito, cannot find module.date.fns or its corresponding type declaration. Tá, a gente copiou alguns módulos aqui para o package.json e a gente esqueceu de dar npm install. Então, a gente copiou essas duas linhas aqui, lembra? E não deu npm install depois. Então, feito isso, voltamos lá no post, já parou de dar o erro lá em cima. Agora a gente tem erros aqui no author, no publishedAt e no content. Se eu passar o mouse por cima, ele fala, opa, author está com o tipo n. Isso aqui é um erro. Por que é um erro? Porque o react, ou melhor, isso aqui até é uma função tradicional, isso aqui não tem nem nada a ver com react. A função post, ela não sabe qual que é o formato da informação author, publishedAt ou content. O que a gente precisa fazer aqui nesses casos? Eu posso criar, por exemplo, uma interface falando, olha, o author tem quais informações dentro do author? Vamos dar uma olhadinha aqui dentro. Ele tem o nome, que é myString, ele tem a role, que é myString e ele tem avatar e url, que é myString. Show, Jamie. Então, eu posso vir aqui no author e colocar dois pontos author. Não deu certo. Por que aqui nesse caso não deu certo? Aqui a gente não pode utilizar simplesmente author, porque dentro de objetos eu não consigo definir a tipagem, ou seja, falar qual que é o formato, o tipo de cada informação do objeto, na propriedade do objeto. Eu tenho que falar qual que é o formato do objeto inteiro. Ou seja, para objetos no Javascript, isso aqui é um objeto, concorda comigo? Por mais que eu esteja utilizando desestruturação, quando eu coloco chaves por volta de uma informação, é um objeto. Quando eu estou tratando objetos, eu não posso definir qual que é o tipo de cada informação do objeto separadamente. Eu preciso definir qual que é o formato do objeto inteiro. Então, eu vou criar uma outra interface aqui e eu vou chamar ela de postProps. Por que postProps? Porque esse objeto corresponde às propriedades do meu componente post. E aí aqui eu vou falar, o postProps recebe uma propriedade chamada author. Qual que é o formato desse author? A gente já tem uma interface, então posso usar aqui a interface. Ou eu poderia copiar esse objeto aqui e colocar aqui. Funciona também, você que escolhe. Ele recebe também uma publishedAt, que é uma data. Um content, que é uma string. E agora eu venho aqui no final do objeto, boto dois pontos, postProps. E agora a gente pode ver que o erro já sumiu. E se eu passo o mouse por cima do publishedAt, por exemplo, ele já sabe que é um date. Se eu não coloco isso aqui e passo o mouse, N. N é ruim, é qualquer coisa, a gente não gosta de N. Passo o mouse no content, ele já sabe que é uma string. Passo o mouse no author, ele já sabe que é um author. Que é essa interface que a gente tinha criado aqui previamente. Vou descendo aqui, a gente vai visualizar que tem mais alguns erros para a gente corrigir. Os erros que a gente precisa corrigir aqui é, primeiramente, vamos lá. Dentro dessas funções handleCreateNewComment, handleNewCommentChange, handleNewCommentInvalidDeleteComment. O que acontece? A gente está usando o event aqui dentro. Só que para o TypeScript, o event, ele não faz bolhufas de ideias do que é o event. O que a gente faz nesses casos? Todas as funções que elas vêm através de eventos, seja onClick, onChange, onInvalid, onSubmit. Automaticamente o HTML passa para essas funções, como primeiro parâmetro, o event. Então, eu posso usar o event aqui no primeiro parâmetro de todas as funções handle. Ou seja, todas as funções que são disparadas através de eventos do JavaScript. OnClick, onSubmit, on qualquer coisa que a gente bota lá nas nossas tags do HTML. Porém, a gente pode ver que o evento aqui continua dando erro, porque ele está como N. Eu não sei, o TypeScript não consegue determinar automaticamente qual é o tipo do evento. O que é esse evento? E aí no React, quando a gente faz uma importação aqui do React, eu dou um vírgula aqui e escrevo event. Deixa eu ver se ele mostra aqui para a gente automaticamente. Olha só, escrevo event. O React, ele dá para a gente aqui vários tipos de eventos prontos para a gente utilizar. Então, tem aqui invalid event, por exemplo. Tem aqui o form event. Tem vários eventos prontos para a gente utilizar. Vou até apagar aqui. Esse handle, create new comment, ele é disparado no onSubmit. Então, isso aqui é um evento do formulário, da tag form. Então, eu venho aqui e dou dois pontos. Form event. Controlo o espaço aqui para ele sugerir a importação. Já deu aqui a sugestão de importação do React. Clico em cima. Ele já importou o React e parou de dar erro. O mais legal é que, olha só, quando eu não tinha colocado isso aqui antes e eu escrevo event e dou um ponto, ele até sugere aqui por causa que eu tenho uma extensão que usa inteligência artificial, mas ele não sabe o que tem dentro do event. A partir do momento que eu coloco o form event aqui dentro e agora eu venho aqui e dou um event ponto, ele me fala todas as informações que eu tenho dentro do evento. Ou seja, a nossa IDE fica muito mais inteligente utilizando TypeScript. Então, eu escrevo aqui o nosso prevent default. Handle new comment change. Isso aqui é um evento que acontece no onChange aqui, nesse nosso evento aqui embaixo. Esse evento aqui, eu acho que eu posso também utilizar o form event. Só que no form event, deixa eu até olhar aqui. onChange TypeScript React event. Vamos dar uma olhadinha. Nesse caso aqui, o que acontece? Como esse form event aqui, ele não foi disparado pelo formulário e sim pelos campos dentro do formulário, pelo input, no caso aqui a text area, eu preciso avisar isso para o TypeScript. E aí o TypeScript tem algo interno dele que a gente chama de generics. Generics nada mais são para a tipagem do TypeScript como são parâmetros para as funções do JavaScript. Então, é como se eu precisasse passar um parâmetro para essa form event falando, olha, aconteceu um evento no meu formulário e eu preciso falar, beleza, mas se aconteceu um evento no seu formulário, esse evento não foi disparado pela tag form, por qual elemento foi? É como se eu passasse um parâmetro, então eu coloco um sinal de menor e maior, essa é a forma da gente passar esses generics para o TypeScript falando, olha, o evento aconteceu em um HTMLTextAreaElement. Isso aqui é muito louco, porque eu estou falando, isso aqui é algo global que existe do TypeScript, eu não preciso definir esse HTMLTextAreaElement nem importar, eu falo que aconteceu um form event nesse HTMLTextAreaElement aqui, mas ele continuou dando erro aqui em event.target, ele não conseguiu encontrar esse value, então vamos entender aqui o que está acontecendo. Tá, já dei uma olhada ali, eu não consegui nem ler o stackoverflow direito, a gente não usa o form event aqui, a gente usa um outro chamado, eu posso até importar aqui, changeEvent, faz muito mais sentido, até porque o nome é onChange, então a gente usa o changeEvent aqui, e a gente pode deixar aqui o HTMLTextAreaElement para ele saber que é uma TextArea, se eu não enviar aqui, ele já volta a dar erro. Então, perfeito, a gente já resolveu isso aqui. Handle new comment is invalid, aqui a gente tem um invalid event, então dou um ctrl espaço aqui, invalid event, beleza? Novamente, de uma HTMLTextAreaElement, então já para de dar erro aqui no setCustomValidit. Na função deleteComment, qual que é o tipo da informação que ela recebe? Qual que é isso aqui, esse comment do delete, não sei se você lembra, isso aqui é um número, isso aqui era uma string, era o comentário que eu quero deletar. Então, dois pontos, string, e assim a gente vai arrumando. Aqui embaixo ele deu mais um erro, content.map, passo o mouse por cima, map não existe no tipo string, então eu falei que content é uma string, mas o content não é uma string, até se eu voltar lá no app, o content aqui é um array com várias coisas dentro, então vamos voltar lá em cima. É, eu botei string, tá errado. Vou criar aqui uma interface chamada content. O content tem dentro dele um tipo, esse tipo aqui é uma string, mas veja só, o tipo aqui, por mais que ele seja uma string, ele só pode ter dois tipos, ou parágrafo ou link. Então, no TypeScript, quando a gente sabe que é uma string, mas ela vai ser essa string ou essa string, eu posso fazer da seguinte forma, ou isso aqui vai ser, e aí eu boto como aspas mesmo, um parágrafo, ou vai ser um link. Dá pra fazer dessa forma, fica mais fácil. E aí ela tem o content, que aí é uma string, aí pode ser qualquer coisa. Agora, aqui o meu conteúdo não vai ser mais uma string, vai ser, na verdade, um array com vários objetos com esse formato aqui. Então, é um array com vários objetos dentro que tem type e content. Então, o TypeScript é muito legal depois que você vai pegando, e isso aqui traz muita inteligência pra nossa ideia, como eu falei. Aqui, se eu não tivesse esse código e escrevesse, novamente, tivesse que escrever esse código do zero, if line.type igual. Olha só, ele já sugeriu pra gente link e parágrafo, porque ele já sabe que são os dois únicos valores que eu tenho aqui pro meu type. Se eu tivesse botado ashwa-ashwa-ashwa-ashwa e tivesse criado o meu if aqui, por exemplo, passo o mouse aqui por cima desse ashwa-ashwa, ele já vai falar, olha só, essa condition sempre vai retornar falsa, já que os tipos do link são parágrafo e link, e ashwa-ashwa não tem overlap, ou seja, não bate com essas opções parágrafo ou link. Então, o TypeScript ajuda a gente evitar ficar escrevendo aqui o nosso código com erros. Vamos lá, tem mais algumas coisas pra gente mexer aqui, e agora a gente vai um pouquinho mais rápido. Nós temos aqui o nosso comentário, nosso comentário, então, a gente só tem erros aqui em cima, eu vou criar uma interface chamada comment props, que são as propriedades do comentário, o conteúdo dele é uma string, e o nosso onDeleteComment é uma função. Como é que eu faço pra adicionar tipagem nas funções? Eu faço? Faço também. Essa onDeleteComment é uma função. Pra eu fazer uma função, é nesse formato aqui, boto como se fosse uma arrow function no JavaScript. Essa função onDeleteComment, ela tem algum retorno de dentro dela? Vamos lá ver, no post, a gente envia pro comentário onDeleteComment, a gente manda a função onDeleteComment, essa função onDeleteComment, não, ela não tem nenhum return no final, ela só faz alguma coisa, mas não retorna nada. Então, o retorno dela é vazio. Porém, a função onDeleteComment, ela recebe um parâmetro, que é uma string. Então aqui, eu preciso falar que ela recebe um parâmetro, que é o comentário, e é uma string. O nome que eu vou dar aqui, não precisa ser o mesmo nome que tá aqui, tá? O nome, tanto faz. Eu só tô avisando pro TypeScript, que essa função precisa de um parâmetro, que é o comentário. Agora eu venho aqui embaixo, dou dois pontos aqui, comment props. Beleza. Aqui embaixo ele tá dando um erro, out, property out does not exist on string attributes has border. Isso aqui é algo importante, tá? Veja só, que no nosso avatar, a gente criou um componente de avatar, e esse componente de avatar aqui, hoje, a gente só tá buscando as propriedades dele has border e source. A gente não tá utilizando a propriedade out em nenhum lugar. Ou seja, essa propriedade out que eu tô enviando aqui, ela não vai ser utilizada pra nada. Então agora, o que eu vou fazer? Eu vou criar uma interface, avatar props. Vou falar que ele pode receber uma propriedade has border, que é um booleano. E agora, ele vai receber uma propriedade também source, que é uma string. E vou falar que ele também recebe uma propriedade out. Aqui eu venho, coloco avatar props. Vou até pegar aqui a minha propriedade out, né, e vou repassar pro meu componente image. Assim, se a pessoa informar algum texto alternativo, a gente mostra também na tag. Se eu sair disso aqui agora e voltar lá pro meu comment, já parou o erro. Agora, se eu for lá no meu post, onde eu uso o avatar, tá dando erro. Vamos lá, passo o mouse por cima, e ele fala, olha, o seu avatar aqui tá enviando a propriedade source, que é uma string, mas faltaram outras propriedades do avatar, como has border e out, que você não tá enviando. Tá, mas essas propriedades são opcionais, eu não quero sempre enviar elas. Então, lá no avatar, aqui nas nossas propriedades, quando eu tenho uma propriedade que é opcional, eu boto um pontinho de interrogação antes dos dois pontos aqui. E agora o has border não é mais obrigatório. O out é opcional também? Beleza. Boto um pontinho de interrogação aqui na frente. Fechou? Salvo, volto no post, e já tá funcionando. No comment também já tá funcionando. Vamos agora aqui no nosso sidebar. É a última coisa. Não tem mais nenhum erro. E assim, a gente terminou de adaptar toda a nossa aplicação pra utilizar TypeScript, e ficou bem legal."
  },
  {
    "id": "153319c8-4daf-4960-89a1-123a91a504c4",
    "title": "Redirect no SSR",
    "transcription": "Uma das coisas que a gente tem que cuidar aqui na nossa aplicação é que rotas que usam o GetServerSideProps ou até rotas que façam o Fetch aqui dentro do próprio componente e que dependem de parâmetros externos a gente sempre tem que pensar que esses parâmetros podem não ser enviados. Hoje essa rota de sucesso, se eu venho aqui e arranco, já deu erro. Porque ele estava esperando um SessionID, aí ele tentou executar essa função, não tinha SessionID, foi o comando Define, deu erro. Então a gente precisa de uma forma de conseguir, opa, se o usuário não informar esse SessionID, se não existisse SessionID, eu nem deveria poder executar o resto aqui. Então vamos lá, eu posso fazer o seguinte, se eu não tiver uma SessionID aqui dentro, o Next permite a gente fazer um redirecionamento do usuário por dentro da função GetServerSideProps. Então olha só, quando eu dou um return aqui, já que eu botei a tipagem aqui, eu dou GetServerSideProps, quando eu dou um return e dou um ctrl espaço, olha só, ele aparece pra gente que a gente pode retornar algumas coisas. NotFound, se eu retorno isso aqui como true, ele vai retornar um erro 404 na página, então se eu salvo isso aqui e dou um F5, peraí, InvalidCheckoutSessionID, Undefined, the error happened while generating the page, tá, provavelmente é, ah tá, é porque como eu, provavelmente como eu, tá, deixa eu fazer um negócio aqui, console.log, type of, tá, eu acho que eu já sei o que que é, porque na verdade eu convertei isso, converti isso aqui pra uma string, então talvez eu tenha que fazer isso aqui de uma maneira diferente, se SessionID, é, na real, deixa eu fazer um teste aqui, como é que isso aqui tá chegando, porque isso aqui deveria ser falso, né, SessionID, deixa eu ir aqui pra baixo, deixa eu dar um F5, tá, tá vindo como Undefined, tá, entendi já, cara que interessante, olha que legal, legal mais ou menos né, porque esse query.SessionID aqui ele tá retornando Undefined, só que quando eu coloco o string por volta, ele acaba transformando isso em Undefined, pelo que eu entendi, deixa eu fazer um type of SessionID, pra ver se isso realmente é o que eu tô pensando, eu dou um F5 aqui ó, se ele retornar string, é isso mesmo, é, é isso mesmo, cara que estranho, é um erro que seria realmente difícil de pegar, né, porque aparece Undefined e aqui tu pensa, pô o id não foi definido, mas não, é Undefined o texto mesmo, Undefined, tá, mas vamos lá, o que que a gente vai fazer aqui, a gente pode fazer uma verificação antes então, né, se eu não tiver o query.SessionID, é, aí eu dou um NotFoundTrue, ó, eu vou salvar aqui agora, olha só, ele dá um 404, só que isso aqui fica feio, né, fica estranho, não é muito legal, então, uma das opções aqui ó, é Redirect, então eu posso redirecionar, aí eu passo aqui, olha só, vai dando Ctrl espaço e ele vai falando, tá, Destination, então eu quero enviar ele pra onde? Pra Home, e se é permanente ou não, ou seja, se é um Redirect 301 ou 302, né, meio que só um atalho pra isso, né, e aqui não é permanente, né, por quê? Porque esse Redirect aqui, ele só acontece caso o usuário não informe a SessionID, ou seja, não é um Redirect permanente, essa rota aqui, quando o usuário entrar, não é sempre que ele vai ser redirecionado, não é permanente, então a gente tem que cuidar só com esses pontinhos aí. Salvamos, agora só dar 5 na página e pronto, a gente já é redirecionado pra Home, caso o Cexas aqui não tenha um SessionID informado, né, então é legal porque a gente aprende que a gente pode fazer redirecionamentos aqui por dentro do GetServerSideProps mesmo, caso alguma condição aí não seja validada."
  },
  {
    "id": "b0ffc283-d019-495b-89d9-2b061cae8696",
    "title": "Estrutura de sucesso",
    "transcription": "Nessa aula o que a gente vai fazer é a estrutura visual da nossa página de sucesso. Hoje a página está basicamente dessa forma aqui, que não está, digamos lá, aquelas coisas. E a gente vai deixar ela com esse visual aqui. É uma página simples, mas a gente tem que passar por essa etapa para conseguir continuar. Então, novamente, styles.pages, vou criar aqui sucess.ts, já vou deixar previamente criado aqui um sucess.container. Igual a style, a gente importa aqui main. E vou criar uma outra aqui também, que é o nosso image.container, que vai ser basicamente essa caixinha que fica por volta da imagem. O resto não tem mais muito o que criar de estilos, porque é uma página muito simples. Agora a gente vai jogar o nosso sucess.container, e dentro do sucess.container a gente vai começar a colocar as nossas informações. Então vou começar com h1 aqui, compra efetuada. A gente vai jogar o nosso image.container, tem que pegar ele do sucess. Aqui dentro eu vou colocar a nossa imagem, por enquanto ela não existe, a gente não tem essa informação ainda aqui na página de sucesso. Logo a gente vai ver como a gente vai fazer isso. Parágrafo, vou colocar aqui agora as informações. Depois a gente vai preencher com as informações corretas. O nome do usuário e o nome do produto, eles vão estar em negrito, então só faço dessa forma. E aqui a gente vai botar um link do next. O link precisa ter uma âncora dentro, ele não serve como âncora, então a gente precisa ter a âncora dentro. Na verdade na última versão do next, deixa eu até confirmar isso certinho aqui. Eu tenho quase certeza que isso não vai mais ser necessário. Então não precisa mais da âncora dentro se eu estou na versão 12.2 para cima. Então não é mais necessário, a gente pode botar diretamente o texto e voltar ao catálogo. Por isso é sempre importante ficar direto de olho nas changelogs do next. E já que a âncora não é mais necessária, a gente pode também voltar lá na nossa home. A gente tinha aqui esse product, ele é uma âncora e ele estava servindo dentro. Então a gente pode voltar isso aqui para ser uma div, por exemplo. E aí pronto, a gente tem o link direto. E aqui a gente vai testar só se está funcionando. Então deixa eu entrar na home da nossa aplicação. Beleza, continua como link, deixa eu dar uma inspeção do elemento aqui. Na verdade não, ele está como uma div por volta e não está como um link. Ele não criou a âncora aqui por volta. Deixa eu dar uma checada aqui. You can opt into this behavior by running the codemod and setting new next link behavior to in the experimental. Isso está experimental ainda. Então no momento que você está vendo essa aula, se ele criou o link aqui certinho já, pode deixar, não precisa configurar nada. Novamente, eu estou no momento que eu estou tendo que usar essa funcionalidade experimental. Então aqui na config do next eu preciso passar esse new next link behavior. Talvez, como eu falei no momento que você está vendo essa aula, não precisa mais. Então deixa eu ver agora, rodando o npm run dev, se vai dar certo como eu estava esperando. Inspecionar elemento. Beleza, agora ele tem uma âncora aqui por volta. Prontinho. Vamos lá, voltamos aqui na página de sucesso. E a gente vai colocar agora alguns estilos aqui dentro. Então, vamos abrir aqui o nosso estilos. Deixa eu só pegar aqui minha colinha. E aqui a gente vai começar colocando então, display flex, flex direction column, align items center. Vamos colocar aqui também justify content center, margin 0 alto e height 656. Isso aqui já vai fazer a nossa página ficar um pouquinho mais estendida. Então já está mais centralizada e um pouco maior, para o header não ficar tão abaixo. E aqui agora a gente vai dar uma estilizada também na nossa imagem. E depois a gente mexe um pouquinho aqui no restante. Mas na imagem aqui a gente vai dar um width de 100%, um max width 130, um height 145. Aqui o background linear gradient a gente copia de outro lugar que a gente já tinha criado aqui. Só para aproveitar. Um border radius 8. Padding 0.25 hem. Display flex, align items center, justify content center e image object fit cover. Salvamos aqui agora, a gente já pode ver a imagem vai ser posicionada ali dentro. Border radius escrevi errado, por isso que não ficou arredondado. Agora a gente precisa só dar uma distanciada aqui entre as coisas. Então vamos lá. O h1 aqui, ele tem o tamanho 32. Depois a gente vai começar a arrumar esses tamanhos. Então o nosso h1 vai ter um font size 2xl. E ele vai ter aqui uma color grey 100, que é aquela cinza bem clarinha. E o nosso p aqui, ele já vai ser um pouquinho diferente. A gente pode ver aqui. O p, ele tem 24 de tamanho. O 24 de tamanho aqui é o nosso xl. Então font size xl. E o color aqui dele é o grey 300. Perfeito. Aqui a gente pode setar um max width nele, para não ficar muito grande. E ele ficar centralizado. Então vou botar um max width de 560, por exemplo. Ele fica dessa forma, centralizado. E a gente bota também um text align center. E agora a gente vai dar uma distanciada nas coisas aqui. Então essa imagem distancia 64 de cima e esse aqui 32. Então o image container aqui a gente pode botar nele um margin top de 4rem. E o p aqui, um margin top de 2rem. Aqui a gente já está com as coisas distanciadas. E aí o nosso voltar ao catálogo tem uma distância de 80. A gente pode fazer um 80 dividido por 16, dá 5. Então a gente vai pegar aqui o nosso voltar margin top 5rem. Podemos dar aqui um display block, para não precisar trabalhar com o display inline, que é um pouquinho mais chato. E aqui, voltar ao catálogo, ele tem o tamanho 20 e a cor um pouquinho mais escura. Então aqui a gente vai botar o nosso font size large. E aqui a color, o nosso green 500. E aí quando o usuário fazer um hover nisso aqui, a gente vai trocar a color pra green 300. Salvo isso aqui agora, a gente vai tirar aqui o nosso text decoration. Vamos botar ele como none, a gente salva. E o nosso font weight aqui vai ser bold. Então, show de bola, a gente já meio que terminou a nossa página. Eu vou só pegar aqui o nosso p e vou dar um line height dele de 1.4. E prontinho, nossa página de sucesso está pronta. O único problema é que ainda não está mostrando realmente as informações reais do produto que foi comprado. A gente estava colocando informações estáticas. Botão de voltar ao catálogo também, já está redirecionando para a ROM. E agora a gente vai realmente fazer essa integração de mostrar os dados reais da compra do usuário."
  },
  {
    "id": "8381e282-62ac-4aa1-b298-4ee818301c65",
    "title": "Utilizando React DevTools",
    "transcription": "O que eu vou fazer nessa aula é te mostrar uma ferramenta pra você conseguir inspecionar aplicações React, principalmente no que tange performance e ciclos de renderização. E essa ferramenta se chama React DevTools. Ela tem pra Chrome, é uma extensão, tem pra Firefox, tem independente do navegador que você esteja utilizando. E o que acontece é que essa extensão fica aqui na sua barra de extensões, e eu posso pegar aqui, eu vou botar ela aqui em cima, e essa extensão é legal porque ela fica colorida quando você entra num site que está usando React. Quando ele é, no caso de desenvolvimento, ela fica vermelha, então fala que está usando a development build do React, mas se você entrar em qualquer outro site que usa React na versão de produção, sei lá, eu posso entrar em praticamente qualquer site do mundo. Eu acho que o Twitter, por exemplo, ele já fica azulzinho. A Figma vai ficar azul também, posso entrar no Notion, a todos os sites praticamente vai ficar azul. Mas o ponto é, quando eu abro aqui o inspecionar elemento, deixa eu tirar um pouquinho do Quando eu uso o React DevTools, ele aparece aqui pra gente duas novas abas no inspecionar, que é o Components e o Profiler. O Components, ele é basicamente uma visão do Elements que a gente tem aqui, pra ver a DOM, porém focada em componentes do React, e eu posso usar esse inspecionar aqui pra inspecionar um componente específico do React. Então, por exemplo, se eu clico aqui, ele vai me retornar exatamente o StyledDiv, que é um componente do StyledComponent, mas se eu for ver aqui em cima, eu tenho o Summary, que é o nosso resumo. E o mais legal é que eu consigo ver, através do React DevTools, todo o fluxo de renderização, ou seja, o Summary foi renderizado porque ele estava dentro de Transactions, que é a nossa página, que estava dentro de App, que estava dentro de CreateRoot, que estava dentro de ReactDOM, e eu consigo também ter acesso aos Hooks que aquele componente usa, então a gente pode ver que o Summary, o nosso componente Summary, ele tem acesso, ele tem um Hook lá dentro dele, Summary, que dentro ele acessa o contexto da nossa aplicação, aqui dentro tem Transactions, olha só, eu consigo ver tudo basicamente aqui dentro. E aqui, ele retorna qual é o nome da variável que eu salvo aqui, o nosso Hook, consigo copiar os dados aqui e tudo mais, e eu consigo acessar as propriedades também, então deixa eu lembrar se tem algum componente aqui nosso que a gente usa propriedade, tem esse PriceHighlight aqui, então se eu inspecionar esse StyledSpan aqui, que ele era aquele nosso PriceHighlight para deixar verde ou vermelho, olha só, ele mostra as propriedades que a gente enviou para o componente, então VariantOutcome aqui por exemplo, o Children, que é o conteúdo interno desse componente, e a gente consegue mexer em tudo nisso, beleza, a gente consegue dar uma olhada aqui total, mas outras coisas que eu gostaria de mostrar para você, que é mais importante, é o que está aqui nessa Settings, quando eu entro nessas Settings aqui, além de selecionar o tema, além de selecionar a densidade, tem uma outra opção aqui que é muito legal, que é essa aqui, HighlightUpdatesWhenComponentsRender, essa opção aqui o que ela faz, toda vez que um componente renderizar, ou seja, ele for recriado em tela, ele coloca rapidinho uma borda por volta do elemento, então olha só, quando eu procuro aqui por exemplo, por Desenvolvimento, e clico em Buscar, todos os componentes que renderizaram na nossa aplicação por causa disso, eles vão piscar, colocar uma bordinha por volta, fica de olho, tá vendo? E você pode ver que na verdade muita coisa na nossa aplicação renderizou porque eu fiz essa busca. Será que todos esses componentes que renderizaram aqui, quando eu fiz a busca, deveriam realmente ter sido renderizados? Não sei, a gente vai ver isso aí ao longo do tempo, ao longo das próximas aulas. Aqui em Debugging a gente tem mais algumas opções, não tem muita importância, aqui em Components também a gente consegue, digamos, esconder alguns componentes que não são importantes, divs que não fazem tanto sentido e tudo mais, e aqui em Profiler também a gente consegue fazer algumas configurações, mas tem outra coisa legal aqui do React Dev Tools, que é essa outra aba aqui que se chama Profiler. O Profiler funciona mais ou menos parecido com o próprio Profiler aqui do navegador, porém ele retorna informações sobre o fluxo de renderização de uma aplicação React. Como é que funciona o Profiler? Olha só, eu clico aqui para começar a gravar, faço alguma ação na aplicação e paro a gravação. E o que ele faz aqui é basicamente mostrar pra gente todos os componentes que renderizaram só porque eu fiz essas ações. Então a gente pode ver que teve 3 commits, o commit nada mais é do que algum componente ou um conjunto de componentes renderizaram, e a gente pode ver que teve um primeiro commit em que o que tiver cinza aqui quer dizer que não renderizou, quer dizer que não teve alterações, ele não precisou ser recriado. O que está com uma corzinha quer dizer que ele teve que ser recriado, e a cor de verde quer dizer que foi muito rápido, até amarelo, até vermelho quer dizer que demorou bastante. Então a gente pode ver que num primeiro commit, ou seja, num primeiro fluxo de renderização, a gente teve uma atualização no search form e no style form, no magnifying glass e no icon base, que são os ícones que estão aqui dentro do botão. Por que isso aqui teve que renderizar? O que acontece? Lembra que lá no nosso search form, que está aqui dentro de components, a gente fez com que basicamente quando o form entrasse em estado de submit, a gente pega esse isSubmitting aqui pra trocar o botão pra disabled. Então foi por isso que esse primeiro commit aqui aconteceu, porque ele trocou o botão aqui pra disabled como sendo true, por causa do isSubmitting, e aqui a gente consegue até ver isso. Aqui no search form, se eu clico em cima dele, ele me traz aqui o porquê que esse componente renderizou. Só que pra eu habilitar isso aqui, eu preciso, aqui dentro de profiler, selecionar essa opção record why each component rendered while profiling. E aqui ele fala, hook 2 mudou. Se a gente for aqui no search form, a primeira chamada de hook que a gente tem é essa. A segunda chamada de hook que a gente tem é essa. Então ocorreu essa renderização porque o segundo hook, o hook 2 no caso, esse aqui, mudou. Alguma informação que estava sendo retornada por esse hook aqui mudou. Sim, o nosso isSubmitting aqui mudou. Então beleza, com isso a gente já consegue ver. E aí ele fala que o form teve que ser renderizado porque mudou a propriedade onSubmitChildren, mudou isso aqui, mudou isso aqui. Então beleza. Outra coisa que a gente pode perceber é que quando um componente renderiza no React, todos os componentes filhos daquele componente, por exemplo esse form, esse input, esse button, esse ícone, eles renderizam também. E é por isso que mostra aqui o form, o ícone, tudo isso renderizou de novo por causa que o componente pai renderizou. Show de bola, isso não é um problema. Depois a gente teve mais um commit. Nesse commit aqui, vamos voltar lá para o nosso app, ele renderizou somente o search form. E por que ele renderizou? Porque o hook 2 mudou de novo. Isso aqui é porque provavelmente o nosso isSubmitting voltou para o valor original, que era falso, então ele mudou para true, depois voltou para falso. E aí no terceiro commit, que foi o mais pesado aqui como a gente pode ver, muita coisa renderizou. Muita coisa que renderizou. Isso aqui basicamente renderizou por quê? Olha só, vamos começar, a gente sempre pega o topo, qual foi o primeiro componente que teve uma renderização nova, foi o TransactionsProvider. Esse TransactionsProvider, por que ele renderizou de novo? Porque o hook 1 mudou. O hook 1 é o nosso Transactions, ou seja, quando a gente fez a busca de transações, a nossa FetchTransactions aqui, ela atualizou o valor de Transactions, o que ocasionou esse estado aqui mudar, como esse estado mudou, todo o TransactionsProvider foi renderizado. E como o TransactionsProvider está lá no nosso app, por volta de toda a nossa página Transactions, ProReact, quando um componente pai muda, todos os componentes filhos mudam também, renderizam também. E aí ele ocasionou aqui uma renderização em todos os componentes filhos, mesmo nos componentes que talvez não precisavam dessa informação de Transactions atualizado. Por exemplo, se a gente for ver aqui, um dos componentes que foi atualizado foi o nosso NewTransactionModal que está aqui, ele foi renderizado de novo. Só que, pensa comigo, o que eu mudei aqui no nosso contexto foi a nossa lista de transações, o nosso componente NewTransactionModal, ele depende da lista de transações em algum momento? Não, não depende. Então por que ele teve que ser recriado do zero? Bom, o porquê é basicamente porque como o nosso contexto mudou e o nosso contexto aqui está por volta de toda a página de transações e o nosso NewTransactionModal está dentro dessa página, ele vai ser recriado automaticamente, é um comportamento padrão do React. E isso não necessariamente quer dizer que vai deixar a aplicação lenta, tá? Tem que ter muito cuidado, porque não é porque um componente foi renderizado novamente que automaticamente isso quer dizer que a nossa aplicação é lenta, não, isso é muito rápido, você pode ver que levou 0.5 milissegundos, ou seja, não deu nem 1 milissegundo. Mas a gente consegue evitar esses comportamentos, principalmente pensando quando a aplicação crescer, essas renderizações desnecessárias aí sim podem causar algum tipo de lentidão. Então é muito do que a gente vai ver aí ao longo das próximas aulas."
  },
  {
    "id": "2d39d8b8-0957-4b19-8eca-0634f82a8778",
    "title": "Componente: Summary",
    "transcription": "Nessa aula, então, a gente vai criar esse nosso componente de resumo aqui com as entradas, saídas e o total. E esse componente eu vou apelidar ele de Summary, é assim que se fala, meu Deus, alguém me ajuda? Summary. Fechou. Summary. Esse componente aqui, então, eu vou criar aqui os estilos dele também. E aqui a gente vai, então, começar configurando o componente. E aqui, já vou partir diretamente para os estilos. A gente vai começar criando, então, SummaryContainer, como a gente sempre começa. Deixa eu importar o InstallComponent. Posso fazer com uma div mesmo, aqui talvez pode ser uma section, talvez seja melhor do que uma div. E aqui eu vou fazer mais ou menos parecido com o header, até, se quiser, a gente pode copiar as estilizações aqui, dessa parte do HeaderContent, porque ele vai ficar centralizado igual o header. Então, e aqui agora eu vou dar um DisplayGrid também, GridTemplateColumns, a gente vai usar um Repeat, 3, 1fr, porque eu quero 3 colunas dentro do grid, todas com o mesmo tamanho, 1, 2, 3, e eu quero um espaçamento entre elas de 2rem, no caso de 32 pixels. E aqui eu vou dar um MarginTop-5rem, tá, por que eu fiz isso? Porque como a gente pode ver, o header aqui, a gente deixou esse espaçamento preto embaixo, usando um padding, e o Summary, na verdade, ele vai ficar aqui embaixo do header. Então eu botei um MarginTop negativo pra jogar esse Summary pra cima, ele vai ficar por cima do header, então essa tag SummaryAll não vai ficar dentro da tag header, dentro do componente header. São duas coisas diferentes, porém, o Summary vai ser jogado ali pra cima do header em si. E é isso, eu vou salvar isso aqui agora, e eu vou começar criando um pouco aqui do componente em si, eu vou chamar de Summary, e aqui a gente vai colocar o nosso SummaryContainer, e aqui dentro do SummaryContainer eu vou começar a colocar o HTML que a gente vai ter aqui dentro. Então aqui a gente vai ter 3 cards, eu vou começar usando divs mesmo, esses cards vão ter um header, que é essa parte aqui em cima, onde está o título e esse ícone, e aí no primeiro aqui eu vou botar um span, entradas pra botar o texto por volta, eu prefiro botar um span porque eu prefiro estilizar sempre a tag que está por volta do texto, eu não gosto de adicionar estilizações de texto, de fonte, essas coisas assim, em elementos que são de container, eu prefiro criar um span, por exemplo, por volta do texto, todo texto tem algum tipo de tag por volta dele, e não deixar ele solto dentro de um container, principalmente se ele vai ter algum elemento irmão do lado dele. E aqui, como a gente vai usar ícones, eu vou instalar a biblioteca do Phosphor React, que é a biblioteca que a gente vai estar utilizando pra ícones, e aqui o ícone que eu vou estar utilizando é o ArrowCircleUp, e aqui ele não fez a importação sozinho, então Phosphor React ArrowCircleUp, e aqui eu vou passar pra ele um tamanho de 32, e eu vou passar também uma cor pra esse ícone, que vai ser a 00B37E, show de bola, e abaixo do header eu vou ter um strong, que é o preço aqui em si, então eu vou copiar aqui o texto mesmo da maneira que ele tá, e essa div agora ela vai ser 3 vezes, aqui só na segunda vez ela vai ser saídas, e não entradas, a cor do ícone também vai mudar pra F75A68, esse ícone a gente conseguiria mudar a cor dele lá por dentro do CSS também, não precisaria mudar aqui necessariamente, até seria melhor né, porque a gente iria usar o tema aqui do style.components, mas bom, tanto faz, e aqui eu vou botar total, e aqui não é ArrowCircleUp, aqui é down agora, aqui ele já entendeu e já fez a importação automática pra mim, e esse último ícone aqui ele é o CurrencyDollar, e a cor aqui vai ser FFF, e aqui só muda porque esse card final aqui ó, ele vai ter uma cor de fundo diferente, mas logo a gente vai fazer isso. Se eu salvar isso aqui agora, voltar aqui na nossa página de transactions e abaixo do header, colocar o nosso componente de Summary, a gente já vai ver que vai aparecer aqui em tela, ele já ficou em cima do header, tá vendo, por causa daquele nosso marginTop negativo, falta agora a gente adicionar a estilização em si. Eu vou começar criando aqui dentro de Summary uma estilização chamado SummaryCard, vou criar como uma div mesmo, e aí aqui dentro eu vou trocar cada uma dessas divs que tá por volta do header por um SummaryCard, então eu posso vir aqui, selecionar todas as divs ao mesmo tempo, escrevo SummaryCard, posso selecionar todas as divs de fechamento e escrevo SummaryCard também. Salvo, não vai mudar nada porque continua sendo uma div, e agora sim, a gente vai pra estilização e as coisas vão começar a mudar bastante aqui. Eu vou começar colocando aqui um background ou backgroundColor, tanto faz, a gente vai estar utilizando a cor gray 600, então agora já vai começar, dá pra visualizar ali o resultado. Vamos colocar aqui também um borderRadius de 6 pixels e eu vou dar um Padding de 2 rem. Agora sim, já dá pra ver bastante como vai estar ficando. Bora pro cabeçalho ali, o cabeçalho é super simples, é só um displayFlex, uma LineItemCenter, dá um JustifyContentSpaceBetween, e aqui a gente vai dar um color usando a colorPropsTheme, aqui a gente vai usar o gray 300, por padrão a cor de texto da nossa aplicação é gray 100, que é esse mais clarinho, o header vai ficar uma cor um pouquinho mais escura. Aqui a gente vai pegar o texto, que é o Strong, que é esse aqui, o do valor, a gente vai colocar aqui nele um displayBlock, porque por padrão a tagStrong vem com um displayInline, e aí a gente não consegue aplicar margem vertical em tags que tem displayInline, e aqui eu vou dar um fontSize 2 rem, 32 pixels no caso, e um marginTopping 1 rem, de 16 pixels. Cara, é muito rápido estilizar, já tá ficando bem massa aqui, não tem quase mais nada pra gente estilizar aqui dentro. O que a gente vai fazer aqui agora é esse último card, deixa eu só conferir o tamanho do texto aqui, esse aqui tá 16 pixels, esse aqui já tá 16 também. Aqui parece um pouquinho diferente né, porque a gente tá com muito zoom aqui no feed, mas se eu botar aqui uns 70%, aí sim, já dá pra ver que tá bem igual. A única coisa é que esse último card precisa ser verde, então uma das formas da gente fazer isso é permitir que seja passada uma propriedade, então eu vou criar aqui uma interface, SummaryCardProps, falando que esse SummaryCard pode receber uma propriedade chamada, sei lá, Variant, por exemplo. E essa propriedade Variant pode receber vários valores. E aqui eu vou botar, como por enquanto a gente só tem uma variante, digamos assim, de cor, eu vou falar que essa propriedade Variant, quando ela existir, porque ela pode não existir, ela não precisa necessariamente ser passada por causa desse ponto de interrogação, mas se ela existir, o valor dela tem que ser green. Mais pra frente, se a gente tivesse mais variantes de cores, a gente poderia fazer isso dessa forma aqui, criando várias condicionais aqui dentro. Mas show, eu vou agora falar que esse SummaryCard pode receber essas propriedades e aqui embaixo eu vou criar uma estilização condicional. Eu vou ter acesso às propriedades do meu componente, se a propriedade Variant for green, eu vou adicionar aqui dentro um CSS. E esse CSS vai ser importado do StyledComponents, já importou lá em cima, e aqui eu boto novamente as minhas template tags e aqui dentro eu vou colocar um background, como sendo... a gente já tem acesso às props ali em cima, então posso jogar direto. Props, Theme, Green, Substance. A gente já tem acesso aos props aqui, eu não preciso escrever de novo isso aqui. Funcionaria também, mas no fim das contas é desnecessário. Eu vou salvar isso aqui agora, a gente volta aqui no nosso Summary. No último card, agora, a gente passa aqui, ó, Variant, e se eu der um Ctrl espaço ele já oferece pra gente aqui o green. Eu salvo, volto aqui no projeto e já tá com o fundinho verde aqui. Então a gente terminou de criar o nosso componente do Summary aqui, do resumo das transações. É claro que os valores eu deixei tudo 17 mil, aqui tá tudo errado, mas já dá pra gente continuar com o desenvolvimento do app."
  },
  {
    "id": "c6c5478b-127e-4cff-856a-330a737eee6e",
    "title": "Data Fetching no Next.js",
    "transcription": "Nessa aula a gente vai falar um pouquinho sobre data fetching dentro do Next, ou seja, como fazer chamadas HTTP, chamadas para API externas de dentro do Next. E a gente já configurou aqui a nossa API do Stripe, mas por enquanto nessa aula a gente ainda não vai utilizar ela porque eu quero que você conheça alguns conceitos importantes do Next antes da gente partir para o uso dessa API. Então, desde que você começou a aprender React, você provavelmente soube da informação que a gente pode fazer chamadas API aqui por dentro do componente para conseguir popular algum estado, fazer alguma lista. Então, dando um exemplo aqui, mesmo sem fazer a chamada API, do que seria o formato de fazer uma chamada API dentro do componente, basicamente a gente faz um useEffect. Você já provavelmente está acostumado com isso. Aí a gente tem algum tipo de fetch de dados aqui. Só para simular eu vou fazer um setTimeout, só para eu conseguir fazer que uma função demore para executar algum tempinho, como se fosse um tempo de delay indo lá na API buscando os dados. E aí a gente tem um estado, ele tem uma lista. Essa lista aqui eu vou preencher ela com um array vazio, mas ela vai ser um array de números só para a gente realmente exemplificar. E aqui dentro eu faço um setList com array 1, 2 e 3. Então, imagina que isso aqui é como se fosse uma chamada API. Então, assim que o componente é exibido em tela, esse useEffect entra em cena. Ele faz a chamada API e quando termina de buscar os dados lá na API, que seja, ele preenche um estado com aquelas informações. Provavelmente foi assim que você aprendeu, se você acompanhou o Kinect ou qualquer outro conteúdo, provavelmente foi assim que você aprendeu. E aí a gente pega essa lista, mostra em tela. Aqui a gente pode até, para exemplificar, eu vou mostrar aqui antes de algum dos produtos. Vou colocar aqui um pré, vou dar um jsonStringFile nessa lista só para a gente visualizar ela. Voltando aqui, opa, eu parei de executar. Eu tinha parado de executar o servidor aqui, não sei porquê. Voltando, a gente pode ver a lista ali, está vazia e do nada ela preenche. Do nada não, depois de dois segundos, porque foi o tempo que a gente colocou no setTimeout. Então é mais ou menos como funciona uma API. O ponto é, lembra que eu te falei que o Next tem um grande propósito por trás de porquê que ele existiu desde os primórdios, que são esses dois carinhas aqui. Vamos conversar um pouquinho sobre esse server-side-rendering antes. O que acontece, quando os crawlers, bots, indexadores vão acessar o nosso site, das duas uma. Ou ele vai acessar com o JavaScript desabilitado, ou ele não vai aguardar esse tempo aqui, que a gente viu que demorou esses dois segundos, para ele entender que o conteúdo da página já foi carregado. E aí se a gente está desenvolvendo alguma página, como por exemplo um e-commerce, que precisa de indexação, muitas vezes isso é um problema. Praticamente 100% das vezes isso é um problema. Até para fazer um teste, você pode vir aqui no inspecionar elementos, vir aqui na engrenagem, desabilitar o JavaScript, dar um F5 e pronto. Isso aqui é como os crawlers e indexadores vêm em teu site. E aí a primeira coisa que você pode ver, já perceber aqui, por exemplo, é que o nosso slider bugou. Por quê? Porque a biblioteca Keyn Slider aqui, ela funciona somente no client-side. E também a gente não tem a nossa lista aqui com o número 1, 2 e 3. Porque esse código aqui executa somente no client-side. Ou seja, quando a gente desabilita o JavaScript do navegador, tudo o que a gente está vendo aqui em tela, é o que foi criado por esta camada aqui do Next. E que se a gente estivesse num SPA tradicional, utilizando o Vite Create React App, isso não ia nem existir. Você pode fazer algum teste, pegar algum projeto seu escrito em Vite, algum projeto que a gente já tenha feito, a página vai ficar totalmente em branco. Então, isso é um dos benefícios do Next. O porquê que ele foi criado hoje tem muito mais benefícios do que só isso. Então, o que o Next está fazendo é, quando a gente acessa essa página aqui pela primeira vez, o primeiro carregamento que a gente faz, ele cria uma versão desta página aqui, ele cria todo o HTML do componente, o CSS, nesta camada aqui. Porém, tudo o que roda somente pelo lado do client-side, como são, por exemplo, os User Facts, como são essas bibliotecas específicas de JavaScript, tudo isso não executa. Mas, porém, entretanto e todavia, existe uma forma da gente falar para o Next que eu quero que essa chamada aqui da API rode também deste lado aqui e não neste lado aqui. Quer ver? Olha só como é que a gente faz isso. Em qualquer página do Next, qualquer arquivo que esteja dentro da pasta Pages, e somente arquivos dentro da pasta Pages, eu não consigo fazer isso em componentes que não estejam aqui dentro, somente nas páginas, eu posso, deixa eu tirar esse User Facts, tirar esse User State, eu posso exportar, deixa eu comentar esse Pratt também aqui, eu posso exportar, e eu gosto de exportar isso sempre no final do componente, aqui embaixo, uma constante, ou melhor, uma função, chamada GetServerSideProps. Se a gente for traduzir, eu quero obter propriedades do server-side. Server-side é o quê? É esta camada aqui. Isto aqui é server-side, isto aqui é client-side. Perfeito? Esta função aqui, ela pode devolver de dentro dela algumas propriedades. Por exemplo, ela pode devolver uma lista contendo 1, 2 e 3. E agora, como isto aqui já diz pelo próprio nome que são propriedades, no React, as propriedades podem ser recebidas pelo parâmetro aqui da nossa página. E agora, se eu mostrar aqui em tela json.stringfileprops.list, e list, lembra, é exatamente o nome que eu estou passando aqui, veja que ao eu salvar este código e dar um F5 na página, a lista já está preenchida aqui dentro, inclusive com o JavaScript desabilitado. Mas agora eu quero que você preste atenção em uma coisa que é muito, muito, muito importante. Isto aqui é muito importante você entender. Quando a gente estava com o código do UseEffect, deixa eu até eu voltar lá, porque isto aqui é muito importante. Quando eu estava com o código do UseEffect aqui dentro, vou até dar um console.log aqui escrito rodou, só para você ter um pouco de ciência disso. Quando eu estava com o código do UseEffect aqui dentro do componente Home, eu quero que você, com o JavaScript habilitado, não tem problema, eu quero que você perceba qual é o funcionamento do navegador assim que a gente dá um F5. O que aconteceu aqui? Assim que eu dei o F5, a página foi exibida em tela por completo, faltando somente as informações ali da minha lista, e depois de um tempo a lista foi preenchida. Concorda comigo? Agora, quando a gente muda este código aqui para dentro do GetServerSideProps, deixa eu ver se eu consigo... Vai, eu vou ter que escrever de novo, porque... Inclusive, vou ter que escrever de novo não, sabia que no Vascode tem uma abinha Timeline? Eu descobri isso aqui nesses dias, cara, olha só. Aí você consegue vir aqui, não é essa? Essa aqui? Não. Essa aqui? Não. Essa aqui? Não. É, é isso aí. Você descobriu o Timeline, mas não serviu para nada. Mas, o que acontece? Quando a gente tira esse código daqui e move isso lá para o nosso código aqui de baixo, o nosso GetServerSideProps, eu quero que você perceba qual é o funcionamento agora. Porém, para a gente simular, porque aqui a gente estava demorando 2 segundos para fazer o retorno da API. Agora, para a gente simular esses 2 segundos, eu vou fazer um await new Promise. Aqui eu pego o resolve, dou um setTimeout, resolve, 2 segundos. Isso aqui é só um códigozinho, um hackzinho, para a gente fazer com que o JavaScript pare por aqui 2 segundos e não execute mais nada abaixo dele. Não tem muita importância em entender isso aqui agora. Mas, eu vou salvar isso aqui agora, e agora eu quero que você preste muita atenção no que vai acontecer com a página, mesmo com o JavaScript desabilitado. Eu vou até fechar a aba e vou abrir de novo. Presta atenção comigo no que vai acontecer. O que aconteceu aqui? Não sei se você prestou atenção, mas a nossa página por completo demorou 2 segundos para ser exibida em tela. E só depois que esses dados aqui estavam carregados, então a página foi exibida. Ou seja, quando a gente cria um código server-side, que ele está rodando nesta camada aqui, o que o Next faz é, ele não devolve nada para o front-end, nada para o browser, até que tudo o que a gente tenha colocado aqui dentro tenha sido executado. Diferente de quando a gente tem uma chamada aqui dentro do useEffect, que daí o React mostra tudo em tela e depois começa a fazer essa chamada. Ou seja, com o getServerSideProps, a gente nunca vai ter um estado de loading, por exemplo, nessa lista, porque a página não vai nem ser exibida em tela enquanto esses dados estão carregando. Não vai haver nenhum momento em que esses dados aqui vão estar, digamos, vazios porque a chamada ainda não foi finalizada, porque a página só vai ser exibida em tela quando os dados estiverem carregados como um todo. Então isso é muito importante entender sobre o getServerSideProps aqui do Next. Uma outra coisa importante a entender, lembra que eu tinha colocado um console.log aqui dentro chamado rodou, né? O mais interessante é que se a gente colocar um console.log aqui dentro escrito rodou, veja só, eu venho aqui no inspecionar o elemento do meu navegador, em nenhum momento eu vou ver esse console.log aqui dentro. Agora se eu volto aqui no Vascode e abro aqui o meu terminal, veja só, o rodou está aparecendo aqui dentro. Por quê? Porque como agora esse código aqui ele está executando na camada server-side, no servidor Node aqui do Next, o Node é isso aqui. Isso aqui que está executando aqui é um servidor Node. Por isso o log não aparece no navegador, porque esse código aqui na verdade ele nem chegou para o navegador, o navegador nem conhece esse código. Ele é um código que ele executa somente nessa camada. E aí, para a gente finalizar essa aula, talvez tenha uma pergunta aí pairando pela sua cabeça, né? Diego, então quer dizer que toda chamada da minha aplicação, toda requisição para API, eu vou fazer dentro do getServerSideProps? Não. Por quê? Como você viu, essa chamada aqui que demorou dois segundos, ela fez a nossa página por completo demorar mais para ser carregada. E apesar de que os dados já vieram populados desde o começo, que facilita a nossa vida como deve, para o usuário que está utilizando a aplicação, isso é meio ruim, porque dois segundos para mostrar alguma coisa em tela é muito tempo. Ou seja, a gente na maioria das vezes ainda vai preferir fazer as chamadas HTTP, requisições para API, do modelo tradicional que a gente sempre aprendeu no React, fazendo useEffect, fazendo aqui, quem sabe, o clique do botão vai fazer uma chamada, qualquer coisa assim. A gente só vai fazer chamadas utilizando o getServerSideProps para trazer informações para a nossa página que a gente necessariamente precisa que estejam disponíveis assim que a página for exibida em tela. Ou seja, somente informações que são cruciais estarem em tela para indexadores, bots, crawlers ou qualquer coisa semelhante. A gente não usa o getServerSideProps para todas as nossas chamadas API no Next. Fechou? Então a gente teve mais um ensinamento super importante e agora sim a gente vai começar a consumir a nossa API do Stripe, buscar os dados dos produtos e por aí vai."
  },
  {
    "id": "f91853a5-1a3c-4e55-aaf6-b326c1ac1d57",
    "title": "Configurando Axios",
    "transcription": "O que a gente vai fazer nessa aula é configurar uma biblioteca para fazer as requisições HTTP aqui, porque por mais que a Fetch API aqui do navegador seja extremamente interessante e é muito melhor do que as antiguidades, onde eu fazia uma XML HTTP request, que na verdade é o que está sendo feito por baixo dos panos, aqui está uma API bem antiga da web, que é esse XML HTTP request, a gente tem que, muitas vezes, quando a gente usa o Fetch, ele não tem a API mais amigável do mundo, então, por exemplo, aqui para eu setar um search parm, por exemplo, eu tive que criar uma URL, dar um append aqui, ele fica uma API meio estranha assim para fazer as requisições, fora que aqui a gente está fazendo uma só requisição, mas quando a gente começar a fazer várias requisições na nossa aplicação, a gente vai ter que chamar toda vez o mesmo endereço, aqui localhost 3353, eu não consigo, por exemplo, setar na Fetch API um prefixo, digamos assim, uma configuração para que todas as requisições partam sempre para um endereço, eu vou ter que toda vez escrever o endereço completo. Na Fetch API também, a API para fazer requisições POST, PUT, DELETE são um pouquinho diferente, então assim, eu gosto sempre de utilizar uma biblioteca para fazer isso, e para isso a biblioteca que eu vou estar utilizando é o Axios, que é a biblioteca mais famosa aqui de requisições no front-end, no back-end também. E aqui, como a gente está lidando com a biblioteca externa, eu vou criar uma pastinha chamada lib, e dentro eu vou criar aqui axios.test, que vai ser a configuração do Axios em si. Aqui de dentro eu vou exportar uma constante chamada API, é igual, axios.create, e aqui, uma das features mais legais do Axios é que a gente consegue setar uma base URL, e veja que o RL aqui é em letra maiúscula, e aqui a gente vai basicamente setar qual que é o endereço da nossa API, que é esse HTTP localhost 3353, e a gente vai colocar aqui dentro, ou seja, todas as requisições disparadas através do Axios, elas vão automaticamente ser enviadas para esse endereço, e aí a gente precisa digitar, aqui no momento que a gente está fazendo a requisição, somente o restante, a gente não precisa digitar todo o endereço completo. Salvo isso aqui agora, a gente volta aqui no nosso contexto, vou tirar tudo isso aqui, e olha como fica mais simples a nossa requisição, a gente vai simplesmente fazer um const response igual, API, ele importa lá do nosso lib.axios.get, que é o tipo, o método que eu estou fazendo, aqui poderia ser post, poderia ser put, poderia ser delete, poderia ser patch, no caso a gente vai usar um get, o endereço, transactions, ou barra transactions, tanto faz, vai dar no mesmo, e aqui eu posso enviar um objeto de configurações, dentro desse objeto de configurações, eu posso enviar parms, que são os nossos search parms, e eu envio aqui o nosso que, como sendo query, e agora aqui no data, eu simplesmente uso response.data, eu não preciso converter isso aqui para json, property data, ah, faltou o await aqui na frente, porque senão ele retorna uma promise, e agora pronto, já configuramos o axios, e a gente pode fazer o restante da mesma maneira, já está tudo funcionando, se eu venho aqui e escrevo site.enter, a gente pode ver que ele continua funcionando aqui sem problemas nenhum, porém aqui a sintaxe ficou muito mais simples de entender."
  },
  {
    "id": "81154c0a-64c7-4fcf-9328-f55866455c44",
    "title": "Estrutura da Home",
    "transcription": "Bora lá então. O que a gente vai fazer nessa aula é a estrutura da Home do nosso projeto. Epa, eu tava editando post no Insta aqui. Vamos voltar aqui então. Essa aqui então é a Home que a gente vai fazer, do Ignite Shop. O que a gente vai fazer aqui agora? Pra gente ir um pouquinho mais a fundo no Stitches, a gente vai criar essa visualização, digamos assim, dessa tela da Home. Mais pra frente, essa listagem de produtos, na verdade, ela vai vir de dentro do Stripe. Mas, por enquanto, a gente vai fazê-la estática, até porque a gente nem conectou API no nosso projeto. Então, uma das coisas que eu vou fazer aqui em Assets, a Milena já deixou preparado pra gente algumas camisetas aqui pra gente estar utilizando. Então, o que eu vou fazer aqui agora? Esse projeto aqui eu não consigo mexer nele, porque ele é um projeto que não tá editável. Então, eu vou duplicar esse projeto pra eu conseguir mexer um pouquinho nele. Agora eu volto aqui em Assets, pego essas camisetas. Eu vou pegar essas quatro camisetas aqui embaixo. Eu não vou pegar essa primeira aqui, porque ela tem umas nuvens ali que eu acho que vai atrapalhar um pouquinho. Bom, eu vou pegar só... eu não preciso de quatro, na verdade. Eu vou pegar umas duas só, pra gente visualizar como que isso vai ficar. Na verdade, eu preciso que crie pelo menos um carrossel aqui. É, três. Tem que ter pelo menos três pra criar o carrossel. Então, eu vou pegar essas três finais. Vou colar aqui embaixo essas camisetas. E por que eu tô fazendo isso? Porque hoje elas estão com 400 pixels aqui. Mas se a gente for ver lá no layout, ela tá sendo utilizada aqui com pelo menos... Deixa eu pegar aqui a layer que tá por volta da camiseta. 480 de altura, 520 de largura. Então, por isso que eu quero exportar ela um pouquinho maior. Então, eu vou pegar cada uma separadamente. Pego essa primeira, venho aqui, seleciono esse constraint proportions. Eu não sabia o nome disso aqui, sorte que tinha um título. Mas pra eu aumentar a largura, ele crescer a largura junto e vice-versa. Então, aqui eu vou botar um 480. Ainda ficou ruim, porque a largura precisava ser 520. Então, eu vou botar 520. Show. Primeira camiseta pronta, deixa eu ver se não deu nenhum bug aqui. Não, tá show. Essa aqui também, 520. E essa aqui também, 520. Opa, 520. Depois eu preparo as outras camisetas. Mas, por enquanto tá bom. Ele acabou ficando meio com essa borda do lado. Deixa eu ver. Ah, aqui também tem. Então, não é bem um problema, na verdade. Ele tá talvez soltando foguete aqui. E agora, eu vou pegar essas três camisetas aqui e vou exportá-las. Então, venho aqui em export. Pode ser PNG, como a gente vai usar o Next Image. Aí ele já vai converter isso aqui para o melhor formato pra gente, que vai ficar delicinha. Isso é bom demais. Então, na exportação das imagens, a gente nem precisa ficar muito se preocupando com Ah, tô exportando a imagem grande demais, tô exportando a imagem no formato errado. Claro que aqui não daria pra ser JPG, porque tem transparência. Mas, assim, a gente não precisa se preocupar muito com a qualidade, porque o Next Image vai salvar a gente. Eu vou exportar essas três camadas e vou colocar lá dentro do nosso projeto. Então, eu tenho aqui Ignite, Aulas, 04 Ignite Shop, SRC. Eu tenho Assets aqui. Isso vai ser provisório, tá? Eu vou colocar aqui Camisetas, em português mesmo, porque a gente vai deletar isso depois, como eu falei. Isso vai vir depois lá de dentro do Stripe. Então, tá exportado. Eu posso ver que aqui dentro de Camisetas agora já tá aparecendo. Eu vou só trocar o nome delas pra 1, 2 e 3. Tanto faz qual que é 1, qual que é 2, qual que é 3, tá? Falando nisso, pô, Camisetas bonitas pra caramba. E agora a gente vai criar a estrutura aqui, visual, da nossa ROM. E é por isso que eu coloquei essas imagens, porque a ROM, cara, assim, do nosso... Meu Deus, cheio de e-mail aqui, tudo aberto. Ih, Diego, vai dar aula, deixa tudo aberto. E-mail, aí vocês vão ler meus e-mail. Aí... tá. A ROM é basicamente imagens, né? Se a gente for ver aqui, a nossa ROM é basicamente imagens. Por isso que eu precisava ter exportado essas imagens aí. Vamos lá. O que eu vou fazer? Antes de mais nada, aqui em Pages, eu vou criar um Home.js aqui nos estilos, pra gente começar a criar a estilização da nossa ROM. E aqui de dentro eu vou exportar, pra iniciar, um HomeContainer. Esse HomeContainer eu vou usar o Style, que vem aqui do Index, que a gente criou. E ele vai ser uma Main, uma seção Main aqui do nosso projeto. E eu vou criar também, já deixar criado um componente chamado Product. Esse Product, ele é, na verdade, cada um dos produtos ali que vai estar dentro do carrossel. Então, cada um desses Boxes aqui vai ser um Product. E o Container é o que fica por volta de tudo. E aí a gente pode salvar, voltar aqui pra ROM. Vamos tirar esse Button aqui de cima, que a gente não vai estar utilizando. Vou jogar aqui no lugar de Button, o nosso HomeContainer, que fica aqui por volta. E dentro do HomeContainer, a gente vai ter vários Products, como eu falei. Esses Products, eu criei como Div lá dentro, mas eu acho que eles podem ser links, âncoras, na verdade, porque vai ser clicável. Então eu venho aqui, jogo um Product. Tem que cuidar pra importar dos lugares certos. E aí cada um desses Products aqui dentro, ele vai ter uma imagem. Eu vou usar o Image, que vem do NextFutureImage. Lembrando, né, se você está utilizando uma versão mais recente do Next, provavelmente, talvez nem exista mais NextFutureImage e seja apenas NextImage, mas o resultado vai ser o mesmo. E aqui dentro de Image, a gente vai colocar o Source contendo as nossas imagens. Então, pra gente simular aqui, eu vou começar importando, sei lá, camiseta1, from.com.br, assets.com.br, camisetas.com.br, 1.png. E eu vou fazer a mesma coisa, camiseta2, camiseta3. E aqui eu vou trocar 2 e 3, tá? E agora eu vou colocar aqui o Source, camiseta1. E aqui a gente vai fazer o seguinte, eu vou pré-setar uma largura de 520 e vou pré-setar uma altura de 480. Lembrando que o NextImage, quando a gente usa ele, é importante, se a gente conseguir, na maioria das vezes, informar uma largura e altura. Essa largura e altura não precisa ser exata, exatamente a largura e altura que aquela imagem vai ter. Até porque trabalhando com layout responsivo, a gente pode ter essa largura e altura diminuindo. Mas, digamos que esse número, a gente coloca qual que é a maior altura e maior largura que a gente vai precisar dessa imagem. Qual que é a maior quantidade de altura e largura que a gente vai precisar. Porque assim, o NextImage, quando importar essa imagem, ele vai diminuir, redimensionar essa imagem, pra gente não importá-la num tamanho grande demais. Então, se a gente acaba não passando largura e altura, e essa imagem tem, sei lá, 2000 pixels de largura, é ruim, porque ela vai importar com 2000 pixels e vai ficar muito grande. Aqui eu vou passar também um texto alternativo, dificilmente a gente vai ter um texto alternativo vindo lá do Stripe, então eu vou deixar ele em branco por enquanto. E essa box aqui embaixo, que tem o título e o preço, a gente vai usar um footer. O footer geralmente é o melhor elemento pra gente fazer isso. Vou colocar um Strong aqui, então vou botar aqui camiseta, X, só pra gente visualizar. E aqui no spam eu vou jogar um preço, por exemplo, o que tá ali, 79,90. Eu acho que esse espaço aqui, ele não deveria existir, se for seguir a regra... Deixa eu ver aqui se eu consigo encontrar. Mas eu tenho quase certeza, espaço, entre, cifra, real, eu não lembro, usa espaço entre o símbolo, não use zero na... Ah, tem que ter um espaço, aí, vivendo e aprendendo. Pronto, salvo aqui agora, voltamos aqui pra nossa home, já podemos ver uma camiseta. O que eu vou fazer, só pra não ficar ruim, eu vou colocar mais uma, tá? Eu não vou colocar três ainda, porque a gente não tem o carrossel, e vai dar scroll horizontal, aqui não é o que eu quero. A gente vai voltar, e agora a gente vai criar um pouco de estilização aqui na nossa home, tá? Então, vamos lá. Primeira coisa que nós vamos fazer aqui dentro, usar um display flat aqui no home container, porque eu quero que uma camiseta fique ao lado da outra. Vou dar um espaçamento de 3rem entre as camisetas, a gente ainda não consegue ver isso direito, mas ele colocou um espaçamento aqui entre os produtos. E aqui, o que a gente vai fazer, tá? Aqui vai ser um negocinho que você vai ficar de cara com o que a gente vai fazer. Pra gente visualizar melhor o que está acontecendo aqui, eu vou colocar um background color red, só pra gente visualizar o container, tá? Que está por volta dessas camisetas. E olha só o que a gente quer fazer aqui no final das contas, tá? Se a gente for ver, esse box aqui que fica por volta das camisetas, por volta dos produtos aqui, ele tem uma margem somente nessa lateral. E aí você pode pensar, tá, eu vou aqui e jogo um margin left x, e vai dar tudo certo. O problema é quando a gente dá um zoom out, né? Porque, olha só, vamos voltar aqui no projeto que eu fiz uma cópia, né? Imagina que isso aqui é a tela da aplicação. Essa nossa box, ela está ocupando, digamos, isso aqui, né? Que é um tamanho específico, mais o restante que tem de margem aqui na direita, digamos assim. E essa margem na esquerda precisa existir. O problema é, o que deveria acontecer quando a gente der um zoom out nisso aqui, né? Se o usuário pegar e dar um ctrl- várias vezes. O que deveria acontecer é, essa margem aqui, ela poderia crescer, porém, o box, ele deveria continuar grudado aqui na direita, né? Então deveria acontecer, no máximo, alguma coisa assim, ó. O box continuar grudado na direita, e a margem na esquerda, ela continuar crescendo quando o usuário der um zoom out, né? Será que deveria ser isso? Será que, eu acho que deveria ficar mais ou menos alguma coisa assim, né? Então, a gente vai ter que fazer um cálculo, porque não é tão simples fazer isso aqui no CSS puro, né? Então vamos entender o que a gente vai fazer aqui agora, tá? Olha só, esse meu container de imagens, até voltando aqui, ó. Esse meu container aqui, ó. Ele vai ter uma, eu vou pensar que ele tem uma largura fixa, tá? Até porque essa largura fixa, eu tenho que mostrar sempre dois produtos aqui, e depois o carrossel vai mostrando mais, né? Então, se eu for pensar aqui na... Cadê? Eu perdi aqui o meu... Ah, tá. Tá dentro de assets. Se eu for pensar... Caramba. Ah, tá aqui. Meu Deus, eu tô perdido em tanto. Deixa eu fechar esse outro aqui, vou trabalhar só com a cópia aqui, que é mais fácil. Se eu for pensar que isso aqui é o meu tamanho de tela, e eu vou ter uma largura fixa pra esse elemento, por exemplo, 1180, o que que eu preciso, né? Antes de mais nada, eu preciso que a largura desse elemento aqui seja o 1180, vai acompanhando comigo o pensamento, 1180, mais esse espaçamento aqui, ó, que ficou aqui no canto. Concorda comigo? Essa aqui é a largura que eu preciso pra esse elemento aqui, eu preciso ocupar esse tanto aqui. Só que pra eu obter esse número aqui, eu vou precisar fazer um cálculo no CSS. Qual que é esse cálculo? Olha só. Eu vou pegar 1180, vou até escrever aqui pra gente visualizar isso melhor. Eu vou pegar 1180, que já é o tamanho que eu espero do elemento, e eu preciso somar esse 1180 com esse número aqui. Como que eu posso obter esse número aqui? Eu posso pegar a largura da tela como um todo, concorda comigo? Menos 1180, 1180, ou seja, ele vai retornar esse valor aqui vezes 2, porque é essa, essas duas partes aqui, isso mais isso, certo? Então, isso aqui, se eu fizer isso menos 1180, ele vai retornar o valor desses dois boxinhos aqui somados. E aí, como eu tenho dois boxinhos, eu pego e divido esse valor por 2. Então, vai ser 1180 mais, isso aqui é muito interessante, a largura da tela menos 1180, dividido por 2. Porém, se eu fizer a divisão assim, não vai dar certo. Então, eu tenho que pegar e colocar um parênteses por volta, porque a divisão sempre executa antes, regrinha da matemática básica. Então, olha só, a gente vai ter que fazer um cálculo no CSS aqui pra conseguir setar a largura certinho. Então, isso aqui é muito massa, eu gosto muito de fazer esses cálculos no CSS. Então, olha só, a gente vai botar aqui um MaxWidth, o padrão Width já é 100%, então, a gente só faz um MaxWidth, um cálculo, e aqui a gente vai fazer o seguinte, sem Vw, vou pegar a largura inteira da tela, menos a largura inteira da tela, de novo, menos 1180, como eu falei anteriormente, só que agora eu preciso dividir isso aqui por 2. Então, eu coloco mais um parênteses aqui por volta desse cálculo, e depois eu dou um dividido por 2. Salvo isso aqui agora, a gente volta aqui pro nosso projeto, e a gente já pode ver, teoricamente, deixa eu colocar aqui talvez um Width 100%, pra ver se ele... show! Agora a gente já pode ver que ele já aplicou aqui, ele deixou uma margem, só que essa margem ela ficou na direita. E aí, olha só, se eu jogo um MarginLeft alto, salvo, e olha só, agora eu dou um ZoomOut, cara, sensacional, né? Então, o nosso contender agora, olha só, ele tá sempre pegando a parte meio que central e o resto da parte pra direita. Eu acho que fica legal assim, tá? Mas se você achar que tem que ficar de outro formato, fica à vontade aí pra mudar, eu acho que assim é o melhor formato pra ficar. Show! O que mais que a gente tem que fazer aqui? Eu vou setar também um MinHeight, uma altura mínima, digamos assim, de 0,656, que é o que tem lá no layout, pro layout ele não ficar tão centralizado verticalmente, tão pequeno verticalmente. E agora, a gente vai estilizar aqui esse nosso footer, aqui o nosso link, pra finalizar o nosso produto, né? Então vamos começar. A gente vai jogar um Background, Linear Gradient, e dentro aqui, a gente vai usar algumas cores que elas não estão lá no nosso tema, então eu vou usar aqui a cor 1E A4 83, saindo de 0%, e ele vai até 7465 D4 no 100%. Se eu salvar isso aqui agora e voltar, já posso ver que o Gradient já foi aplicado, eu vou tirar esse Background Color Red que a gente não vai utilizar. Beleza? Já dá pra começar a visualizar, né? Vou colocar aqui um Border Radius de 8, vamos colocar aqui também um Padding de 0,25 rem, que são 4 pixels, né? Vamos colocar aqui um Cursor Pointer, eu acho que não precisa do Cursor Pointer, vai precisar sim, Cursor Pointer. A gente vai jogar aqui, precisa do Cursor Pointer porque eu não botei um href ainda no link, né? Mas não tem problema também, podemos deixar assim. Um Position Relative, porque o nosso footer depois vai estar com Position Absolute ali dentro. Vamos colocar um Display Flex, Align Item Center e Justify Content Center pra que a imagem fique centralizada. Se eu não tenho isso aqui, a imagem fica no topo, eu quero que ela esteja centralizada. Show! Já dá pra começar a ver que tá ficando legal, né? Agora, uma coisa é que a imagem, se você for perceber, ela vai ficar distorcida, tá? Porque, lembra que a gente exportou a imagem com o mesmo o mesmo tanto de largura e altura, 520x520. E aqui, a gente importou ela com 520x480. Então, uma dica que eu te dou é quando você faz isso, sempre trabalhar dentro da Tag Image aqui no CSS com a propriedade Object Fit. E assim a gente tem as várias opções. A mais legal pra mim é Cover, que ele não vai distorcer a imagem, porém vai fazer ela caber no container. Olha só, ele fez a imagem caber no container, cobriu o container certinho, porém sem distorcer. Existem outras, né? A gente pode usar o Fill, por exemplo, que ele vai preencher o máximo que ele conseguir. Cara, tem várias opções, tem o Fit. E agora, a gente vai estilizar aquele nosso footer ali pra finalizar. Position Absolute. Vou botar aqui um Bottom 0.25 Ren. Vamos colocar aqui também o Left. Opa! O Left e o nosso Right com 0.25 Ren. Vamos dar um Border Radius de 6. Display Flex. Align Items Center. Justify Content aqui. Vamos colocar um Space Between porque o preço e o nome da imagem ou o nome do produto vão ficar totalmente um pra esquerda e um pra direita. Já tá assim. E aqui a gente vai começar agora com a parte mais visual do fundo ali. Então, RGBA 0.0.0.6 0.0.0.6 que é o fundo. Vamos colocar aqui também um Padding aqui em cima de 2 Ren, porque ele tá muito pequenininho. Show! Agora já tá bem melhor. E agora, eu vou pegar o nosso Strong, que é o nosso nome do produto. Eu vou dar um Font Size. Aqui a gente acabou não criando variáveis para os tamanhos de fonte. Mas, se a gente for ver aqui no Figma, os tamanhos de fonte são meio que pré-setados. 18, 20, 24 e 32. Então, quando a gente tem valores que vão ser pré-setados, o melhor é a gente vir aqui no nosso tema e criar aqui dentro de Font Sizes por exemplo, valores comuns. Não tem como a gente fugir desses valores e colocar tamanhos de fonte que não existe, digamos assim, no Layout. Então, eu vou criar aqui alguns tamanhos. Eu vou começar com o tamanho Medium, que é o tamanho de 18 Pixels. Ele vai ser 1.125 Rem. Esse é o menor tamanho que a gente tem. O Large, que ele vai ser 1.25 Rem, que é 20 Pixels. Nós vamos ter o XL, que é 1.5 Rem, que é 24. E vamos ter o 2XL, que é 2 Rem, que é 32 Pixels. Então, eu cobri todos os tamanhos que a gente tem aqui de fonte dentro do Figma, aqui no nosso tema. Agora, aqui dentro, quando a gente for utilizar o Font Size, basta botar um sinal de Dólar. O que eu errei aqui? Ah, faltou uma vírgula aqui dentro. É só eu colocar o sinal de Dólar e ele já vai trazer para mim... Vai não? Amigo? Deixa eu ver aqui. Ele não está trazendo o autocomplete aqui no... Ah, porque eu estou em dois níveis de encadeamento. Será que é isso? Ah... Font Size... Aqui ele traz 2XL, Large, Medium e XL. Mas quando eu estou aqui dentro, Font Size, ele não está trazendo o autocomplete. Hum, estranho. Mas mesmo assim, eu vou colocar aqui e depois a gente dá uma olhadinha nisso. Aqui eu vou botar o Font Size Large. E aqui, no Span, a gente vai colocar o Font Size XL, Font Weight Bold e Color. Aqui a gente vai botar o Green 300, que é a cor que a gente tem lá no nosso sistema. Então, trocamos aqui, salvamos isso aqui e podemos ver já o footer aqui embaixo. O que falta agora para a gente finalizar essa aula, que ficou um pouquinho maior, mas não tem problema. A gente vai vir aqui, fechando o footer, nós vamos pegar e colocar um Hover aqui dentro. E nesse Hover, o que a gente quer fazer? Olha só, eu vou pegar aqui no footer, primeiramente, e eu vou adicionar nele, pode ser antes do Strong aqui, um Transform Translate Y, 110% para ele sair da tela. E vou colocar também aqui um Opacity de 0. E vou colocar também um Transition ao 0.2 segundos. Is In Out. E agora, aqui embaixo, quando eu der um Hover no nosso link, aqui no nosso produto, no A, na tag A, eu vou pegar o footer e eu vou dar um Transform Translate Y 0%, ou seja, voltar para a posição original e mudar o Opacity para 1. Então, salvo isso aqui agora, olha que legal, quando eu passo o mouse por cima, ele vem ali. Mas está vendo que dá para ver ele saindo do produto aqui atrás? Então, aqui no Product, eu vou jogar um Overflow Hidden, isso aqui deve ser suficiente para esconder ali o footer atrás. Show de bola, né? Então, agora a gente já tem aqui o Hover sendo feito em cima das camisetas, a gente só ainda não tem o carrossel, claro, e também isso aqui está tudo estático, não está vindo de API. 20 minutinhos de aula, espero que você esteja aqui comigo até o final, se você estiver aqui comigo até o final, dá um gole de água e manda um salve na comunidade, me marcando um grande abraço e valeu!"
  },
  {
    "id": "c069c62e-d41c-471c-b4c9-d488992c41c7",
    "title": "Configurando conta Stripe",
    "transcription": "O que a gente vai fazer nessa aula é configurar a nossa conta do Stripe que a gente vai estar utilizando, tanto para cadastro dos produtos quanto a parte de checkout aqui da nossa loja. Então vamos lá, a gente vai abrir aqui o site do Stripe, eu posso abrir direto o dashboard.stripe.com que na verdade é o local do dashboard. Eu já tenho uma conta, se você não tem é só se cadastrar, é bem tranquilo, não pede cartão, não pede nada. Vou dar um continuar aqui, e aí a gente vai criar um projeto do zero para visualizar. Vou aguardar um pouquinho, beleza. Aqui dentro está criada o Ignite Store, eu vou criar uma nova conta aqui dentro, porque eu quero criar do zero com você, então você vai criar essa conta no começo ali, Ignite Shop. E aí no Stripe, quando você está rodando com o modo de teste, ele não pede para você cadastrar nenhuma informação sensível, cartão ou qualquer coisa assim. Então aqui dentro, agora a gente vai começar dentro de produtos, vamos começar criando alguns produtos aqui dentro. Eu vou começar cadastrando aquelas camisetas que a gente tinha, eu já tinha exportado algumas, eu exportei essas três últimas, faltou exportar essa aqui, então o que eu vou fazer, eu vou copiar ela aqui embaixo também, e vou definir ela também com uma largura de 520, vou exportar ela também, vou chamar ela de 4, a gente já cadastrou uma, duas e três, e vou começar botando aqui, Ignite, Aulas, Ignite Shop, Assets, Camisetas, vamos pegar uma aqui, essa aqui é da Maratona Explorer, e aqui é legal a gente ter uma descrição, então o que eu vou fazer é pegar lá no site da reserva que a gente tem as camisetas da Rocket para comprar, aqui dentro meio que tem uma descrição padrão, deixa eu pegar essa aqui, é engraçada essa descrição, então eu vou botar essa descrição aqui mesmo, e aqui agora a gente vai colocar os preços, então aqui é uma única vez, não é recorrente, R$ 79,90, vou botar essa camiseta, sei lá, vou botar qualquer preço, e aqui está finalizado, a gente vai para o próximo, vou clicar em salvar e adicionar, vamos carregar aqui a próxima, essa aqui é do camiseta Igniter Abort, e vou colocar a mesma descrição, preço aqui eu vou botar só R$ 89,90, só para a gente ter alguns preços diferentes, para não ficar tudo igual e a gente ver a diferença, salvar e adicionar, vamos cadastrar a próxima, camiseta Ignite Lab, vou botar só R$ 69,90, uma única vez, salvar e adicionar, por último, essa aqui, camiseta Maratona Explorer 2.0, vou botar R$ 74,90, uma única vez, e salvar o produto agora. Com os nossos 4 produtos cadastrados aqui já, a gente vai precisar agora usar, digamos listar esses produtos lá na nossa aplicação, e aí aqui do lado tem desenvolvedores, a gente clica aqui dentro e a gente tem todo o painel de desenvolvimento aqui do Stripe, e aqui em chaves de API, a gente tem as nossas chaves que a gente vai estar utilizando aqui para fazer as nossas requisições, então aqui eu vou precisar, primeiramente, eu vou copiar essa chave aqui, que é a chave pública, e aí aqui dentro do meu projeto, eu vou salvar ela como uma variável ambiente, se você ainda não sabe o que são variáveis ambientes, variáveis ambientes são aquelas variáveis que a gente quer que o valor delas mudem de acordo com o ambiente da nossa aplicação, então em desenvolvimento, por exemplo, o valor dessa variável vai ser um, em produção vai ser outro, e também são variáveis que a gente vai manter secretas, que elas não vão para o GitHub ou qualquer coisa assim, então aqui no Next, para eu criar variáveis ambientes, eu uso .env e .local, e aí aqui eu vou criar, vou salvar só o valor dessas duas variáveis, então eu nem preciso, eu vou criar aqui, public, underline key, e jogo o valor, e aqui embaixo eu pego a chave secreta, eu vou criar como secret, underline key, e aqui eu vou botar só um prefixo Stripe, underline na frente, para a gente não se perder e saber o que é Stripe, inclusive eu posso colocar um comentário, é aconselhável, eu vou botar Stripe, aí a gente salva todas as variáveis aqui dentro. Pronto, agora a gente já está com a nossa conta do Stripe configurada, já estamos com as nossas variáveis aqui, ambiente com as chaves, e agora a gente já pode começar a fazer requisições para a API do Stripe, para começar a listar os produtos."
  },
  {
    "id": "442e5c31-cf6c-4c34-9994-b9e2fc944383",
    "title": "Criando rotas da aplicação",
    "transcription": "Nessa aula a gente vai entender um pouquinho como que funcionam as rotas dentro de uma aplicação Next. E se a gente for dar até uma olhada no layout que a gente vai estar desenvolvendo ao longo dessa aplicação, que tem a Home, onde vão estar listados aqui os itens que o usuário pode realizar a compra. Porém, quando ele clicar em um desses itens, ele vai para uma página interna, que é a página do produto. Então, imagine que para acessar essa página, por enquanto, provisoriamente, eu vou pensar que a gente tem uma página chamada simplesmente barra product. No Next, uma das coisas mais legais é algo que a gente chama de File System Routing. Se a gente for traduzir para o português, é um roteamento baseado em arquivos físicos. E aí, o que isso quer dizer? É, se eu quero criar uma página que ela vai ser acessível quando o usuário botar barra product, é só eu criar dentro da pasta pages um arquivo chamado product.tsx. E aqui de dentro, eu simplesmente exportar por default um componente, o nome tanto faz, e dentro eu boto o que eu quiser. Só de salvar isso aqui e voltar aqui para a nossa página, dando um F5, eu posso ver que a página já começa a funcionar. Isso quer dizer com que todo arquivo que eu criei dentro da pasta pages, ele automaticamente vire uma rota, menos alguns arquivos específicos que o Next provê para a gente, como é, por exemplo, esse app que logo a gente vai falar sobre ele. Mas, aqui então, o nosso índex é a home, a nossa página de produto é product, e a gente pode ter, por exemplo, mais uma página, que a gente pode ver que ela existe, que é essa página aqui de compra efetuada com sucesso, eu vou chamar ela de success.tsx, e eu vou colocar aqui simplesmente escrito success dentro do h1 e no nome do componente. Se eu acesso o success aqui agora, eu posso ver que já aparece para mim aqui o h1 com o success. Porém, ainda que a gente tenha aprendido que todo arquivo tsx ou js aqui dentro da pasta pages vire uma rota, existem rotas dentro da nossa aplicação que a gente vai precisar receber parâmetros. Por exemplo, aqui na rota de produto eu vou precisar saber qual produto o usuário clicou, e geralmente isso na web a gente faz um parâmetro na rota, então é barra product, barra algum id ou alguma coisa que traga a informação sobre aquele produto, então aqui eu vou começar com um id, então imagina que a gente receba barra product, barra 1, por exemplo, e esse 1 aqui significa o id do produto. Nesse caso a gente pode ver que ele retornou 404, porque o next não vai entender automaticamente que isso aqui é um parâmetro, na verdade ele vai passar a procurar por alguma rota que tenha um nome de componente que tenha 1 no nome, só que não tem nenhum, na verdade o componente aqui é product. E para isso, para quando a gente vai trabalhar com parâmetros, a gente pode fazer algo bem legal, mas uma outra coisa que eu quero te mostrar, que é muito interessante aqui, é que a gente pode criar subpastas aqui dentro da pasta pages, então se eu tenho uma pasta, por exemplo, product, e eu trago esse arquivo product que eu tenho aqui, aqui para dentro, porém agora eu mudo o nome dele para index, veja que quando eu acesso a rota product, eu continuo mostrando o h1 product que eu tenho aqui dentro, porque como esse arquivo agora, index, está dentro de uma pasta product, basicamente ele virou o arquivo principal, a home, digamos assim, do nosso subendereço chamado product. E agora se eu tiver um outro arquivo aqui dentro, por exemplo, test.tsx, e dentro dele aqui eu vou simplesmente escrever test, se eu acessar a barra product, barra test, agora a gente vai acessar esse arquivo aqui, ou seja, eu tenho uma pasta product que virou essa parte aqui do endereço, e esse arquivo test aqui que está dentro da pasta product virou essa parte aqui do endereço. Mas a parte mais incrível disso tudo, voltando para o que eu queria mostrar antes, se eu tivesse um id aqui, barra product, barra 1, por exemplo, é que o nome dos meus arquivos, eles podem ser parametrizados. Então se eu trocar o nome desse arquivo index aqui, simplesmente por coxete, abre e fecha, e dentro o nome do parâmetro que eu espero receber, por exemplo, um id, veja que agora quando eu acesso o product, barra 1, ele cai automaticamente dentro dessa página de produto. Por quê? Porque ele entende, estando dentro da pasta product, que é essa parte do endereço, e tendo um arquivo aqui dentro que tem os coxetes, ele vai entender que qualquer coisa que eu digite aqui, depois de product, ele deveria cair nessa rota, é como se fosse uma rota wildcard, que ela vai receber vários tipos de endereços, e tudo que vier depois da barra vai ser adicionado aqui no parâmetro id. E aí aqui dentro eu posso pegar o valor desse parâmetro, utilizando, de dentro do next, deixa eu digitar aqui e ver se ele vai pegar automaticamente, é useRotor, que vem do nextRotor, só que ele não está conseguindo fazer a importação automaticamente, então eu acho que eu já sei o que é, mas a gente pode escrever aqui, que que deu com o meu VS Code, está tão lento, useRotor, loading, meu VS Code ficou um pouco lento, às vezes ele dá uma bugada, bom, é aqui, basicamente lá dentro do nosso tsconfig, esse nosso module, a gente precisa passar um module resolution como sendo node, veja se na sua instalação também vai precisar, talvez já esteja corrigido, mas no momento que eu estou configurando esse projeto next, essa configuração precisa ser adicionada. E aí a gente volta, já volta aqui a funcionar. E aí usando esse hook useRotor, que vem de dentro do next, eu tenho acesso aqui aos nossos params, que estão dentro do objeto chamado query, que vem de dentro desse useRotor. E se eu mostro esse query aqui em tela, então só para ficar mais fácil aqui, eu vou mostrar via json.stringfile.query, a gente salva, eu posso ver que aqui dentro vem o meu id, como sendo 1, que é o id que eu digitei lá em cima. Se eu trocasse aqui para qualquer outra coisa, ele iria trazer exatamente o que eu digitei aqui em cima, como sendo o meu id desse produto. E aí eu posso utilizar esse id que veio de dentro desse query, para buscar um produto específico lá de dentro da minha API. Mas basicamente é assim que funcionam as rotas, e é legal dizer que eu posso ter vários níveis de subpastas aqui dentro, quantas vezes eu quiser. Então a gente consegue ter estruturas bem complexas de páginas aqui dentro do next, usando esse sistema de file system routing dele aqui."
  },
  {
    "id": "c67d4c45-5f8b-4850-a13c-468e72bdf02f",
    "title": "Aplicando o useCallback",
    "transcription": "No React, como eu falei já anteriormente, toda variável ou toda função que a gente cria no corpo de um componente, aquilo é recriado do zero sempre que aquele componente renderizar. E isso não necessariamente é o problema, como eu já falei. Isso não vai deixar a sua aplicação simplesmente mais lenta porque ele está recriando aquilo do zero toda vez. Mas, em alguns casos, isso causa um problema de igualdade referencial, que é o que a gente está tendo aqui agora. Então, no caso desse nosso contexto de transactions, essa função createTransaction, como ela está sendo ouvida, observada, por um outro componente que é o newTransactionModal. E esse componente aqui a gente quer evitar que ele renderize, porque a função createTransaction não mudou entre uma renderização e outra. Nesses casos, a gente pode usar uma função que vem de dentro do React, um hook, na verdade, que se chama useCallback. O useCallback, o que ele vai fazer? Ele vai evitar com que alguma função seja recriada em memória, se nenhuma informação que aquela função dependa, digamos assim, tenha mudado. Então, como é que eu faria isso? Eu vou comentar, ou a gente até aproveita aqui, eu vou, na verdade, trocar isso aqui por uma constante, createTransaction, mudo aqui para igual e boto aqui uma arrow function. Essa função precisa ser assíncrona, por isso copio o conteúdo aqui da função em si e coloco um useCallback por volta. E o useCallback vai receber como parâmetro a nossa função em si, e o segundo parâmetro vai ser o array de dependências. Deixa eu salvar aqui para ele atualizar o linting. Esse array de dependências funciona assim como no useEffect. O que eu passar para esse array de dependências, variáveis ou qualquer coisa assim, é o que vai fazer essa função ser recriada em memória. Se o meu array de dependências for vazio, essa função aqui nunca vai ser recriada em memória. Mas cuidado, se essa função aqui estiver precisando, ela precisar de alguma informação que venha de fora dela, por exemplo, a lista de transações ou qualquer outra coisa que venha daqui de fora, eu preciso colocar essa informação que vem de fora aqui no array de dependências. Senão, quando o usuário executar essa função, essa informação que vem aqui de fora vai estar com o seu valor desatualizado, o valor original, digamos assim, antes de qualquer modificação pelo usuário. Show? Vamos salvar isso aqui agora e vamos testar. Só com essa alteração do useCallback. A gente vai atualizar o projeto. Vamos limpar aqui. Vou escrever aqui, desenvolvimento. Clico aqui em gravar, buscar, pronto. Voltamos aqui, vamos para o último commit aqui. E agora, clicando aqui em New Transaction Modal, a gente vai ver que agora o motivo de renderização do New Transaction Modal não é mais porque o contexto mudou. Lembra que antes era esse o problema que a gente estava tendo. O motivo dele renderizar agora é porque o componente pai renderizou. Ou seja, a gente mudou a motivação desse componente renderizar. E por mais que pareça que isso vai acabar não dando muito efeito, é claro, essa aplicação é pequena. Realmente não vai dar muito efeito, não vai mudar muito a questão de performance. Mas a gente está aprendendo como que a gente evita certas coisas renderizarem. E aí tu vai me falar, pô Diego, mas tá, esse componente aqui renderizou porque o pai desse componente renderizou. Não tem como eu evitar isso, que um componente renderize só porque o componente pai renderizou? Tem, a gente vai ver isso ainda. O ponto é, nem sempre vale a pena, mas eu vou te explicar isso aqui com o tempo. O que eu vou fazer aqui agora é, como essa função FetchTransactions também é uma função que a gente tem aqui dentro do contexto e ela é uma função que a gente acaba observando ela aqui no search form. Pra eu fazer o search form aqui evitar, posso vir aqui na renderização, search form, cadê o nosso aqui, search form. Ele foi renderizado de novo porque o contexto mudou, o hook1 mudou. Se eu colocar aqui o useCallback também nessa função. Agora com isso, olha só. Atualizamos aqui. Desenvolvimento. Busca. Agora a gente vai ver que o search form não foi mais renderizado por causa que um hook mudou, porque o contexto mudou. E sim porque o componente pai mudou. E aí a gente vai ver como a gente pode evitar isso também, caso a gente precise, que não são todos os casos."
  },
  {
    "id": "c274641e-a389-4622-bd9e-f4a4c79ed208",
    "title": "Aplicando o memo",
    "transcription": "Pra gente aprender a próxima funcionalidade do React, a gente precisa entender um pouquinho como é que funciona o fluxo de renderização de um componente no React. Então o que é que acontece? Aqui a gente está vendo que o componente SearchForm, por exemplo, ele está renderizando de novo porque o componente Pie dele foi renderizado. Deixa eu abrir aqui o SearchForm e colocar aqui alguns comentários pra gente entender algumas coisas. Primeiro, por que um componente renderiza? Tem três motivos. FluxChanged, ou seja, mudou o estado, mudou o contexto, mudou um reducer, qualquer coisa assim. PropsChanged, mudou propriedades, não tenho nem o que falar, ou ParentRendered, então o componente Pie renderizou e aí o componente Filho vai renderizar também. Isso aqui são os três motivos de por que um componente renderiza. E aí, qual o fluxo de renderização? Porque renderizar não é necessariamente o componente ser reescrito, ser reprocessado do zero em tela, não é isso. Na verdade, o fluxo de renderização tem três passos. Primeiro, o React recria o HTML, digamos assim, da interface daquele componente. Então, nesse caso do SearchForm, por exemplo, quando o componente Pie dele mudou e agora isso aqui acaba gerando uma renderização novamente do SearchForm, o primeiro passo que o React faz com o SearchForm é recriar o HTML da interface dele, ou seja, ele vem aqui e recria isso aqui, claro, não na DOM mesmo, ele recria, digamos, na memória. E aí, o que ele faz? Compara a versão do HTML recriada com a versão anterior, ou seja, o React compara essa nova visualização do SearchForm com a anterior. E aí, no final, se mudou alguma coisa, ele reescreve o HTML na tela. Então, o fluxo de renderização do React funciona dessa forma, são três passos. Isso aqui é extremamente rápido, por isso que eu digo que nem sempre vale a pena a gente ficar tentando evitar renderizações no React. Agora, pensa comigo, se um componente meu tem um HTML muito grande, muito grande mesmo, imagina que aqui dentro, por exemplo, desse componente do SearchForm, imagina que eu percorresse uma lista de, sei lá, 200 itens e isso acabasse gerando um HTML bem grande. Essa comparação aqui, da versão do HTML recriada com a versão anterior, ela iria ficar bem lenta, porque o React teria que comparar cada coisinha, cada detalhe ali dentro pra ver se tá tudo igual ou não. Ou seja, quanto maior o componente, no quesito o que ele retorna, mais a gente pode ter problema com essa questão de lentidão no fluxo de renderização. E aí, somente nesses casos, a gente deve e a gente pode olhar pra utilizar um carinha que vem de dentro do React, que se chama Memo. O Memo é uma função que a gente usa em componentes do React pra gente conseguir memorizar aquele componente. O Memo nada mais é do que o seguinte, quando o React entra nesse fluxo aqui, e o componente usa o Memo, e eu já vou mostrar o que é usar o Memo, esse fluxo acaba mudando um pouquinho. Antes de fazer esse fluxo aqui, existe o passo zero, digamos assim, ele vai adicionar um passo a mais antes desse fluxo aqui. O Memo vai olhar o seguinte, mudou alguma coisa nos hooks do meu componente? Ou mudou alguma coisa nas props do meu componente? E aqui ele faz algo que a gente chama de Deep Comparison, ou seja, ele vai olhar de forma profunda pros hooks e pras propriedades desse componente, comparar, passo 0.1, comparar com a versão anterior dos hooks e props, e aí, se mudou algo, ele vai permitir a nova renderização. E aí, cai aqui pra esse fluxo que a gente já conhecia. Porém, se não mudou nada, ele nem vai entrar nesse fluxo aqui de recriar o HTML, que pode ser algo pesado. Lembrando que a gente só vai usar isso aqui em componentes que tem realmente um HTML bem pesado. E aí, como é que a gente faz pra utilizar o Memo? A gente vai fazer o seguinte, a gente vai parar de exportar o componente aqui em cima, eu vou dar um nome um pouquinho diferente pra esse componente, eu vou chamar ele de SearchFormComponente, por exemplo, e aqui embaixo eu dou um ExportConst SearchForm, que era o nome original, igual a Memo, passando o meu SearchFormComponent, que a gente criou ali anteriormente. Então a única coisa que eu preciso é colocar o Memo aqui por volta, tá? Salvo isso aqui agora, a gente vai voltar aqui pro Chrome, e a gente vai fazer o teste. Olha só, vou limpar aqui, desenvolvimento, boto pra gravar, buscar, paro de gravar, venho no último commit, e veja só, agora o meu SearchForm não renderizou de novo. A gente pode ver que ele tá cinza, ele não renderizou de novo, porque, como eu coloquei o Memo, ele percebeu que o meu hook não mudou, que as minhas props não mudaram aqui nesse componente, e com isso, se não mudou nada, ele nem entrou nesse fluxo de renderização do React. E aí, novamente, você pode passar na sua cabeça em algum momento, Diego, eu vou jogar o Memo em todos os componentes da minha aplicação. Não faça isso, por quê? Essa comparação, pra ver se os hooks mudaram, e se as props mudaram, ela pode acabar sendo mais lenta, muitas das vezes ela vai ser mais lenta, fazer essa comparação, do que recriar o HTML do zero, e fazer essa comparação aqui de cima. Então pro React, e não só pro React, pro JavaScript no geral, muitas das vezes é mais custoso fazer uma comparação profunda, principalmente se as propriedades e os hooks do componente aqui são complexos, estruturas de dados complexos, é mais custoso fazer isso aqui do que necessariamente comparar uma versão de HTML do componente. Então por isso que a gente evita utilizar o Memo em componentes que simplesmente são simples pra caramba, como é o caso desse componente aqui. A gente só vai utilizar o Memo realmente em componentes que tem interfaces bem complexas, cheio de condicionais, repetições, listas e por aí vai. Então nesse caso aqui, como eu falei, nem vale a pena por isso, eu nem vou colocar o Memo aqui, vou deixar o nosso search form mesmo, mas pelo menos a gente já sabe quando e como a gente pode utilizar essa funcionalidade."
  },
  {
    "id": "53996221-243b-4322-a3d0-5e32ef298a23",
    "title": "Calculando resumo de transações",
    "transcription": "O que a gente vai fazer nessa aula é calcular o resumo de entradas, saídas e o total, aqui no final, baseado nas transações que a gente carregou. Para a gente fazer isso, é importante que você cadastre no seu JSON Server, pelo menos uma transação de entrada e uma transação de saída. Senão, não vai ter resultado nenhum aqui, praticamente, porque a gente não vai conseguir fazer cálculo nenhum. Então, vamos lá. O que a gente vai fazer? Primeiro, aonde eu vou fazer esse cálculo do resumo? Tem várias possibilidades. Uma delas, por exemplo, é eu fazer esse cálculo aqui mesmo, dentro do meu contexto. Eu poderia vir aqui, criar uma variável, por exemplo, summary, e dentro dela ter o resumo, aqui, de entradas, saídas e o total. Só que eu sempre tenho que me perguntar, antes de colocar uma informação no contexto, essa informação é importante para mais componentes ou para um único componente da minha aplicação? E aqui a gente pode ver que não faz muito sentido esse cálculo estar dentro do contexto, porque, na verdade, só essa parte aqui da aplicação precisa dos dados do resumo. O restante, como a lista de transações, ou até a parte de nova transação, nada disso vai realmente precisar do resumo aqui de transações. Então, por enquanto, o melhor lugar para a gente colocar isso é aqui, no próprio componente summary. Então vamos lá, como é que a gente vai fazer aqui? Eu vou começar criando uma variável chamada summary, e aqui eu vou fazer o seguinte, eu vou utilizar um método que muita gente tem medo de utilizar aí, que é o reduce. O método reduce, se você não conhece, ele é basicamente um método que permite a gente percorrer um array e reduzir esse array a alguma nova estrutura de dados. Nesse caso, eu quero converter o meu array de transactions num objeto que vai seguir a seguinte estrutura. Ele vai ser um objeto que vai ter income, o total de entradas, outcome, o total de saídas, e total, que é o número de entradas menos o valor de saída. O valor de entrada menos o valor de saída. Ou seja, eu quero reduzir o meu array de transactions a essa estrutura de dados. Então a minha sintaxe precisa ser da seguinte forma, eu vou passar uma função como primeiro parâmetro, e o segundo parâmetro é, digamos, a estrutura de dados inicial que eu vou começar. Então é basicamente isso aqui. Eu vou copiar esse objeto e vou colocar aqui no segundo parâmetro. Aqui eu posso quebrar algumas linhas para ficar mais fácil a gente visualizar. Então eu vou dar um enter aqui, um enter aqui, um enter aqui. Eita, Giovana aqui, um enter aqui, um enter aqui. E show de bola, a gente já tem aqui. É claro que o TypeScript vai começar a dar alguns erros aqui, por quê? Porque aqui de dentro dessa função, eu vou receber dois parâmetros. Eu vou receber o resumo atual, digamos assim. Então aqui geralmente a gente chama de accumulator dentro do reduce. Eu poderia usar também summary aqui, mas como está sendo já usado fora, acho que confundiria um pouco. Então eu vou utilizar o accumulator mesmo. O accumulator nada mais é do que esse objeto aqui. E aos poucos eu posso ir modificando a propriedade dele, aumentando o income, aumentando o outcome, aumentando o total e por aí vai. Então todas as operações dentro do reduce eu vou fazer no accumulator, que é o que vai ser retornado aqui no final. E aqui eu recebo cada transaction. E aí aqui dentro, até para parar os erros do TypeScript, eu posso simplesmente retornar o meu accumulator. E agora aqui em cima eu preciso fazer as operações com o meu accumulator. Então o que eu vou fazer? Se a minha transaction.type for igual a income, eu vou pegar o accumulator income e vou somar com o transaction.price. Se não, eu vou pegar o accumulator outcome e vou somar com o transaction.price. Assim, cada iteração aqui que vai acontecer na minha lista de transações, ela vai aumentando o income e o outcome do meu accumulator, que no caso é o meu summary aqui, aumentando o valor de income e outcome dele. O total eu ainda não estou carregando. Então o que eu tenho que fazer? Quando for uma entrada, eu vou aumentar o total com o preço da transação. Quando for uma saída, eu vou diminuir o total usando o preço da transação. E agora aqui embaixo, no lugar dos valores aqui, por enquanto eu não vou fazer a formatação, eu vou simplesmente jogar summary.income. Aqui nas saídas eu vou jogar o summary.outcome e aqui no total, summary.total. Eu salvo isso aqui agora, volto no Chrome, vou dar um F5 aqui e a gente já pode ver que ele já mostrou o total de entradas, 14.000, o total de saídas, 60.000 e o valor final, 13.940. Se a gente for lá no nosso server.json e cadastrar aqui mais uma saída, então tinha hambúrguer aqui, eu vou botar Ignite, Rocket City, Price, não, brincadeira, não vou colocar isso aqui não, vou botar, sei lá, 1980, Category, Educação, eu vou deixar como Outcome, o ID eu vou botar 3, a data aqui tanto faz, vou botar 19, 24. Vou salvar isso aqui agora, e agora quando eu dou um F5 aqui, a gente pode ver que o cálculo já deu certinho, 1980 mais 60, 2.040, 14.000 menos 2.040, 11.960. Então a gente já estava calculando aqui o resumo de entradas e saídas e mostrando aqui. É claro que nada formatado ainda, mas aos poucos a gente vai melhorando."
  },
  {
    "id": "ec17e479-870c-40e1-9a42-d4e9c8a852d5",
    "title": "Configurando JSON Server",
    "transcription": "Durante aqui o nosso projeto do DeepMoney, a gente vai precisar consumir uma API. Até porque um dos focos desse projeto é a gente aprender a utilizar a API de Fetch do navegador pra fazer comunicação de um front-end com um back-end. Independente da linguagem que esse back-end seja criado. Mas a gente vai estar seguindo aqui um padrão de uma API RESTful, beleza? E aqui, como a gente não tem um back-end pra esse projeto, a gente não criou um back-end em nenhuma outra linguagem, a gente está fazendo aqui especificamente o projeto em React, a gente precisa de alguma ferramenta que permita a gente ter, pelo menos, a simulação de um back-end pra gente começar a testar. E o JSON Server, pra mim, é uma das melhores opções que a gente tem atualmente. E se você não conhece o JSON Server, é um projeto muito famoso, tem mais de 60 mil stars aí no GitHub atualmente. E, basicamente, o que esse projeto aqui faz é, a partir do arquivo JSON, ele cria uma API completa pra gente. E quando eu digo completa, é completa mesmo. Porque ele permite a gente criar rotas, fazer filtros, paginação, ordenação, conseguir, na paginação, cortar um pedaço, fazer operações, full-text search, relacionamentos. A gente consegue armazenar esses dados. Cara, tem muita coisa que dá pra fazer com o JSON Server em si. E eu vou te mostrar como que a gente faz isso. Então, a gente vai começar instalando o JSON Server. Eu vou instalar ele como uma dependência de desenvolvimento. Com o JSON Server já instalado, eu vou criar um arquivo aqui na raiz do meu projeto, chamado server.json. Dentro desse server.json, eu vou começar criando um objeto. E pra cada propriedade que eu passo nesse objeto, vai ser uma rota da nossa aplicação. Ou a gente pode pensar, na verdade, como cada propriedade que eu passo pra esse objeto é uma entidade da minha aplicação. Então, uma entidade a gente pode pensar como se fosse uma tabela do banco de dados. Então, imagine que eu tenha, por exemplo, uma tabela de transactions, onde eu posso ter várias transações sendo adicionadas aqui dentro. Como são várias transações, eu coloco um array pra ser retornado. E aqui, por enquanto, eu não vou inserir dados, porque eu quero te mostrar com mais calma. Mas é importante lembrar que o JSON Server vai ser ótimo pra gente durante o desenvolvimento, mas em produção a gente não vai conseguir utilizar ele. Ele é um projeto pra gente conseguir, digamos, construir a nossa interface front-end, sem depender que o nosso back-end esteja pronto. Porém, já deixando o React com tudo pronto pra fazer o consumo de uma API que possa vir no futuro, assim que a gente for colocar o nosso projeto em produção de verdade. E aí, assim que a gente ataca esse arquivo server.json, e eu já tenho o JSON Server instalado aqui no meu projeto, eu posso rodar um npx.json.server e passar o nome do arquivo. No nosso caso, server.json. Quando eu dou um Enter aqui agora, address already in use. Por padrão, ele vai tentar subir o JSON Server na porta 3.000. O que eu vou fazer é passar um \"-p 33 33\", pra ele subir o JSON Server na porta 33 33, que também está em uso. Aí me ferrou, né? Deixa eu ver o que está rodando na porta 33 33 aqui. Eu acho que eu deixei rodando uma aplicação Node e eu não fechei. Então, deixa eu fechar aqui essa aplicação Node que eu estava rodando. E agora sim. Vou rodar o JSON Server na porta 33 33. E agora, se eu acesso aqui ao localhost 33 33 no navegador, a gente pode ver que ele não retorna nada. Porém, se eu acesso com barra transactions, ele vai retornar um vetor. Esse vetor é exatamente o que eu estiver retornando aqui dentro. Por exemplo, se eu venho aqui e coloco um objeto pra representar uma transaction, vou colocar um id. É legal que toda instância de alguma entidade tenha um id, numérico e incremental. E aqui eu vou começar colocando, por exemplo, a primeira transaction vai ser desenvolvimento de site. O tipo dela, se é uma entrada ou uma saída. Eu vou colocar entrada, então vou botar income. Ela tem uma category, venda, que é exatamente os campos que a gente tem naquela tabela de listagem de transactions. A gente tem também um preço, o valor, sei lá. Aqui eu posso botar um número diretamente, vou botar 14 mil. E a gente tem created at, que eu vou seguir esse padrão de QML Case, mas aqui eu vou precisar passar uma data. Por padrão, o JSON não suporta que a gente escreva datas no JavaScript mesmo. O JSON não tem suporte. Então eu vou ter que mandar a data como uma string. E aí uma dica que eu posso dar pra você, pra colocar a data certinho, é abrir aqui um inspecionar do seu navegador. Veja aqui no console. Escrever new date. E aí você dá um ponto toIsostring. Esse toIsostring vai retornar a data já num formato que o JavaScript entenda, inclusive com o timezone, pra você reaproveitar isso depois. Mas se você mandasse também só 2022, 07, 13, 00, isso aqui iria funcionar também, mas eu prefiro já mandar nesse formato aqui. E aí quando a gente salva isso aqui, e eu venho aqui no navegador DOMF5, a gente vai ver que ele não retorna nada. Porque por padrão, o JSON Server não fica monitorando esse arquivo aqui do server.json pra ver se ele mudou e mostrar as informações atualizadas. Se eu quero fazer esse funcionamento, eu preciso, aqui quando eu rodo o comando, passar um \"-w\". E esse \"-w\", agora, é um modo watch. Então ele vai ficar observando as mudanças e vai atualizar o servidor. Agora se eu venho aqui DOMF5, olha só. Ele já apareceu aqui a nossa transaction de desenvolvimento de site. E agora, se eu cadastro mais uma transaction com id2, e aqui eu vou botar hambúrguer. O tipo dela vai ser Outcome, a categoria Alimentação. E eu vou botar um valor aqui de, sei lá, 50. Hambúrguer caro pra caramba, mas é isso aí. Botar a data aqui, só mudar um minuto. Botar um pouquinho mais cedo, na verdade, um pouco antes do desenvolvimento de site aqui. Se eu salvo isso aqui agora e venho em DOMF5, olha, já tá aqui. Então não preciso ficar atualizando lá o JSON Server. E lembra que eu falei que o JSON Server é uma ferramenta muito poderosa? Porque olha só, o JSON Server não é só algo pra listagem. A gente consegue criar uma API completa. Eu posso criar novas informações, se eu fizer uma requisição POST aqui HTTP nessa rota. Eu consigo criar uma nova transaction, eu consigo atualizar transactions já existentes pelo ID. Consigo deletar transactions. Consigo listar uma transaction específica, por exemplo, se eu quero listar apenas essa transaction do desenvolvimento do site, basta eu colocar a barra 1 aqui e ele traz somente essa transaction. E eu consigo também fazer ordenação e tudo mais. Olha só, vamos procurar aqui como, por exemplo, eu faço um filtro. Então, pra fazer um filtro, eu preciso utilizar o ponto de interrogação, o nome da propriedade, por exemplo, o type e o valor. Eu quero procurar apenas transactions em que o type for income. Não enter e pronto. Ele trouxe apenas o desenvolvimento do site. Se eu trago outcome, ele traz apenas o hambúrguer. Eu consigo ordenar também. Então posso tirar isso aqui e agora eu venho aqui e falo, olha, eu quero ordenar isso aqui pela data de criação, pelo created at. E agora a gente pode ver que o hambúrguer veio antes do desenvolvimento do site porque ele faz, por padrão, a ordem crescente. Se eu quero fazer a ordem decrescente, eu posso passar aqui mais um parâmetro, order igual a desk. E aí ele faz decrescente. E, novamente, a gente consegue fazer muitas outras coisas. A gente pode fazer, inclusive, uma full text search, que é basicamente uma busca por texto em todos os campos aqui dos nossos registros. Então se eu escrevo venda, por exemplo, ele vai procurar porque aqui tem venda. Se eu escrevo site, ele vai procurar porque aqui tem site. Se eu escrevo só ham de hambúrguer, ele vai trazer porque esse aqui tem hambúrguer. E por aí vai. Eu posso ir testando. Então o JSON Server é uma API completinha. E ele é ótimo para o momento que a gente está desenvolvendo um front-end e a gente ainda não tem o back-end, isso acontece muito no dia-a-dia no mercado de trabalho, a gente já pode ir deixando o React preparado para consumir uma API assim que ela for ao ar. E uma das features que eu gosto de habilitar aqui no JSON Server também para deixar tudo mais realista é a feature de delay. Então eu dou um \"-d 500\", e ele vai adicionar 500 milissegundos de delay em todas as requisições. Agora a gente pode ver que não interessa qual requisição eu faço no JSON Server, eu vou dar um enter, ele demora 500 milissegundos para responder. Isso é ótimo porque quando a gente desenvolve com uma API em localhost, muitas das vezes a gente não tem delay, o delay é muito baixo. E a gente acaba não vendo como vai ficar realmente a nossa interface na hora que ela estiver em produção e estiver ali com um mínimo de latência. Então com o delay a gente lembra de colocar os estados de loading, a gente consegue lembrar de desabilitar um botão, por exemplo, na hora de fazer uma inserção para o usuário não ficar clicando mil vezes naquele botão e disparando mil requisições. Então tem muita coisa que a gente pode fazer. E aqui só para a gente lembrar desse comando, uma das coisas que eu vou fazer aqui é copiar o comando inteiro, sem o npx, venho aqui no meu package.json e vou criar aqui um novo script chamado dev2.server. Jogo aqui o comando do JSON Server, quando eu rodo ele por dentro do package.json, não é necessário passar o npx, apesar de que é opcional. Eu salvo isso aqui agora, e agora quando eu rodo npm run dev2.server eu vou ver que ele já começa a rodar o nosso servidor. E a gente vai utilizar bastante o JSON Server ao longo das próximas aulas e a gente vai vendo o poder dessa ferramenta."
  },
  {
    "id": "c3ad8b09-e574-43cf-b766-abb27a264164",
    "title": "Introdução",
    "transcription": "Fala, galera! Beleza? Bem-vindo a mais um módulo aqui do Ignite na trilha de React. E nesse módulo, o nosso principal objetivo é a gente falar sobre consumo de APIs. E a gente vai começar a entender como que a gente faz requisições entre um front-end e o back-end da nossa aplicação utilizando o React. E uma das coisas também que a gente vai bater muito nesse módulo é sobre performance. A gente vai conhecer sobre as funcionalidades do React voltadas a performance e também algumas bibliotecas que a gente pode utilizar. E até ferramentas para medir performance e entender como que os nossos componentes estão se comportando, dadas as atualizações. E vai ser muito massa. O projeto que a gente vai desenvolver aqui... Deixa eu abrir meu Figma. O projeto, então, é esse aqui. É o DT Money. Ele é um projeto que a gente já tinha desenvolvido anteriormente, mas agora ele está com um novo visual e com novas funcionalidades. A ideia desse projeto é basicamente um controle financeiro que a gente tem entradas e saídas e um cálculo aqui de total. A gente consegue cadastrar novas entradas, saídas, fazer buscas, filtros. A gente vai trabalhar novamente com formulários. A gente vai trabalhar também bastante com acessibilidade dentro desse projeto. Conhecer um pouquinho bibliotecas que a gente pode utilizar para melhorar a acessibilidade da nossa aplicação. E aqui tem também a modal de transação. Aqui a gente vai aprender um pouquinho mais a fundo como lidar com campos que não são nativos do HTML dentro de formulários, como é o que a gente está fazendo aqui com esse form tendo entradas e saídas, um campo de entrada e saída. E basicamente o projeto é esse. Aqui embaixo também tem uma versão mobile caso você queira adaptar depois o projeto para rodar também dentro do mobile ou criar o responsivo. Não é algo que a gente vai focar tanto no desenvolvimento desse projeto em si. Mas é isso, espero que você curta e bora codar junto. A gente tem bastante aula aí pela frente. Tamo junto? Bora lá!"
  },
  {
    "id": "ffb997ab-7791-4d22-9c7c-f9bbb203e869",
    "title": "Aplicando o useMemo",
    "transcription": "Nessa aplicação, a gente entendeu que eu posso utilizar o useCallback para evitar que alguma função seja recriada em memória quando ela não precisar ser recriada em memória. E aqui, inclusive, como eu utilizei o useCallback dentro dessa função FetchTransactions, o React pede que eu coloque essa FetchTransactions aqui como uma dependência do useEffect. E não tem problema nenhum, tá? Como essa função FetchTransactions não tem nenhuma dependência, ela nunca vai ser recriada, isso não vai fazer com que meu useEffect dispare mais vezes. Ele vai disparar uma única vez, porque a FetchTransactions só está sendo criada uma única vez. Mas tudo bem, o ponto dessa aula nem era esse. A questão é que a gente aprendeu como evitar que funções sejam recriadas em memória. Mas a gente não aprendeu como a gente pode evitar que variáveis sejam recriadas em memória. E para o mesmo caso de uso de funções, a gente não vai fazer isso com todas as variáveis da nossa aplicação, pelo mesmo motivo que eu acabei de explicar do memo. Muitas das vezes é mais performático a gente recriar aquela variável em memória do que necessariamente ficar comparando duas versões daquela variável para ver se mudou alguma coisa. Então, muitas das vezes é melhor a gente deixar que as variáveis sejam recriadas em memória mesmo. O único problema de variáveis sendo recriadas em memória é caso aquela variável seja usada, seja repassada para vários outros componentes e assim a gente cai naquele problema de igualdade referencial. Porque por mais que a variável não tenha mudado o seu valor, quando ela é recriada, ela ocupa um novo espaço na memória e com isso o React acaba renderizando novamente componentes que talvez não precisassem ser renderizados, porque na verdade o valor da variável não mudou. Então, aqui nessa aplicação a gente não tem necessariamente um caso de uso que eu consiga mostrar isso, que seria, por exemplo, eu ter um cálculo aqui dentro do meu contexto de alguma informação e essa informação ser repassada aqui para o contexto. Então, para eu mostrar como que isso funciona em um caso de uso, por exemplo, eu posso vir aqui no próprio hook use summary, onde a gente tem esse cálculo aqui do summary, e eu posso utilizar essa função que eu estou querendo mostrar para você, que é, de dentro do React, o useMemo, que ele é exatamente como o memo que a gente usou para memorizar um componente, porém para memorizar variáveis. E o que muda é que eu copio o código do cálculo, escrevo o useMemo aqui por volta, aqui dentro precisa ser uma função, o primeiro parâmetro, e o segundo é o array de dependências. Aqui dentro eu retorno o meu cálculo, e no array de dependências eu boto quais são as variáveis externas do useMemo que eu estou usando aqui dentro. Se a gente está usando o slint, ele já avisa para a gente, no caso aqui, transactions. E aqui o que eu fiz quando eu botei esse useMemo? Essa variável summary, ela só vai ser recriada quando o transactions mudar. Antes, ela era recriada toda vez que esse useSummary aqui fosse renderizado de novo. Então, por exemplo, aqui como ela está sendo utilizada pelo componente summary, e esse componente summary é renderizado em tela toda vez que os componentes pai dele mudarem, essa variável aqui, summary, ela estava sendo calculada sempre do zero, toda vez do zero. E agora ela só está sendo calculada uma única vez, independente se o componente pai dela mudar ou não mudar."
  },
  {
    "id": "7aceb85b-b12e-451c-8db1-1247a3b23f72",
    "title": "Criando nova transação",
    "transcription": "O que a gente vai fazer nessa aula é permitir que o nosso modal, aqui, o newTransactionModal, ele realmente cadastre uma nova transação na nossa API. E pra gente fazer isso, como eu já tenho os dados aqui dentro, e eu já tenho acesso ao API, ali do que a gente configurou com o Axios, eu posso simplesmente vir aqui e fazer o seguinte, await api.post, e o post a gente usa quando a gente quer criar alguma coisa, e é super importante dizer que o JSON Server, automaticamente, quando a gente tem, aqui no arquivo server.json, por exemplo, uma rota transactions, ele cria a possibilidade da gente fazer uma requisição de post, de cadastro, na rota transactions, e ele vai inserir, automaticamente, um novo registro aqui na lista. Ele até mostra aqui que eu posso fazer tanto post, quanto patch, quanto delete, e por aí vai. E aqui embaixo, deixa eu ver se tem até um exemplo aqui de criação, acho que ele não dá um exemplo aqui na hora, mas, bom, a gente vai ver como que a gente consegue fazer isso aqui dentro mesmo. E aí, o que eu vou fazer aqui? Deixa eu voltar aqui, api.post, a gente vai passar qualquer rota, transactions, e aqui dentro eu passo o corpo da minha requisição, que é exatamente os campos que eu vou cadastrar. Aqui eu poderia colocar campo por campo, então, por exemplo, eu vou cadastrar uma transaction, aí a description, data.description, vou cadastrar a categoria, que é data.category, price, que é data.price, e o último que é o type, data.type. Eu gosto de fazer isso porque eu acho que fica mais claro do que simplesmente fazer ponto, ponto, ponto, data, mas para melhorar um pouquinho isso aqui, eu vou fazer só uma desestruturação aqui em cima, vou fazer o seguinte, eu vou pegar os campos description, price, category e type aqui do data, e aí aqui eu vou enviar description, price, category e type, usando a short syntax aqui do objeto, fica mais fácil. E aí uma outra coisa é que a gente tem aqui na nossa transactions, a gente tem o ID. O ID, o JSON Server, ele cria sozinho, a gente não precisa enviar, ele vai pegar qual que foi a última transação, vai ver que o ID foi 3, e ele vai criar uma transação com o ID 4, ele cria automaticamente para a gente, assim como um backend faria na vida real. Agora, o createdAt aqui, ele não vai criar sozinho, a gente até conseguiria fazer para ele criar sozinho, mas daí a gente teria que criar um custom server ali no JSON Server, não vale tanto a pena. Então, o que eu vou fazer aqui é criar, enviar um campo createdAt junto, como sendo a data atual. Então, geralmente quando você for trabalhar com o backend na vida real, você não vai precisar enviar isso aqui, isso aqui vai ser girado automaticamente pelo backend. Só estou enviando aqui para a gente não ter que configurar muita coisa ali no JSON Server, que nem é o foco aqui da nossa aula. Então, eu vou salvar isso aqui agora, e agora eu venho em modal F5, só para garantir, nova transação, vamos botar aqui uma transação de entrada, então desenvolvimento de app, vou botar aqui só 10 mil, categoria, vamos botar venda, é uma entrada, e eu clico em cadastrar. Já cadastrou, ele não fechou o modal automaticamente, depois a gente pode ver como é que faz isso, mas o ponto que eu queria te mostrar é que aqui no server.json, se a gente for aqui embaixo, já está aqui o desenvolvimento de app, preço 10 mil, categoria venda, type income, o createdAt e também o id 4. O único ponto aqui, a gente pode ver que o formulário aqui não foi resetado, então para resetar o formulário, a gente pode pegar aqui do nosso useForm a função reset, e chamar essa função aqui no final de tudo, então eu venho aqui e dou um reset, quando acabar de fazer o post aqui para a nossa page de transações. E outra coisa que a gente pode ver que também não aconteceu, é que a lista lá atrás, ela não recarregou, não tem a informação lá do desenvolvimento de app, porém se eu venho aqui e dou um F5, aí aparece desenvolvimento de app, inclusive deixa eu ordenar essa lista aqui, vamos voltar no contexto rapidinho, eu vou botar aqui, deixa eu lembrar aqui no jsonServer como é que faz uma ordenação, sort, aqui a gente consegue enviar, sort com underline na frente, igual o nome do campo createdAt, no nosso caso eu quero que os criados mais recentes estejam em cima e depois os mais antigos, então a ordem vai ser decrescente aqui, eu vou salvar e agora se a gente vem aqui e dá um F5, pronto, desenvolvimento de app já vem aqui para cima porque foi o último criado. Voltando, essa lista não está recarregando, então eu tenho duas maneiras de fazer essa lista recarregar, eu posso, aqui na hora que eu cadastro o nosso post, cadastro a nossa transaction, eu posso aqui executar esse método FetchTransactions de novo, só que não seria talvez o melhor, porque eu estou fazendo já uma requisição HTTP para cadastrar uma nova transação, se eu chamar o FetchTransactions eu vou ter que fazer mais uma requisição HTTP para buscar as transações, então não fica muito legal porque eu vou estar batendo na API duas vezes, sendo que na verdade esse método APIPost aqui, ele já me retorna a transação que foi criada, então se eu venho aqui e dou um const response igual ao APIPost e dou um console.log no response.data, quando eu crio aqui a nova transação, venho aqui e boto, vamos botar uma saída agora aqui, comi um pastel, paguei cinco pilas, categoria alimentação, é uma saída, quando eu clico aqui em cadastrar, olha só, ele me retorna aqui os dados da transação que foi criada, inclusive já com o ID e com o created at, então para eu não precisar fazer mais uma requisição para buscar a lista atualizada, eu poderia simplesmente pegar esse retorno aqui do response.data e jogar lá dentro desse nosso objeto aqui de transactions, para fazer isso existem formas de eu fazer, uma das formas é eu expor aqui do meu contexto uma função, por exemplo, para eu atualizar esse nosso objeto de transactions, só que eu acho isso um pouco perigoso, porque eu vou estar expondo uma função para os meus componentes e essa função pode mudar da maneira que ela quiser as nossas transactions, e aí eu acho ruim porque cada componente vai ter a sua lógica, digamos, de como atualizar esse objeto de transactions lá dentro do componente, e eu acho ruim porque a gente acaba deixando muito aberto as possibilidades, o componente pode atualizar o que ele quiser da nossa lista de transactions, então o que eu prefiro nesses casos é expor, na verdade, uma função daqui de dentro para criar a transaction aqui de dentro, e essa função aqui é quem vai fazer a requisição aqui do Axios, então eu venho aqui, copio isso aqui, jogo aqui para dentro, preciso ter acesso a esses Description, Price, Category e Type aqui, então aqui eu vou receber isso através de uma, vou chamar aqui de um, sei lá, Data, Input, tanto faz, pode ser Data, e aqui eu preciso tipar isso aqui, e aí eu posso criar aqui em cima uma interface para tipar isso, e aí você pode estar se perguntando, tá Diego, mas lá no NewTransactionModal a gente já tem uma tipagem para isso, que é esse NewTransactionFormInputs, será que não é melhor eu exportar isso daqui e carregar isso lá no contexto? Eu vou te falar que não, tá, por mais que pareça que a gente está repetindo o código, criando uma nova interface aqui para o CreateTransactionInput, falando, olha, para eu criar uma nova transação eu preciso de uma descrição, preciso de um Price, preciso de uma Category e preciso de um Type, que é Income ou Outcome, por mais que pareça que a gente está repetindo o código, na verdade a gente está fazendo um desacoplamento em relação ao componente de NewTransaction, o que eu quero dizer com isso? Imagine que no futuro a gente possa criar uma nova transação a partir de mais de um lugar da nossa aplicação, não só através desse modal, e nem usando o ReactHookForm ou qualquer coisa assim, ou seja, se eu uso esse Type aqui, lá dentro do meu contexto, o meu contexto na verdade fica totalmente atrelado, acoplado ao NewTransactionModal, e um dia se eu tiver uma outra opção de criar a transação, ou até eu querer deletar o meu modal, eu vou bugar o meu TransactionsContext, porque ele estava dependendo de um componente específico do modal, mas você concorda comigo que quando a gente cria um contexto, a gente cria um contexto para compartilhar funcionalidades com vários componentes, ou seja, não faz sentido o nosso contexto estar atrelado a um único componente que é o NewTransactionModal, e é por isso que muitas vezes faz sentido sim a gente duplicar algumas coisas. E agora que eu já tenho o Data aqui, a gente pode fazer mais ou menos semelhante ao que a gente tinha feito aqui dentro, eu posso pegar aqui e fazer uma desestruturação do nosso Data, e pronto, a gente já tem aqui o CreateTransaction. E aí no final das contas, o que eu vou fazer aqui é fazer um SetTransactions, vou copiar todas as transações que eu já tenho, e aí uma coisa importante, quando eu vou fazer uma atualização de estado que depende do valor anterior daquele estado, é melhor eu fazer isso utilizando um callback. E aí eu uso o .state, adiciono a nova transação que retornou aqui da resposta, da criação, no final da minha lista de transações. Ou melhor, no começo, porque como elas vão estar ordenadas da mais recente para a mais antiga, como essa que eu acabei de criar, com certeza ela vai ser a mais recente, então eu boto ela no começo da lista ali. Beleza, vamos continuar aqui, agora eu vou falar que o nosso contexto, deixa eu mover isso aqui para cima do TransactionContextType, porque eu vou falar que o meu contexto agora tem também uma função, CreateTransaction, essa função recebe um Data nesse formato aqui, e ela devolve também PromiseVoid. E aqui agora eu devolvo a função CreateTransaction, e aqui no nosso newTransactionModal eu vou acessar do meu contexto, a nossa função CreateTransaction, e aqui eu vou chamar a WaitCreateTransaction, passando os nossos campos Description, Price, Category e Type. Salvo isso aqui agora, e vamos testar. Não estou mais usando o Axios aqui dentro, venho no Chrome, nova transação, vamos botar aqui mais uma alimentação, comi um iogurte de banana. Preço custou R$ 4,00, categoria Alimentação, saída, quando eu clico em Cadastrar agora, veja que o formulário foi limpo, e já cadastrou lá o iogurte de banana, já foi cadastrado e já apareceu aqui na minha lista em tempo real."
  },
  {
    "id": "ab95107a-f3d2-486c-bf16-3740b575e030",
    "title": "Controlled components",
    "transcription": "Agora que eu voltei aqui, tinha ido lá pegar mais um cafezinho, a gente vai usar agora uma funcionalidade do React Hook Farm pra conseguir fazer o envio dessa informação aqui, de entrada e saída, pra dentro do nosso formulário. Por quê? O React Hook Farm é quando a gente tem campos com elementos que são nativos do HTML, como o Input, independente do tipo dele, Radio, Checkbox e tudo mais, a gente usa essa função Register, e ela funciona simplesmente a gente passando isso aqui pro nosso Input. Nesse caso aqui, que a gente quer inserir uma informação, e essa informação não vem através de um campo nativo do HTML, de um elemento nativo do HTML, a gente precisa utilizar uma API do React Hook Farm de controle. E a gente já falou sobre isso antes, sobre formulários, que existem duas formas de a gente construir, principalmente formulários, não só formulários, mas principalmente formulários no React, que é de uma maneira uncontrolled e uma maneira controlled. Uncontrolled é basicamente a gente buscar a informação do nosso Input somente quando a gente realizar o Submit. E isso funciona pra todos os Inputs, elementos de Input nativos do HTML. E tem a maneira Controlled, que é quando a gente anota o valor de uma informação, armazena o valor de uma entrada do usuário, toda vez que o usuário mudar aquele valor. Ou seja, se isso fosse no Input, cada vez que ele digitasse uma informação, a gente armazenava isso em algum estado, alguma variável. Nesse caso aqui, a gente vai ter que utilizar esse conceito de Controlled. E como que a gente faz isso no React Hook Farm? É super simples. A gente vai, aqui de dentro do UseForm, pegar um carinha chamado Control. Perfeito? Então, sempre que a gente precisar incluir uma informação num formulário, essa informação não vem de um Input ou de qualquer elemento nativo do HTML, a gente vai usar esse formato aí de Controlled. E agora o que a gente vai fazer? Aqui embaixo, por volta do TransactionType, eu vou até dar um Ctrl-X, isso aqui é um Cmd-X no caso porque eu estou no Mac. Eu vou utilizar um componente que vem de dentro do React Hook Farm, chamado Controller. Aqui, ele já dá a opção de importar. Ele não é um componente que tem filho, então a gente fecha ele nele mesmo. E aqui dentro eu passo para ele a propriedade Control, que é aquela nossa propriedade Control aqui de cima, que a gente importou aqui do UseForm. E passo para ele qual que é o nome do campo, ou seja, aqui em cima, o nosso Type, eu posso tirar o comentário. E aqui, se eu dou um Ctrl-Espaço, ele já fala quais são as opções de campos que a gente tem. No nosso caso, o Type, que é a informação que eu quero inserir. E aqui eu vou passar para ele uma última propriedade, que é o Render. O Render é basicamente uma função que vai retornar qual que é o conteúdo relacionado a esse campo, o HTML relacionado ao campo Type, a forma de eu inserir esse campo Type no formulário. E aí eu posso botar o nosso TransactionType aqui dentro, com todas as informações. E agora, de dentro desse Render aqui, eu consigo pegar uma série de propriedades. Se eu der um Console.log aqui nessas propriedades, eu salvo isso aqui agora, venho no Chrome, dou um F5, abro aqui o modal de NewTransaction. Eu vou ver que dentro dessas propriedades, eu tenho acesso a algumas informações. Por exemplo, eu tenho acesso ao Field, ao FieldState e ao FormState. E ao FormState. O FormState me traz dados do contexto do formulário. Ele me traz informações sobre o formulário como um todo. Por exemplo, igual aquelas informações que eu tinha acesso aqui em cima, no FormState. Se o formulário está em Submit, se ele não está, se ele está com erro, ou seja, eu tenho acesso às informações do contexto do formulário. O FieldState traz informações sobre o campo Type, especificamente. Então, nesse FieldState, eu consigo saber, por exemplo, tem algum erro relacionado a esse campo Type, por exemplo, de validação. Esse campo Type, ele já teve alguma entrada do usuário, ou seja, ele está Dirty, ele tem um valor diferente ao valor inicial, ou ele já teve uma entrada de dados, indiferente se está diferente do valor inicial ou não, ele está Touched. Então, a gente consegue pegar várias informações através do FieldState. E o Field, em si, é onde estão os nossos eventos para a gente conseguir alterar o valor desse campo. Então, aqui dentro do Field, a gente tem, por exemplo, o OnChange, que passando o novo valor do Type, é essa função que vai salvar esse valor dentro do formulário. E a gente tem o Value, que é o valor atual, digamos assim, desse campo no formulário. Então, olha só que interessante. Aqui, se a gente for na própria documentação do RadixUI, e a gente procurar lá o nosso RadialGroup que a gente utilizou aqui dentro, a gente vai ver que aqui no elemento Root, que é esse elemento do TransactionType, lembra que a gente usou o RadialGroup Root aqui, a gente pode passar para ele uma propriedade chamada OnValueChange. Essa propriedade OnValueChange é basicamente um evento que é chamado toda vez que o valor do Radial mudar, ou seja, que a pessoa selecionar entrada ou saída. Então, olha só que interessante. Se eu passo aqui para ele OnValueChange e passo aqui a função console.log, quando eu salvo isso aqui agora e clico em Entrada, ele retorna Income. Se eu clico em Saída, ele retorna Outcome. Ou seja, se eu tenho dentro do meu Field, acesso a função OnChange, e essa função OnChange é a função que anota o valor do campo type, e eu tenho um EventHandler aqui, OnValueChange no RadialGroup, que me diz qual que é o valor, é muito simples. Basta eu vir aqui das minhas propriedades, eu vou desestruturar, vou pegar apenas o Field, e vou falar o seguinte, quando o valor do meu campo type mudar, eu vou chamar a função OnChange aqui do meu Field. E aí agora, olha só, deixa eu continuar dando um console.log aqui no nosso Field, agora salvo, e olha só que interessante, vou dar um F5, abro o modal de nova transação, ele trouxe aqui o OnChange, e o Value dele por enquanto está Undefined. Quando eu clico em Entrada agora, olha só, ele trouxe novamente o mesmo console.log, que é esse aqui, porém agora o valor não está mais Undefined, e sim está como Income. Então a gente consegue ter acesso a essa informação. E aí como eu tenho acesso a informação do valor atual, eu posso passar o Value como sendo Field.Value. Isso aqui é importante, principalmente se eu for querer iniciar o valor aqui do type com algum valor padrão, por exemplo, aqui no meu formulário, eu posso passar o DefaultValues.Type como sendo Income. E aí agora, quando eu abro o modal, ele já vem selecionado aqui o Entrada. Se eu não tivesse passado esse Value, o Field.Value, ele não herdaria esse valor, ele não vem nada selecionado. Então é importante a gente utilizar esse Value aqui. Eu vou acabar dando alguns Enters aqui, só para separar as propriedades. E agora para a gente testar, eu vou realizar o Submit, para ver se está tudo certinho aqui dentro do nosso formulário. Então, vamos lá. Eu vou preencher aqui qualquer coisa, um preço, uma categoria, vou selecionar Saída, e vou clicar em Cadastrar. A gente aguarda um pouquinho, e pronto. A gente pode ver que já veio todas as informações, inclusive o Type aqui veio como Outcome, que foi o que eu selecionei. Se eu trocar para Entrada e clicar aqui no Submit novamente, aguardamos um pouquinho, e o Type agora vem Income."
  },
  {
    "id": "6181272a-d8e4-4969-beb6-3d1e82416f43",
    "title": "Tabela de transações",
    "transcription": "Nessa aula o que a gente vai fazer é a nossa tabela de transactions, essa tabela aqui. Essa tabela em si eu não vou colocá-la num componente, eu vou botar direto aqui dentro da página de transações. Mais pra frente ela até poderia virar um componente sozinho, se a gente visse que é algo que tem muita lógica associada ou que a tabela dá pra ser reaproveitada em outros lugares, sei lá, a gente tem um local onde a gente lista só transações acima de tantos reais, sei lá, a gente poderia reaproveitar um componente de tabela de transações. Mas aqui nesse caso não tem tanto problema em a gente fazer aqui mesmo. Eu vou começar criando aqui uma table mesmo. Essa tabela não tem header, se a gente for ver. Ela é uma tabela direta que já é auto-explicativa, então não tem muito por que ter o thead ali. E aqui eu vou ter vários TRs pra cada linha. A primeira coluna vai ser o tipo da transação, o nome dela, desenvolvimento de site. E aqui eu vou botar um width diretamente na tag de 50%. Poderia botar por CSS também, acho que dos dois jeitos funciona. Mas porque eu quero que essa primeira coluna ocupe mais espaço. Eu acho que não precisa ser 50%, pode ser 40% aqui. Vamos botar até 50%. Depois se a gente ver que ficou ruim, a gente diminui. Eu quero que ela ocupe mais espaço que as outras, senão ele vai ocupar o mesmo tanto em todas as colunas. E aqui eu vou botando mais alguns TDs. O próximo é o preço. Vamos copiar aqui. Copy as text. Depois essa TD aqui a gente vai precisar que ela tenha uma cor diferente. Aqui a categoria. E o último é a data. 13 de 4 de 2022. Eu vou copiar isso aqui várias vezes. Só tem outras aqui que a gente vai precisar que ela tenha um estilo com preço negativo. Vou até colocar uma aqui. Deixa eu copiar o texto. Copy as text. Ele vem com um menos na frente. Dessa forma. Ele acaba criando, porque eu estou com a font-ligatures aqui, ele acaba criando um caractere especial. Mas no HTML, na visualização, depois não vai mudar nada. E aqui, hambúrguer boa. Hambúrguer. Bom demais. E aqui vai ser alimentação. E a data 10 de 4. Eu vou botar só duas linhas por enquanto, para a gente estilizar esses dois estados. Uma entrada e uma saída. Salvo isso aqui agora. Volto. Está lá. Ficou bem ruim. O que eu vou fazer é colocar por volta dessa table uma transactions container. Que vai ser exatamente o que a gente fez no header e no summary. Que é para fazer a centralização. Então ele vai centralizar todo o conteúdo igual a gente fez nos outros. Esse transactions container aqui, ele vai vir aqui de dentro. Styled. Vou usar aqui um styled main, talvez. Pode ser. E esse transactions container, ele vai ser exatamente o que a gente fez lá no header e no summary. Que é esse estilo aqui. A única diferença é que nesse margin, eu não vou botar zero alto. Eu vou botar 4 ran em cima, alto nas laterais e zero abaixo. E o resto vai continuar tudo igual. Só para a gente distanciar um pouquinho essa tabela do summary aqui em cima. E agora sim, deixa eu importar aqui o nosso transactions container. Salvo. E pronto. Já está aqui nossa tabela. E agora a gente pode partir para a tabela em si. Eu poderia estilizar aqui direto de transactions container a nossa table. Só que a nossa table vai ter bastante estilização. Nesses casos eu prefiro criar um styled component só para ela. Então eu vou chamar de transactions table. E aqui eu vou estilizar a tabela diretamente. E aqui eu vou usar transactions table aqui diretamente. E pronto. A estilização acaba que não vai ter muito não. Eu vou dar um width de 100%. Aqui eu vou dar um border collapse como separate. Isso aqui eu estou usando border collapse separate porque se a gente for ver, entre cada linha aqui da tabela existe uma separação. E aí quando a gente usa o border collapse separate eu consigo usar o border spacing de zero nas laterais e 0.5 ran verticalmente. Então ele vai botar esse espaçamento aqui de 0.5 ran, que vai dar 8 pixels entre cada linha da nossa tabela. Vou botar um margin top aqui de 1.5 ran também. Isso aqui na verdade eu vou deixar comentado, porque vai ser a margem entre o formulário de busca. Como a gente não tem o formulário de busca ainda, isso não vai ser necessário. E aí eu vou estilizar diretamente o nosso TD, que vai ser um padding de 1.25 ran e 2 ran. Vamos botar aqui também um background props, props.theme.gray700. Aqui a gente vai estilizar a primeira TD de cada linha, porque eu quero que ela tenha na primeira TD um border radials na lateral. Então eu vou botar um border top left radials, 6 pixels. Border bottom left radials, 6 pixels. E no último TD de cada linha, que é esses aqui, eu quero ter um border top right e border bottom right radials de 6 pixels. Eu prefiro escrever assim, border top left radials, 6 pixels, do que escrever dessa forma aqui, 0, 0, 6, 6, porque eu não acho isso aqui descritivo. Eu sempre esqueço qual é a ordem desses parâmetros aqui. Então eu prefiro escrever dessa forma, porque assim não tem como esquecer. 6 pixels no top left, ou seja, no canto superior esquerdo. Bottom left, inferior esquerdo. E por aí vai. Então eu acho mais descritivo. Então eu prefiro manter dessa forma. Posso ver que aqui já está a nossa tabela tudo certinho. O que falta agora é o nosso preço, verde ou vermelho, de acordo com se é uma entrada ou se é uma saída. Para isso eu vou criar mais um componente aqui dentro. Eu vou chamar ele de PriceHighlight. Ele vai ser um span. E ele vai receber uma propriedade aqui, falando qual é a cor do texto. Então, interface, PriceHighlight, props. Eu vou chamar de variant. E ele vai ser ou uma entrada ou uma saída. Então, income para a entrada, outcome para a saída. Eu vou passar aqui no nosso span. E aí vai ser bem simples aqui. Eu vou pegar simplesmente a minha propriedade variant. Se ela for income, eu vou botar a cor do texto como sendo props.theme.green 300. Se não, vai ser props.theme.red 300 aqui. Aqui eu poderia dar umas quebradas de linha para ficar melhor. Eu acabei não configurando o ES20 aqui no projeto. Mas a gente configura isso logo mais. E daí a gente já arruma. Posso mostrar também como que a gente... Até legal para eu mostrar como que a gente faz um fix em todos os projetos. Caso a gente queira instalar o SLint, o Prigger. Depois num projeto que já tem muito código. Para a gente não precisar ficar arrumando as coisas manualmente. Mas, beleza. Agora, aqui dentro do Transactions, por volta aqui do preço. Eu vou colocar o nosso componente PriceHighlight. E ele precisa receber aqui uma Variant. Eu vou escrever como Income. E nesse aqui de baixo, que é o negativo. Eu vou também colocar o PriceHighlight por volta. Porém, a variante dele vai ser Outcome. Por que ele... Ah, faltou um sinalzinho de maior aqui. E aqui a gente já pode ver então que ficou vermelho e verde. Dependendo aqui do tipo do preço. E pronto, a gente já configurou. Então toda a nossa tabela já está 100%. E agora a gente pode continuar para finalizar o de busca aqui. E o modal de inserção aqui de um novo registro de transação."
  },
  {
    "id": "0c11187e-1160-49b6-ac4c-58311e941be0",
    "title": "Aplicando Context Selectors",
    "transcription": "Vamos continuar, então, para a gente começar a entender como que a gente consegue evitar renderizações que são desnecessárias no React. Uma das coisas que eu quero te alertar antes da gente começar a trabalhar nisso é que performance, geralmente, a gente tem que cuidar para não tentar resolver problemas de performance que nem existem ainda de forma prematura. É muito mais provável que quando a gente tenta criar um código já com todos os problemas de performance evitados, a gente acabe criando um código menos performático. Porque, como eu falei, o React por si só já é muito rápido. Não necessariamente a gente vai ter que ficar a todo momento evitando renderizações. Porque o algoritmo de reconciliação do React, que é o algoritmo que roda por baixo dos panos, que calcula quando que um componente deve ou não ser renderizado ou ser recriado em tela, ele é extremamente rápido. Então, a gente tem que cuidar com essas otimizações de performance de forma prematura. Então, geralmente, o que a gente vai fazer? Quando a gente quer olhar para performance, a gente vai vir aqui no profiler, a gente vai entender através dos commits aqui, através das ações que a gente faz, o que foi renderizado. E aí sim, olhando aqui pelo tempo de renderização, a gente vai entender as coisas que poderiam ser evitadas de renderizar aqui. Então, vamos começar? Vamos lá. Aqui eu posso ver que quando eu atualizei aqui, fiz a busca e atualizei a minha lista de transações, eu tive aqui uma renderização dentro do TransactionsProvider, beleza, isso é normal, porque eu atualizei o estado. E quando eu atualizo o estado, o componente renderiza. Tá certo. O ContextProvider faz sentido, porque o ContextProvider está aqui dentro, então ele vai ser recriado, não tem porque evitar isso. Na página de Transactions, o que faz sentido também, porque a página de Transactions é a página que lista as nossas transações, então se eu fiz uma busca, isso aqui precisa ser atualizado. Então, beleza, novamente faz sentido. No header, talvez a gente pode dar uma olhadinha, o header foi atualizado basicamente porque como a página de Transactions foi renderizada de novo, todos os componentes filhos dessa página são renderizados também. Então como o header é um componente filho da página de Transactions, ele foi renderizado de novo aqui. E beleza, não necessariamente isso aqui é o problema, como eu falei, isso aqui é muito rápido para o React fazer essa renderização. Depois a gente teve renderização aqui no Summary também, que também está certo, porque o Summary depende do valor de Transactions lá do contexto. Como esse valor mudou, acabou atualizando o Summary também. E dentro aqui do header depois teve mais algumas coisas que atualizaram, por exemplo, o NewTransactionModal. Então, uma das coisas que é importante falar sobre contextos, quando a gente lida com contextos no React, é que o React não possui uma API interna ainda para a gente selecionar campos específicos de um contexto. O que eu quero dizer com isso? Aqui no nosso NewTransactionModal, quando eu passo o mouse por cima do NewTransactionModal nesse commit, a gente pode ver que ele mudou por quê? Ele renderizou por quê? Porque o context mudou, tá vendo? Nem foi porque o componente pai mudou, que é o que a gente vê em alguns outros aqui. Ah, o parent component rendered. Ah, o header só renderizou porque o Transactions renderizou, senão ele não tinha renderizado. O que faz ele ficar muito rápido. Nesse caso do NewTransactionModal, o que fez ele renderizar é porque o contexto mudou. Veja que aqui dentro do NewTransactionModal, a única informação que eu estou buscando lá do contexto é o CreateTransaction, certo? E a informação que mudou do meu contexto, na verdade, foi a lista de transações. Não foi o meu CreateTransaction, concorda comigo? O que acontece é que no React, por padrão na Context API, a gente não consegue falar para um componente, olha, eu quero que você olhe apenas para a informação CreateTransaction e não para as outras que estão dentro do contexto. Não é possível a gente fazer isso. No React, independente de qual informação mudar dentro desse contexto, todos os componentes que dependem de qualquer informação desse contexto vão ser renderizados. E até existe uma APR aberta, uma discussão aberta dentro do React para a gente ter uma API para conseguir fazer isso. Isso é um conceito que a gente chama de Selector. Mas enquanto essa API ainda não existe, uma biblioteca que foi criada para resolver esse problema foi essa UseContextSelector, que a gente pode utilizar para resolver esse problema. Então vamos lá, olha só como ela funciona. Eu vou começar instalando a UseContextSelector e ela depende de uma outra biblioteca chamada Scheduler. A gente vai instalar essas duas dependências e ela é super simples de utilizar, olha só que legal. Lá no nosso contexto agora, ao invés de eu chamar o CreateContext que vem de dentro do React, eu vou chamar a CreateContext que vem agora de dentro do UseContextSelector. A API é exatamente a mesma, a gente não precisa mudar em nada. Porém, agora a gente não vai mais utilizar o UseContext para selecionar o nosso contexto. A gente vai na verdade usar o UseContextSelector. E aqui no UseContextSelector, além de passar o nosso contexto, eu preciso passar agora uma função aqui como segundo parâmetro. Essa função recebe o nosso contexto como parâmetro e eu devo retornar daqui de dentro quais informações desse contexto eu quero observar, ficar de olho, digamos assim, para saber se elas mudaram ou não. E aí eu vou falar, olha, a única informação que eu quero nesse caso, então como é uma única informação, nem preciso retornar como um outro parâmetro. A única informação que eu quero nesse caso, então como é uma única informação, nem preciso retornar como um objeto, é a função createTransaction. E aqui agora como eu estou retornando uma única função, eu não preciso mais fazer uma desestruturação aqui em cima, porque eu estou retornando uma informação só. Então eu tiro aqui também a nossa chave, salvo aqui para o slint arrumar, e pronto, a gente já fez aqui a alteração que a gente precisava fazer. Posso remover também essa importação. Venho aqui na minha lista de transações e a gente vai ter que ir arrumando os outros pontos aqui. Então desse aqui, eu quero pegar returnContext.transactions. Então a gente vai começar a falar exatamente quais informações a gente quer, aqui não é uma vírgula. Vamos lá, eu acho que tem mais componente que a gente usa, acho que aqui no search form, talvez isso. Aqui então, useContextSelector, tiro a importação que eu não estou usando, venho aqui e pego o meu context e retorno apenas o fetchTransactions. Não lembro se tem mais algum lugar que tem que alterar, então como eu não lembro, eu posso vir aqui e executar um npm run lint, ele vai me avisar se tem mais algum lugar. Dentro de TransactionsIndex, ah, faltou tirar essa importação. De resto, deve estar tudo funcional. E agora, vamos fazer um novo teste aqui na nossa aplicação. E agora, vamos fazer um novo teste aqui na nossa aplicação. Então, erro, cannot read properties of undefined, tá. Lá no meu hook, useSummary, aqui ó, faltou aqui também, não sei porque o lint não tinha me avisado sobre isso aqui. Estranho tá, vou olhar isso aqui, porque aqui o lint está dando erro. Não, é o Typescript que está dando erro aqui dentro, não é o lint, por isso. A gente poderia rodar um npm run tsc no emit, isso aqui também, o Typescript não está instalado. Tá instalado, npx tsc no emit, é isso. Ele vai me avisar os erros de Typescript, agora sim, ele deu erro aqui no useSummary. Isso aqui é um erro de Typescript, não de lint, por isso que ele acaba não dando erro. Vamos trocar para useContextSelector, e nesse caso aqui, eu pego o meu contexto e retorno context.transactions. E aqui eu tiro também a desestruturação. Salvo, e agora a nossa aplicação já deve estar funcionando novamente. Vou fazer o seguinte, venho agora no meu profiler, aposto limpar aqui, e agora eu vou escrever aqui desenvolvimento, vou botar para gravar, clico em buscar, paro, e agora a gente vai analisar de novo o que aconteceu aqui dentro. Beleza, teve um primeiro commit que foi por causa do loading, segundo commit também foi por causa do loading, agora a gente teve um terceiro commit aqui, que ele atualizou o transactionsProvider, então ele atualizou a lista de transações, ele atualizou o contexto e atualizou o searchForm de novo, porque o hook4 mudou o searchForm, esse foi provavelmente esse hook, como a gente colocou useContextSelector, não sei se disparou mais algum commit aqui, transactionsProvider, esse aqui foi o searchForm, esse foi o transactionsProvider que disparou, então alguma coisa, eu acho que é porque mudou a lista de transactions. Ah, tá bom, já sei o que aconteceu aqui, mas vamos olhar para esse último aqui, antes da gente olhar para aquele ali. O que acontece aqui, a gente pode ver que agora o nosso newTransactionsModal aqui, ele continuou renderizando, e ele falou que ele continuou renderizando aqui porque o nosso hook1 mudou, então se eu volto lá no nosso newTransactionsModal, eu vou ver que o hook1, na verdade, é esse nosso useContextSelector, ou seja, será que esse useContextSelector não funcionou? Porque se eu estou olhando agora apenas para a informação da função createTransaction, e a informação que eu atualizei na verdade foi a minha lista de transações, por que esse componente newTransaction aqui renderizou? Sendo que a função createTransaction não mudou, será que ela realmente não mudou? O que acontece? Quando a gente cria funções no React dentro de um componente, quando esse componente renderiza de novo, no caso esse transactionsProvider está renderizando de novo porque a gente está atualizando a lista de transactions, todas as funções e variáveis que a gente tem aqui dentro, elas são recriadas do zero em memória, ou seja, como esse componente newTransactionModal está olhando para a função createTransaction, essa função aqui está sendo recriada do zero quando o componente atualiza, ou seja, ela muda sim, por mais que o conteúdo dela não mude, a posição dela, a referência dela para a memória é uma referência diferente, e é por isso que o nosso componente de modal está renderizando, mas vamos com calma que a gente ainda vai corrigir isso."
  },
  {
    "id": "128e7745-52b7-472b-9d91-c8529c653342",
    "title": "Modal de nova transação",
    "transcription": "Cai sou eu novamente, depois de já ter almoçado um feijãozinho top. E agora a gente vai estilizar esse nosso modal. E eu vou começar criando um componente novo. Eu vou chamar ele de newTransactionModal. Dentro eu vou criar um index.tsx e um styles. E esse newTransactionModal vai ter só a parte do conteúdo do modal em si. E aqui eu posso botar dentro dele... Eu vou fazer o seguinte, eu vou botar aqui do portal para dentro. E aqui eu vou usar então o newTransactionModal. Vou pegar aqui, jogo aqui, importo isso aqui e show de bola. E agora dentro do meu newTransactionModal tem algumas dessas coisas aqui que eu quero estilizar. Principalmente o overlay e o content. Então o que eu vou fazer? Eu vou criar aqui dentro o meu próprio overlay. Ele vai ser um styles. E aqui eu vou importar também o css do dialog.overlay. Quando a gente quer estilizar algum desses elementos do ReactDialog, aí não tem muito como fugir de trazê-lo aqui para dentro do styledComponents. Não com o styledComponents, é com outras bibliotecas css até dali. O overlay a gente importa aqui dos styles. Cuidar para importar do lugar certinho, tem que ser dos styles. E aqui eu vou criar um content também. Então eu vou chamar de content.dialog.content. E aí eu vou trocar esse carinha aqui. Cuidar para importar do lugar certo também. Styles. Prontinho. Dentro do nosso content em si, a gente vai ter, além do título, um formulário. Esse formulário aqui vai ter três campos. Isso, descrição, preço e categoria. Então o primeiro input, o placeholder dele é descrição. Ele é um campo obrigatório, então eu já posso colocar um required aqui. Esse próximo campo que é o preço, eu vou botar o type dele como number, preço. E o último é categoria. E fechou. Esses dois aqui, entrada e saída, vamos deixar mais para frente. E aqui no final eu vou ter um button do tipo submit, que vai estar escrito cadastra. Só isso aqui agora, vamos testar aqui. Nova transação, está carregando ali. A gente vai arrumar um pouco o CSS desses carinhas aqui. Então aqui no CSS do new transaction modal, a gente vai começar com o CSS do overlay. Eu vou dar um position fixed nele. É melhor usar position fixed nesse caso do que absolute, porque o fixed, mesmo que a gente tenha scroll, ele vai ficar sempre na mesma posição da tela. Vou botar aqui um width de 100vw e um height de 100vh para forçar que esse overlay ocupe a tela toda. Vou usar um inset como zero. Se você não sabe o que é o inset, é a mesma coisa que eu fazer top zero, bottom zero, left zero, right zero. Eu posso escrever, na verdade, inset zero e é a mesma coisa. E vou colocar um background rgba0000.75 para ele ficar com o fundo mais escuro. A gente já pode ver que deu certo. Se eu não me engano aqui a gente poderia fazer também hashtag 000000 e botar 75 no final. Eu acho que ele aplica também a mesma transparência. Então a gente pode escolher as duas formas. Nesse caso, quando lida com transparência, eu prefiro escrever dessa forma. Mas, novamente, é uma preferência, é questão de custo. O conteúdo aqui, eu vou botar um minwidth de 32rem, um border-radius de 6px. Esse aqui tem um pouquinho mais de estilos, mas é rapidinho também. Pede em 2.5 no topo e embaixo e 3 nas laterais. E vou botar aqui um background props-theme. E vou botar o gray 800, que é a mesma cor que a gente estava usando de fundo ali na aplicação. Também vou colocar um position-fixed, porque se esse aqui está com fixed, eu quero que esse aqui também fique fixo na tela. Top 50%, left 50% e vou usar aqui um transform-translate. Translate. Menos 50%, menos 50%. Se você nunca fez isso aqui, isso aqui é um hack para a gente centralizar coisas na tela. Então, imagina o seguinte. Deixa eu abrir aqui um sigma para te mostrar exatamente o que isso significa no final das contas. New Design File. Então, imagina que a gente tenha aqui uma tela qualquer. E aí, eu estou aqui colocando o meu conteúdo do modal, que por padrão, digamos que ele venha desse lado. Quando eu dou um top 50%, ele vai pegar qual é o tamanho da tela. Nesse caso, o tamanho da tela é 982. Então, esse aqui, eu vou fazer a distância dele para o topo de 982 dividido por 2, que é 50% da tela. Então, ele ficou aqui. E aí, left 50%, ele vai pegar qual é a largura da tela, 1512. Então, o x dele aqui vai ser 1512 dividido por 2. Só que ele não ficou centralizado, com top e left 50%. E aí que vem o translate, menos 50% no eixo x e menos 50% no eixo y, que é o seguinte. Eu pegar menos 50%, isso aqui é relativo ao tamanho do conteúdo em si. Então, nesse caso, qual é a largura do conteúdo? 413. Então, eu vou diminuir a posição em, aqui vou botar entre parênteses, 413 dividido por 2. E aqui a gente pode ver que ele ficou centralizado horizontalmente. Faça a mesma coisa para o eixo y, ou seja, menos 487 dividido por 2. E agora, o nosso conteúdo está totalmente centralizado na tela. Então, é só um hackzinho, só quis ir para o Figma para caso você não entendesse o que isso significa. Acho que é legal a gente conhecer esses hacks do CSS. Show, olha só, o nosso conteúdo agora já está centralizado e a gente vai partir agora para estilizar o nosso formulário. Então, margin-top, vou dar um 2rem para ele distanciar um pouquinho ali do título. Display flex, flex-direction-column, vou dar aqui um gap de 1rem para distanciar os inputs. E agora a gente vai estilizar aqui os nossos inputs em si. Então, border-radius 6px, border 0px, background-props, props.theme.gray 900px. Color, a gente vai usar uma cor gray 300px, que é um cinza um pouquinho mais escuro do que o padrão que a gente usa. Padding, 1rem, e aqui, placeholder, vamos colocar a cor gray 500px. Salvo isso aqui, podemos ver que os inputs já estão em tela certinho. A gente vai agora para o nosso button, e aqui eu vou botar button do tipo submit, porque mais pra frente a gente vai fazer com que essas entradas e saídas também sejam botões. Então, por isso que eu vou estilizar somente o botão do tipo submit aqui. Vou botar nele um height de 58px, um border 0px. Esse botão aqui é muito parecido com aquele botão do header, apesar de que ele é maior. Então, tem que cuidar com algumas coisinhas caso você vá copiar o CSS. Vou ir aplicando aqui o nosso CSS, uma cor branca para o texto. .weightbold, padding 0px, 1.25rem, border-radius 6px, e margin-top 1.5rem. Já podemos ver como ele ficou, parece que está praticamente pronto, mas falta só o nosso cursor-pointer e falta o nosso hover aqui. No hover eu vou modificar a cor para um 700, um pouquinho mais escuro, e vou adicionar aquele nosso transition também no background-color 0.2s. Já está aqui, botãozinho de fechar ali do modal, acabamos esquecendo. Então, o que eu vou fazer? Aqui onde eu tenho esse dialog close, ele pode ficar em qualquer lugar do modal, eu vou botar aqui em cima porque se a gente for pensar estruturalmente, visualmente, vem o título, aqui vem o botão de fechar e aí vem o formulário, mas ele poderia ficar em qualquer lugar aqui. Como ele vai ter um conteúdo agora, aqui dentro do dialog close eu vou colocar o nosso ícone de fechar. Esse ícone é o ícone chamado x e ele vem de dentro do Phosphor React. E aqui eu posso criar uma estilização para esse carinha, deixa eu só ver aqui na minha colinha. Sim, eu vou precisar criar uma estilização para ele, então eu vou fazer o seguinte, eu vou criar aqui mais um componente chamado closeButton, ele vai ser um styled dialog.close ou eu poderia criar ele como um button mesmo e fazer aquela mesma coisa que a gente fez lá no outro elemento, usar o style aqui, mas tanto faz. Então agora eu vou trocar esse dialog close por closeButton, o meu x já está aqui dentro, no caso do x aqui eu vou só aumentar um pouquinho o tamanho dele para 24, e agora aqui no closeButton a gente vai adicionar o css que a gente precisa colocar. Então nesse caso aqui o position dele vai ser absoluto, porque como ele vai ser relativo ao conteúdo não tem necessidade de ser fixo. Ele é um botão como qualquer outro, então eu preciso resetar o css dele, botar aqui um fundo transparente, tirar a borda que é padrão dos botões no HTML, e aqui eu vou fazer o seguinte, eu vou distanciar ele 1.5 rem do topo e 1.5 rem da direita, para ficar bem no canto superior direito. Aqui eu vou dar um lineHeight zero, isso aqui é importante e já explico o porquê, vou deixar comentado e daqui a pouco eu explico o porquê que isso aqui é importante. Vou botar um cursorPointer também e por final um colorProps.thin.gray500. Salvo isso aqui agora e olha só que legal, nosso botão já está lá, se eu clico nele ele já fecha, mas veja que quando eu estou com foco no botão aqui, está vendo que a caixinha do foco fica maior que o próprio ícone? Isso é por causa do fontSize, o tamanho do focus do caso do botão é relativo ao fontSize do botão, então se eu por exemplo colocar aqui um fontSize zero, a gente vai ver que ele já ajusta, ele já ficou o tamanho da caixa certinho, mas pode ser também um lineHeight zero, vai funcionar da mesma forma, porque nesse caso ele vai também fazer com que o tamanho da linha, da fonte seja igual, então tanto faz, fontSize zero, lineHeight zero, vai dar o resultado visual igual. E pronto, agora a gente já tem aqui o nosso modal e ele está totalmente acessível, então eu abro, fecho com o ESC e posso navegar totalmente por teclado, se eu pego o foco aqui do X e dou um Enter, ele fecha também, então está ficando bem legal."
  },
  {
    "id": "90121a60-2733-4aa8-9c67-7e93d019e650",
    "title": "Criando contexto de transações",
    "transcription": "Agora que a gente já carregou aqui os dados das transações, a gente vai precisar, na verdade, essa lista de transações também em outros lugares da aplicação. Aqui, por exemplo, no Summary, que é o local onde a gente tem o resumo de entradas, saídas e o total, eu vou precisar ter acesso às transações carregadas aqui até para conseguir calcular essas entradas, saídas e total. E aqui, hoje, eu estou pegando essas transações aqui e eu poderia enviar esses dados de transações aqui para o componente Summary como uma propriedade. E funcionaria perfeitamente bem. E se fosse só isso, provavelmente eu faria dessa forma. Mas, mais para frente e daqui a pouco, a gente vai ter que fazer também a inserção de uma nova transação. E durante a inserção de uma nova transação, que o componente está lá no cabeçalho, que está aqui dentro do header, dentro do newTransactionModal, eu vou ter que também acessar essa lista de transações aqui para inserir uma nova transação dentro dela. Até para eu não precisar fazer uma nova requisição para dentro da API de Transactions, buscando todas as Transactions toda vez que eu inserir uma nova Transaction. Então, para isso, eu posso trabalhar direto com o State, incluir aqui a Transaction que o usuário acabou de adicionar. Então, como eu tenho vários componentes de níveis diferentes precisando acessar essa informação de Transactions, o modelo, a forma mais fácil de eu fazer isso, é com Contexto. Mas cuidado, porque Contexto, muita gente que aprende a trabalhar com a Context API no React, começa a resolver qualquer compartilhamento de estado simples, às vezes, também utilizando Contexto. E aí fica um código super complexo de dar manutenção, sendo que, muitas vezes, passar uma propriedade pode ser mais fácil, mais performático, menos verboso, do que criar todo um Contexto. Aqui a gente está criando somente por causa desse ponto que eu falei, para eu não ter que passar a propriedade Transactions aqui para o header e teria que também passar, claro, uma função ali para conseguir adicionar uma nova Transaction. Depois, do header para dentro do new Transaction modal, ou seja, quando a gente começa a ter esses múltiplos níveis de componente precisando ter acesso a uma informação, a maneira mais simples, nativa, do React, sem utilizar alguma biblioteca, é utilizando o conceito de Context API. Para isso, eu vou começar da maneira mais simples possível, criando aqui uma pasta chamada Contexts, no plural, e aqui eu vou criar um TransactionsContext.tsx. Eu vou criar ele como TSX, porque, como a gente já havia visto antes, aqui dentro eu vou criar o meu TransactionContext, que é igual a CreateContext que vem de dentro do React. Eu vou criar uma interface para falar quais são as informações que eu vou armazenar, barra, retornar de dentro desse contexto. Então, aqui eu vou chamar de TransactionContextType, e eu vou falar que, por enquanto, a única informação que vai ter aqui dentro é uma lista de transações. E aí eu vou trazer aqui de dentro essa interface, vou jogá-la aqui dentro, vou falar que eu retorno uma lista de transações de dentro desse contexto. Aqui eu vou falar, basicamente, a maneira de eu adicionar o TypeScript ao contexto, eu posso fazer dessa forma aqui, porém, ele vai falar que esse objeto aqui não contém essas informações, aí eu tenho que fazer Transactions, passar um Array vazio para funcionar. Só que não tem muita lógica, no meu ver, é melhor você vir aqui e fazer um S, TransactionsContextType, dessa forma você não precisa ficar passando valores para esse objeto, sendo que os valores vão ser passados depois pelo Provider. E aqui eu vou dar um Export também, num componente, chamado TransactionsProvider. E aqui, esse TransactionsProvider, a única coisa que ele vai fazer é retornar o nosso TransactionsContext.Provider, passando aqui um Value que precisa ter, realmente, a informação de Transactions. Então, eu posso passar aqui, por enquanto, por exemplo, Transactions, é um Array vazio, só para parar de dar erro. E aqui, o restante, ele vai renderizar o Children, que é uma propriedade. E aqui, como é uma propriedade, eu preciso tipar também. Então, eu vou criar aqui o TransactionsProviderProps, falando que o Children é um ReactNode. ReactNode é qualquer elemento válido no React. Pode ser um componente, pode ser um HTML, pode ser um texto, pode ser um número, pode ser qualquer coisa assim. Show! Agora que o nosso contexto já está criado, o que eu vou fazer, na verdade, é mover esse código aqui de chamada para API lá para dentro. Então, eu vou tirar isso aqui daqui, movo aqui para dentro. E agora, vou importar o useState, vou importar o useEffect. E agora, aqui embaixo, ao invés de passar um Array vazio, eu vou passar o nosso Transactions em si, que é o estado que a gente criou aqui em cima. Salvo isso aqui agora, a gente vai lá no nosso app. Poderia ir direto na página, mas como a gente só tem uma página por enquanto, poderia botar aqui dentro, não vai ter tanta diferença. Eu vou botar aqui no app mesmo, o nosso Provider por volta aqui da página, TransactionsProvider. E agora, pronto. Aqui dentro, basta eu utilizar agora o nosso useContext. E aqui eu preciso exportar o nosso contexto. Então, TransactionsContext. Ah, eu escrevi TransactionContext. Então, TransactionsContext. Agora vem para cá de novo, importa. E pronto, daqui de dentro, só dar um Ctrl espaço, eu já tenho acesso às minhas transactions. E agora, posso salvar aqui, ver que está tudo funcionando normalmente. Agora, lá no meu componente de Summary, que é o componente de resumo aqui das transactions, eu posso ter acesso também, só eu importar tudo de novo, eu tenho acesso aqui dentro também agora, dando um console.log, aos dados da nossa transaction. E agora, com isso, eu posso simplesmente calcular aqui o... Eita, posso calcular aqui o resumo de entradas, saídas e o total sem problemas nenhum. É isso, bora continuar."
  },
  {
    "id": "412185ae-f091-4424-9dd9-258ab8e89617",
    "title": "Corrigindo erros de linting",
    "transcription": "O que a gente vai fazer nessa aula é corrigir os erros de linting aqui na nossa aplicação. Então, a gente criou a aplicação toda até agora sem instalar o eslint. Então, vai ser bem simples. A gente vai instalar aqui o eslint e a gente vai instalar também o arroba rocketseat barra eslint traço config. Ambos como dependência de desenvolvimento. Só aguardar um pouquinho. E aqui eu já posso ir criando. Vou criar um arquivo chamado .eslintrc.json. E aqui eu vou simplesmente escrever extends arroba rocketseat barra eslint traço config barra react. Salvo isso aqui agora. E agora, se a gente for aqui no nosso terminal e rodar npx eslint na pasta source arquivos com a extensão .tsx e .ts também, se eu der um enter nisso aqui, ele vai me retornar todos os problemas de linting que eu tenho no código. E se eu abrir esses arquivos aqui, ele vai sublinhar já em vermelho, caso a gente esteja com a extensão do lint instalada, todos os problemas que a gente tem de linting na nossa aplicação. Como daria um trabalho imenso ficar abrindo um por um e corrigindo, o que a gente pode fazer é aqui no nosso package.json a gente criar dois scripts. Um chamado lint, que ele vai executar exatamente isso que eu tinha executado antes, os dois pontos aqui, o eslint. E outro chamado de lint fix, que ele vai executar o mesmo comando, porém usando uma flag fix do eslint, que ele vai corrigir os problemas de forma automática. Então eu salvo isso aqui agora, se eu rodar npm run lint dois pontos fix, ele corrige todos os erros, ele só não corrige aqueles que ele não conseguiu corrigir de forma automática. Então a gente pode ver que só sobrou esses dois erros aqui, que é basicamente importações que a gente fez e não utilizou. Agora se eu rodo lint novamente, não tem mais nenhum erro no nosso código, e pronto, tudo já foi ajustado de forma automática, já colocou os parênteses aqui por volta, mudou tudo para aspa simples, removeu os pontos e vírgulas aqui no final das linhas, então já ajustou todo o nosso projeto."
  },
  {
    "id": "907c9a81-8f06-4feb-a293-db96fc118ade",
    "title": "Introdução",
    "transcription": "Fala Dev, nesse módulo a gente vai desenvolver mais um projeto, claro, utilizando o React para conhecer algumas ferramentas e alguns conceitos muito importantes dentro dessa biblioteca. Nesse módulo a gente vai desenvolver, claro, uma aplicação completa do total zero até o cem por cento, utilizando algumas ferramentas como o Styled Components, React Hook Form, Zod, React Halter DOM, a Context API do React. Vamos conhecer também sobre como utilizar alguns hooks do React mais avançados, como o Use Reducer. Também vamos falar sobre imutabilidade de uma maneira um pouco mais avançada, utilizando uma ferramenta chamada Imer. E a aplicação que a gente vai desenvolver aqui, ao longo de todo o módulo, é uma aplicação de Pomodoro. Então você já deve ter ouvido falar desse conceito. Pomodoro nada mais é do que a gente trabalhar em alguma tarefa por um tempo específico, totalmente focado, e depois a gente tira um tempo de descanso. Então aqui, geralmente, a gente faz intervalos, por exemplo, 25 minutos de trabalho, 5 de descanso, e a gente tenta fazer alguns ciclos desse, claro, no momento que a gente estiver trabalhando, sem se desconcentrar com qualquer rede social ou qualquer coisa assim. Aqui a pessoa vai basicamente digitar qual tarefa ela vai começar a trabalhar, por quanto tempo, e aí o timer vai começar a rodar a partir disso. Aqui a gente tem mais alguns exemplos de tela com estados diferentes, aqui a gente vai listar quais foram as últimas tarefas que esse usuário trabalhou, para caso ele queira continuar trabalhando nessa tarefa. Aqui o usuário vai poder interromper o timer, caso surja algum problema, digamos assim. O usuário vai poder também ver um histórico de todos os ciclos que ele já realizou, se o ciclo foi concluído, se ele foi interrompido, se ele está em andamento. E aqui a gente pode ver que a gente vai começar a trabalhar com algumas coisas que aplicações front-end precisam. A gente vai começar a trabalhar com telas rotas. A gente fala, então, uma tela de histórico e uma tela do timer. São duas visualizações diferentes, digamos assim. A gente vai começar a trabalhar com listagem de dados, com dados compartilhados entre várias telas. Então, tem muita coisa para a gente aprender aqui nesse modo. Então, bora codar!"
  },
  {
    "id": "a4f13ee7-0731-4db9-a680-b83cf7ab891f",
    "title": "Styled Components",
    "transcription": "Nesse projeto a gente vai começar utilizando uma ferramenta que a gente ainda não conhece, que é o Styled Components. O Styled Components é uma maneira de a gente estilizar as nossas aplicações em React, utilizando um conceito chamado CSS em JS. CSS em JS, como o nome próprio já diz, é a gente escrever o CSS da nossa aplicação no formato da linguagem, na sintaxe da linguagem JavaScript. Então vamos lá, vamos entender o que é o Styled Components e o porquê que a gente vai utilizar ele e que problemas que ele resolve. Então eu vou abrir um novo terminal e vou começar instalando aqui o Styled Components. Como a gente está utilizando o TypeScript, o Styled Components é um daqueles pacotes que ele não traz consigo as tipagens. Até se a gente acessar aqui no npmjs.com, a gente vai ver aqui que esse dt, até passando o mouse por cima aqui, que as declarações de tipagem desse pacote elas ficam num pacote separado, que é TypedStyledComponents. Nesses casos a gente sempre instala também TypedStyledComponents. Como dependência de desenvolvimento, a gente não vai precisar dessas tipagens em produção, porque em produção o nosso código sempre vai ser convertido totalmente para JavaScript. Então não tem relevância ter código TypeScript lá dentro. Agora com o Styled Components instalado, vamos entender o que o Styled Components resolve e por que faz sentido utilizar ele. Imagina que a gente tenha na nossa aplicação em algum momento, eu vou criar algo simples só pra gente exemplificar, uma pasta Components, dentro dela um arquivo button.tsx, que no caso é um componente de botão. Eu vou agora exportar uma função, button, e esse botão nada mais faz do que exportar o próprio botão do HTML, e eu vou escrever enviar aqui dentro, só a caso de visualmente a gente ter alguma coisa na tela. Aqui no lugar desse h1, eu vou simplesmente colocar um fragment, que é aquela div que na verdade não renderiza, não aparece no HTML, algo só pra gente colocar por volta dos nossos componentes. E aqui eu vou simplesmente importar o nosso botão, e a gente vai repetir ele quatro vezes em tela. A gente volta aqui no nosso navegador, e se eu for lá ver dentro do meu localhost, eu já vejo aqui os quatro botões em tela. E aí uma das coisas que a gente pode fazer, uma coisa que eu gosto de fazer, enquanto a gente ainda não tem CSS nenhum na aplicação, uma das coisas que você pode fazer também é utilizar o darkreader aqui do Chrome, a gente pode habilitar e ele já ficaria tudo escuro. Eu só não vou fazer isso aqui agora, isso aqui é só uma dica, porque a gente vai precisar ver o CSS e o darkreader pode acabar prejudicando o nosso CSS. Então eu vou ficar com essa claridade na tela mesmo, aqui no rosto, e depois a gente resolve isso. Agora que a gente já tem com os quatro botões, uma das coisas que é muito comum a gente precisar fazer dentro do React, é aplicar estilizações que elas são condicionais às propriedades que esse botão recebe. Então imagina que o nosso botão aqui, ele possa ter cores customizadas. Então imagina que aqui de dentro do app, eu precise passar de alguma forma para esse botão, opa, esse botão aqui tem uma cor, esse tem outra, esse tem outra e esse tem outra. Então isso é muito comum, geralmente a gente tem aplicações onde a gente tem várias cores, vários tamanhos de botões em lugares diferentes. E aí quando eu boto um botão que eu quero que ele signifique uma ação de prosseguir, de sucesso, eu coloco o botão verde por exemplo, uma ação de deletar eu boto o botão vermelho, uma ação neutra eu boto o botão cinza. Isso é muito comum em todas as aplicações. E o que acontece é que muitas vezes nessas aplicações o que a gente quer fazer é colocar aqui no nosso botão uma propriedade. Então a gente pode criar uma interface, botão props, falando que esse botão aqui ele pode receber, eu não vou colocar type porque type já existe algo no botão chamado type, que é pro type button, type submit, então a gente não vai utilizar, eu vou colocar color mesmo porque não existe um atributo color no botão original do HTML, nativo do HTML. E aí eu vou falar que essa color ela pode ser, ao invés de colocar simplesmente string eu vou falar quais cores a gente pode ter. Então eu posso ter uma cor primária, a primária geralmente é aquela cor que é a cor de brand, a cor da marca da nossa aplicação. Então no caso aqui da Roca esse seria o roxo, no caso do Ignite seria mais o verde, a gente puxa geralmente as aplicações do Ignite para esse verde. Cor secundária seria, como o próprio nome já diz, a cor que ela é, geralmente a gente escolhe uma cor análoga e tal, não tem porque a gente entrar aqui na parte interna da escolha de cores, mas geralmente é uma cor que acompanha a cor primária para ações secundárias. Aí a gente pode ter uma cor também, danger, que geralmente a gente usa, que é uma cor para ações de perigo, remoção, delete, que é o vermelho, geralmente a gente usa, e o success que é o verde. E a gente pode escolher até uma outra cor, por exemplo, neutral ou warning também para amarelo, neutral para o cinza, aqui a gente pode ter várias cores. Eu vou deixar quatro cores para ser mais simples, para a gente também não ficar entrando tão a fundo. E aí quando eu falo agora que esse botão aqui ele pode receber essas propriedades aqui, button props, olha só que legal, eu volto lá no app, claro ele já está falando que está faltando alguma propriedade, e eu posso até colocar essa propriedade como opcional Para caso o usuário não informe nenhuma cor, ele assuma talvez a cor primária como padrão, não sei, a gente pode escolher isso e definir o que a gente achar melhor. E aqui agora nos buttons eu posso passar uma propriedade color, ele até já aparece aqui, color. E aí quando eu coloco aqui as nossas aspas duplas ele já fala aqui as quatro cores que eu posso ter, então danger, primary, secondary e success. Eu vou começar colocando primary nesse primeiro, a gente vai começar colocando secondary nesse segundo, vamos colocar success no nosso terceiro botão, no quarto danger, e eu vou deixar um botão aqui sem cor, até porque a gente deixou isso aqui opcional, vai ser legal a gente validar que realmente pode ser opcional. E aí lá no botão agora vem a mágica né, quando a gente está utilizando o CSS tradicional sem utilizar nenhuma ferramenta de estilização específica, tudo o que a gente tem aqui dentro são as nossas classes, então se a gente quer estilizar esse botão, o que a gente geralmente vai fazer é criar aqui um button.module.css que é algo que a gente já viu né, sobre CSS modules, vamos criar aqui uma classe button, e aqui eu vou só para exemplificar, definir uma largura fixa e uma altura fixa para esse botão, a gente importa os estilos aqui dentro, e aí nós definimos através da classe desse botão styles.button, se a gente volta lá no nosso navegador, a gente já pode ver que o botão ficou um pouquinho maior até com base no tamanho que eu passei para ele. E aí agora se a gente quer uma cor de fundo diferente para esse botão, baseado nessa propriedade que a gente está recebendo, a gente também vai ter que trabalhar com as classes, e aí a gente teria que fazer algo tipo assim, aqui dentro do class name, como a classe é sempre uma string, a gente teria que botar o assento grave, para a gente fazer uma interpolação de strings dentro do javascript, e aqui eu falaria, olha, esse botão sempre vai ter a classe styles.button, e a próxima classe que ele vai ter depende da cor, então a gente pode ter um botão, por exemplo, styles, e aqui eu teria que pegar, mesmo com o objeto eu posso utilizar essa sintaxe de array, quando eu quero incluir uma variável, por exemplo, eu quero que eu tenha uma classe aqui que ela seja a cor, então aqui, por exemplo, styles.primary, só que esse primary aqui, ele vem de dentro das props, então eu preciso colocar aqui um cochete props.color, o que acontece é que isso aqui é opcional, então a gente vai precisar vir aqui e falar, olha, eu tenho uma cor para esse botão, e se essa cor não for passada, como ela é opcional, eu quero que o padrão seja primary, pode ser, e aí vamos ver, cannot find name props, porque a gente removeu o props aqui, agora é só color, beleza, agora eu volto lá no meu css, e a gente vai agora fazer o seguinte, eu vou criar uma outra classe aqui chamada primary, vou definir uma cor aqui purple, só para a gente visualizar, a gente vai ter uma outra secondary, eu vou botar aqui uma cor green, vai ficar feio pra caramba, mas não tem problema, não é esse o ponto agora, a gente vai criar aqui uma danger, eu vou botar aqui uma cor red, e a gente tem também uma classe success, que eu vou colocar uma color green também, e essa secondary aqui eu vou trocar para orange, para ela não atrapalhar a gente, eu salvo isso aqui agora e volto no nosso navegador, e a gente pode ver que a cor já trocou, na verdade eu queria que a cor fosse a cor de fundo, então background, beleza, ficou horrível, mas funcionou, então é muito comum a gente precisar fazer isso dentro do react, a gente ter estilizações que elas são baseadas em informações que vem dentro das propriedades, e é aí que brilha o styled components, a partir do momento que a gente utiliza uma ferramenta como o styled components, tudo isso aqui se torna muito mais simples, e a gente vai ver como que isso se torna mais simples, é claro que algumas coisas elas ficam mais complexas talvez, mas são complexas por um bom motivo, para a gente sentir mais facilidade em coisas que seriam ainda mais complexas no CSS tradicional, então vamos lá, vamos começar fazendo aqui, o que a gente vai fazer? Primeira coisa, eu vou trocar esse arquivo nosso CSS aqui, por também um arquivo JavaScript, então essa biblioteca styled components, toda a estilização que a gente vai criar, também vai ser código JavaScript, e aí o nome que eu vou dar vai ser button.styles.js, o nome aqui sendo bem, JS não, no caso TS, porque a gente está utilizando o TypeScript, não precisa ser TSX, porque dentro desse arquivo não vai ter nenhum componente, a gente só coloca TSX em arquivos que a gente vai ter aquela sintaxe HTML dentro do arquivo, e agora nesse TypeScript aqui, a gente pode ver que ele já está dando erro, porque isso aqui não são sintaxes válidas para dentro do arquivo TypeScript, e a gente vai começar aqui mudando um pouquinho, eu cortei esse código, eu não simplesmente deletei, eu vou começar importando styled from styled components, e agora veja só, eu vou começar daqui de dentro exportando uma constante chamada button container, o nome aqui tanto faz, a menos, a única coisa que não é tanto faz é que também precisa ter a primeira letra maiúscula, porque no final das contas isso aqui também vai ser um componente, o nome lembra styled components, são componentes estilizados, o que a gente está fazendo aqui agora é criar componentes React que são apenas abstrações de CSS, estilizações, e aqui eu vou falar, olha, esse button aqui, ele vai ser um componente estilizado, e aí eu preciso falar para ele qual elemento HTML esse button aqui vai ser, qual elemento HTML ele vai herdar, e a gente quer herdar o button tradicional do próprio HTML, e agora a gente vai utilizar uma sintaxe do JavaScript que se chama template literals, que nada mais é do que a gente simplesmente passar aqui para o styled button, esses dois assentos graves aqui, essas duas crases, e dentro dela a gente vai colocar o nosso CSS, é só importante que você esteja com a extensão do styled components instalada no seu Vascode, porque senão ele não vai aplicar aqui a sintaxe do CSS dentro desse bloco, então aqui dentro agora a gente pode colocar lá o nosso width 100 pixels e o nosso height 40 pixels, eu salvo isso aqui agora e volto lá para o meu botão tradicional, e agora olha o que a gente vai fazer, o que a gente vai mudar aqui dentro, eu vou tirar o class name daqui de dentro, e eu vou trocar essa tag button aqui agora pelo nosso button container, que vem de dentro do arquivo button styles, posso até remover o outro estilo que a gente estava utilizando aqui, e agora button container aqui também depois do enviar, se eu salvo isso aqui agora, veja que o meu botão continua com a altura e a largura diferentes, com a largura de 100 pixels e a altura de 40 pixels, ou seja, a gente ainda está com o nosso CSS aplicado, porém agora a gente está utilizando um componente estilizado, um styled component, e agora a gente quer simplesmente que essa cor aqui, ela afete a cor de fundo aqui do nosso button container, e aí olha que interessante, ao invés da gente passar uma class name aqui dentro para esse button container, que claro também funcionaria, quando a gente utiliza o styled component, o que a gente vai fazer ao invés disso, é passar realmente uma propriedade color, ou eu posso dar o nome que eu quiser, aqui eu vou chamar de color, mas poderia ser qualquer propriedade, e vou passar o nosso color aqui para dentro, então eu estou só pegando essa propriedade color que está vindo aqui das propriedades do nosso botão, enviado aqui pelo nosso app, e passando lá para o nosso button container, aqui ele não deu erro, porque eu estava errado, existe um atributo color nativo, então vamos trocar isso aqui, ao invés de color, qual que é o que a gente usa aqui na rocket, deixa eu olhar o que a gente usa aqui na rocket no botão, variant, então vamos usar variant, ao invés de color, vamos enviar como variant, e aí a gente pode ver até que ele já está dando erro aqui, vamos trocar aqui tudo para variant, a gente não precisaria, mas vamos trocar, lá no app também, variant, show, e agora a gente pode ver que ele está dando erro, porque claro, não existe uma propriedade variant nesse button container, como eu falei, isso aqui também é um componente no react, e a gente também precisa criar uma interface no nosso button container props, falando quais propriedades isso aqui recebe, e aí novamente, variant recebe todas essas propriedades aqui, e agora é um ponto importante aqui, porque a primeira coisa que você como programador ou programadora vai pensar agora, meu Deus, é a mesma coisa, eu estou repetindo, meu Deus, deixa eu criar uma variável para abstrair isso, porque eu não quero repetir código, calma, nem sempre a gente precisa levar essa coisa de não repetição de código tão a sério, porque se você for ver realmente, as propriedades aqui são diferentes, as propriedades aqui nesse caso das button props, a gente vê que a variante aqui é opcional, no caso dos estilos, não tem como a nossa variante ser opcional, porque mesmo que aqui ela seja opcional, quando ela é opcional aqui, quando não for passada, a gente já está setando ela como primary, ou seja, quando chegar aqui nos nossos estilos, ela nunca vai ser opcional, ela nunca vai estar vazia, então aqui ela não é, o que a gente pode sim, não repetir, são as nossas cores aqui, que essas são pré-setadas, então vamos lá, vamos criar aqui um tipo no typescript, e eu vou chamar de variant, ou talvez button variant color, não, button variant só, pode ser assim, e agora eu vou utilizar esse button variant aqui dentro, então a gente já criamos uma variável de tipagem para abstrair isso, vamos exportar isso aqui de dentro, para a gente conseguir acessar isso aqui fora desse arquivo de estilos, e lá no nosso botão também, aqui no lugar das cores, vamos botar button variant, que vem lá de dentro dos nossos estilos, show, feito isso aqui agora, nos nossos estilos, agora a gente precisa falar que esse button container, ele pode receber essas propriedades aqui, como que a gente faz isso no style do complements, eu vou copiar o nome button container props, e isso fica com uma sintaxe um pouco feia, eu confesso, mas funciona, a gente aqui antes, depois do button, depois do elemento HTML que a gente usa antes do acento grave, a gente vai colocar a sinal de menor e maior, e passar o nosso button container props, voltando lá para o botão, a gente pode ver que ele já para de dar erro aqui, só temos que trocar aqui para variant também, então já não temos mais erro nenhum, porém o CSS, claro, ele não foi aplicado, e agora o que a gente pode fazer aqui dentro? Olha que interessante, eu vou simplesmente criar aqui uma constante, chamada button variant, e eu vou falar, olha, para a nossa cor primária, eu quero que a cor de fundo do nosso botão seja purple, para a nossa cor de fundo secundária, eu quero que seja orange, opa, aqui não é ponto e vírgula, é apenas vírgula, para a nossa cor de fundo danger, eu quero que seja red, e success, eu quero que seja green, e agora, aqui dentro do nosso botão, eu vou fazer uma interpolação de string, olha só, eu vou simplesmente colocar aqui dentro uma interpolação, e o que o style do component faz para a gente é, toda vez que a gente coloca uma interpolação, ou seja, que eu faço essa sintaxe de, eu quero incluir um código JavaScript dentro de uma string maior, que é o que está aqui por volta dos nossos acentos graves, da nossa crase, o código que está aqui dentro, o style do component vai executar como uma função, e ele vai enviar para essa função todas as propriedades do meu botão container, ou seja, o meu botão container está recebendo aqui uma propriedade variant, essa propriedade variant vai vir aqui para dentro desse prop, e aí o que eu posso fazer aqui dentro, olha, eu quero colocar uma cor de fundo no nosso botão, ou até para a gente visualizar isso aqui melhor, podemos colocar chaves aqui por volta, com um return, vai dar na mesma, e essa cor de fundo aqui, ela vai ser a nossa button variant, usando a nossa props variant como chave, ou seja, a props.variant aqui é o que está vindo aqui do nosso botão, ela pode ser primary, secondary, e aí eu estou correndo aqui no nosso objeto, usando a chave, o que está vindo lá da variant, e aí ele vai setar purple, orange, red, green, aqui no background color, a gente salva isso, eu volto lá para o Chrome, e a gente pode ver que a cor de fundo está aplicada, então como eu falei, o estado do component traz um pouco mais de complexidade, mas lá no nosso componente, a gente vai ver que o nosso código fica muito mais simples, a gente não vai precisar ficar trabalhando com múltiplas e múltiplas classes para ficar controlando a estilização, é claro que isso aqui é um exemplo muito simples, mas existem componentes, por exemplo, aqui que a gente tem no Design System da Rocket, que ele tem umas 8 propriedades que mudam as estilizações do componente, imagina a gente fazer tudo isso com classes, não fica tão legal, por isso que a gente usa essas ferramentas como o style.components, não existe só o style.components, mas com certeza, se você for trabalhar com React no mercado em algum momento, você vai precisar utilizar o style.components, escreve o que eu estou falando, porque grande parte das empresas usam essa ferramenta, e por mais que a sintaxe talvez fique um pouco diferente, você vai se acostumando com o tempo, a gente fez um exemplo até mais complexo aqui, não é um exemplo tão simples, mas isso aqui é muito legal, o que a gente pode fazer só, último ponto para melhorar, a gente pode ver que o background-color aqui não ficou com aquela sintaxe, com a corzinha aqui do CSS, e aí para isso a gente pode importar aqui do style.components o CSS, e aí é só botar aqui CSS antes da classe e já está funcionando, a gente já pode ver que está tudo certinho, volto lá e pronto, não mudou nada no código, porém agora o nosso código já está todo certinho, inclusive eu poderia dar um enter aqui para ficar até melhor, e escrever o background-color aqui dentro, a gente salva e pronto, nosso código já está finalizado."
  },
  {
    "id": "69a1e6ad-c8c0-47fc-a156-e390c959abbb",
    "title": "Aplicando React Hook Form",
    "transcription": "O que a gente vai fazer nessa aula é configurar o React Hook Farm nos formulários da nossa aplicação. Então hoje a gente tem dois formulários, o formulário de busca, que é muito simples, é só um campo de busca, e a gente tem o formulário de nova transação, a gente vai configurar o React Hook Farm em ambos esses formulários aqui. Bora começar com o formulário de busca, que é o mais simples, mas antes eu vou instalar algumas bibliotecas aqui para trabalhar com o React Hook Farm. A primeira é o próprio React Hook Farm, e a gente também vai instalar o Zod, que é a ferramenta que a gente vai estar utilizando para a validação dos nossos formulários. E o Zod não funciona só necessariamente para a validação, ele funciona também para a definição do esquema do formulário. O esquema é basicamente qual é o formato do objeto de dados que a gente vai receber quando realizar um submit desse formulário. Então é super importante utilizar o Zod, mesmo que você não tenha necessariamente uma validação nos campos. Então aqui no Search Farm a gente vai começar criando o nosso formulário. Então com o React Hook Farm a gente escreve simplesmente o UseForm, e aqui dentro do UseForm a gente precisa passar qual é o nosso DefaultValues e tudo mais. Mas aqui no UseForm eu vou pegar o Register, e vou pegar também a nossa função handleSubmit. E aqui no nosso input a gente vai dar alguns Enters aqui só para ficar mais fácil. E nós vamos colocar a função Register passando o nome do campo, que nesse caso aqui eu vou chamar de Query. Geralmente quando a gente faz uma busca, e essa busca não é em um campo específico, eu vou buscar em vários campos de um registro ao mesmo tempo, a gente usa Query, ou até Search mesmo, eu acho que Query fica mais amigável. E aqui no nosso Search Farm Container, lembrando que isso aqui é a nossa Tag Farm em si, eu vou colocar o nosso onSubmit, handleSubmit, e aqui eu vou criar uma função aqui em cima, só por enquanto, eu vou chamar ela de handleSearchTransactions. Lembrando que ações que são disparadas através de alguma ação do usuário, seja um Submit, Click, Blur, qualquer coisa assim, eu gosto de iniciar o nome da função com handle, e assim fica mais fácil para eu saber que essa função foi disparada através de uma ação do usuário. Funções que são disparadas através de Side Effects, ou simplesmente são chamadas pela minha própria aplicação, eu gosto de chamar elas, por exemplo nesse caso, de só Search Transactions, para eu saber que não é uma função que vai ser disparada através de um evento. Então é só um pouco de Patterns aplicado dentro do React. E aqui então eu boto a nossa função handleSearchTransactions, e aqui agora eu vou criar o nosso esquema do formulário utilizando o Zod. Então eu vou importar tudo as z from Zod, e aqui eu vou criar então o nosso esquema, eu vou chamar ele de searchFarmSchema, é igual a z.object, ele vai ter um único campo, que é o query, e é z.string. Não tem mais muito o que eu colocar aqui. Agora eu vou criar a tipagem do nosso formulário, e como eu estou usando o Zod, eu posso utilizar a função que o Zod traz, uma função do TypeScript, chamada z.infer, passando a tipagem do nosso searchFarmSchema. Isso aqui vai basicamente retornar qual que é a tipagem dos campos do nosso formulário. Então como eu botei aqui a query sendo uma string, ele retorna exatamente query.string. Se eu tivesse mais algum campo, ou isso aqui fosse number, por exemplo, ele já ia trocar para number aqui dentro. Então uma integração com TypeScript bem legal. E aqui no useFarm agora então, eu dou um menor e maior, passo o nosso searchFarmInputs, vou precisar instalar mais uma biblioteca que eu acabei esquecendo, que é o hookFarm-resolvers. Aguardo um pouquinho a instalação dessa lib aí. E agora aqui dentro eu passo ZodResolver, que ele acabou não conseguindo importar automaticamente, então importo ZodResolver from hookFarmResolvers-zod, e aqui ZodResolver searchFarmSchema. E aqui embaixo, no handleSearchTransactions, eu vou receber os dados, que são na verdade o valor dos meus campos aqui do formulário, e o formato desses dados é o nosso searchFarmInputs, que é a tipagem que eu peguei aqui. Por enquanto eu vou dar só um console.log pra gente visualizar que deu tudo certo. Salvo isso aqui, voltamos aqui no Chrome, inspeciono, dou um console, venho aqui, escrevo, por exemplo, test, dou um buscar, e está ali, query.test. Então ele já está retornando os dados. Uma outra coisa que eu poderia fazer aqui pra deixar isso mais charmoso, digamos assim, eu vou dar um enter aqui na desestruturação do useForm, e eu vou pegar do formState, eu vou desestruturar uma propriedade interna, aqui que no caso é o formState, e eu vou pegar a informação isSubmitting. Essa informação, essa variável, ela vai me retornar um true ou false, dizendo se o formulário está em estado de submit, ou seja, está enviando ainda as informações ou não. E aí uma das coisas que eu gosto de fazer é ver aqui e desabilitar o botão quando eu estiver em submitting, enquanto ele ainda estiver enviando. Como eu só tenho um console.log, eu praticamente não vou conseguir visualizar isso aqui, porque é muito rápido. Então uma das coisas que eu poderia fazer, que é legal, olha só, eu posso transformar essa função aqui em uma função assíncrona, a handleSearchTransactions, e eu posso simular aqui uma requisição para uma API, fazer algo demorar aqui dentro. Olha que legal, eu posso dar um await, vou criar uma nova promessa, e eu vou resolver essa promessa depois de dois segundos. Olha que interessante isso aqui, eu estou criando uma promise, e aí o resolve da promise, que é para dizer que deu tudo certo com a promise, eu vou chamar esse resolve depois de dois segundos. Então eu salvo isso aqui agora, e lá nos meus estilos do search form, eu venho aqui no botão, e eu falo o seguinte, quando esse botão estiver disabled, eu vou diminuir a opacidade dele para 0.7. E o estado de hover aqui eu vou aplicar somente se ele não estiver desabilitado, senão não faz nem sentido o usuário poder fazer hover no botão que está disabled. Salvo isso aqui agora, voltamos lá de novo, e agora quando eu clico em buscar, está vendo que ele fica, e agora ele voltou. Deixa eu fechar o console aqui para não ficar dando aqueles glits na tela. E aqui está faltando um cursor pointer no nosso botão. Vou fazer o seguinte, cursor pointer, e quando ele estiver disabled, eu vou botar o cursor not allowed. Vamos lá, clico aqui agora, olha que legal, ele já desabilitou, e depois ele volta. Poderia até diminuir um pouquinho mais a opacidade, talvez 0.6, vamos ver se fica melhor. Ah, chegou, já está, legal. E é isso, a gente já terminou o nosso search form, e agora a gente vai acionar o formulário no nosso new transactions modal. Então, bora lá, eu vou começar importando tudo as Z from Zot. Vou começar criando o nosso esquema, aqui então é new transaction form, esquema, é igual a Z.object. Aqui a gente tem basicamente quatro informações que a gente vai ter dentro do nosso esquema. A primeira delas é a description, que é uma Z string. Nós vamos ter o price, que é um Z.number. Vamos ter a categoria, que é um Z.string. E o tipo da transação, que ele vai ser um ou outro, e nesse caso a gente pode usar o enum do Zot. E aí eu falo dentro do enum, passo um array, quais são as opções. Então ele pode ser income ou outcome. O enum a gente usa para uma enumeração, a gente usa para quando a gente tem um valor, que ele tem que andar dentro de certas opções, digamos assim. E como a gente só vai ter tipos de transações de entrada e saída, é melhor usar assim do que usar a string. E aqui eu vou também pegar agora type new transaction form inputs, eu botei inputs ou input, inputs, tá bom, igual a Z.infer type of new transaction form, esquema aqui. E agora a gente vai fazer todo o restante aqui, então é const, igual a use form, imported reactor form, aqui eu passo resolver, Zod, resolver, agora ele já importou, new transaction form, esquema, aqui eu pego o nosso register, o handle submit, vou dar um enter aqui, porque depois eu vou precisar pegar mais coisas, aí já tá mais fácil. E aqui agora eu vou jogando os nossos register, então aqui eu vou quebrando as linhas, e aqui eu vou botar o nosso register, aqui a gente vai jogando, opa, esqueci um pontinho a mais aqui no começo, agora como eu tenho tipado já aqui o meu schema, quando eu dou um ctrl espaço aqui em cima ele já fala quais são as opções, no caso esse aqui vai ser o description, esse vai ser o price, e esse vai ser o nosso category. O price como ele é um tipo número, eu venho aqui e coloco um value as number como sendo true, assim ele vai converter o valor desse input pra número. E aqui a gente tem um último campo que é esse de entrada e saída, que a gente precisa passar o valor pra dentro do nosso formulário, mas a gente já vai fazer isso. Então aqui no nosso formulário agora eu vou colocar o nosso onSubmit, ele vai chamar o nosso handleSubmit aqui, e aí eu vou ter uma função handleCreateNewTransaction, ela recebe o data, que o formato é o newTransactionFormInputs, e aqui eu vou dar simplesmente um console.log o nosso data, e aqui eu vou chamar essa função aqui. Vou transformar isso aqui em uma função assíncrona também, vou roubar aquele awaitNewPromise e jogar aqui dentro, só pra gente simular uma leve lentidão, e aqui no nosso botão a gente vai ter também aquele nosso disabled, igual a gente fez no outro campo, e agora a gente vem aqui nos estilos, dentro do nosso content, form, input, botão submit aqui, eu venho no disabled, opacity 0.6, cursor not allowed, e aqui eu aplico o hover somente quando não estiver disabled. Salvo isso aqui agora, voltamos lá, nova transação, deixa eu abrir aqui o nosso inspecionar elemento, console, preencho aqui, qualquer coisa, qualquer coisa, cadastrar, tá, já sei o que aconteceu. Aqui no nosso newTransactionModal, como a gente falou que esse campo type é obrigatório, e a gente ainda não preencheu, ele tá falhando a validação. Por enquanto eu vou comentar esse campo type, até porque a gente não registrou esse campo ainda, eu vou te mostrar isso como fazer daqui a pouco. Salvo isso, voltamos, cadastrar, ah, deu certo. É só porque como eu coloquei aquele delay de 2 segundos, pra ver o input ali, o input tá ficando opaco, eu não consigo clicar de novo, e aí depois ele já me traz os dados, então a gente já configurou o ReactHookFarm certinho nos dois formulários da nossa aplicação."
  },
  {
    "id": "72322612-0d3c-4307-805e-1f8501316225",
    "title": "Componente: SearchForm",
    "transcription": "Nessa aula, a gente vai construir esse nosso formulário de busca. Esse formulário em si, ele provavelmente vai existir somente dentro da página de transações, que, por enquanto, é a nossa única página, mas eu já vou criar uma pasta com valentes aqui dentro e vou criar esse formulário de busca aqui dentro. Então, search farm. Estou um pouco ofegante, porque fui lá brincar com o meu cachorro, que ele estava latindo pra caramba. E vou criar aqui um arquivo styles.ts. Esse search farm, nada muito especial do que a gente já não conhece. Vou botar uma div aqui por volta, por enquanto. E aqui eu já vou começar uma breve estilização. Vou chamar de search farm container igual a styled. Deixa eu pensar aqui. A gente só tem um input e um botão, então o próprio container já pode ser o próprio farm. Porque não tem mais nada dentro do search farm, a não ser o formulário em si. Vou começar dando um display flex gap 1rem, porque eu quero que o espaçamento entre o botão e esse carinha aqui seja de 1rem. E aí eu vou fazer o seguinte. O input, eu quero que ele tenha flex 1 para ele ocupar o espaço todo. O button não precisa. Então o input vai ocupar o máximo de espaço possível e o button vai ocupar o espaço que ele precisa ocupar. O border-radius, vou botar de 6 pixels, border 0. Vamos colocar aqui um background-color um pouco mais escuro no nosso input em si. Então props-theme, vou botar um grey 800, porque a cor de fundo da aplicação é grey 800. O color aqui a gente também vai mudar para grey 300. E a gente vai botar um padding de 1rem aqui dentro do nosso input. Vou também pegar o placeholder do input e vou colocar uma color nele de grey 500, que é um cinza um pouquinho mais escuro. E aqui agora, vou pegar diretamente o nosso botão, vou estilizar ele. Esse botão aqui, ele tem algumas coisas parecidas com esse botão aqui de cima, mas não tem muita coisa a ver. Se eles fossem exatamente iguais, eu poderia pensar em criar um componente para abstrair isso, mas aqui não tem tanta necessidade. Esse botão, como ele tem um ícone, eu vou botar um display flex nele, porque fica mais fácil para alinhar o ícone e o texto, principalmente quando eles não tem o mesmo tamanho. Eu vou botar um gap de 0.75rem, que vai dar aqui nesse caso 12 pixels, a diferença entre eles. Vou começar adicionando aqui algumas estilizações padrão. Então, um padding de 1rem, border 0. Aqui a gente pode botar um background transparent, porque ele não tem fundo. E a gente vai botar um border 1px, solid. Props, theme, green 300. Aqui a gente vai botar a cor do texto também, green 300. Aqui a gente vai botar um font-weight bold e um border radius de 6px. Às vezes você vê que eu digito CSS bem rápido, mas algumas dicas que eu posso te dar, é por exemplo, eu quero escrever border radius, eu escrevo as duas primeiras letras, por exemplo, da palavra border e as duas primeiras de radius. Então, dou um borre, por exemplo, a primeira sugestão vai ser border radius. E por aí vai, você pode ir fazendo isso com várias coisas. E aqui eu vou dar 6px. O que mais que a gente pode fazer aqui dentro? Talvez um hover? Então, hover, o que a gente pode fazer de hover? Se a gente for ver aqui no Figma, dentro de assets, ele tem o hover aqui. O hover é basicamente fazer com que o botão fique preenchido. Então, eu vou mudar essas três propriedades aqui. E aí, a propriedade do background vai ser o green 500. A borda eu vou trocar a cor também pro green 500. O tamanho não precisa mudar. E o texto eu mudo pra white. No caso aqui, white. Dessa forma tá bom. E aqui eu vou botar um transition. Tanto no background color de 0.2 segundos, quanto no próprio color de 0.2 segundos. E talvez no border color também de 0.2 segundos. Então, a gente consegue adicionar. Se quiser, pode quebrar a linha pra ficar mais fácil de visualizar. Dessa forma. Mas, tudo faz. Salvo. Voltamos ao nosso search form. E agora, a gente vai começar a criar o HTML. Então, search form container. Vamos ter um input. Esse input vai ter um placeholder, que vai estar escrito... Busque uma transação. Busque uma transação eu acho que não fica tão legal. Busque por transações. Talvez fica melhor. Porque pode retornar mais de uma. E aí, além desse input, nós vamos ter um button. Submit. Que dentro dele vai estar escrito buscar. E ele vai ter um ícone. Dentro dele. Que é o magnifying glass. E esse ícone vai ter um tamanho de 20. Salvo. Volto ao Chrome. Vamos dar uma olhadinha. Não tem nada aqui porque eu não coloquei esse search form em nenhum lugar. Então, eu venho aqui dentro de transactions container. Antes da nossa tabela. E eu coloco o nosso search form. Salvo aqui. Beleza. Já tá ali. Agora eu volto aqui na minha estilização da página de transactions. E habilito esse margin top aqui no meu transactions table. Pra ele distanciar um pouquinho aqui do input. Show de bola. Tá bem certinho. Conforme a nossa estilização. Claro, nada funcional ainda. Mas já tá bem bonito. A gente já consegue visualizar. Essa parte. Até um ponto aqui. Essa parte de paginação. Eu não vou fazer. Ela não vai adicionar muito conhecimento novo. Então, eu não vou fazer essa parte de paginação em si. Mas fica como um desafio aí pra você depois que terminar a aplicação. Incluir essa parte de paginação. Mas eu vou partir direto pra estilização desse modal. E aí, a gente já vai pra parte de funcionalidade da aplicação. Começar a fazer chamadas API. Começar a entender a integração aqui do nosso front-end com o back-end. Começar a entender quais bibliotecas que a gente vai utilizar pra isso. Então, tem bastante coisa legal que a gente ainda vai ver."
  },
  {
    "id": "ca25b073-c1c1-44d9-946c-338885ec34aa",
    "title": "Tipagem de temas",
    "transcription": "Uma das coisas que a gente pode ver aqui no nosso CSS é que por mais que lá no nosso tema a gente tenha falado que a gente tem cores white, primary e secondary, lá nos nossos estilos, quando a gente escreve props.theme e escreve aqui o ponto, ele não completa pra gente, ele não fala, olha, tu tem aqui as opções white, primary e secondary, então ele não integra ao TypeScript de forma automatizada quando a gente cria esses temas customizados. A gente precisa meio que dizer de forma manual para o Style.components, olha, essas aqui são as propriedades que eu tenho dentro do meu tema que o usuário, que o desenvolvedor ou desenvolvedora vai poder utilizar ali dentro do CSS. Então o que a gente vai fazer? Quando eu estou utilizando TypeScript nos meus projetos, eu tenho a possibilidade de criar arquivos de tipagem específicos da minha aplicação, customizados para a minha aplicação. Então o que eu quero dizer com isso? Eu vou criar aqui dentro a pasta search, vamos criar primeiro e depois a gente vai entender o que a gente está fazendo, eu vou criar aqui dentro uma pasta arroba types, o nome da pasta não precisa ser esse, pode ser qualquer nome de pasta, por que eu botei arroba types? Porque ele vai ficar bem em cima, então arroba types vai ficar sempre no começo, porque o arroba sempre ordena as pastas aqui no caso o VSCode por ordem alfabética, então o arroba fica em cima, e ele fica com o ícone do TypeScript, então isso é interessante. E aqui dentro eu vou criar um arquivo chamado styles.d.ts, o que é o d.ts? O d.ts quer dizer que dentro desse arquivo eu só vou ter código de definição de tipos do TypeScript, e nunca código JavaScript ou qualquer outra coisa assim. Então por exemplo, lá no meu botão, se esse arquivo aqui, button.tsx, fosse um arquivo d.ts, a extensão, a única coisa que ele poderia ter aqui dentro é isso aqui, a interface, que é o único código que é específico do TypeScript. Isso aqui, por exemplo, é um código que está integrado ao TypeScript, mas na verdade é um código JavaScript, por aí vai, o TypeScript em si só está adicionando novas funcionalidades aqui dentro. Mas isso aqui é totalmente TypeScript, então aqui dentro desse arquivo eu só vou poder ter código totalmente TypeScript, a gente chama isso aqui de um arquivo de definição de tipos, é um arquivo que só tem tipagem. O que a gente vai fazer aqui dentro? Eu vou importar style.components, eu vou importar o meu tema default, que vem lá de dentro de styles-themes-default, e aqui eu vou chamar de default-theme, que é como ele está exportando lá de dentro, e aqui, olha que interessante, se eu passo o mouse em cima de default-theme, olha só, está vendo que ele retorna aqui do lado de default-theme esse objeto aqui, white-primary-secondary, string, string, string, ou seja, isso aqui é a tipagem desse default-theme. Isso aqui é criado meio que de forma automática pelo TypeScript, mas existe uma forma de eu acessar isso e guardar isso dentro de uma variável. Olha só, a gente pode escrever aqui, type, theme, type, aqui eu posso dar o nome que eu quiser, novamente, igual, e aqui eu uso uma chave, uma função específica do TypeScript chamada typeof, e aí eu escrevo o nome da variável do JavaScript em cima. Agora olha só, se eu passo o mouse em cima do theme-type, olha só, white-primary-secondary, a mesma coisa que estava sendo retornado lá dentro. Então eu estou guardando esse valor inferido aqui de forma automática pelo TypeScript, de quais são as propriedades que existem dentro do meu tema, dentro dessa variável theme-type. Isso aqui, sim, é complexo, principalmente se você está vendo o TypeScript pela primeira vez aqui no Ignite, mas é o tipo de coisa que dificilmente você vai decorar. Até hoje eu não decorei isso aqui, eu não fico salvando isso na minha cabeça porque é um negócio bobo, eu vou criar uma vez por projeto. Então é uma coisa que eu mantenho um exemplo no meu GitHub de algum projeto, e eu simplesmente copio em todos os outros projetos que eu vou utilizar styled-components. Então isso é muito comum, nem sempre você vai precisar decorar tudo que você vai codar. Muitas coisas você vai copiar de projetos já existentes, e é por isso que é tão interessante você ter um portfólio sólido, um portfólio bem completo. E aqui dentro agora, o que eu vou fazer? Eu vou escrever declare module styled-components. O que esse declare module está fazendo? Ele está falando, olha, eu estou criando uma tipagem para o módulo styled-components do npm. E aqui, o que isso aqui vai fazer? Toda vez que eu importar o styled-components em algum arquivo, como eu estou fazendo aqui dentro, a tipagem que ele vai puxar, a definição de tipos do TypeScript que ele vai puxar, é o que eu defini aqui dentro. Como eu estou querendo apenas sobrescrever alguma coisa lá de dentro, e não criar toda uma tipagem nova, por isso que eu importei o styled-components aqui e declarei ele. Se eu não tivesse importado, eu estaria meio que criando do zero a definição de tipos do pacote styled-components. Mas eu não quero isso, eu quero pegar o que já tem e colocar alguma coisa nova, sobrescrever alguma coisa. E o que é que eu vou sobrescrever aqui dentro? Se a gente voltar lá no button styles e eu passar o mouse aqui por cima de fin, a gente dá um ctrl aqui e eu clico em cima do fin, ele fala que ele está utilizando essa propriedade aqui, fin props, essa propriedade fin props aqui, a gente pode dar uma olhada aqui dentro. Só que se eu for procurar um pouquinho mais profundamente aqui dentro, existe algo dentro do styled-components que se chama default fin, isso aqui é a tipagem do styled-components, é só o código typescript do styled-components. E aqui, está vendo que essa propriedade está vazia, essa interface, default fin? Porque o styled-components, por padrão, ele até bota aqui, unfortunately, there is no way to write tests for this, tal, tal, tal, tal, tal, e aqui ele basicamente fala que é essa interface que a gente vai utilizar para falar quais são as nossas propriedades dentro do nosso tema. Então, aqui de dentro, a gente vai exportar essa interface de novo, e o que a gente quer é simplesmente que essa interface, ela estenda o nosso fin type, e aí ela pode ficar em branco mesmo. Agora, passando o mouse por cima desse fin type, a gente espera que o nosso tema tenha essas três propriedades aqui. Olha só, vamos voltar lá para o nosso botão styles, agora eu apago aqui o nosso primary, e agora se eu boto o ponto, olha só, primary, secondary e white. Ele já entendeu quais propriedades eu tenho dentro do meu tema, e aí eu posso clicar aqui e pronto. E aí, se eu tentar usar uma propriedade que não existe, ele dá erro, isso que é o mais legal. Então, a gente fez a total integração do styled-components com o typescript. Novamente, isso aqui, claro, não é um negócio tão simples, principalmente se é seu primeiro contato com o typescript, mas é o tipo de coisa que, sendo bem sincero, não vale a pena você se preocupar em entender a complexidade disso, não é algo que você vai ver muitas vezes no seu dia-a-dia. Eu sou bem sincero que a única vez que eu precisei fazer isso foi utilizando o styled-components, nenhuma outra biblioteca eu precisei fazer isso, então no seu dia-a-dia dificilmente você vai fazer. Mas é algo interessante você saber que a gente pode, sim, sobrescrever tipagens de uma biblioteca existente, como a gente fez aqui no styled-components."
  },
  {
    "id": "da7932bd-5ec0-458f-ac29-ae00aa6be5ad",
    "title": "Configurando temas",
    "transcription": "Uma das coisas legais aqui do Styled Components é que ele permite a gente fazer a gestão de temas na nossa aplicação. Então no CSS tradicional a gente tem variáveis para fazer isso e aí a gente pode cadastrar variáveis de cores e tudo mais e na maioria das vezes a gente cria lá o tema light e o tema dark. Só que no Styled Components a gente pode ter quantos temas a gente quiser e esses temas eles são controlados também por Javascript. E aí como é que a gente faz isso, né? Eu vou começar aqui na pasta source, começando criando uma pasta styles, dentro dessa pasta eu vou criar uma pasta chamada themes e dentro dessa pasta eu vou criar um tema, eu não vou chamar nem de light nem de dark, eu vou chamar de default, que é o tema padrão. E aí depois se a gente quiser criar outras variações desse tema, não tem problema. Nesse tema default aqui, o que a gente vai fazer, tá? Start const default theme e aqui eu posso colocar em formato de variáveis Javascript, objetos Javascript, cores, né? Então por exemplo lá, nossa cor primária é purple, né? Aqui a gente pode ir colocando variáveis, né, propriedades, CSS, propriedades Javascript, como a gente preferir. Então aqui a gente pode ir colocando, por exemplo, isso aqui, tá? E agora o que a gente vai fazer? Lá no nosso app, eu vou simplesmente, aqui, importar de dentro do style component um carinha chamado theme provider. E agora, aqui por volta dos nossos botões, eu vou colocar o theme provider, ou seja, o tema ele só vai ser aplicado para componentes que estiverem dentro do theme provider. Então aqui, eu vou botar theme provider aqui e também aqui por fora. Antes a gente tinha o fragment, mas o theme provider pode ser colocado no lugar do fragment, porque o theme provider também no final não vai ser uma div, nem nada disso, então não vai atrapalhar a gente. E esse theme provider, como ele é um componente, ele recebe uma propriedade chamada theme, e eu vou passar pra ele o nosso default que a gente tinha cadastrado lá. E pronto, a gente pode ver já que ele não está dando mais erro nenhum aqui. E agora, o que a gente vai fazer? Lá no nosso botão, veja só que interessante, lá no nosso botão container, na verdade, na estilização do style component em si, a gente consegue acessar essas variáveis que a gente colocou aqui dentro. Como que a gente faz isso? Por exemplo, eu vou até comentar esse código que a gente tinha colocado anteriormente aqui das props, todos os botões vão voltar para a estilização original, a gente não vai utilizar esse botão depois, por isso que eu estou bagunçando ele mesmo, depois a gente vai criar novas coisas com tudo isso que a gente está aprendendo para fixar esse conhecimento. E aqui agora eu vou fazer o seguinte, olha, eu quero que a cor de fundo desse botão aqui, ela seja a nossa cor primária que está cadastrada aqui no tema. Como que a gente faz isso? Da mesma forma que eu fiz aqui embaixo, que eu posso acessar as nossas props, as nossas props aqui, dentro dela o style component coloca para a gente props.theme, eu consigo acessar o meu tema aqui de dentro, e aí do meu tema eu quero a cor primária, que foi a cor que eu cadastrei aqui, primary. Se eu salvo isso aqui agora, a gente vai ver que todos os botões ficaram roxos, porque ele está pegando a cor primária que vem lá do meu tema, se eu troco aqui a cor primária por uma cor, por exemplo, 8257e6, que é um roxinho, a gente salva isso aqui, volta, e a gente vai ver que agora já está aplicado aqui. E aí a gente consegue cadastrar quantas cores a gente quiser, se a gente quiser cadastrar uma cor branca aqui, white, que é só fff, voltar aqui e falar, olha, a cor do botão vai ser props.theme.white, eu salvo aqui agora e a gente vai ver que ele já aplicou a cor branca aqui. E aí, claro, a gente pode ir aplicando outros CSS aqui, eu não vou ficar aplicando muitos CSS aqui no nosso botão, até porque não é um intuito aqui, só para não ficar muito feio, a gente já consegue aplicar alguns CSS aqui para ele ir melhorando. Então, basicamente o StartComponents funciona com essa funcionalidade de temas para a gente adicionar quantos temas a gente quiser na nossa aplicação. Por mais que a aplicação que a gente vai criar aqui no Ignite, ela vá ter apenas um tema, para a gente fazer a transição dos temas é muito simples, é só a gente ter um outro arquivo de tema, então ao invés de ter um default, eu poderia ter um tema default e outro light, por exemplo, que seria o tema claro. E aí no nosso app, a gente só precisa alternar essa propriedade, usando o estado do React, alguma coisa assim, para trocar ela entre uma e outra, através de um clique no botão, por exemplo, o usuário clicou para trocar o tema para light, eu troco essa default por light-theme. Então, é super simples e toda aplicação vai ser responsiva a isso, eu troco o tema, toda aplicação já troca as cores de forma totalmente automática."
  },
  {
    "id": "719bf36c-ce66-40d6-8906-754f3b0bc95c",
    "title": "Cores & fonte",
    "transcription": "Nessa aula o que a gente vai fazer é definir qual vai ser a fonte que a gente vai utilizar nesse projeto e também as cores que a gente vai estar utilizando aí nesse app que a gente vai estar desenvolvendo. Primeiro, claro, a fonte que a gente vai estar utilizando é a fonte Roboto, eu posso importar essa fonte do próprio Fonts Google, então aqui vou até desselecionar a fonte que eu já tinha selecionado pra ficar em branco aqui, e a gente vai estar utilizando a fonte Roboto, deixa eu ver os tamanhos que a gente vai estar utilizando ela, tá? Nós vamos estar utilizando a Roboto no tamanho 400, então seleciono aqui o regular 400, no 700, aqui é o bold, seleciono aqui também, select this style, e a gente vai estar utilizando uma outra fonte também, posso inverter minha câmera aqui, a gente vai estar utilizando também uma outra fonte que também é da Roboto, só que o nome é Roboto Mono, então a gente procura aqui o Roboto Mono, que ela é a fonte Roboto, porém Mono espaçada, Mono espaçada quer dizer que todos os caracteres da fonte têm sempre a mesma largura, e isso facilita pra gente quando a gente precisa trabalhar com textos que a gente não quer que o container desse texto modifique o seu tamanho baseado em qual caractere tá ali, o i é menor, o m é uma letra maior, então a gente usa uma fonte Mono espaçada, e a gente vai estar utilizando a Roboto Mono, a gente vai utilizar ela só no tamanho 700, que é o bold, então aqui ó, Roboto Mono Bold 700, seleciono, e aqui agora eu vou importar esse, o que tá aqui no nosso index, vamos voltar a câmera aqui pra como tava antes, show, voltamos aqui no nosso VSCode, a gente vai lá no nosso index HTML, e a gente coloca aqui o HTML que ele gerou pra gente, deixa eu só dar um tab aqui, e aqui eu vou fazer esses dois links aqui, eu vou importar lá em cima, quanto antes vier esses dois carinhas aqui melhor, porque ele já vai criando aí uma pré-conexão com o servidor da Google pra carregar as fontes, carrega mais rápido daí, e aqui esse outro link aqui que é das fontes mesmo, pode ficar no final, não tem tanta necessidade de ficar lá em cima, e agora aqui embaixo, aqui nesse link também eu vou botar essa barrinha aqui no final, que eu gosto, como um padrão, todas as tags que elas não tem uma tag de fechamento, eu vou colocar essa barra aqui no final, salvo isso aqui agora, a gente volta aqui nos nossos estilos globais, e eu vou definir que pro body, pro input, pro textarea e pro button, a gente vai ter uma font-family, por padrão Roboto, e se a fonte Roboto não conseguir ser carregada, a gente bota uma fonte sem serifa qualquer, aí a font-weight normal vai ser 400, e o font-size, 1rem, é o padrão que a gente vai estar utilizando. E aí agora que a gente já definiu as fontes, a gente vai definir também as cores que a gente vai estar utilizando pra nossa aplicação lá no nosso tema, e aqui eu já copiei todas as cores que estão lá no Figma, no layout dessa aplicação, e eu coloquei já em variáveis pra facilitar, então eu vou dar um ctrl-v aqui, mas pra você não precisar copiar e colar isso aqui, eu vou deixar como aqui embaixo da aula, pra você copiar isso aqui, pronto. Então a gente vai ter a cor branca, vários tons de cinza, isso é padrão em qualquer aplicação que tenha tema dark, tons de verde que a gente vai estar utilizando, porque é a cor do Ignite, tons de vermelho, e um tom de amarelo aqui que a gente vai estar utilizando na nossa aplicação. Pronto, com essas cores aqui configuradas, eu posso voltar lá no meu global.ts, e agora a gente vai utilizar algumas dessas cores aqui dentro do nosso CSS. Então aqui no body, por exemplo, a cor de fundo agora, eu vou definir ela também utilizando aquela mesma sintaxe né, props, props, ponto, theme, e olha só que legal, de dentro aqui do nosso theme, quando eu dou um ponto, ele já aparece todas as propriedades que eu posso utilizar, todas as cores que eu tenho lá dentro. E aqui no nosso caso a gente vai utilizar grey900. Como o grey900 tem um ifim no meio, eu não posso utilizar a sintaxe, o dot notation, a sintaxe de ponto, não dá para escrever assim por causa do ifim, eu tenho que escrever com a sintaxe de cochetes. Então agora aqui a cor do texto, a gente vai definir também, props, vamos lá, props, props, ponto, theme, e aqui a gente vai usar o grey300. E aqui a gente vai definir também um padrão para o focus dos nossos elementos, aí todo elemento que tiver com focus na nossa aplicação, eu vou dar um outline zero, que é o padrão, o foco geralmente é definido por outline no navegador, então eu tiro isso, e eu vou definir um box shadow 000, então ele tem zero no eixo x, zero no eixo y, zero de blur, e ele tem dois pixels de tamanho, com a cor props, props, ponto, theme, green, 500, o verde. E pronto, agora já está tudo bem definido aqui, está dando erro lá nos nossos estilos do botão, porque os nossos botões ainda estão utilizando aqui uma cor primary, que ela nem existe mais, então vamos colocar aqui o nosso green 500 também no lugar do primary, só para ele parar de dar erro, salvo isso aqui agora, volto no navegador, e olha só, já dá para previamente visualizar aqui o que a gente vai ter na nossa aplicação, o tema da aplicação, esse fundo preto, essa cor verde aqui é muito específico das aplicações que a gente vai estar desenvolvendo aqui dentro do Ignite, particularmente eu acho um tom de cor muito massa esse verde com essa conciliação do verde com o preto aqui. E é isso!"
  },
  {
    "id": "c177661c-c44c-42b9-b0fa-c9cd732e186a",
    "title": "Estilos globais",
    "transcription": "Outra coisa que a gente consegue fazer aqui no Styled Components é definir estilos globais. Então a gente pode ter cores, cores de fundo, definir fontes que são globais para todos os componentes da nossa aplicação. O que a gente vai fazer aqui? Deixa eu só fechar a pasta NodeModules. Aqui na pasta Styles eu vou criar um arquivo chamado global.ts. Até os meus estilos globais eles vão ser com arquivos com sintaxe JavaScript. A gente não vai criar arquivo CSS quando a gente está utilizando o Styled Components. Aqui dentro eu vou importar de dentro do Styled Components uma função chamada createGlobalStyle. E aqui de dentro eu vou exportar também um componente chamado globalStyle que é igual a createGlobalStyle. E aqui eu também boto aquelas nossas duas crases, o acento grave aqui. E aqui dentro eu boto todos os CSS que eu quero que seja global na minha aplicação. Por exemplo, todos os elementos eu quero que eles tenham margem zero, padding zero, box size, border box. Eu quero que o body da minha aplicação tenha uma cor de fundo cinza escuro, por exemplo, uma cor de texto branca. Aqui eu posso ir brincando, posso ir colocando todas as propriedades que eu quero adicionar. E aqui a gente vai ver, depois de eu já ter configurado isso, eu posso voltar aqui no meu globalStyle. E eu vou simplesmente importar esse globalStyle em qualquer lugar da minha aplicação. Posso inclusive aqui dentro do próprio app. É importante apenas que esse globalStyle também esteja dentro do ThemeProvider. Senão ele não vai ter acesso às variáveis do nosso tema. E a gente geralmente quer também utilizar essas variáveis dentro dos nossos estilos globais. Então aqui no final, e tanto faz a posição dele, eu vou colocar o componente globalStyle. Ele já fez a importação automática aqui. Posso dar um Enter para deixar os estilos juntos. Eu salvo isso aqui agora, volto no Chrome, e a gente vai ver que a cor de fundo já está cinza escuro. E se eu colocar algum texto aqui em tela, já vai estar o texto branco também, que foi o texto que a gente colocou. Então a gente aprendeu como trabalhar com estilos globais utilizando o Style2Components."
  },
  {
    "id": "1a70d561-f864-49ca-b203-b1d896f450b8",
    "title": "Layout de rotas",
    "transcription": "O que a gente vai ver nessa aula aqui é como que a gente trabalha com layouts de rotas e o que é essa funcionalidade de layouts de rotas. Dentro da nossa aplicação, o que a gente pode ver, por exemplo, é que tem coisas que se repetem visualmente, independente da rota que a pessoa está acessando. Então aqui na Home, por exemplo, que a gente tem o timer, a gente vai ver que o layout é basicamente um box cinza, o header está aqui em cima com a logo, com o logo, designers me desculpem, não pode falar a logomarca, jamais, aqui na Rocket se eu falo me matam, é o logotipo nesse caso, mas o logo, o cabeçalho aqui, o menu, ele se repete. A gente pode ver que tanto nessa tela quanto na tela do histórico, ambas telas têm os mesmos elementos. E se a gente simplesmente pegar e repetir isso, o header, esse box, tanto na tela Home quanto na tela de Histórico, quando o usuário navegar entre uma tela e outra, tudo isso vai ser recriado do zero, o React vai precisar pegar esses elementos e construir em tela do total zero. É claro que o tamanho da aplicação que a gente está desenvolvendo aqui, com a performance do React, isso não seria necessariamente um gargalo, que a nossa aplicação vai ficar super lenta, não, provavelmente a gente nem ia perceber qualquer tipo de lentidão. Mas se a gente pode criar de alguma forma algo que pode ser reaproveitado entre as telas, com certeza o melhor é a gente fazer isso. Então vamos entender o que a gente vai fazer. Por exemplo, aqui dentro eu vou começar criando um componente header.tsx, então o que a gente vai fazer nesse componente é simplesmente retornar um h1 novamente, veja que eu não estou colocando muito estilo nas coisas por enquanto, é mais para a gente entender o funcionamento, depois a gente se preocupa em deixar bonito e tudo mais. Então é só um h1 escrito header dentro. E aí novamente o que eu falei, o que eu poderia fazer, vir aqui na página Home, escrever aqui, além do h1, eu vou ter aqui uma div, eu vou ter o nosso h1 e vou ter o header, e aí faço a mesma coisa aqui no histórico, aí meu celular começou a pingar aqui, aí eu boto aqui header também e histórico, isso aqui novamente, falei, funciona, a gente pode vir aqui, header está aqui, seu acesso histórico, header está aqui também, funciona, mas a gente não quer isso, se o header vai estar em todas as páginas, tem forma melhor da gente fazer. Vou tirar ele daqui então, pode deixar a div aqui, não vai mudar nada, veio na Home, tiro ele daqui também, e agora a gente vai criar uma nova pastinha aqui, chamada layout. Galera, uma das coisas que é importante a gente falar antes de mais nada é que não existe estrutura de pastas perfeita para todos os projetos. Isso que eu estou mostrando para você é que talvez quando você for construir aplicações de porte de tamanho diferente, menores ou maiores, talvez mude. O mais importante é você encontrar qual é a melhor estrutura de pastas para o momento do time e que combina com o estilo de desenvolvimento do seu time. Então, aqui eu estou mostrando uma estrutura de pastas que geralmente a gente segue nos nossos projetos, mas você pode dar um nome diferente para as coisas, quer chamar de screens ao invés de pages, taca de pau, quer botar layouts dentro de pages, assim, não tem problema, você pode fazer da maneira que você achar melhor, desde que o time esteja acostumado a trabalhar nesse formato. E aqui dentro de layout a gente vai começar criando um único layout, a gente vai chamar ele de default layout, que é o layout padrão, digamos assim, ele também vai ser um componente. E aqui dentro nós vamos criar uma função default layout, e aqui nós vamos criar simplesmente uma div, dentro dessa div nós vamos colocar o nosso header, como eu tinha falado, e aqui embaixo do header é onde a gente quer que vá o nosso conteúdo, ou seja, o header eu quero que ele fique fixo para todas as páginas, e aqui, essa partezinha é o que vai transicionar. Então, aqui no lugar de conteúdo eu quero que se a pessoa estiver na home, mostre esse conteúdo aqui, se a pessoa estiver no histórico, mostre esse conteúdo aqui, aqui, exatamente aqui. E para isso a gente tem um componente, que vem de dentro do React Hotterdom, que se chama outlet. O outlet nada mais é do que um espaço para ser inserido um conteúdo. Então o React Hotterdom, quando ele estiver utilizando esse layout aqui, com o outlet ele vai saber exatamente aonde que ele tem que posicionar o conteúdo que é específico de uma página, então específico da home, específico da history, vai ser posicionado aqui, no lugar do outlet. E aí agora, claro que o nosso layout ainda não vai estar funcionando, porque nós precisamos voltar lá nas nossas rotas, e agora como é que a gente faz para utilizar o layout em si? A gente vai por volta dessas duas rotas, a gente vai colocar mais um elemento, root, só que agora veja que esse root, que está no singular e não no plural, ele não é uma rota normal, que se fecha nela mesma, a gente vai colocá-la por volta das duas outras rotas que a gente tem. E agora, nesse root aqui, nós vamos passar path, barra também, e a gente vai passar o elemento default-layout. Por que eu passei o barra aqui? Porque a gente quer aplicar esse layout em todas as rotas. Geralmente quando a gente tem outras aplicações, imagina que a gente está construindo uma aplicação que ela tem um painel de administração, e aí para o painel de administração a gente pode ter um layout diferente. O que a gente faz nesses casos é, a gente cria, por exemplo, aqui eu vou ter o admin-layout, e ele vai aplicar para todas as rotas que começarem com barra-admin. Então aqui no path, a gente pode falar, olha, todas as rotas que começarem com barra-admin, elas vão ter o admin-layout, e aí a gente define as rotas aqui dentro. E aí é muito interessante que se a gente colocou barra-admin aqui em cima, e aqui a gente cria uma rota, por exemplo, chamada barra-products, para acessar essa rota aqui, vai ser sempre a soma desse path com esse path. Então são rotas encadeadas, uma rota é filha da outra rota, e aí se eu quero acessar aquela rota ali, seria localhost 3000 barra-admin barra-products, então ele vai somando os paths. Mas show, vamos tirar isso aqui agora porque a gente não está mexendo nisso, salvamos isso, voltamos lá no nosso Chrome, e agora olha só, eu volto aqui, o header está aqui junto com a home, mesmo que lá dentro da home o header não esteja aqui, e se eu transiciono agora para o nosso history, a gente vai ver que o header mantém e também eu tenho a minha página history, e isso por causa do layout que a gente criou. Se a gente colocar mais elementos aqui, sempre vai aparecer em ambas as rotas, então a gente não precisa ficar se preocupando sempre em trocar nos dois lugares, e assim a gente evita também repetição de código."
  },
  {
    "id": "ebde6122-8644-4f95-9abc-063ce5de7612",
    "title": "React Router DOM",
    "transcription": "Nessa aula, a gente vai aprender a fazer uma das coisas mais importantes em aplicações web, que é lidar com várias rotas. Então, imagina, eu estou acessando a home da nossa aplicação e eu quero visualizar alguma coisa. Se eu digitar no endereço localhost 3000-products, eu quero ver a listagem de produtos e por aí vai. A gente tem que ter várias rotas, várias páginas diferentes baseadas no endereço que o usuário está acessando na nossa aplicação. Para isso, a gente vai utilizar a biblioteca mais famosa de lidar com rotas, que é o React Outer. E ele tem tanto integração para web quanto React Native, por isso que ele tem mais de um pacote aqui dentro. O pacote que a gente vai utilizar, como a gente está lidando com ele na web, é o React Outer DOM, porque a gente está em ambiente da DOM, ambiente web. Para isso, eu vou instalar o React Outer DOM e a gente vai começar criando uma pasta pages aqui dentro de src. E a gente vai ter uma página Home, que é um componente, e uma outra página, History, que também é um componente. Até olhando para a nossa aplicação aqui, a gente tem essa página Home, que é o timer em si, digamos assim, e a página do histórico, que exibe aqui o histórico dos últimos timers que eu executei na aplicação. Ambos serão componentes, como eu falei, então só para visualizar por enquanto, eu vou dar um return em um H1 mesmo, escrito Home aqui dentro da Home, salvo, fecho, e no History também. E agora a gente vai apagar esse componente Button, que a gente não vai estar utilizando, posso apagar o uso dele aqui de dentro, apago o Button aqui de cima também, e agora nós vamos criar um componente chamado Router.tsx. Por que eu estou criando esse componente? Eu poderia colocar tudo aqui dentro do app, mas eu vou só separar a definição de rotas da nossa aplicação em um componente separado. Por isso hoje eu estou criando um componente novo, mas poderia ser tudo aqui dentro do app também. A gente vai fazer a declaração de quais rotas existem na nossa aplicação também através da sintaxe de componentes. Então aqui nós vamos exportar uma função Router, e aqui de dentro agora a gente vai retornar as nossas rotas. Para isso, eu vou importar de dentro do React Router DOM, dois carinhas, dois componentes, um deles se chama Roots, com plural, e outro, Root. E agora aqui dentro, Roots, por volta de tudo, a gente precisa primeiramente esse componente aqui por volta de tudo, e agora para cada rota da nossa aplicação, para cada página, nós teremos uma rota. E aí a rota é muito simples. Primeiro, uma propriedade. Qual que é o endereço que a pessoa estará acessando? Então nesse caso da Home, por exemplo, a gente bota só uma barra, porque na verdade a Home a gente quer que acesse quando o usuário não digite nada aqui, não tenha barra nada aqui. E daí nesse caso a gente bota apenas uma barra, porque isso aqui não pode ficar vazio. E aí a gente fala, olha, o elemento que vai carregar, o componente que vai carregar quando eu estiver nesse caminho aqui, no caminho barra, é a Home. Então a gente bota aqui um componente nesse formato, e aí faz a importação da nossa página. Mesma coisa para o histórico, tá? Path, barra History, ou só History, vai funcionar também. Eu gosto de manter um padrão, de colocar aqui a barra na frente. E aqui, Element, History, já deu a importação aqui. E salvo isso aqui agora, volto no meu app, e aqui dentro agora eu boto o nosso router. Se eu salvar isso aqui e tentar executar a nossa aplicação, a gente vai ver que ela está dando erro, tá? Posso ir até aqui no console da aplicação, e aí ele dá vários erros aqui, que na verdade acaba não dando para entender muito. Mas se eu for aqui na própria documentação do React Router, e for aqui no Guia, no Getting Started Guide, ele fala aqui basicamente, se a gente der uma olhadinha aqui embaixo, que nós precisamos importar o BrowserRouter do React DOM, e fazer um wrap do nosso app dentro do BrowserRouter. O que isso quer dizer na prática? Aqui no nosso app, nós vamos importar, de dentro do React Router DOM, o BrowserRouter, e assim como o nosso ThemeProvider, eu preciso envolver toda a minha aplicação com esse BrowserRouter. Ah Diego, mas ele vai por fora ou por dentro do ThemeProvider? Tanto faz, tá? Então a gente vai jogar aqui o BrowserRouter, e aí o GlobalStyle também pode ficar fora, não tem problema, só é importante que o BrowserRouter fique por volta das nossas rotas em si, tá? Feito isso, salvamos, voltamos ao Chrome, DOM F5, e agora a gente pode ver que está aparecendo o ROM. Se eu digito barra history aqui em cima, ele mostra history. Então é muito simples, a gente fez aqui a configuração, como a gente bem pôde ver, e não teve nenhum problema. A gente pode continuar, inclusive, seguindo o guia caso você queira, mas a gente ainda vai muito a fundo aqui, utilizar exemplos de rotas. Uma das coisas que talvez possa ter intrigado você aí que está assistindo as aulas, é o que são esses componentes como o ThemeProvider, o BrowserRouter, que eles visualmente não produzem nada em tela, eles não têm um visual, eles não têm uma interface, mas eles são necessários e eles precisam sempre ficar por fora dos outros componentes. Isso aqui talvez seja algo que tenha intrigado você. Isso é algo que a gente vai ver ainda ao longo das próximas aulas aqui. Isso aqui, o nome talvez te assuste agora, mas eles são chamados de ContextProviders. Ou seja, são componentes que não têm efeito nenhum visual, mas eles produzem um contexto para os componentes que estão dentro deles. Ou seja, informações para os componentes que estão dentro deles saberem do contexto de fora, do mundo externo. Os componentes conseguirem obter informações além do que eles têm ali dentro deles, do mundo externo, digamos assim. É isso que eu posso falar por agora, mas mais pra frente a gente vai bem mais a fundo nisso."
  },
  {
    "id": "8bc48946-1b3e-4dc4-bf1f-5c417074194b",
    "title": "Header & Layout",
    "transcription": "Nessa aula a gente vai configurar o cabeçalho da nossa aplicação, que nada mais é do que esse logo e esses dois ícones aqui. E também a gente vai configurar esse layout por volta, que na verdade é só essa caixa cinza. Mas aqui no nosso código a gente já deixou pronto esse default layout, que é basicamente o componente que a gente vai ter como wrapper da nossa aplicação, como container da nossa aplicação em todas as páginas. Então a gente já aprendeu a configurar o outlet e tudo mais. Como todas as páginas vão ter esse cabeçalho aqui em cima e esse layout com esse box cinza por volta, a gente vai configurar esse layout, dessa caixa cinza aqui, exatamente dentro desse default layout. Então vamos lá. Como a gente está utilizando o styled components aqui nesse caso, o que a gente pode fazer, o que eu gosto muito de fazer é o seguinte. Ao invés de a gente ter os nossos componentes simplesmente como arquivos TSX, default layout, quando eu uso styled components ou outra biblioteca de CSS e JS que o arquivo de estilo está separado do arquivo de estrutura do HTML, eu crio uma pasta para o componente. Então ao invés de utilizar default layout como nome do arquivo, eu crio uma pasta chamada default layout. E aí eu gosto de chamar o meu componente de index, jogo dentro dessa pasta e eu crio também um styles. Então todos os arquivos que representam alguma coisa do default layout vão ficar dentro dessa pasta. Mais pra frente a gente pode ter arquivos de teste aqui dentro, arquivos de tipagem. A gente pode ter um monte de coisa, até sub-componentes, digamos assim, componentes que só são utilizados pelo default layout nesse caso, eles podem estar dentro dessa pasta. Então eu gosto muito de utilizar esse modelo. E aí você pode pensar, tá Diego, mas o meu código não vai ficar cheio de arquivos index e arquivos style? Sim, mas isso não necessariamente é um problema, porque se eu por exemplo der um CTRL-P aqui no VS Code pra procurar um arquivo e escrever default layout, eu vou cair dentro aqui já pra ver todos os arquivos relacionados. Aí se eu quero trabalhar na estilização, eu venho pro styles, se não eu vou pro componente. E aí aqui no nosso styles, como a gente já tinha mesmo visto, eu vou importar o styles de dentro do styles.components e aqui a gente vai criar um componente estilizado chamado layout-container. O nome aqui, tanto faz. Eu só não gosto de dar o nome container pra todos, eu geralmente coloco um prefixo, porque assim também depois fica mais fácil na hora de refatorar, na hora da gente saber o que é o que. E aqui a gente vai criar um style.div. Não necessariamente eu posso chamar isso aqui já da tag main do nosso site, porque aqui dentro do layout, na verdade o layout não pode ser a tag main, porque na verdade o layout não é o conteúdo da página. Geralmente a gente coloca dentro da tag main qual que é o conteúdo específico daquela página, o conteúdo principal da página. Nesse caso aqui vai estar o header, vai estar o footer, vai estar tudo aqui dentro do layout, então isso aqui não é a main. E agora a gente vai começar adicionando algumas estilizações. Primeiro eu vou dar um max-width aqui, e aqui é bem louco porque eu vou utilizar um valor de 74 rem. E aí se a gente for ver, deixa eu abrir aqui o raycast, 74 vezes 16 vai dar 1184. Então por que eu botei esse tamanho aqui? Porque se a gente for lá no layout e clicar aqui, ele tem 1120, então 1184 daria na verdade 75 rem, mas eu quero deixar um espaçamento, um padding lateral, então eu tenho que colocar a width um pouquinho menor. Beleza. Ficando parecido ali está massa. E aqui agora eu vou colocar o height desse elemento, eu quero que ele seja o tamanho da altura total da tela menos um tanto, para que sobre aqui também o espaçamento em cima e embaixo. Como com o width nos elementos do HTML, do CSS, a gente consegue dar um 100% e ele ocupa a tela toda, mas o height a gente não consegue, tem que fazer um monte de... ficar colocando height 100% no HTML, no body, mas eu posso utilizar o 100vh, que aí sim ele vai utilizar o 100% do viewport-height, e aí eu não preciso usar o percentual e ele consegue ocupar a altura total da página. Porém eu quero tirar aqui 10 rem, então por isso que eu fiz um cálculo, porque assim eu consigo deixar um margem de 5 rem em cima e embaixo, e nas laterais eu boto alto para que isso fique centralizado. Se eu salvar isso aqui agora e ir lá no meu index do default layout, trocar essa div aqui por layout-container, que vem aqui de dentro dos estilos, e aqui eu tenho que arrumar também a importação do header, porque como eu coloquei mais uma pasta interna, eu tenho que botar mais um ponto-ponto-barra aqui, eu salvo, volto aqui no Chrome, e a gente vai ver que agora a nossa aplicação já está centralizada horizontalmente, e verticalmente a gente pode ver que a nossa div está ocupando todo o espaço da tela, tirando apenas um espaçamento embaixo e em cima. Então já está ficando bem legal. E agora aqui no nosso layout-container a gente vai finalizar a estilização colocando um padding lateral e em cima e embaixo também de 2.5 rem, para o conteúdo do container ficar um pouquinho mais distanciado. E agora para a gente visualizar mesmo isso aqui funcionando, eu vou adicionar uma cor de fundo, então eu vou usar o tema para isso, eu vou usar a cor grey 800, a gente já pode ver como está ficando. A gente vai adicionar aqui também um border-radius 8 pixels, e aí lembrando, no border-radius dificilmente você vai utilizar uma medida em rem, você geralmente vai utilizar pixels absolutos, então por isso que a gente não usa rem aqui nesse caso. Display-flex, e aqui eu vou dar também um flex-direction-column. Por que eu botei esse display-flex e esse flex-direction-column? Porque se a gente for ver dentro aqui do nosso layout, a gente tem um header e nós temos o conteúdo. Um está em cima do outro. Eles estão seguindo a direção de coluna. E agora que o nosso layout está pronto, a gente vai partir para o header. O header, mesma coisa que a gente fez no layout, como a gente está criando um componente que tem estilização, a gente vai criar uma pasta chamada header, esse arquivo aqui vai se chamar index, a gente vai mover para dentro aqui do header, e aí eu vou criar um styles.cs. Novamente, a gente vai fazer a estilização aqui do nosso header, para isso eu vou criar aqui um header-container, é igual a styled, que vem do styled-components. Uma coisa que é importante é que assim, você vai perceber ao longo de todas as aulas que eu vou gravando, é que dificilmente eu escrevo imports na mão. O Vascode, na maioria das vezes, sugere importação para a gente. Então, tenta abusar disso porque melhora bastante a produtividade. Aqui a gente vai utilizar então uma tag header mesmo. Aqui eu vou dar um display-flex, align-items-center, então eu quero que a logo, ou logo, desculpa designers, o logo e o menu, eles estejam horizontalmente alinhados, e no meio aqui, na parte vertical, também eles estejam ao centro. Só que o logo está totalmente para a esquerda, e o menu totalmente para a direita. Por isso a gente vai botar um justify-content-space-between, para ele adicionar esse espaço aqui, e jogar um totalmente para a direita e um totalmente para a esquerda. Eu particularmente gosto muito de utilizar o flex para tudo. Agora, aqui no header, a gente vai começar então utilizando o nosso header-container. E aqui, só para a gente exemplificar por enquanto, enquanto a gente ainda não tem a imagem de logo, nem nada disso, eu vou colocar um menu totalmente para a direita. Então, dentro desse menu eu vou ter dois links, vou botar como âncora mesmo. Aqui eu vou escrever dentro desse timer, e desse aqui eu vou escrever history. Depois a gente vai melhorar. E aqui, o nosso logo, eu vou representar ele por um span, por enquanto, escrito logo. Só para a gente visualizar essa ordenação que a gente está fazendo. Se eu volto aqui no ignite-timer, a gente já vai ver que o logo está totalmente para a esquerda, e o menu totalmente para a direita. Fechou? Agora eu venho aqui no figma, claro, eu vou exportar tudo o que a gente tem. Então eu venho aqui e seleciono o logo, aqui a nossa camada do logo. Posso exportar já os itens aqui também, então posso selecionar... Deixa eu ver, esse aqui está com 48, esse aqui com 40, o ícone está com 22, 26... Esses ícones aqui, eles estão com um tamanho um pouquinho diferente, se a gente for ver. Esse aqui está com 22, e esse aqui está com 26 de altura. Então o que eu vou fazer é exportar o elemento que está por volta deles, esse menu item, porque os dois estão com um tamanho igual, 48 por 48. Então vai ser isso mesmo. Eu vou pegar esse... Se bem que isso aqui eu acho que está utilizando um pacote de ícones. Sim, esse aqui está utilizando um pacote de ícones, que é o do Phosphor React. Então eu acho que a gente não instalou ainda o Phosphor React, então eu vou instalar Phosphor React aqui dentro, e aqui dentro eu vou importar apenas o logo, o símbolo aqui do Ignite. Então aqui no meu Figma, no caso, ele está aqui embaixo, o export, mas para você... Depende como você acessar, se você duplicar o arquivo também vai estar aqui embaixo. Se você estiver apenas visualizando o arquivo, vai estar aqui em cima no labinho, acho que inspect, acho, ou export, não sei. Mas eu vou exportar ele como SVG, então logo exportado. Estou mostrando... Show in Finder... Aqui. E agora eu só arrasto ele aqui para dentro do Vascode. A gente vai colocar ele... Vou jogar dentro da pasta Search mesmo, porque a gente precisa criar aqui uma pasta chamada Assets. E dentro dessa pasta Assets, eu vou jogar o meu logo aqui. E aí eu vou chamar isso aqui de logoIgnite. E agora, aqui dentro do meu header, eu vou fazer a importação, logoIgnite, de dentro de Assets barra logoIgnite.svg. E aqui no lugar do logo, então, a gente joga Image. No lugar do Search, a gente bota logoIgnite. Aqui no Out, isso aqui é uma coisa importante, né? Tipo, a gente pensa muito em... Pô, vou botar um texto alternativo para dar acessibilidade para a minha aplicação. E aí muita gente coloca aqui no Out, por exemplo, a logo do Ignite. Mas para quem tem problema de visão, imagina uma pessoa que não consegue enxergar. O que o logo do Ignite explica para ela? Nada, ela não sabe o que é o logo do Ignite. Então, se a gente não conseguir representar o logo do Ignite, que seria, por exemplo, aqui nesse caso, a gente teria que botar dois triângulos. Se a gente não conseguir escrever exatamente a imagem em texto, é melhor deixar o texto alternativo em branco, porque pelo menos o leitor de tela não lê isso, sendo que não necessariamente é uma informação importante para quem está acessando a nossa aplicação. Então, texto alternativo aqui a gente pode sim deixar em branco, tá? Isso é uma coisa importante, melhor do que escrever qualquer coisa. E agora, dentro aqui desses links, a gente vai colocar os nossos ícones que vêm lá de dentro do Phosphor React. Esse primeiro aqui vai se chamar timer, que ele não deu a opção de importar automaticamente. Então, nesse caso aqui, Phosphor React, a gente vai importar o timer, e nós vamos importar também um carinha chamado scroll. Aqui no nosso caso do timer, eu vou botar um tamanho dele 24, e aqui embaixo a gente vai colar também, trocar timer por scroll, tamanho 24 também. Voltamos, vamos lá no Google Chrome, visualizar, a gente já pode ver que está bem legal, o logo do Ignite já está aqui, e os nossos ícones aqui também já estão aparecendo na direita. É claro que agora a gente tem que dar uma pequena estilizada apenas no menu. Eu acho que o logo do Ignite em si nem vamos precisar mexer em nada. Então vamos lá, começar utilizando aqui o nosso nav. O nav, eu vou começar dando pra ele um display flex, e aí o padrão do flex direction já é row, um do lado do outro, não precisa mudar. E aqui eu vou usar o gap, 0.5 rem, o gap com certeza é a melhor propriedade CSS inventada nos últimos meses, no caso, dependendo de quando você está vendo esse vídeo. Ele vai adicionar um espaço, aqui de 8 pixels, no caso, entre cada item dentro do container. Isso aqui é muito bom, melhor do que ficar adicionando margin-left e margin-right. E aqui pra cada link, a gente vai adicionar um width de 3 rem, height de 3 rem, se a gente lembrar lá no layout, todos os links do menu tinham 48 por 48, de altura e largura, então por isso que a gente está colocando fixo. E aqui a gente vai dar um display flex, com justify-content-center, align-items-center, pra centralizar o ícone no meio desse tamanho de 48 por 48. Aqui a gente vai dar uma color-props, props.theme-gray-100, a gente vai estar utilizando. Aqui eu vou dar um border-top, 3 pixels sólido e transparent, já vou falar o porquê disso, e um border-bottom, 3 pixels sólido e transparent também. Então, eu estou adicionando uma borda, mas ela não vai ter efeito visual nenhum, porque eu coloquei como transparente. Vamos salvar isso aqui pra ver como é que está ficando. Olha só, esses aqui já são os nossos ícones, então já está bem parecido aqui com os ícones que a gente tem, mas se a gente for aqui na seção de assets, aqui, itens do menu, a gente vai ver que quando a gente faz um hover dentro do nosso botão do menu, eu preciso adicionar essa borda aqui embaixo. E aí está o porquê da gente ter colocado essa borda transparente, tanto no top quanto no bottom. E aí, mesmo a gente precisando dessa borda só no bottom aqui, por que eu botei ela em ambos os lugares? E por que eu botei ela transparente? Por que eu não boto só no hover? Olha só, se eu fizer o seguinte, quando estiver com hover nesse botão, eu dou um border-bottom, 3 pixels sólido, a cor eu quero a props.theme, green, 500. Salvo isso aqui agora, volto lá, olha só o que vai acontecer. Está vendo que ele joga o ícone um pouquinho para cima quando eu boto? Porque ele colocou uma borda nova que não tinha. Então, por isso que eu coloquei esse border-bottom 3 pixels já fixo. Então, olha só, se eu faço assim, ele já tinha a borda antes, então ele já está levemente posicionado um pouquinho mais acima, ela só estava transparente. Mas por que eu botei esse border-top 3 pixels? Porque como eu quero que o meu ícone esteja totalmente centralizado, como eu tenho 3 pixels de borda abaixo agora, na verdade, o meu ícone está 3 pixels acima do centro. Então, eu boto uma borda top 3 pixels para ele voltar para o centro, mesmo que essa borda não apareça. Então, agora sim, a gente já está com o nosso ícone aqui totalmente estilizado, o nosso menu totalmente estilizado. E aí, por enquanto é isso, a gente não precisa se preocupar, só que a gente tem duas páginas já, se eu acessar aqui barra history, eu consigo acessar a página de histórico, mas os meus links aqui, eles ainda não estão enviando o usuário para nenhum lugar. Para isso, a gente vai fazer o seguinte, aqui dentro do nosso header, eu vou trocar essas âncoras aqui por um componente que vem de dentro do React Houderdon, chamado nav-link. Aqui, eu uso esse nav-link em todos os lugares, no lugar do A, no lugar da âncora. E aqui, ao invés de href, eu uso o to. Então, eu troco aqui para o to, aqui eu boto a página, a timer, na verdade, é a home, e aqui eu boto history. E aí, como esses ícones aqui, para quem precisar de acessibilidade, eles não indicam nada, geralmente, a gente coloca um title. Então, nesse caso aqui, eu boto timer, e aqui eu boto histórico, por exemplo, porque a minha página é em inglês, em português. Então, eu salvo aqui agora, volto lá para o Chrome, e agora eu passo o mouse por cima, a gente vai ver que ele já mostra, timer, e aqui histórico, e se eu clico entre eles, eu sou navegado entre as telas. E aí, um último ponto aqui, é que esse nav-link do React Houderdon, quando a página ativa, for, por exemplo, a history, o que ele vai fazer para a gente de forma automática, é colocar na âncora, que está por volta do nosso ícone, uma classe chamada active, e também um area current page. E aí, eu posso usar essa classe active, por exemplo, lá no meu estilo, para fazer uma estilização do link. Nesse caso, a estilização que eu vou fazer é simplesmente colocar a cor verde. Então, a gente vai botar aquele green500 na cor do menu. E olha só, agora o histórico está verde, se eu clico no timer, o timer fica verde, e por aí vai, eu consigo navegar tranquilamente entre as páginas aqui da minha aplicação."
  },
  {
    "id": "2a420558-432f-40d1-ab4c-fb57f813c07b",
    "title": "Página: Home",
    "transcription": "Nessa aula, a gente vai estilizar e criar a estrutura desse componente da nossa ROM, do timer aqui. Então, a gente vai criar esse formulário, se é que dá pra dizer, esse mini-formulário aqui em cima, esse timer que a gente tem aqui no meio, o countdown, e o botão. Então, são poucos elementos, vai ser super tranquilo a gente fazer essa estrutura e depois que a gente finalizar essa estrutura, a gente vai começar a dar vida pra isso e vai ficar muito legal o projeto. Bora lá! A gente vai começar aqui no nosso VSCode, na nossa página ROM, e hoje ela só tem um H1. E da mesma forma que eu fiz em todas as outras páginas aqui, todos os outros componentes que têm styles componentes, que têm estilização, eu vou criar uma pasta pra ROM também. E dentro dela, esse arquivo ROM vai ser index, na verdade, e eu vou ter um arquivo styles.ts. E show! O styles por enquanto pode ficar em branco. Esse index aqui, agora a gente vai começar colocando toda a parte estrutural da nossa página. Então, bora lá! Aqui eu vou começar tendo uma div por volta de tudo, que vai ser o nosso container. Geralmente toda página, todo componente tem um container por volta, que na maioria das vezes vai ser uma div, então a gente pode começar com uma div, depois a gente escolhe a tag melhor lá dentro do styles component. Aqui dentro agora a gente vai ter três coisas dentro dessa div, um formulário, que é esse carinha aqui em cima, esse countdown e um botão, então é super simples. Aqui dentro do formulário a gente vai ter o quê? Vamos dar uma olhadinha aqui, deixa eu só pegar a minha cola aqui dentro. Esse formulário vai ter o seguinte, vou trabalhar em, isso aqui eu vou botar como uma label, então vou trabalhar em, por que eu botei como uma label? Porque eu quero que quando a pessoa clica aqui em vou trabalhar em, ela já dê focus nesse input aqui de forma automática. Então vou trabalhar em, aqui eu vou botar um input, e aí pra eu conseguir trabalhar aqui com a label, eu preciso botar um id, vou botar o id task e aqui html for task. Aí aqui embaixo eu vou ter outra label, escrita durante, que é essa label aqui, aqui eu vou botar também um input, o type dele agora vai ser number, e o id eu vou chamar de minutes amount, que é a quantidade de minutos, eu acho que fica melhor do que duration, porque duration não necessariamente especifica pra quem tá lendo o código que essa duração ela é em segundos, minutos, horas, eu gosto de ser um pouco mais explícito nesse caso, e aí no final eu vou botar um span, que é aqui o minutos, que é esse minutes aqui no final, e isso não vai ser uma label, por que não vai ser uma label, perfeito, aqui o nosso formulário já tá finalizado, e agora a gente vai ter abaixo do nosso formulário em si, a gente vai ter o nosso countdown ali que eu falei, o nosso countdown eu vou botar simplesmente uma div por volta dele, e aí ele vai ser bem simples, ele vai ter um span pra cada box desses aqui, então 0 e 0, que representa esse e esse box aqui, esses dois pontos aqui no meio eu vou criar um, sei lá, eu vou botar uma, vou botar um span também por enquanto, com dois pontos, mas mais pra frente ele vai ser um componente diferente, e aqui mais um span 0, mais um span 0 que representa os segundos, então bem simples, e agora pra finalizar, lá embaixo a gente vai ter um botão, e aí esse botão aqui ele vai começar o form, ele vai dar um submit nesse formulário, então na verdade eu preciso que o formulário fique por volta de tudo isso aqui, então eu vou botar o formulário por volta disso tudo, e aqui, essa parte aqui de cima do formulário eu vou botar ela por volta de uma div também pra eu conseguir estilizar ela separada aqui do countdown, então ficou entendido né, eu preciso colocar esse formulário por volta de tudo aqui, porque como o meu botão de enviar o formulário ele tá aqui embaixo, é melhor que eu faça o formulário, a tag form por volta de tudo, do que ter que fazer uma gambiarra pra fazer um submit do formulário pelo javascript, vai dar muito trabalho isso aqui, e fica muito feio, então esse nosso botão aqui, ele vai tá escrito começar, e dentro dele tem esse botão de play aqui, que vem do Phosphor também, então eu procuro play, aqui Phosphor React, e boto aqui com tamanho 24, salvo isso aqui, vamos ver como é que ficou nossa ROM, aqui ó, show de bola, já dá pra visualizar como que vai ficar e agora a gente vai começar a estilizar e criar componentes pra isso aqui né, então vamos lá, eu vou começar criando aqui o nosso home container, styled.main, aqui eu vou usar, e aqui eu vou precisar de mais alguns containers aqui né, eu vou criar o nosso countdown container, vou usar uma div mesmo, aqui esse form, então ele vem antes, então eu vou botar aqui em cima, nosso form container, e aqui embaixo, pra estilizar, eu vou estilizar o nosso botão também, depois eu estilizo isso, vamos começar por partes aqui, senão a gente vai criar muita coisa e vai ficar muito demorado aqui, e agora, aqui eu vou começar usando o lugar dessa div aqui, a nossa home container, essa que tá por falta de tudo, aqui essa div dentro do form, eu vou chamar de form container, e essa aqui, o nosso countdown container, e todos eles já importados aqui do styles, é claro, salvando aqui agora, a gente volta aqui pra estilização, e a gente vai começar a estilizar esses carinhas aqui, então bora lá, primeiro nosso home container aqui, eu vou dar pra ele um height 100%, flex 1, não sei se precisa desse height 100%, eu acho que o flex 1 já resolve, mas vamos lá, display flex, flex direction column, porque eu tenho um elemento abaixo do outro, align item center, e justify content center também, salvar aqui agora, já tá centralizado, deu certo, e agora eu vou estilizar o form que tem aqui dentro, e uma das coisas legais aqui do styled components é que ele permite eu fazer essa estilização em cascata, então assim como no sass, por exemplo, e até outros pré-processadores css, eu posso estilizar a tag form dentro dessa tag main, só criando uma cascata mesmo, então aqui o form que estiver dentro da main eu consigo adicionar alguns estilos a ele, isso aqui é muito legal, assim como a gente fez isso lá dentro do header também, com o a, por exemplo, no nav, eu acho que eu acabei pulando a explicação aqui, mas isso aqui é o styled components, ele permite a gente seguir uma sintaxe muito semelhante ao sass, isso é muito bacana, aqui no form, eu vou dar um display flex, flex direction column, align item center, e um gap de 3.5 rem, o que eu to fazendo com esse form basicamente, eu to só alinhando esse carinha, o countdown e o button, todos ao centro, horizontalmente, e colocando um espaçamento entre eles de 3.5 rem, que dá 56, e agora a gente vai continuar estilizando aqui a nossa aplicação, então a gente vai para o nosso form container, deixa eu pegar aqui só para a gente não se perder, o nosso form container aqui, eu vou dar para ele um width de 100%, um display flex, align item center, justify content center também, gap 0.5 rem, que é o espaçamento entre cada carinha desse aqui, label, input, label, input e span, aqui a gente vai dar um color, props, props.theme, gray 100, que é um cinza bem clarinho, font size 1.125 rem, font weight bold, e flex wrap wrap, porque flex wrap wrap? Porque quando a tela for menor eu quero que ele quebre, se a gente dividir, ele vai quebrar os campos em mais linhas, se eu não coloco esse flex wrap, olha só, ele vai criar uma barra de rolagem, que vai ficar um negócio muito estranho, então aqui pelo menos ele quebra. É isso, agora a gente vai continuar aqui estilizando o nosso app, uma das coisas, deixa eu ver um negocinho aqui, a gente não criou aqui, ele está usando font family roboto, não está certo, deixa eu dar uma olhadinha como é que está aqui, vou trabalhar em, show, é isso mesmo, aqui no styles, global, uma coisa que eu não fiz, que para mim faz toda a diferença, é colocar uma tag chamada webkit, uma propriedade, font smoothing, anti-aliased, acho que é isso, salva, deixa eu ver aqui se ele aplicou, olha só a diferença que dá, quando taca a propriedade ela fica mais sharp, mais detalhada, se eu tiro ela fica mais extrema me parece, então eu vou deixar esse webkit font smoothing anti-aliased aí. E agora, é isso, a gente já tem aqui os nossos inputs, por enquanto eu não vou trabalhar muito aqui, a gente vai dar só uma estilizada aqui no nosso countdown, e aí depois a gente continua na estilização desses elementos. Então o nosso countdown aqui, a gente vai utilizar uma outra fonte, então lembra que a gente usou a fonte roboto mono, a gente importou a fonte roboto mono, a gente vai utilizar ela nesse caso aqui, então font-family roboto mono, se ele não encontrar essa fonte eu quero que ele utiliza qualquer outra fonte mono espaçada, onde todos os caracteres tenham a mesma largura. Aqui eu vou dar um font-size 10rem, line-height 8rem, color props, props.theme-gray 100, aqui a gente vai dar um display-flex-gap 1rem, e aí eu vou pegar os meus spans que tem ali dentro, e eu vou fazer o seguinte, vou dar um background-props-theme-gray 700, a gente vai dar aqui também um padding 2rem em cima e 1rem nas laterais, e border-radius de 8px. Se eu salvar isso aqui agora, olha como é que ficou, já dá pra visualizar, só que esse carinha aqui no meio, ele não ficou muito legal, por isso a gente vai criar aqui mais um componente estilizado chamado separator, eu vou estilizar ele como uma div mesmo, esse separator aqui vai ter o seguinte, um padding 2rem e 0 nas laterais, um color props, props.theme-green 500, então um verdinho, width fixo de 4rem, vou botar aqui um overflow-hidden, display-flex e justify-content-center. Eu volto aqui no nosso index e eu troco esse carinha aqui pelo nosso separator, e ele já fez a importação automática dos estilos, fechou, se eu volto aqui no nosso app, já tá o carinha aqui, então a gente já tem aqui a nossa separação. E assim a gente já tem uma estrutura base da nossa ROM, é claro que ainda falta muita estilização, mas até pra essa aula não ficar tão grande, vamos parar por aqui e a gente continua logo mais."
  },
  {
    "id": "1bbefc35-e09b-42cd-932b-18c03e2d5123",
    "title": "Aprimorando os inputs",
    "transcription": "Tem muitas coisas que a gente consegue fazer no HTML que às vezes a gente investe um monte de tempo criando aquilo com JavaScript, instalando uma biblioteca, mas dá pra fazer de forma nativa, fácil, acessível, então vamos dar uma olhada nisso aqui. Por exemplo, aqui no nosso Home, no Index, que a gente tem esse input de minutos. Uma coisa que eu quero é que a pessoa não possa vir aqui e botar 99999, por exemplo, e que quando ela vai aumentando aqui, aumente não de 1 em 1, porque, por exemplo, se eu quero uma tarefa, eu vou ficar trabalhando um projeto 20 minutos depois, tem que ficar aqui. Não faz sentido, não faz sentido. Então, algumas coisas que a gente pode fazer, por exemplo, inputs do tipo número, a gente pode passar pra ele um carinha chamado Step, não sei se você sabia, que no HTML tradicional a gente coloca isso como um texto, mas no React, essas propriedades do HTML, que elas recebem textos, mas o valor é numérico, a gente pode sim passar isso aqui como um número, e aí basta eu botar aqui chaves e dentro o valor. Então, por exemplo, Step 5. O que isso vai fazer? Olha só, se eu salvo agora e venho aqui e aumento, ele pula de 5 em 5. Então, novamente, tem mais coisas que a gente pode fazer aqui que deixa isso aqui ainda mais interessante. Outra coisa, eu posso definir um valor mínimo. O valor mínimo disso aqui é 5, e o valor máximo é 60. Olha que legal, eu vou agora aumentando, chega em 60, ele para. Se eu tento abaixar de 5, ele para também. Então, aposto que se você fosse fazer isso aqui, talvez não agora, talvez você já conhecesse isso, mas eu tenho certeza que tem gente assistindo isso aqui que não conhecia, e ia dar um jeito de fazer isso aqui com o JavaScript. Vamos lá, o que mais que a gente pode fazer? Então, por exemplo, aqui no task, uma das coisas que eu quero fazer nesse projeto, eu até pedi para o Dani aqui desenhar, é isso aqui, que ele traga uma lista, digamos assim, de sugestões de projetos baseados nos projetos que eu já fiz. Então, imagina, sei lá, todo dia de manhã eu acordo e eu faço um ciclo para trabalhar num projeto X, um projeto lá que eu estou trabalhando na minha empresa. Pô, não é o único projeto que eu faço, só que quando eu começar no outro dia de manhã, eu quero recomeçar, digamos assim, o ciclo do mesmo projeto que eu já fiz, eu não quero digitar o texto do projeto, tudo de novo. Então, olha só que legal que a gente consegue fazer aqui no HTML. Embaixo desse task input, eu posso passar um elemento do HTML que se chama dataList. O dataList nada mais é do que uma lista de sugestões para um input. E aí eu passo um id para essa lista, eu vou chamar de taskSuggestions, por exemplo, eu posso dar um nome mais descritivo. E aqui dentro eu posso passar cada sugestão como uma option, beleza? E essa option, ela precisa ter um valor. Aqui eu boto, por exemplo, projeto1, projeto2, projeto3 e aqui, só para variar um pouco, banana, para a gente ver que dá pra ser qualquer coisa. E aqui no nosso task input, eu posso passar list e passo task, opa, sem o hashtag, taskSuggestions. Salvo isso aqui agora e olha que legal, quando eu venho aqui no input e escrevo aqui, olha só, projeto1, projeto2, projeto3 e banana. Se eu clico aqui, eu posso automaticamente preencher, senão eu digito o projeto que eu quero. Só que eu não quero essa flechinha desgraçada aqui. E aí eu olhei isso aqui para resolver só no Chrome, eu não olhei para os outros navegadores, então você pode dar uma olhada caso você esteja utilizando outros navegadores. Mas para a gente tirar isso aqui no Chrome, eu tenho que vir aqui no meu task input e botar o seguinte, eComercial, que eu referencio esse mesmo input, né? 2 pontos, 2 pontos, traço, WebKit, traço, Calendar, CalendarPicker, Indicator, Display, Known, Important. Meu, quanto tempo que eu não uso Important no CSS. E beleza, dele já sai aquela flechinha ali. Agora, por que que é Calendar? Não sei, acho que alguém ali do desenvolvimento do Chrome esqueceu de mudar o nome ali, ou deu um Ctrl-C, Ctrl-V, mas é isso aí. E agora, fechou, a gente já está com o nosso input aqui totalmente estilizado, o nosso botão, o nosso formulário aqui, na verdade, é a nossa homepage, ela já está finalizada, agora a nossa página de histórico aqui está uma decepção que só a gente precisa melhorar isso aqui."
  },
  {
    "id": "8b396dcd-bc3a-4136-a6c4-0075e93eb269",
    "title": "Finalização da Home",
    "transcription": "Bora lá finalizar nossa ROM aqui. Então, o que a gente vai fazer, tá? Faltam algumas estilizações aqui no formulário, esses inputs aqui que estão bem estranhos e também a parte do botão. Então, vamos começar com o botão que é mais simples. E aqui eu tenho esse button type submit, então eu poderia fazer o seguinte, né? Aqui nos estilos, eu já tenho aqui em cima a ROMContainer, por exemplo, que pega esse main, que tá aqui por volta, que é esse aqui. E aí eu tô estilizando o form dentro dele, aqui, e eu poderia estilizar o botão também fazendo aqui, por exemplo, a button, dois pontos submit, né? Ou type submit, tanto faz. Eu poderia estilizar o botão aqui dentro, direto do form, com uma cascata. Só que a gente tem que cuidar, apesar de a gente poder fazer isso, na grande maioria das vezes, quando a gente tá utilizando style do components, é importante a gente tentar evitar cascatear muito a nossa estilização e focar mais em criar novos componentes estilizados. Então, é uma das coisas que eu vou fazer aqui. Então, por exemplo, ao invés de eu cascatear e criar mais uma estilização para um botão aqui dentro do submit, eu vou criar um novo componente para o botão. Eu vou chamar ele de startCountdownButton. E aqui nos estilos, vou criar ele aqui embaixo. Eu vou criar ele, pode ser, aqui embaixo de tudo, export, const, startCountdownButton, style, button. E aqui agora eu venho e dou um control ponto, importo dos estilos, e pronto. Nosso botão já tá aqui. E agora, nesse startCountdownButton aqui, eu vou adicionar algumas estilizações. Essas estilizações aqui são bem simples, eu vou simplesmente definir que ele tenha a largura de 100%, não quero borda, que é o padrão do HTML, né? Vou dar um padding de 1 rem também, 16 pixels no caso, border-radius 8, que é o padrão que a gente tá usando praticamente em todo projeto. Vou centralizar o texto e o ícone do botão ao centro, então sempre, tanto a line quanto o justifyContentCenter. Vou dar um distanciamento do ícone para o texto do botão em 8 pixels, e um font-weight bold. E agora cursor-pointer, pra ficar com o cursor certinho de botão. E aí, no caso desse botão, eu vou colocar um background dele de props.theme-green-500 e a cor do texto vai ser a gray-100, que é aquela cor quase branca, se não me engano é e1, e1, deixa eu até lembrar aqui, e1, e1, e6. E é isso. E agora a gente pode fazer o seguinte, quando o usuário estiver fazendo o hover nesse botão, a gente vai dar um background-props-green, porém 700, dá uma escurecidinha no botão. Bem simples a estilização, voltamos aqui, olha só, o botão já tá aqui, não tem nem muito o que falar aqui, a estilização já tá perfeitinha. Uma das coisas que a gente pode criar de variação nesse botão, é que aqui a gente pode ver que esse botão tá um pouco mais opaco. Aí se a gente for nos assets, a gente vai ver que esse botão aqui tem uma variação disabled. Então, além da variação hover que a gente tem, que é essa aqui, que fica mais escuro, nós temos uma variação disabled. E na variação disabled, basicamente, a gente diminui a opacidade pra 0.7. Então, o que a gente pode fazer? Pra testar, eu volto aqui na home, passo aqui pra ele um disabled, voltamos aqui nos estilos, e aí eu vou fazer o seguinte, se esse botão aqui estiver disabled, eu dou uma opacity 0.7, e também eu vou trocar o cursor dele pro not allowed, que é aqui a plaquinha de não fume aqui. Só que ele ainda tá com o hover, tá vendo? Só que a gente não quer isso aqui. Então, esse hover só pode aplicar se o botão não estiver disabled. Ou seja, se não, e aí entre parênteses, estiver disabled, quando eu fazer o hover, então a gente consegue fazer esse joguinho de concatenação de seletores no CSS. Já ajuda bastante, agora já não tem o filtro. É claro que esse botão, por enquanto, a gente não vai ter ele disabled, mas como a aplicação também nem tá funcionando nada, não tem problema deixar o disabled ali só pra gente testar. E agora, a gente vai pro nosso formulário aqui, pra gente finalizar o nosso form com chave de ouro. E aí o nosso form, deixa eu pegar minha little cola aqui. Vamos lá. Voltamos aqui nos estilos, nós temos o nosso form container aqui dentro, e dentro do form container nós temos os nossos inputs. Perfeito, vamos começar estilizando aqui. Deixa eu ver, a nossa label não precisa estilizar, porque a gente já colocou o font-size e tudo no container, eu só preciso estilizar os meus botões, os meus inputs, na verdade. Os meus inputs vão ter uma estilização um pouquinho diferente. Então, se eu for ver aqui no layout, eu tenho um botão que é maior que o outro. Apesar de que eles têm estilizações semelhantes, eu não vou poder aplicar um CSS igual pros dois inputs, porque eu preciso que esse input aqui ele expanda, ele tenha um tamanho, digamos, relativo, ele ocupe o máximo de espaço que ele puder, e esse input aqui ele precisa ter um tamanho fixo, porque como ele vai ter sempre dois caracteres, eu vou permitir, sei lá, que a pessoa faça um ciclo de no máximo 60 minutos, então ele vai de 00 até 60, não vou botar mais do que isso, então eu sei que ele vai ter um tamanho fixo, então eu posso setar isso especificamente. Nesse caso, o que eu vou fazer? Olha só que legal que a gente pode fazer aqui com o installo do component, tá? Eu vou criar um componente estilizado chamado TaskInput, e eu vou criar um outro componente estilizado chamado, vamos chamar aqui de MinutesAmountInput. Show. E aí aqui agora eu venho aqui no lugar desse aqui e boto TaskInput, faço aí a importação, e esse aqui é o MinutesAmountInput, fez a importação também. Salvo, teoricamente não muda nada, o que eu vou botar aqui já agora pra melhorar é no TaskInput, eu vou botar aquele nosso placeholder que tem ali, que é dê um nome para o seu projeto. E aqui no MinutesAmount, o placeholder vai ser apenas 00. E aí aqui é legal a gente quebrar, eu já estou usando o SLint aqui, mas é bom a gente sempre quebrar, aqui o meu no caso não quebrou, porque não ocupou o mínimo de 80 colunas aqui, né? Mas vamos lá, agora nesses dois inputs, a gente pode fazer estilizações que são comuns, por exemplo, os dois inputs aqui, eles vão ter um background, por exemplo, transparente. Então, se eu jogar background transparente aqui no TaskInput, esse aqui fica com o background transparente, só que esse não fica. E aí eu posso pegar e repetir o mesmo CSS para os dois. Mas se os dois inputs vão ter estilizações semelhantes, não tem uma maneira de eu reaproveitar a estilização? Claro que tem, olha só. A gente pode criar um componente estilizado aqui em cima, eu nem preciso exportar ele, ele vai ser usado só aqui dentro. Eu vou chamar ele de BaseInput, como se fosse o input base que vai ser utilizado para criar os outros inputs. E esse aqui eu vou chamar de StyledInput, então ele vai ser um input, e eu vou botar o background transparente nele, e vou tirar dos outros dois. Nos outros dois, ao invés de eles terem um StyledInput, que é o input tradicional do HTML, olha só que legal, eu vou copiar o nome BaseInput, e aqui no final do Styled, eu vou botar parênteses, ou seja, abre e fecha parênteses, passando um parâmetro, e eu mando o BaseInput, olha só. E agora aqui embaixo eu faço a mesma coisa. Ou seja, agora eu estou usando um componente estilizado de base para criar outros componentes estilizados, isso é muito legal. Eu salvo isso aqui agora, olha só, os dois já estão transparentes. Tudo que eu colocar aqui no BaseInput vai ser aplicado automaticamente para os dois inputs. Isso aqui é sensacional para fazer customização, para fazer herança de estilização. E agora a gente vai adicionar alguns CSS aqui, então vamos lá. Height 2.5 rem, border 0, porque vem padrão no input, sempre tem que tirar, chatinho, mas tem que fazer. Vou botar uma borda desses inputs embaixo usando a cor grey 500. A gente vai dar aqui também um font-weight bold, font-size 1.125 rem, padding 0, 0.5 rem. Uma coisa legal de falar também é o seguinte, aqui eu estou aplicando font-size 1.125 rem, mesmo que no container dele já tenha esse tamanho, porque o input não herda o font-size do container. Se eu não quiser fazer isso, eu poderia passar aqui, Inherit, não sei se você conhece isso aqui, mas basicamente, eu não sei, faço a menor ideia como pronunciar isso aqui, Fisk, Fisk, em inglês e espanhol é Fisk. Mas esse Inherit aqui, ele herda o font-size do container, e a gente não tem necessidade de usar isso aqui só no font-size. Se eu quiser usar no bold aqui, ele vai herdar o que o container está impondo para ele. Isso aqui é muito legal, mas aqui nesse caso eu vou botar fixo, que eu acho que fica até mais descrito, mais fácil de entender. E aqui eu vou botar também a cor do texto, grey 100, e beleza, já está aqui os nossos inputs. E agora, o input de duração aqui é menor, então o que a gente vai fazer? Eu vou vir aqui no Minutes Amount Input, e eu vou definir para ele, olha só que legal, width 4rem, e aí eu já tenho esse input menor que esse. E aí esse input aqui, eu quero que ele ocupe o máximo de espaço, ele não está ocupando o máximo de espaço, porque está sobrando espaço aqui na esquerda, está sobrando espaço aqui na direita, então eu venho aqui no Task Input e dou para ele um flex1, porque flex1, como o container, o form container tem display flex, eu boto flex1, eu estou basicamente, o flex1 na verdade ele é uma, como é que se diz? Quando uma propriedade, na verdade ela, um atalho? É, o flex1 ele é um atalho para setar 3 propriedades flex, flex grow, flex shrink, flex basis. Flex grow é, eu dou habilidade para o meu componente crescer, além do tamanho original dele, sim ou não? Sim, 1. Flex shrink, eu dou habilidade para o meu componente diminuir o tamanho dele, de forma, para o tamanho menor, caso seja necessário, sim ou não? 1 ou 0. E flex basis, qual que é o tamanho ideal do meu elemento? Se ele não estiver nem maior nem menor por causa do grow e do shrink. Então o flex1, ele automaticamente diz, esse elemento ele pode aumentar, pode diminuir, ele vai caber no espaço que ele tiver ali para caber, mas se tiver mais espaço ele vai aumentar até coberto. Então dou um flex1 aqui, e pronto, esse input aqui, ele já está ocupando o máximo de espaço que dá, e a gente pode ver que agora nem sobrou espacinho aqui, nem na esquerda, nem na direita. Isso é bem massa, é legal entender o porquê das propriedades CSS, CSS é um negócio muito incrível, é muito profundo o tanto de conhecimento que dá para ter em CSS, e eu aprendo CSS todos os dias, criando meus projetos, porque tem muita coisa que a gente as vezes só faz da maneira que é imposto e não para para entender realmente. E agora eu vou estilizar o placeholder aqui do nosso do nosso input, e eu vou botar aqui uma color grey 500, então aqui a gente pode ver que fica um cinza um pouquinho mais escuro, e quando esse input aqui estiver com focus, o que eu vou fazer? Eu vou dar um box-shadow-none para ele não ficar com essa sombra por volta, como eu tenho nos outros elementos, e eu vou botar nele um border-color, que é a borda que ele já tem, porém usando aquele nosso verde green 500. Então agora olha só que legal, quando eu dou a bordinha fica verde, e pronto, a gente está com o nosso input finalizado. Outra coisa legal da série coisas que você faz as vezes de uma maneira mó complicada, e o HTML traz de maneira padrão para a gente. Vou te mostrar algumas coisas legais que a gente pode fazer aqui nesse input, mas não agora. Tchau!"
  },
  {
    "id": "e8946983-bbe0-462e-a9de-abdf1e541ac8",
    "title": "Página: History",
    "transcription": "Nessa aula, a gente vai estilizar, criar, que é a estrutura da nossa página de histórico. Então, vamos aqui, vestcode, history. Agora a gente vai criar uma pasta também, history. Dentro, a gente agora troca o nome desse arquivo pra index. Arrasta aqui pra dentro. E aqui, a gente cria o nosso styles.ts. Aqui eu vou criar já o nosso history container. É igual a styled. Bota main aqui por enquanto. Salva, volta aqui no index. Agora troca essa div aqui pra history container já. Pra deixar previamente criada a estrutura. Na página de histórico, ela vai ser mais simples que a home. Então, vamos lá. Aqui dentro desse history container, eu vou ter um h1. Eu vou chamar ele de meu histórico. E aqui embaixo, eu vou ter uma tabela. Como a gente pode ver aqui nessa página. E a gente pode simplesmente criar essa tabela aqui. Só que eu vou criar ela com uma div por volta. Eu já explico o motivo. Então, eu vou criar primeiro uma div aqui. Vou criar um componente estilizado. HistoryList. Qualquer coisa assim. E aqui a gente cria ele aqui dentro. Então, historyList vai ser uma div. E aí a gente volta aqui dentro. Importa o historyList aqui do styles. Ficou com um T a mais sem querer aqui. E agora dentro do historyList, eu vou criar minha tabela. Então, deixa eu pegar minha cola aqui. Aqui. A gente vai começar criando o table. Thead. Tr. Th. E aí vai ser tarefa. Duração. Início. Status. E aí. Tebari. Abaixo do Thead. Vocês são da época que não existia nem Thead, nem Tebari? Eu sou. Numa época não existia nada disso aí. Nem Th. Era só Tr, Td e Tebo. E aí Tebari. Aqui a gente vai ter a nossa... Pra cada linha a gente vai ter um Tr. E aí Td pra cada coluna. E aí no primeiro Td é qual a tarefa. Então, vou botar aqui tarefa só por enquanto. No segundo é a duração. Então, vai ser só 20 minutos. No terceiro é qual a data de início. E aí, se a gente for ver, a data de início aqui é estilizada, por exemplo, há tanto tempo. Então, por enquanto eu vou botar um texto aqui mesmo. Há dois meses... Qualquer coisa assim. Há... Ah, tanto faz. E aqui o status. A gente vai ter... Essa bolinha seguida do nome. Por enquanto eu vou botar aqui só concluído. A gente não vai se preocupar em criar essa bolinha por enquanto. A gente vai se preocupar mais na estilização da tabela em si. E agora eu vou pegar esse tr aqui e vou... Replicar ele algumas vezes aqui. Então... Show. Repliquei eu não sei quantas vezes eu botei em tela, tá? Mas... No f5 já tá aparecendo tudo ali. E agora bora lá pra estilização. Então... A gente vem aqui no styles. Vamos começar estilizando o nosso... Container em si. O nosso container eu vou fazer o seguinte. É... Flex1. Padding 3.5. Ham. Display. Flex. Flex. Direction. Column. E aí a gente pega o nosso h1. Font size 1.5. Ham. E color. Props. Props. Theme. Gray. Same. Salva. Vamos ver como é que ficou. Show. Meu histórico já tá aqui embaixo. Mais ou menos onde ele tem que estar ali mesmo. E agora a gente vai pra tabela em si. E aí a gente tem esse history list aqui por volta, tá? Por que que eu criei esse history list? Porque... Aqui o Dani acabou não criando a versão mobile desse projeto. E se tem uma coisa chata de fazer em mobile, é tabela. Tá? Porque... Não existe uma forma da gente representar uma tabela no mobile de maneira satisfatória. Então, o que que a gente fez? Eu criei aquela div por volta da tabela. Porque quando tiver no mobile, quando a tela estiver menor... Eu vou fazer com que o usuário consiga dar scroll na tabela. Ou seja, ele consiga arrastar a tabela de um lado pro outro. E aí a única forma da gente fazer isso é em div. Não dá pra fazer scroll em table. Então por isso que eu botei essa div por volta. E aí essa div aqui por volta... Eu vou colocar nela um flex1 pra ela ocupar o máximo de altura possível ali. E aqui ó, eu vou botar overflow alto. Isso vai fazer com que se o tamanho aqui da tabela for maior do que o tamanho do container que eu tenho disponível pra ela... Ele gere uma barra de rolagem. E aí eu vou dar um margin.tops. Aqui, 2 rem. Salvo. E beleza. Por enquanto não vai aparecer nada. Agora a gente vai estilizar a tabela em si. Então, aqui eu venho pra table, dentro do history list. E a gente vem width 100%. Border collapse. Esse border collapse, caso você não saiba o que que é... É basicamente pra... Se eu boto, por exemplo... Uma borda no td. De um pixel. Se eu não botar esse border collapse, ele vai pegar um pixel do td da esquerda mais um do da direita. Ou seja, vai ficar dois pixels. Se eu boto border collapse, ele conta como se só existisse uma borda entre eles. E não as duas bordas dos dois elementos. Ficou claro? Mais ou menos né? Mas é isso. Aqui a gente vai botar um min width de 600 pixels. Isso aqui vai forçar com que quando a gente tiver um tamanho menor, ele gere o scroll. Aqui, eu vou pegar o meu th. Eu vou dar um background color de props. Theme gray 600. Então a gente pode ver aqui a tabela. Vou dar aqui um padding de 1 rem. Um text align left, que por padrão ele vem como center. Color aqui, a gente bota um gray 100. Font size 0.875, que é o 14 pixels. E o line height de 1.6, ou seja, 160%. Show! Já ficou bem legal ali a tabela. E agora, o que a gente vai fazer? Eu vou selecionar a primeira th. E eu vou dar um border top left radius de 8 pixels. Ou seja, aqui no cantinho eu quero arredondado. E eu vou pegar a última th. E eu vou dar um top right radius de 8 pixels, que é lá. E também vou aumentar um pouquinho o padding left nessa aqui. Pra 1.5 rem. E nessa aqui, aumentar um pouquinho o padding right. Pra distanciar um pouquinho mais daqui. Isso tudo por causa aqui do layout. E vamos lá. Agora, depois do th aqui, a gente vai estilizar o nosso td. O nosso td, ele vai ter um background color gray 0.7. Um border top 4 pixels solid props theme gray 0.8. O que que eu fiz aqui? Aí. Então, já dá pra ver como que tá ficando. Eu botei a mesma, essa gray 0.8 é a mesma cor de fundo. Por isso que parece que é só uma borda transparente. Mas é isso. Padding aqui, 1 rem também. Font size 0.875 rem. E line height 1.6. Show. Já dá pra ver como que vai ficar. E agora, a gente vai fazer essa mesma coisa de first child, last child. Porém, a gente não vai fazer isso aqui pro radials. Apenas pro padding. Então vai ficar assim. E eu quero que esse primeiro td aqui, ele ocupe mais espaço. A tarefa em si. Então eu venho aqui no first child, boto pra ele ter, sei lá, o width 50%. Pra ele ocupar a maioria do espaço. E o restante aqui ficar menorzinho, porque são informações que não vão exigir muito espaço em si. Então, essa aqui é basicamente a nossa tabela em si. Se eu reduzo a tela aqui, a gente pode ver que ele acaba gerando essa barra de rolagem. Que é o que a gente queria. É claro que o responsivo ainda tá bem mais ou menos, digamos assim. Mas a gente vai dar uma melhorada nisso aqui depois. Mas algumas coisas já dá pra gente ir deixando pronto. Pra depois evitar ter que voltar e refazer muita coisa. Então a gente já tá com as nossas páginas aqui. Do timer e do histórico funcionando. Falta o status aqui agora. E claro, depois da vida pra tudo isso. Pra fazer isso tudo se conversar e realmente funcionar."
  },
  {
    "id": "f8354f59-d2c1-4a88-9997-3ca6a6279d24",
    "title": "Componente: Status",
    "transcription": "O que faremos agora é adicionar um pouco de cor para o nosso status. Desculpa por essa encenação, mas... Aqui nos nossos status, onde a gente tem em andamento, interrompido e concluído, a gente vai colocar essa bolinha aqui. E é legal porque, por mais que pareça algo super simples, a gente consegue aprender muita coisa com isso. Então, vamos lá, vamos criar isso juntos. Então, o que eu vou fazer? Aqui, onde a gente tem o nosso histórico, aqui embaixo, a gente escreveu todos como concluído. O que a gente vai fazer? A gente vai criar um novo componente para esse botão, botão não, para essa flag do status. Não sei se dá para chamar assim uma badge, não sei exatamente. Mas esse componente não precisa ser necessariamente um arquivo separado. Ele pode ser apenas um componente estilizado. Então, toda vez... Isso é algo importante para a gente ter na cabeça. Quando a gente está usando styled components, toda vez que a gente for criar um componente novo na nossa aplicação, só porque algo é visualmente diferente, aquilo não necessariamente precisa ser um arquivo novo. Aquilo pode ser só um styled component mesmo, um componente estilizado que fica dentro do nosso styles.ts. Olha só que legal, eu vou criar aqui um export, const, status. Isso aqui pode ser um span, vamos botar uma div. Pode ser um span. É bom porque ele já fica com o display inline mesmo. E aqui a gente vai fazer o seguinte, olha só que legal. Display, flex, alignItemCenter e gap 0.5rem. Por que eu botei flex, alignItemCenter e gap 0.5rem? Se dentro do meu status, vamos inclusive selecionar todos aqui, concluído. Vou quebrar, vou dar um enter, botar aqui status, importar, botar sim e dentro eu vou escrever concluído. Então, veja só, dentro do status eu só tenho um texto. Um texto só. Então, se eu só tenho um texto, eu estou botando espaçamento do quê? AlignItemCenter do quê? Olha só que interessante. A gente consegue adicionar um elemento novo dentro desse status através do CSS, usando o before e o after. O before e o after são elementos que a gente coloca que ficam dentro da tag, no caso dentro do span, dentro do status, no começo ou no final. O before é no começo, ou seja, antes de qualquer conteúdo e o after no final. O before, se eu quero que ele seja visualmente... Nossa, visualmente visível, eu ia falar isso. Tá certo, né? São duas coisas que parecem que são a mesma coisa, mas é isso. Se eu quero que ele apareça na tela de alguma forma, ele precisa ter um conteúdo. E aqui eu preciso passar o conteúdo em branco. Mesmo que seja em branco, eu preciso passar esse content, senão ele não aparece em tela. E aí eu vou botar aqui width 0.5, height 0.5 que dá 8. Border radius aqui, eu posso botar 50% caso eu queira que fique totalmente arredondado. Ou boto aqui 9, 9, 9 pixels. Tem gente que... Cada pessoa prefere de uma maneira diferente. E aqui, olha só, eu vou botar por enquanto um background. Props. Vou botar aqui props.theme e vou botar aqui yellow 500, que é uma cor amarela que a gente tinha utilizado. Por enquanto eu vou deixar só essa cor de fundo mesmo. E agora volto aqui, salvo só pra garantir. E agora volto no Chrome. Olha só que legal. A gente já tem a bolinha ali, tá vendo? Faltou eu colocar status concluído e mais alguns aqui, nesses dois aqui embaixo. Então eu vou dar um enter aqui. Show. Então essa bolinha aqui, ela é o before que a gente colocou. Então aqui dentro do explore, olha só, before é a bolinha. Tá vendo? E aqui, o concluído, é o nosso texto ali do lado. Aqui inclusive eu tenho que melhorar, olha só, essa tabela que era pra estar cortando pela metade aqui e dando um overflow. Logo a gente dá uma organizada aqui no estilo dessa tabela. Mó feio que tá aqui. Mas tá, daqui a pouco a gente vai arrumar, não tem problema. E agora esse status aqui, apesar de ele ser um componente que a gente criou dentro dos estilos, a gente também pode repassar propriedades pra esse status. Então olha só que interessante. Aqui dentro dos estilos, se eu quero fazer esse componente de status poder receber alguma propriedade, eu crio uma interface falando quais são as propriedades que ele pode receber. Então status prop. E eu vou receber, por exemplo, uma propriedade... Talvez... O que a gente pode fazer aqui? A gente pode fazer uma propriedade chamada... Deixa eu pensar aqui o melhor nome que a gente poderia dar isso aqui. Por mais que eu tenha uma colinha aqui. Eu acho que a gente pode dar um nome mais legal aqui. Eu posso dar um nome, por exemplo, de status... StatusColor mesmo. E aí eu vou falar que essa statusColor pode ser... Yellow... Red... Ou Green. E aqui eu venho no span e falo que esse meu span pode receber essas propriedades. Usando aqui o generic do TypeScript. E agora... Eu vou lá no meu index e eu vejo que ele já está dando erro, porque eu preciso passar essa propriedade statusColor. Então, se eu selecionar aqui todos os status e passar aqui statusColor e dou um CTRL espaço aqui, ele provavelmente já vai dar a opção para a gente. Green, Red ou Yellow. Vamos colocar Green em todos, até porque está como concluído, e depois a gente vai mudando. Claro, se eu volto aqui, continua amarelo. E aí o que eu vou fazer aqui agora? Eu vou criar aqui um objeto. StatusColors, por exemplo. E aí eu vou fazer um mapeamento dessa cor aqui para um RGB. Então, no caso do nosso Yellow, eu quero que seja uma cor específica, só que essa cor vem lá do nosso tema. Então, essa cor precisa ser variável. Isso aqui vai dar um trabalhinho meio chato, mas a gente consegue fazer. É bom que a gente cai nessas coisas que não são tão simples de desenvolver para a gente comparar isso com o mundo real. Então, o que eu vou fazer? Eu vou mapear, ao invés de mapear isso aqui para um hexadecimal direto, eu vou mapear para uma string lá do nosso tema. Meu Deus, onde é que eu estou? Aqui. Então, essa cor aqui vai ser a Yellow 500. A nossa cor verde vai ser... Deixa eu até pegar aqui para garantir que estou pegando a cor certa. Vai ser a Green 500. E a cor vermelha vai ser a Red 500. Perfeito. E agora, aqui embaixo, eu vou fazer o seguinte. Eu vou selecionar a cor baseada no StatusColors, passando aqui a chave, a propriedade, que vem de props.statusColor. Vamos dar uma olhadinha aqui. O nosso StatusColor, se eu passar o mouse por cima, ele está Yellow, Green, Red. String, string, string. Aqui ele fala, No index signature with a parameter of type string was found on type default theme. Isso aqui provavelmente acontece, porque aqui ele está entendendo que esse conteúdo pode ser qualquer string. Deixa eu ver se talvez eu vou usar um AsConst. Aqui ele já para de dar erro, está vendo? E é muito importante entender o que é esse AsConst aqui no final. Olha só, eu criei um objeto. O TypeScript, quando ele lê esse objeto, ele entende... Esse objeto aqui pode ter uma chave Yellow, Green e Red. E o valor dessas propriedades é um texto. Pode ser qualquer texto. Pode ser qualquer texto. É um texto variável, digamos assim. Para eu dizer para o TypeScript que esse texto aqui sempre vai ser um desses três, e ele não pode mudar, eu passo esse AsConst. E a gente pode ver a diferença simplesmente fazendo o seguinte. Eu passo o mouse em cima do StatusColor. Yellow, string, Green, string, Red, string. String não quer dizer nada, é um texto qualquer. Se eu passo AsConst, passo o mouse aqui, já muda. Ele fala, quando for Yellow, é Yellow 500. Quando for Green, é Green 500. Quando for Red, é Red 500. Não tem outra opção, não é uma string. São essas três strings exclusivamente. E agora já para de dar erro. Porque o erro estava dando porque quando poderia ser qualquer string, ele estava dando um erro. Opa, o teu tema lá, o default, não pode ser qualquer string. Tem que ser uma dessas que está aqui. Não pode ser qualquer uma, senão ele não vai encontrar a variável. Quando eu falo que vai ser exclusivamente essas três, aí ele encontra as três no tema e ele fala, não, beleza, então tá show. O tema tem essas três. Se eu passasse alguma aqui que não tivesse, por exemplo, um F, ele já vai dar erro. Porque o tema não tem Red 500 F. Então isso é importante. São coisinhas, claro, são chatas. É legal a gente cair nesses edge cases porque a gente sai do básico. Sai daquela, ah, está dando tudo certo, mil maravilhas. E, cara, a gente pode melhorar isso aqui ainda mais. Você concorda comigo que essa status color aqui, Yellow, Red e Green, são as opções que eu tenho aqui. Se eu tivesse mais opções aqui, eu também teria que colocar aqui, obviamente. Aqui, ao invés de eu definir Yellow, Red e Green, eu posso falar, olha, as cores disponíveis que eu tenho são as chaves, as keys desse objeto. Então, as cores que eu tenho disponíveis são as keys do meu, tipo, do meu status color. Eu não posso dar status color direto porque ele é um objeto JavaScript. O TypeScript não consegue ler o objeto JavaScript. Ele consegue ler apenas a tipagem do objeto JavaScript. Então, se eu passo o Type Off, aí sim eu consigo trabalhar com isso dentro do TypeScript. E agora eu passo o mouse em cima do status color, Yellow, Red e Green, não muda nada. Se eu adicionasse mais uma cor aqui, por exemplo, Grey, e aí eu boto aqui o Grey 500, a gente tem Grey 500? Ah, já deu certo. Volto no status color, já está ali, Grey aparecendo também. Legal, né? Então, é interessante a gente ir mais a fundo e ir descobrindo como que a gente pode melhorar as coisas. E agora, eu vou trocando aqui. Ao invés de Green, se eu quiser botar um Yellow e botar um Red, e aí o Yellow é em andamento e o Red é interrompido. Salvo isso aqui agora, eu volto aqui, e olha só, em andamento, interrompido. E assim, a gente já tem a estilização do componente de status. Ficou bem legal e bem customizável. A gente consegue melhorar esse componente e está show. Agora falta a gente dar vida para a nossa aplicação, porque esse CSS, tirando a nossa tabela aqui que está quebrada, que logo a gente vai arrumar, o resto já está bem massa."
  },
  {
    "id": "28eb3ebe-8b16-49d6-986e-188bc94478e7",
    "title": "Formatando valores",
    "transcription": "O que a gente vai fazer nessa aula é a formatação dos valores que a gente tem aqui na nossa aplicação. Então, por enquanto, a gente tem tanto aqui no resumo, nas entradas, nas saídas e no total, e também aqui na tabela, a gente tem vários valores que não estão formatados, então é isso que a gente vai fazer agora. Como eu vou lidar tanto com formatação de preços e datas, e essas formatações precisam acontecer em vários componentes diferentes, por enquanto o resumo e a tabela aqui, eu vou criar uma pasta Útils, e aqui dentro eu vou criar um arquivo chamado Formatter. E aqui dentro eu vou criar os dois objetos de formatação, então eu vou criar um para data, eu vou chamar ele de DateFormatter, ele vai utilizar o INTL, a API de internacionalização do próprio Javascript, e eu vou utilizar o DateTimeFormat, PTBR, simples assim, não precisa mais muita coisa além disso. E eu vou também criar o PriceFormatter, que ele vai utilizar o NumberFormat, também PTBR, porém eu vou passar para ele StyleCurrency, para ele formatar como moeda, e vou passar que a moeda é o BRL, para ele colocar o RS na frente. E show, com isso feito, a gente vai salvar isso aqui, vamos lá para a página de transações, e aqui dentro onde eu tenho o TransactionPrice, eu vou utilizar o nosso PriceFormatter.format, passando o meu Transaction.price, volto para o Chrome, eu posso ver já que já está formatado. Uma coisa que eu vou fazer aqui também, é que nas saídas aqui, os que estão em vermelho, eu quero botar um menos na frente. Então aqui, antes do preço, eu vou fazer uma condicional. Se a Transaction.type for igual a Outcome, que é a saída, e eu posso utilizar o e-comercial, quando o meu if só tem um then e não tem o else, digamos assim, porque no Javascript, isso aqui, talvez você já saiba, mas vale sempre falar, no Javascript, diferente de algumas outras linguagens, no Javascript, quando a gente faz uma condicional, por exemplo, eu crio um if, certo? E esse if, por exemplo, ele tem duas condicionais aqui dentro. Se o x é maior que 5, ou o y é menor do que 3. Qualquer coisa assim. Quando o Javascript vai ler essa condicional, ele lê a primeira condição, e se essa condição já for verdadeira, digamos assim, se o x é maior que 5, o resto da condicional nem é lida, ou seja, isso aqui nem é executado. Isso vale também para quando eu coloco o e-comercial. Se essa condicional aqui for falsa, o restante nem é executado, porque não interessa, o restante não é importante, porque se isso aqui já foi falso, nada, aqui pode dar verdadeiro, para o Javascript não vai mudar nada, porque não vai entrar na condição. E é por isso que a gente pode utilizar o sinal do e-comercial, ou até o sinal do ou, para eu conseguir executar a segunda parte da nossa condicional, digamos assim, da nossa instrução, da nossa expressão, baseado no valor booleano da primeira condicional. Então isso é bem legal, é um pouco mais de fundamental da linguagem, mas vale falar. Então aqui se o transaction type for igual a outcome, a gente vai renderizar aqui um sinal de menos. E aqui para o sinal de menos não ficar colado no valor, eu boto um espaço aqui no meio. E aqui vale mais um aprendizado. No React a gente não consegue colocar um espaço, simplesmente vindo aqui, por exemplo, vamos supor, eu quero botar um espaço antes da categoria. Eu venho aqui, se eu tentar botar espaço assim, não vai funcionar. Está vendo? Ele não funcionou. Mudou um pouquinho o visual porque eu tirei o espaço daqui, foi isso que mudou o visual. Mas isso aqui não funcionou. Sempre que eu quero colocar um espaço em branco no React, eu preciso colocar chaves, string, e aí eu boto o espaço aqui. Aí sim funcionou. Só que nesse caso aqui, como é uma tabela, ele acaba reestilizando o HTML, ele acaba forçando com que o category fique para a esquerda. Mas eu vou botar isso aqui no meio de, por exemplo, se eu quisesse botar aqui um espaço entre o if e o nosso format. Se eu venho aqui e boto isso aqui, ele botou um espaço só. Ele acabou botando um espaço só. Ele acaba botando um espaço só. Eu acho que eu tenho que fazer repetidas vezes o espaço, se não me engano. Ah, mas é por causa do próprio HTML, na verdade. Eu não consigo botar múltiplos espaços, mesmo dentro de um parágrafo. Eu não consigo fazer, por exemplo, a test. Ele bota um espaço só. Isso aqui é o próprio HTML que não deixa, não tem nem muito a ver com o próprio React. Eu tenho que acabar usando aqueles NBSP, que isso aqui é o carácter especial para realizar um espaço. Aí sim, eu consigo colocar vários espaços. Mas tudo bem. A gente estava pegando alguns conhecimentos aqui profundos que não eram tão necessários aqui. Mas show, a gente já botou o espaço aqui, vamos formatar a data também aqui. Lembrando que esse createdAt, quando ele vem da nossa API, ele vem como string. Então, quando a gente for formatar ele, a gente precisa converter ele para uma data, usando o newData. Salvo. Pronto, já está formatado. Vamos lá para o nosso summary. E aqui a gente vai pegar, onde eu tenho o summary.income, outcome e total. E eu vou usar aqui o priceformatter. Boto aqui, aqui, aqui, .format, aqui e aqui. Salvo e pronto. Já está formatado aqui também as entradas, saídas e o total. E assim a gente já está com tudo formatado, agora é só continuar."
  },
  {
    "id": "63712c2a-3ed6-4535-90ed-9fb5d2fab5fd",
    "title": "Reduzindo countdown",
    "transcription": "Bora continuar então agora, mas antes, claro, água. Bebam água. Você está tomando água enquanto está assistindo às aulas. Bora lá. O que a gente vai fazer aqui agora é fazer os segundos realmente passarem. Porque aqui na nossa aplicação, por enquanto, a gente está setando o horário inicial do timer, mas a gente não está reduzindo. E existem muitas formas de a gente reduzir a cada segundo, digamos assim, o timer aqui dentro. E aí você já deve ter pensado em algumas, e provavelmente a primeira que veio na sua cabeça, se você nunca criou algo assim, é setInterval. Acertei? E o setInterval, com certeza, é uma ótima opção para a gente utilizar aqui. Mas eu vou te falar algo tanto sobre o setInterval quanto o setTimeout, que talvez você não sabia. Sabe quando a gente coloca que a gente quer que um intervalo, ou o timeout ali do setTimeout, aconteçam após um segundo? O que você talvez não sabia é que esse um segundo, ele geralmente não é preciso. Ele é uma estimativa. Principalmente se você está rodando o seu navegador numa aba em background, ou se o seu computador está com o processamento muito lento, essa estimativa de um segundo, ela pode não acontecer em exatamente um segundo. Então, se a gente for se basear somente no um segundo do intervalo do timeout, do intervalo, setInterval, para reduzir o nosso contador e aumentar o tanto de segundos que passaram, pode ser que o timer não fique correto. E ele talvez passe menos segundos do que realmente já passou. Então, como que a gente vai fazer? Existem várias formas, como eu já falei. A forma que eu mais gosto de fazer é o seguinte. Quando a gente criar o nosso ciclo, que hoje a gente está salvando id, task e o tanto de minutos, eu vou salvar também qual que foi a data, e aqui data é um date do Javascript, então é tanto data quanto horário. Eu vou salvar a data que o meu timer começou, ou melhor, a data que ele ficou ativo, e aí, com base nessa data, a gente vai conseguir saber quanto tempo passou. Então, olha só que legal. Aqui, quando eu criar um novo ciclo, eu vou jogar o startDate como sendo a data atual, ou seja, a data que o ciclo iniciou. E aí, agora, aqui dentro do nosso código, deixa eu pegar aqui a minha colinha, a gente vai fazer o seguinte. Nós vamos criar aqui um useEffect, e dentro desse useEffect, a gente vai criar o nosso intervalo. Então, aqui dentro, eu vou fazer o seguinte. Se eu tenho um ciclo ativo, então eu vou mover essa variável activeCycle aqui pra cima desse useEffect, e aí eu vou fazer o seguinte. Se eu tiver um activeCycle, por quê? Porque eu só quero fazer a redução do countdown se tiver um ciclo, se não, não tem lógica, né? Eu vou fazer a redução do quê? Não tem muita lógica aqui. Então, se eu tiver um ciclo ativo, eu vou dar um setInterval. Posso botar a cada um segundo, não tem problema. Só que aqui dentro do intervalo, ao invés de eu fazer um setAmountSecondsPassed, como algo assim, state mais um, que ele vai incrementando mais um, mais um, mais um a cada segundo, como esse um segundo aqui não é preciso, eu vou comparar a data atual com a data que eu salvei aqui no startDate, e ver quantos segundos já se passaram. Olha que interessante. Pra isso, eu vou instalar um pacotezinho aqui chamado DateFns, e de dentro desse pacote, do DateFns, eu tenho uma função que se chama DifferenceInSeconds, que ele calcula a diferença de duas datas em segundos. E aqui, agora, eu vou dar um setAmountSecondsPassed, como sendo a diferença em segundos da data atual, sempre a data mais adiante a gente coloca como primeiro parâmetro, senão ele vai dar a comparação em segundos em negativo. E depois, a data que o ciclo começou. Vou salvar aqui agora, a gente já pode ver o código. E aqui no nosso UseEffect, eu posso ver que por eu estar utilizando o slint, ele já deu um aviso aqui embaixo. ReactHook, UseEffect has a missingDependencyActiveCycle, either include it or remove the dependency array. O que isso está querendo dizer? A gente está utilizando aqui dentro do UseEffect uma variável, que é o ActiveCycle, que é uma variável externa a esse UseEffect. Sempre que a gente usa uma variável externa, a gente obrigatoriamente precisa incluir essa variável como uma dependência do UseEffect. Isso vai implicar também em um funcionamento que é o seguinte, cada vez que essa variável ActiveCycle mudar, esse código vai executar de novo. O que pode ser bom ou pode ser ruim, mas por enquanto eu vou deixar assim, e a gente vai descobrir os problemas que isso aqui pode acontecer com o tempo, e aí corrigir. Não tem porque a gente prematuramente tentar resolver problemas que a gente nem tem. Bora salvar isso aqui agora, e olha que legal, vou voltar para a minha aplicação, está aqui, aplicação limpa, e vou falar aqui que vou começar a trabalhar no projeto 1 por 20 minutos, ou acho que a gente... é, por 10 minutos vou colocar, tanto faz. Vou começar, e agora olha que interessante. O nosso timer já está rodando. E é claro que tem bugs aqui, a gente sempre vai testar o cenário mais incrível, a gente nunca vai testar os cenários que podem dar algum tipo de problema. Mas se o nosso counter chegar a zero hoje, ele vai continuar executando para sempre. Mas a gente não vai se preocupar com isso agora. Outro problema que a gente deixou aqui, é que se eu começo um novo projeto aqui, enquanto eu já tenho um ciclo rodando, olha só que interessante, vou começar um novo aqui, de 20 minutos agora. Olha ali, Maria José, está tudo bugado. Por quê? Porque esse código aqui, como eu mudei o ciclo ativo, ele executou de novo, começou outro intervalo, ou seja, está uma desgraceira aqui, ou seja, tem vários bugs que a gente precisa resolver. E a gente vai resolver esses bugs com o tempo, mas por enquanto está ótimo."
  },
  {
    "id": "9885e4e0-f85d-415d-8a8a-49124eb22f94",
    "title": "Validando formulários",
    "transcription": "Tinha esquecido da luz aqui. Uma das coisas que a gente vai fazer aqui no nosso projeto que, por mais que a gente não vá precisar, porque pense comigo, olha só, eu tô deixando o botão de começar o novo ciclo desabilitado quando não tem nada escrito, então a pessoa não vai conseguir clicar de qualquer forma, mas mesmo assim eu vou te mostrar como que a gente pode fazer validação no formulário para caso você queira deixar a pessoa clicar e quando ela clicar e o valor do input estiver em branco ou inválido, mostrar uma mensagem, botar uma borda vermelha, que é o comum da maioria dos formulários. Então eu vou te ensinar isso mesmo a gente não fazendo porque eu sou gente boa pra caramba. Não, brincadeira, vamos lá. O que a gente vai fazer aqui? Por padrão, o React Hook Form ele não traz nada de validação. Tá Diego, então pô, tu me apresentou uma biblioteca. Beleza, né? O que que acontece? O React Hook Form, ele prefere se manter uma biblioteca mais enxuta, que tem menos funcionalidades, e utilizar de outras bibliotecas feitas para validação que já são muito boas, integradas a ele. Ou seja, ele não ter que criar todo algo de validação junto na biblioteca, sendo que já existem outras bibliotecas muito boas de validação. E aí, existem bibliotecas de validação. Então, por exemplo, IUP, é uma biblioteca muito comum de validação. Existe uma outra chamada JOI, que também é uma validação, uma biblioteca de validação, todas elas extremamente parecidas. E existe uma outra que se chama ZOD, que também é uma biblioteca de validação. E novamente, pessoal, todas elas extremamente semelhantes. Qual que a gente vai utilizar? Qual que é melhor? Sinceramente, tanto faz. Eu vou utilizar a ZOD aqui, porque ela traz um pouco mais de integração com TypeScript. Então, eu particularmente gosto da ZOD, porque ela traz um pouco mais de inteligência, inteligência. Você vai digitando, ela não permite você validar campos que não existem. As outras, elas ficam um pouco mais abertas. Mas a questão de qual é melhor em funcionamento, pessoal, tanto faz, não muda nada. Nem sei por que existem essas três. É comunidade JavaScript. Tipo, não gostei de alguma biblioteca, vou lá falar que eu posso melhorar aqui. Nada, vou criar a minha. Vamos lá. Então, a ZOD, como é que a gente faz para instalar ela aqui? Vamos dar até uma olhadinha aqui embaixo. Eu não preciso olhar nada aqui embaixo, é só dar um NPM e instalar a ZOD aqui e a gente já consegue sair utilizando. Mas, como eu falei, o React Hookform, ele integra com essas bibliotecas. Para eu integrar com essas bibliotecas aqui, eu preciso instalar uma outra biblioteca chamada arroba-hookform-resolvers. Essa biblioteca aqui é o que vai permitir eu integrar o React Hookform com as bibliotecas de validação. E aí, olha só, eu vou vir aqui em cima e vou importar de dentro de hookform-resolvers barra ZOD, veja que eu tenho uma integração específica para a biblioteca ZOD. Eu tenho aqui IUP também, JOI, que eu mostrei. Existem várias outras, por isso que eu estou falando. E aqui dentro eu vou importar um carinha chamado ZOD-resolver, que vem de dentro aqui dessa biblioteca. E aí eu também vou importar a biblioteca ZOD. Então, eu posso dar import ZOD from ZOD. E aí, uma das coisas, está vendo que ele deu um erro aqui nesse ZOD, ele deu defined but never used. Mas, se eu dou um ctrl aqui e clico em cima de ZOD, eu vou ver que ele exporta aqui, ele não tem nenhum export default aqui dentro. Isso é importante da gente olhar, tá? Essa biblioteca, ela não tem nenhum export default, ou seja, eu não consigo necessariamente utilizar o import default, um import assim, dessa forma. Então, eu teria que importar cada função do ZOD aqui, separadamente. Ou, eu posso utilizar uma técnica aqui do ECMAScriptModules, que é importar tudo e dar um nome pra isso aqui. Então, a gente só vai usar essa sintaxe de importação quando a biblioteca que eu estou importando não tem um export default aqui dentro. Se eu for em alguma outra biblioteca aqui, eu acho que nenhuma dessas aqui tem export default, e aí eu não vou conseguir mostrar. Nenhuma dessas aqui vai ter. Nenhuma dessas aqui tem, então eu não vou conseguir mostrar. Mas, eu acho que ficou claro, né? E agora, aqui embaixo, o que a gente vai fazer? Aqui no nosso useForm, a gente vai passar pra ele um objeto de configurações, e aqui dentro desse objeto de configurações, eu vou falar, olha, eu quero utilizar um resolver de validação, que é o meu ZODResolver. E aqui pra dentro do ZODResolver, eu preciso passar qual que é o meu esquema de validação, ou seja, de que forma eu quero validar os dados que eu tenho aqui embaixo dos meus empates. Então, por exemplo, eu tenho que falar o seguinte, olha, a minha task, ela é obrigatória, e ela precisa ter no mínimo cinco caracteres, por exemplo. O meu MinutesAmount, ele precisa ser um número, precisa ser múltiplo de cinco, tem que ter o máximo de tanto, o mínimo de tanto, então eu preciso passar quais são as minhas regras de validação. Pra isso, eu vou criar um objeto aqui fora do componente mesmo, chamado newCycleFormSchema, ou ValidationSchema, e aqui veja que eu não simplesmente criei, ah, FormValidationSchema, porque se um dia mais pra frente eu tiver mais de um formulário dentro dessa página, aí eu já vou ter que renomear variável, fica ruim, então eu já vou dar um nome que representa o formulário de criação de um novo ciclo, e aí eu criei o esquema de validação. A gente chama de esquema porque essas bibliotecas, elas usam um formato de validação que é SchemaBased, esquema nada mais é do que a gente definir um formato e a gente validar os dados do nosso formulário com base nesse formato, com base num esquema, assim como a gente tem um esquema de um banco de dados, por exemplo, que é um formato, como as coisas estão, como que as coisas vão ser salvas, digamos assim. Como que a gente faz isso agora? Aqui onde que eu fiz esse import tudo as Zod, aqui eu vou fazer o seguinte então, Zod.object, e aí o seguinte, lembra que eu dei um console.log nesse meu data aqui né, vamos voltar lá para o nosso projeto, ignite timer, eu digito alguma coisa, boto 20 e dou um começar, ele deu o log aqui dos dados. Esses dados que eu recebi aqui, esse console.log que eu dei aqui, qual que é o formato dessa informação aqui? Não do task, não do minutes amount, dessa informação que eu dei o console.log, o formato aqui do meu data, que são os dados do meu formulário, é um objeto, por isso que eu usei object, eu estou validando um objeto. Dentro desse objeto eu tenho dois campos, eu tenho task, e aí a validação do task vai ser, eu quero que isso aqui obrigatoriamente seja uma string, que tenha no mínimo um caractere, então eu tô falando que isso aqui é obrigatório, tem que ter no mínimo um caractere, e se a pessoa não informar esse caractere, esse um caractere, a mensagem de validação que eu quero retornar para ela é, informe a tarefa. Todo método de validação aqui, eu posso passar uma mensagem de validação, qual que é a mensagem que vai ser retornada para o usuário, caso esse campo não esteja válido. E aí eu tenho outro campo, que é o minutes amount, esse minutes amount aqui, ele vai ser um número, o mínimo dele é 5, e o máximo é 60, acho que foi isso que a gente colocou aqui embaixo, exatamente. Agora que eu já tenho o meu esquema de validação, eu vou passar isso aqui para o meu Zod resolver aqui dentro, perfeito? E agora, se eu salvo isso aqui agora, a gente volta lá para o nosso Chrome, eu faço aqui a inserção da tarefa, e agora aqui nos minutos, eu vou colocar, por exemplo, 100, que a gente sabe que a gente não queria permitir um valor acima de 60. Se eu clico em começar agora, a validação do HTML já não permitiu eu colocar um valor maior que 60, mas mesmo se eu não tivesse a validação aqui do HTML, deixa eu até comentar ela, e voltasse aqui e desse um começar, veja que o meu console.log aqui embaixo não está aparecendo, ou seja, o código não está chegando mais nesse console.log. Por quê? Porque a gente está tendo erros de validação. E como é que eu consigo visualizar esses erros de validação? Essa função useForm, ela me devolve também um carinha chamado formState, e de dentro desse formState aqui, eu posso dar um console.log em qualquer lugar aqui, eu tenho uma variável chamada errors. Se eu salvo isso aqui agora, olha que interessante, eu vou dar um F5, vou limpar aqui, vou preencher o formulário, está vendo que ele está dando log toda vez que a gente preenche? Isso acontece porque eu estou utilizando o nosso watch, que transforma o nosso formulário em um controlled. Lembra que a gente falou sobre controlled e uncontrolled? A partir do momento que eu estou monitorando se a minha task muda ou não muda, esse meu formulário é um controlled component. Por isso que é importante a gente entender da onde que partem as coisas, senão a gente fica meio perdido. Meu Deus, por que está dando tanto console.log aqui na tela? Porque o nosso componente aqui está sendo recriado toda vez que eu mudo o valor aqui da minha task, porque eu estou usando um controlled component. E agora, se eu colocar aqui um input maior que 60, por exemplo 100, e aqui veja que quando eu alterei os minutos ele não deu console.log, porque eu não estou monitorando, não estou fazendo um watch no meu input de minutos, somente no de task. Então ele não recria o componente. Super legal a gente ir pegando essas coisinhas por baixo dos panos que acontecem, tá? Agora eu clico em começar, olha só, esse meu console.log aqui de farmstate errors, olha só, ele me retornou agora que o minute amount está tendo um erro, e a mensagem de erro é number must be less, ou seja, menor que ou igual a 60, porque foi a validação que a gente fez aqui em cima. Se eu quisesse uma mensagem de erro diferente, o valor, ou melhor, o intervalo precisa ser de, no máximo, 60 minutos. Ou melhor, o ciclo precisa ser de, no máximo, 60 minutos. E no mínimo eu posso botar aqui, o ciclo precisa ser de, no mínimo, 5 minutos. E aí eu quebro aqui só para não ficar feio, e beleza, a gente já tem agora. Se eu dou um começar de novo, a gente vai ver que a mensagem já vem mais bonitinha, o ciclo precisa ser de, no máximo, 60 minutos. E aí eu posso utilizar essa mensagem para mostrar em tela, para dar um alerta, para fazer o que eu quiser. Só que no nosso caso, como a gente não tem uma interface, não tem porque mostrar aqui e a gente já está validando pelo HTML, a gente nem vai trabalhar com essas mensagens de validação, só queria realmente te mostrar que a gente tem acesso a elas, mas a gente não vai necessariamente utilizar elas, porque o usuário de qualquer forma não vai conseguir fazer submit do nosso formulário se ele não preencher a tarefa, e se ele não colocar aqui um valor válido, porque o próprio HTML já vai validar. Então isso é importante a gente ter em mente aqui, mas claro, como eu mostrei, a gente consegue trabalhar com essas mensagens sem problema nenhum. Eu vou tirar aqui o nosso console.log agora, vou também tirar o nosso form state, a gente não vai precisar dele agora. E pronto, agora é claro, a gente precisa trabalhar com esses dados de formulário e ainda tem mais algumas coisas para a gente fazer aqui na nossa aplicação."
  },
  {
    "id": "0dbce7f1-0a73-49a6-9742-6ce074bb3b4b",
    "title": "Controlled vs Uncontrolled",
    "transcription": "Bora continuar nossa aplicação aqui e hoje agora, na verdade, nessa aula a gente vai falar sobre construção de formulários. Não repara que meu cabelo está meio baixo hoje, não fiz nem um topetinho, mas está tranquilo, uma ótima segunda-feira para todo mundo. Hoje a gente vai falar sobre formulários no React. Aqui dentro da nossa aplicação a gente tem esse formulário, que por mais que tenha poucos campos é importante a gente começar a entender como que a gente cria bons formulários no React desde já. Então aqui eu tenho esse vou trabalhar em, aqui a pessoa insere qual é a tarefa que ela vai trabalhar, por quanto tempo e hoje, por mais que isso aqui ainda não esteja funcionando, tem várias coisas nesse formulário que são importantes. Então vou te falar algumas delas. Primeiro, validação. A gente precisa ter alguma forma de validação em cima desses campos para que a pessoa não faça o submit do formulário sem preencher esses campos, ou preenchendo até com valor errado. A pessoa vem aqui de alguma forma nos minutos, por exemplo, se ela colocasse um texto. É claro que o input de number hoje do HTML previne isso, mas a gente não sabe se isso é prevenido em todos os navegadores, se no Bubble funciona da mesma forma. Então a gente tem que ter alguma forma de conseguir validar essas informações aqui e fazê-las funcionar da melhor forma. Outra coisa importante é que aqui a gente tem esse botão de começar. E esse botão fica ativo, ele perde o status de disabled somente quando os campos aqui estão preenchidos. Então de alguma forma a gente precisa monitorar se a pessoa está preenchendo, se ela já preencheu os campos aqui em cima do formulário em tempo real, digamos assim, e quando ela terminar de preencher os dois campos a gente habilita esse botão aqui para que então ela possa fazer o submit do formulário, senão a gente deixa aqui com o desabilitado. Então vamos lá. Existem várias formas de a gente criar formulários no React. A gente já viu uma dessas formas aqui de criação de formulários no React, que é a forma mais tradicional, e ela não está errada, mas ela tem alguns problemas e a gente vai conversar sobre isso. Então quando a gente vai trabalhar com formulários no React, não só formulários, mas principalmente formulários, a gente tem dois modelos de trabalho dentro da nossa aplicação. A gente pode trabalhar de uma forma controlled ou uncontrolled. E aqui é muito importante você entender esses termos porque eles têm muito a ver com como o React funciona. Controlled nada mais é do que a gente manter em tempo real o estado, a informação que o usuário insere na nossa aplicação, dentro do estado, dentro de uma variável no nosso componente. Então toda vez que o usuário mudar a informação e escrever um novo texto no input, eu atualizo uma informação no estado, contendo esse novo valor, para que então eu possa ter o valor atualizado do que o usuário digitou no input. A gente já fez isso antes, então vamos tentar entender como que funcionaria esse formato de Controlled Components dentro da nossa aplicação. E claro que aqui eu estou falando em relação a formulário, mas isso pode ser a qualquer coisa que tenha input do usuário. Controlled é quando a gente mantém em tempo real a informação do input do usuário guardada no estado da nossa aplicação. Então por exemplo, nesse caso do formulário, se eu for seguir esse modelo de Controlled Components, eu teria aqui um estado para cada um dos inputs. Então aqui, por exemplo, setTask é igual a useState, e aí eu começo ele com um valor vazio e branco, como uma string. É sempre importante a gente inicializar o estado da nossa aplicação com um valor que represente o tipo de informação que a gente vai armazenar ali dentro. Se eu não colocasse, por exemplo, essas aspas simples, botasse null aqui por enquanto, ou deixasse vazio, a gente vai ver que passando o mouse por cima de task ele vem como undefined, mas a gente sabe que, cara, não é undefined na verdade, eu queria que isso aqui guardasse uma string. Então se eu começo isso aqui com uma string vazia, passando o mouse por cima eu vejo que ele já entende que isso vai ser uma string. Facilita muito a gente na hora de lidar com o TypeScript aqui dentro. E agora, como eu estou falando aqui de formulários controlados, Controlled Components, o que eu faço é, a cada vez que o usuário trocar o valor desse input, ou seja, digitar uma nova tecla, eu salvo isso dentro do meu estado aqui usando a função setTask. E aqui eu pego o evento, aqui ele só está pedindo para eu colocar parênteses por volta, mas eu estou, basicamente, cada vez que uma letra é digitada ou removida eu atualizo o estado. E aí uma das boas práticas, isso não é necessariamente obrigatório, é a gente também utilizar o value com o valor aqui do nosso estado. Por que a gente faz isso? Porque se esse estado aqui mudar por uma origem que não seja a digitação do usuário, eu quero também atualizar visualmente esse input para mostrar o novo valor. O que é muito comum acontecer, quando a gente faz o submit do formulário e eu quero limpar os campos, eu vou pegar, quando eu vou resetar o formulário, imagina que eu tenho uma função para resetar o formulário, eu vou em cada um desses estados aqui e colocar o valor em branco. E aí eu preciso que meus inputs reflitam isso, eles mostrem em tela o input sem nenhum valor dentro. Então isso aqui são Controlled Components, nada mais é do que eu ficar monitorando a cada digitação e salvar no estado essa informação. Quais benefícios que eu tenho com isso? Como eu tenho o valor da task aqui no caso, e eu teria que criar mais um igualzinho para o Minutes Amount Input aqui, como eu tenho esse valor em tempo real, eu consigo facilmente ter acesso a esses valores na hora de fazer o submit e eu consigo facilmente também refletir visualmente alterações na minha interface baseado no valor desses inputs. Então por exemplo, se eu quero desabilitar aqui o meu input de countdown somente quando eu não tiver nada escrito dentro do task. Posso usar sim ou task.len ou task, eu quero desabilitar quando o task for igual a vazio, tem várias formas de fazer isso aqui, todas elas vão funcionar e depende muito do que você achar que fica mais legível no código. Particularmente eu acho que só dessa forma assim já dá para entender, quando não tem uma task, a gente desabilita o botão. Se eu salvo isso aqui, como a gente está utilizando o conceito de Controllers Components, olha só que legal, a partir do momento que eu começo a digitar aqui dentro, pronto, meu input já ficou habilitado automaticamente porque ele percebeu que eu tenho um texto aqui dentro. Se eu apago o texto ele já fica desabilitado de novo. Então o Controllers Components dentro do React, ou seja, qualquer componente que eu fique monitorando em tempo real o input do usuário, ele traz muita fluidez para a gente conseguir mostrar e deixar de mostrar coisas na nossa interface baseado nesse input do usuário. Mas, como toda coisa que tem seus lados bons, também tem lados ruins. Como a gente já sabe e a gente vai ver também com mais clareza e mais profundidade ao longo das próximas aulas, o React, toda vez que a gente faz uma atualização de estado, a gente provoca uma nova renderização. E a gente vai falar sobre isso, o que é essa nova renderização. Mas basicamente toda vez que a gente chama essa função setTask, por qualquer motivo que seja, ou qualquer função de alteração de estado, o React precisa recalcular todo o conteúdo do componente do estado que mudou. E esse recalcular todo o conteúdo do componente não necessariamente é lento, mas se a gente tiver interfaces que são muito complexas, com muita informação, isso pode sim virar um gargalo. Então, muitas das vezes, lidar com formulários dessa maneira controlled pode ser um problema para a nossa aplicação em questão de performance. Na maioria das vezes não vai ser, mas em alguns momentos pode ser. E aí a gente tem um outro modelo de trabalho, que não vale só para formulários, mas principalmente em formulários, que é o uncontrolled. O uncontrolled nada mais é do que a gente busca a informação do valor do input somente quando precisarmos dela. Então, o que mudaria? Aqui no taskInput, ao invés de eu simplesmente salvar a informação aqui do nosso input, a cada vez que o usuário digita essa informação, eu poderia apagar essas duas linhas aqui, e aí aqui no meu submit do formulário, eu teria um handle submit, e aí nessa função de submit aqui, eu poderia utilizar o próprio HTML, os métodos que a gente já tem do JavaScript mesmo, tradicional, para buscar os valores dos meus inputs. Então, por exemplo, aqui eu pego o evento de submit, eu faria event.target, como ele tem um id, acho que é pelo nome na verdade, eu teria que botar um nome, e aí eu posso fazer event.target.pet, e assim eu consigo pegar dessa forma o valor do input aqui, e aí eu consigo trabalhar com esse input. O que eu perco com isso? Eu perco o que eu estava falando antes, a fluidez. Como eu não tenho acesso ao valor digitado letra a letra, eu perco essa fluidez de habilito alguma coisa, desabilito alguma coisa, mas eu ganho em performance. Então vão ter momentos na nossa aplicação que a gente vai precisar escolher. Eu vou para um formulário controlled, e geralmente quais são as situações que eu vou utilizar um formulário controlled? Formulário simples, com poucos campos, numa interface simples, um formulário de login, um formulário de cadastro, ou eu vou para um formulário uncontrolled, não controlado, ou seja, que eu não monitoro o valor digitado em tempo real. E quais são os casos de uso de um formulário uncontrolled? Imagina aqueles dashboards que a pessoa, isso tem na Rocket também, que a pessoa vai cadastrar uma informação, aqui a gente tem um painel onde a gente cadastra uma jornada, por exemplo, trilha de React. Aí a pessoa bota todas as informações dos módulos, todas as aulas, e tem, cara, 200 inputs em tela. Sem brincadeira, tem 200 inputs em tela. Imagina cada vez que a pessoa digita uma tecla, eu atualizo essa tela inteira. Fica lento. Então eu preciso ir para um modelo de uncontrolled. E eu gosto de dar essa introdução para você, mesmo antes da gente aplicar qualquer coisa aqui, porque a gente vai utilizar uma biblioteca para construir aqui o nosso formulário, mas essa biblioteca, por baixo dos panos, ela utiliza desses conceitos de controlled e uncontrolled, e é importante a gente entender o que está acontecendo por trás antes da gente começar a utilizar uma biblioteca em si."
  },
  {
    "id": "7032e450-9d8a-47d6-b645-8bb4baf7c269",
    "title": "Contexto no formulário",
    "transcription": "Agora a gente vai ajustar o nosso formulário para também funcionar com o contexto. A primeira coisa que o NewCycleFarm precisa, que já dá pra ver de cara, é o ActiveCycle. Ele já está no nosso contexto. A gente já está enviando o ActiveCycle para dentro. Então, bora lá. A gente vem aqui e dá um const, igual a useContext, ctrl-espaço, importa do React, escreve cyclesContext, e aqui a gente pega o nosso ActiveCycle. E assim já para de dar vários problemas aqui. Agora, a gente cai num problema. A gente cai num problema. Qual que é o problema? Aqui, a gente tem esse useForm aqui dentro da nossa aplicação, dentro do NewCycleFarm. Porém, esses métodos aqui, handleSubmit, watch e reset, eles não são usados nesse componente aqui. Eles são usados lá na ROM. Lá na ROM aqui eu tenho, o watch é usado aqui, reset aqui e o handleSubmit aqui. Então, se eu for pensar melhor, esse código aqui, talvez, ele deveria estar lá na ROM. Então, eu poderia vir aqui e colocar esse código em qualquer lugar, aqui tanto faz. Aqui, por exemplo. Trazer para cá também, de volta, essa parte aqui da validação e tudo mais. Então, venho aqui e trago aqui de volta para aqui. As importações eu já tinha deixado aqui, então não precisamos tirar. E aqui, agora, o que acontece? A gente pode voltar com esse código aqui. Podemos voltar com esse código aqui, com esse código aqui, esse código aqui, esse código aqui e esse código aqui. Show! Beleza, já voltou tudo a funcionar. Só que agora, o que acontece? Essa função register aqui, ela é usada dentro do newCycleForm. Então, para eu conseguir acessar essa função register lá no newCycleForm, deixa eu até tirar algumas importações que eu não estou usando aqui, eu tenho, novamente, duas opções. Eu posso enviar com uma propriedade, dessa forma assim, e lá no newCycleForm eu consigo acessar ela, aqui pelas propriedades do componente. Ou eu posso enviá-la por contexto também, aqui no meu CyclesContextProvider. Só que, você concorda comigo que uma função para registrar um campo no formulário, se a gente for parar para pensar mesmo, ela não tem muita relação com as informações dos ciclos aqui. Ela é uma função muito mais... porque a gente está usando uma biblioteca, que é o React Hook Form. Se a gente mudar, perde totalmente sentido isso aqui. Ou seja, não é muito uma informação que pertence ao nosso contexto. Ela é algo de uma biblioteca externa. Geralmente, a gente tenta manter no contexto somente coisas que não vão mudar se a gente trocar uma biblioteca, ou qualquer coisa assim. Então, essa função register, a gente não vai enviar para o contexto. Tá Diego, então a gente vai enviar por propriedade? Também não. Por quê? O React Hook Form oferece para a gente um contexto próprio que a gente pode utilizar. Então, olha que legal. Aqui em cima, ao invés de eu fazer essa desestruturação aqui, eu vou fazer o seguinte. Eu vou chamar isso aqui de New Cycle Form. E aí, como eu preciso de algumas funções que vêm de dentro do New Cycle Form, como Reset, Watch e HandleSubmit, eu vou fazer a desestruturação, mas eu faço embaixo. Não é a mesma coisa que eu tinha antes, só que assim eu continuo tendo acesso a essa variável New Cycle Form completa, sem desestruturar. Aí aqui dentro eu vou tirar o register, porque o register eu não estou utilizando dentro do componente Home, eu uso só lá no componente de formulário. E agora, olha que legal. Aqui por volta do meu New Cycle Form, eu vou colocar um carinha chamado FormProvider. E aqui eu boto o nosso New Cycle Form. E aí, para esse FormProvider aqui, eu vou fazer algo que a gente chama de Spread. Eu vou dar aqui as chaves, que é a variável que a gente tinha lá em cima. Esse Spread, a gente já viu o que é, que é basicamente, eu pego cada uma das propriedades desse objeto, New Cycle Form, e passo como uma propriedade para esse componente aqui. Então, se aqui dentro do New Cycle Form eu tenho, por exemplo, o register, eu vou colocar um carinha chamado New Cycle Form. E aí, eu vou colocar um carinha chamado New Cycle Form, Então, se aqui dentro do New Cycle Form eu tenho, por exemplo, o register, ele vai fazer isso aqui, register, register. Se eu tenho, que mais que eu tenho ali dentro? Nossa, eu até estou esquecendo aqui. Tenho o formState, ele vai fazer a mesma coisa, formState. Então, ele só repassa cada uma das propriedades que eu tenho dentro desse carinha aqui, como uma propriedade por elemento FormProvider. E agora, olha que interessante. Eu vou lá no meu New Cycle Form, por que eu botei ele só por volta do New Cycle Form? Porque é só o New Cycle Form que precisa acessar alguma coisa do formulário. Então, eu venho aqui no New Cycle Form e faço o seguinte, const é igual a useFormContext de dentro do React Hook Form, e aqui eu acesso a minha função register. E pronto. Mas lembrando, esse useFormContext aqui, ele só funciona se tiver um provider por volta do componente que está usando o useFormContext. Aqui em cima, show, já está tudo funcionando. O único problema que a gente tem é que essa função aqui, handleCreateNewCycle, ela atualiza o setAmountSecondsPassed para zero. Ou seja, ela precisa também acesso a variável amountSecondsPassed, que eu tinha jogado essa variável lá para dentro do nosso countdown. Então, o que eu vou fazer? Como o componente Home também precisa acesso a essa informação, a melhor forma de resolver isso é pegando isso aqui, jogando de volta para Home, e passando aqui o amountSecondsPassed lá para dentro do nosso contexto. Então, eu venho aqui no nosso contexto e passo o amountSecondsPassed. Beleza? A gente pode ver que aqui na Home agora sumiram todos os erros. Ah, só tem aqui erro de importação. Mas sumiram todos os erros. Mas, aqui o newCycleFormer eu tinha esquecido de salvar também. Mas, se a gente volta ao countdown, a gente tem erro, porque agora o countdown precisa ter acesso à função setAmountSecondsPassed. E aqui, deixa eu acessar também aqui do contexto o nosso amountSecondsPassed. Beleza? Agora, a gente precisa, aqui dentro desse arquivo, ter acesso à função setAmountSecondsPassed. E aí, a gente precisa também, então, enviar ela pelo contexto. Mas, mesma coisa que a gente tinha feito antes, eu não gosto de enviar a função set inteira lá para dentro. Então, a gente vai fazer só um proxy, digamos assim, uma função que chama outra função. Então, aqui eu vou chamar essa função de... E aqui a gente pode até, deixa eu dar uma olhadinha aqui, totalSeconds. Por enquanto, a gente vai fazer uma função simples mesmo. Eu estava pensando em outra coisa que a gente poderia fazer aqui, mas eu vou fazer uma função simples mesmo. Eu vou chamar de setSecondsPassed mesmo. Vai ficar com o nome meio repetitivo, mas mais pra frente a gente vai mudar um pouquinho a lógica aqui, e aí essa função não vai mais existir. Por isso que eu estou escolhendo um nome um pouquinho mais bobo, mas mais pra frente a gente pode melhorar isso aqui. A gente vai melhorar, na verdade, porque essa função depois vai mudar. E aí aqui eu vou falar que no meu contexto eu tenho uma função também chamada setSecondsPassed, e aqui ela recebe um valor, que é um número, e ela não tem retorno, por isso eu coloco o nosso void aqui. Aí uma das coisas que eu particularmente gosto de fazer é manter todas as funções aqui do contexto no final e deixar as variáveis em cima. E aí agora a gente vai enviar essa função aqui no nosso contexto. A ordem aqui, tanto faz. E aí no countdown eu vou pegar essa função aqui e aí troco aqui pela setSecondsPassed. Aqui embaixo também preciso adicionar a nossa setSecondsPassed no array de dependências do useEffect. Show! Vamos testar agora a nossa aplicação. Então a gente volta aqui a projeto 1, boto aqui 15 minutos, dou um começar e a gente vai ver que toda a nossa aplicação voltou a funcionar. Porém, agora o nosso componente Home está muito mais limpo, ele tem bem menos código dentro dele, é fácil a gente entender o código que tem aqui, é simples, e a gente vai deixar mais simples ainda, ainda nesse módulo. E os outros componentes, como o countdown, por exemplo, o newCycleForm, eles também têm bem menos código dentro deles, um código mais específico, mais abstraído. E se um dia a gente quiser totalmente arrancar o countdown de dentro da Home, é bom porque a gente vai arrancar ele com tudo que ele precisa também ser deletado e não vai ficar nenhum resto de código, digamos assim, dentro da Home. Porque a Home tem somente as variáveis e funções que ela usa, o countdown tem somente as variáveis e funções que ele usa, o newCycleForm a mesma coisa. Então o contexto permite a gente deixar o nosso código muito mais organizado. Mas lembrando que não é porque a gente tem a possibilidade de criar um contexto que a forma de comunicação que a gente conhecia anterior, que era através de propriedades, deixa de fazer sentido. Lembra que eu falei, a forma principal de comunicação entre os componentes do React é através de propriedades. A gente só parte para utilizar um contexto quando a gente realmente sente que a gente vai ter muitas propriedades para enviar de um componente para outro e isso acaba tornando o nosso código muito complexo. Resto, de restante, a gente não usa contexto e prefere, sim, sempre utilizar propriedades na maioria das vezes."
  },
  {
    "id": "c00c5f17-9279-4749-a5b2-485049f29470",
    "title": "Interromper ciclo",
    "transcription": "Eu quero que a nossa aplicação tenha algumas coisas diferentes na interface quando a gente estiver com o ciclo rolando. A primeira delas é que o botão, quando o ciclo estiver rolando, no caso, sei lá, um ciclo de 10 minutos aqui, ele tem que mudar, não mais para ser um botão escrito Começar, e sim um botão escrito Interromper, caso eu queira interromper o ciclo atual. E aí, se eu quiser iniciar um novo ciclo, eu tenho que interromper o atual para, então, iniciar um novo ciclo. Então, uma das coisas que a gente vai fazer é o seguinte, lá embaixo, onde a gente tem o botão de iniciar um novo ciclo, aqui eu vou fazer um if. Se eu tiver um ciclo já rolando, eu vou mostrar alguma coisa, deixa eu botar aqui uma div em branco por enquanto, se não, eu mostro o botão de iniciar um novo ciclo. E aí eu vou copiar, vou botar o mesmo botão aqui, só que ao invés de Start, eu vou chamar de Stop. Stop Countdown Button. E aqui, ao invés do ícone Play, eu vou usar o HandPalm, que vem também lá do Phosphor React, e ele já foi importado aqui. Disabled aqui, por enquanto, eu não preciso ter. Posso deixar só assim. E o tipo dele não vai mais ser Submit, ele vai ser Button, porque quando eu clicar nesse botão, eu não quero fazer um Submit no formulário, eu não estou querendo criar um novo ciclo, eu quero só interromper o atual, e aí depois ele vai ter, basicamente, um OnClick. Quando eu clicar nele, aí eu faço alguma coisa. Mas primeiro a gente tem que criar a estilização aqui, o Stop Countdown Button. Então eu vou lá nos estilos, a gente já tem um Start Countdown Button aqui dentro, e aí a gente vai criar o Stop. Como o Stop e o Start são extremamente parecidos, o que eu vou fazer? Eu vou transformar isso aqui em um Base Countdown Button. E aí aqui embaixo, eu vou criar o Start Countdown Button, que ele vai utilizar o Base e adicionar alguns CSS a mais, e o Stop Countdown Button, que ele vai utilizar o Base e adicionar alguns CSS a mais. No caso do Start, o que eu vou copiar aqui é tudo que está relacionado com cores. Então aqui, esse BackgroundGestureColor vem pra cá, e esse carinha aqui vem pra cá. O resto, que não tem relação com cores, eu não preciso mudar. E aí aqui embaixo eu vou copiar as mesmas propriedades que eu tenho aqui no Start, vou colar no Stop, só trocando as cores. Então a cor de fundo vai ser Red 500, a cor do texto vai ser a mesma, então eu poderia deixar isso aqui até lá em cima, nem precisaria tirar daqui, então deixa mais simples. E aqui a cor de fundo, quando eu passo a mouse por cima, vai ser Red 700, e não Green 700. Salvo isso aqui agora, tem que importar o botão aqui, então Ctrl, espaço. Pronto, já fez a importação. E aqui é Interromper e não Começar. Salvo, voltamos ao Chrome, Projeto 1, 10 minutos, Começar, e está ali o botão de Interromper. Claro, se eu clicar nele, nada acontece. E aí, outra coisa que eu quero fazer é o seguinte, se o meu ciclo não estiver ativo, eu também não quero deixar o usuário escrever aqui, digitar, ou melhor, se já tem um ciclo rolando, eu não quero que o usuário possa digitar qualquer coisa aqui nesses inputs aqui em cima. Então, tem várias formas de fazer isso. Uma delas, talvez a mais simples, é eu colocar um Disabled, então vou desabilitar isso aqui caso tenha algum ciclo ativo. E aí a gente pode... Aqui precisa ser um boolean, então eu teria que colocar aqui dois pontos de clamação que vai converter. Se isso aqui tiver algum valor dentro, converte para True, se não, converte para False. Posso botar isso aqui no Minutes Amount também. E aí, Projeto 1, 5 minutos, Começar, beleza? E ele não deixa mais eu preencher nada aqui dentro dos inputs. Só que agora, claro, clicando nesse botão, nada acontece. O que a gente gostaria de acontecer, caso clicasse nesse botão, é a gente voltar para o estado inicial da aplicação. Então, vamos lá, eu vou criar aqui uma função, vou chamar ela de HandleInterruptCycle. E essa função, HandleInterruptCycle, o que ela vai fazer aqui? Ela vai setar o ciclo ativo, o SetActiveCycleId, de volta para nulo, porque eu não quero que tenha mais nenhum ciclo ativo. E o que eu vou fazer também é anotar dentro do meu ciclo se ele foi interrompido ou não, como uma forma de eu ter um histórico depois de quais ciclos foram interrompidos pela metade e quais não foram. Até para lá no histórico, depois, a gente conseguir mostrar quais ciclos foram interrompidos manualmente, quais foram completos, que não tiveram nenhum tipo de interrupção, e quais ainda estão em andamento, ou qual ainda está em andamento, porque vai ser só um, na verdade, pode ser só um. Então, o que eu vou fazer? Aqui na minha interface do ciclo, eu vou anotar mais uma data, que é a InterruptedDate. Só que essa data é opcional, porque se a pessoa não interromper o ciclo, essa data não vai existir. Por isso que eu botei o ponto de interrogação. Ela pode existir ou não. Então, agora, aqui no meu HandleInterruptedCycle, o que eu vou fazer? Eu vou utilizar aqui o SetCycles, porque eu preciso mudar o nosso ciclo. Hoje ele está guardado dentro dessa variável, unicamente dentro desse estado. Então, se eu quero mudar alguma coisa no ciclo, eu preciso ser nessa variável. E aí, como é que a gente vai fazer aqui? Esse Update aqui vai ficar um pouquinho confuso, mas vai dar certo. Esse Update aqui, eu vou fazer o seguinte. Eu vou percorrer todos os ciclos. E aí, eu vou fazer o seguinte. Para cada ciclo que eu estou percorrendo, se o ciclo for o ciclo ativo, eu vou retornar todos os dados do ciclo. Porém, eu vou adicionar uma nova informação chamada InterruptedDate, como sendo a data atual. Se não, eu retorno o ciclo sem alterações. Esse código é um pouco confuso? É, mas a gente tem que lembrar que no React, a gente nunca pode alterar uma informação sem seguir os princípios da imutabilidade. Nesse caso, quando a gente está trabalhando com Arrays, isso fica até mais chato. Aqui, no caso, são Arrays de objetos. Então, se eu quero mudar uma informação de um desses objetos, desse Array de ciclos, eu obrigatoriamente preciso percorrer todos os itens do Array, procurando pelo objeto que eu quero alterar, para daí fazer a alteração. E aqui, veja que eu utilizei o Map. Por quê? Eu estou chamando a função setCycles, ou seja, eu estou alterando o valor da variável que armazena os ciclos da minha aplicação, e se eu estou alterando o valor, eu preciso dizer qual é o novo valor. Por isso, o Map é importante, porque ele vai percorrer cada um dos ciclos, e ele vai retornar, de dentro do Map, cada um dos ciclos alterados ou não. Eu só estou alterando o ciclo que é o ciclo ativo. E é até, inclusive, interessante eu botar esse setActiveCycleId aqui para baixo do setCycles, porque fica mais legível. Eu estou, primeiro, alterando o ciclo ativo para anotar a data de que ele foi interrompido, e depois eu falo que não tenho mais nenhum ciclo ativo. E agora, então, eu chamo essa função no meu botão de interromper, e só para a gente garantir que tudo deu certo, eu vou colocar aqui, em qualquer lugar, tanto faz, um console.log na minha variável cycles. E aqui, a gente vai ver esse console.log acontecendo várias vezes, não se preocupe, a gente só quer ver o último dele. Então vamos lá, projeto 1, trabalhando por 5 minutos, vou dar um Começar, e agora vou dar um Interromper. A gente pode ver que já voltou para o estado original, o input já dá para digitar de novo, tanto o minutos quanto a task, e se eu for ver aqui o log, que eu só tinha um ciclo, ele anotou a data que o ciclo foi interrompido dentro da nossa variável interruptedDate. Então, bem legal, a gente já está conseguindo progredir bastante com a nossa aplicação, mas ainda tem mais algumas coisas que a gente pode fazer aqui."
  },
  {
    "id": "5144123e-dec9-4508-acc9-46860372da59",
    "title": "Iniciando novo ciclo",
    "transcription": "Nessa aula, finalmente, a gente vai fazer com que quando a gente clica nesse botão Começar, a gente realmente comece um novo ciclo. E aí a gente vai fazer toda a experiência de timer, então a gente vai partir ali se a pessoa colocou 10 minutos de ciclo até chegar em zero, quando chegar em zero vai completar o ciclo, ela vai poder interromper. Então agora a gente vai começar toda a funcionalidade da nossa aplicação em si. E cara, se tem uma coisa boa em home office é que você pode ficar aqui de blusa normalzinha mas embaixo ficar de pijama e pantufa, então dá-lhe. Agora, galera, o que a gente vai fazer agora? Vamos lá. Então vamos abrir aqui o nosso VSCode e até agora uma das coisas que a gente tem é essa função handleCreateNewCycle. Por enquanto a gente está fazendo apenas um console.log dos dados e não é isso que a gente quer. A gente quer basicamente conseguir ter um ciclo ativo na nossa aplicação. E aí para eu conseguir refletir na minha aplicação que um novo ciclo se iniciou, eu preciso ter um estado. O estado é a única forma de eu conseguir armazenar alguma informação no meu componente que vá fazer com que a minha interface reaja a essa informação, ou seja, que a minha interface se mude, tenha uma reação realmente a essa nova informação. Então a gente vai começar criando um estado para a gente armazenar esse ciclo em si. Então aqui eu vou dar um useState do React, ele já fez a importação automática. E aqui é importante a gente definir qual que vai ser o formato da informação dos nossos ciclos em si. Então eu tenho até uma colinha aqui e eu vou começar criando aqui uma interface aqui em cima. E aqui por enquanto esse componente Home vai ficar de forma proposital, deixa eu mover a importação do React aqui pra cima, ele vai ficar com bastante coisa aqui dentro. Mas não se preocupe com isso, a gente vai criar tudo aqui no mesmo componente pra mais pra frente a gente separar isso, então é super proposital. Esse componente fica até bem confuso pela quantidade de funcionalidades e informações que a gente vai colocar aqui dentro, mas não se preocupa com isso, me acompanha, vai prestando atenção o que eu estou mudando, o que eu estou adicionando, porque como vai ter muita informação dentro desse componente, a gente pode acabar se perdendo aí com o tempo. Bom, bora lá, eu vou começar criando uma interface pra definir qual que vai ser o formato dos ciclos, de cada ciclo que eu adicionar dentro da minha aplicação. Eu vou chamar de Cycle mesmo, eu acho que não tem nome mais descritivo. E aí, uma das coisas que a gente pode perceber, até olhando pelo layout, até olhando pelo que a gente já construiu, é que na nossa aplicação, por mais que a gente tenha apenas um ciclo ativo em cada momento, não tem como a gente estar com dois ciclos rodando ao mesmo tempo, eu só tenho um timer, por mais que eu só tenha um ciclo rodando, eu tenho vários ciclos que já podem ter acontecido anteriormente. Então, a informação que eu vou armazenar de ciclos, é super importante que eu tenha um ID, pra eu conseguir representar unicamente um ciclo. Toda vez que eu tenho alguma informação na minha aplicação, que ela vai ser uma lista onde eu vou ter vários ciclos, é super importante que eu tenha alguma forma de identificar cada ciclo de forma única. Então, quando a gente não tem alguma informação de um usuário, as vezes a gente tem um email, então é único, a gente não precisa botar um ID, mas o ciclo a gente não tem, então a gente geralmente cria um ID, mesmo que a gente crie aqui na mão, pra ter alguma coisa. E aí o ciclo, claro, ele tem qual que é a tarefa que a gente está trabalhando, então quando a gente insere um ciclo aqui, a gente insere qual que é a tarefa, e tem a quantidade de minuto, que é basicamente as três informações que a gente precisa pra agora, aí no nosso ciclo. E aí, aqui no meu estado, eu vou falar que esse meu estado aqui, ele vai armazenar uma lista de ciclos. Pra isso, eu vou falar aqui então, usando o generics do TypeScript, que esse estado aqui vai armazenar ciclo, porém um array de ciclos, então eu boto o cochete aqui no final. E aí é super importante, sempre que eu vou iniciar um estado, como eu já falei milhares de vezes, e vou repetir porque é importante, eu vejo muita gente errando isso, iniciar sempre o estado com uma informação do mesmo tipo a qual eu vou manusear ao longo da minha aplicação. Então, se ao longo da aplicação isso aqui vai ter uma lista de ciclos, eu preciso iniciar o estado com uma lista mesmo que vazia. Isso é super importante pra qualquer estado. E aí aqui eu vou dar um nome de cycles, e claro, o nosso método aqui de alteração sempre vai ser set com o nome da variável. Show, beleza! Aqui no método handleCreateNewCycle, então eu posso criar, ou seja, colocar um novo ciclo aqui dentro. Vamos lá! Então, const, vamos começar criando o nosso novo ciclo, newCycle eu vou chamar, e aqui o nosso ciclo precisa ter id, task e minutesAmount. Novamente eu estou usando o TypeScript, se eu der um ctrl espaço aqui dentro desse newCycle, ele não vai me oferecer nenhuma inteligência, mas se eu venho aqui na variável newCycle e eu boto aqui dois pontos, cycle, isso aqui já facilita bastante porque eu venho aqui dentro e ele já fala quais são as informações que eu preciso ter aqui dentro. Então, eu preciso ter um id. A questão do id, como eu estou no front-end, eu não quero instalar biblioteca nenhuma aqui pra isso, eu vou fazer algo mais simples que é o seguinte, eu vou pegar a data atual e eu vou dar um ponto getTime. Esse getTime aqui, ele vai me retornar o timeValue em milissegundos, isso o que quer dizer? Ele vai pegar a data atual convertida pra milissegundos, ou seja, se a pessoa criar novos ciclos repetidamente, a menos que ela crie um ciclo no mesmo milissegundo, dois ciclos no mesmo milissegundo, que é humanamente impossível, ela não vai ter ids repetidos. Então, a gente vai só converter isso aqui pra uma string também, então boto aqui o constructor de string por volta porque a gente está falando que o nosso id é uma string. Eu prefiro sempre trabalhar com ids no formato de string porque é mais fácil, então a gente converte aqui. E aí, eu vou anotar aqui dentro a nossa task, que vem de data.task, olha só como o TypeScript ajuda a gente. Então, eu tenho TypeScript nesse objeto, eu tenho TypeScript nesse objeto, é muito difícil eu cometer erros. E aí, eu salvo também o nosso minutesAmount, que vem de data.minutesAmount. E aí, aqui agora, eu vou adicionar esse novo ciclo à minha listagem de ciclos em si. Então aqui, pra eu adicionar uma nova informação no array, a gente já viu isso antes, eu preciso copiar todos os ciclos que eu já tenho, caso eu esteja adicionando um novo ciclo numa lista que já está repleta de vários outros ciclos que já aconteceram, eu vou adicionar ele no final. Então, é basicamente dessa forma que a gente faz. E aí, uma das regrinhas aqui no React, que a gente já viu inclusive isso, toda vez que eu estou alterando um estado, e esse estado depende da sua versão anterior, da sua informação anterior antes de eu alterar, é super legal esse valor do estado ser setado no formato de função. Inclusive, a gente já falou sobre isso, sobre closures dentro do React. Então aqui, eu uso uma arrow function, eu pego o estado atual da minha variável de ciclos, copio o estado atual e adiciono o novo ciclo no final. Aqui só o ESLint reclamando pela questão dos parênteses, mas sempre a gente lembrar desse ponto aqui, sempre que uma alteração de estado depender do valor anterior, a gente usa o formato de arrow function. Show! A gente já está salvando no estado aqui, mas claro que a gente ainda não está usando essa informação para nada. E aí, como eu falei, a gente tem sempre uma lista de ciclos na nossa aplicação, que é o nosso histórico, porém, a gente tem apenas um ciclo ativo por momento. E aí, a gente tem duas formas de controlar qual que é o ciclo que está ativo nesse momento. Uma delas seria, aqui no ciclo, a gente colocar uma informação, por exemplo, isActive, como um booleano, por exemplo, para indicar se esse ciclo aqui é o que está ativo ou não. Só que qual é o problema disso? Quando eu colocar um novo ciclo como ativo, eu vou ter que percorrer os outros ciclos até eu achar qual que era o que estava ativo antes para colocar aquele como falso, no isActive. Ou seja, toda vez que eu for colocar um novo ciclo como ativo, eu vou ter que também mudar um outro ciclo que já estava ativo para falso. Ou seja, eu sempre vou ter que fazer duas modificações no mínimo, duas operações no mínimo para conseguir tornar um novo ciclo como ativo. Uma outra alternativa seria a gente manter um estado com qual é o id do ciclo ativo, por exemplo, que nesse caso aqui vai ser uma string ou nulo, e aí eu começo com nulo novamente. Por que eu fiz isso aqui? Super importante parar para pensar porque a gente faz essas coisas. Quando a minha aplicação inicializa, por exemplo, que ela está aqui, tem algum ciclo ativo? Não tem. Está zero, zero, a pessoa precisa digitar. Ou seja, o ciclo ativo, o id do ciclo ativo, ele pode ser nulo, porque é o valor inicial. E aí tanto que eu inicializo isso aqui como nulo. Então é muito importante a gente prestar atenção nessas coisinhas aqui. E agora, quando eu crio um novo ciclo, eu vou também setar o ciclo recém-criado como sendo o meu ciclo ativo. Então eu vou tirar isso daqui de dentro, ou eu posso botar simplesmente newCycle.id, ou eu posso tirar isso daqui de dentro, por exemplo, colocar uma variável chamada id, usar o id aqui embaixo e aqui embaixo usar o id também. Das duas formas vai funcionar da mesma forma e você pode escolher qual for melhor. Eu prefiro assim, porque assim a gente quebra e fica um pouquinho mais fácil visualizar o fluxo mais. Novamente, tanto faz. E assim agora a gente tem a informação de todos os ciclos da nossa aplicação e a gente tem a informação também do ciclo ativo. E agora para eu mostrar na tela qual que é o ciclo ativo, basta fazer o seguinte. Eu crio uma variável, por exemplo, chamada activeCycle e essa variável ela precisa fazer o seguinte, com base no id do ciclo ativo, percorrer os ciclos que eu tenho, todos os ciclos que eu tenho e me retornar qual que é o ciclo que tem o mesmo id do ciclo ativo para eu conseguir retornar essas informações. Então essa variável, ela vai percorrer a variável, o vetor de ciclos e vai encontrar um ciclo em que o id do ciclo seja igual ao id do ciclo ativo. Eu repeti ciclo acho que umas 40 vezes nessa aula, me desculpa, mas eu tenho que falar, é uma aplicação basicamente que a gente faz isso, mas se a gente passar o mouse agora por cima desse activeCycle, olha só que legal, ele fala que essa variável aqui é um ciclo ou undefined, porque pode ser que não encontre, né? Se por algum motivo, sei lá de qual, essa activeCycleId guardar um id de um ciclo que não existe mais, isso aqui vai me retornar undefined, né? Então é importante a gente entender o porquê que o TypeScript joga essas resoluções nessas inferências aqui como undefined que ele jogou aqui dentro. E agora, se eu quero mostrar alguma informação do ciclo na tela, por exemplo, a gente já tem aqui, até pra ser mais simples, vamos fazer o seguinte, vamos dar um console.log aqui nessa activeCycle, a gente vai salvar, a gente vem aqui pro Chrome, inspecionar elementos, no console, limpamos a tela aqui, dando F5 a gente pode ver inclusive que deu undefined aqui no console.log, por quê? Porque essa variável aqui ela tá como undefined por enquanto, não tem nenhum ciclo ativo. Agora eu venho aqui, projeto 1 durante 25 minutos, se eu clicar em começar agora, veja que ele já deu o log aqui no nosso console, né? Então eu já tenho o id aqui do meu ciclo, o tanto de minutos, a task, então eu tenho qual que é o ciclo ativo. E antes da gente continuar, eu acho legal falar que você vai ver que toda vez que a gente coloca um console.log na nossa aplicação, ele acaba dando dois console.log, né? Um que vem realmente do nosso arquivo, que é o index.tsx62, que se a gente clicar vai cair ali no nosso console.log, e outro vem aqui, React, DevTools, Backend, uma parada muito louca. Isso a gente não precisa se preocupar, não é nenhum problema, tá? Isso é algo do próprio React, e você pode pesquisar um pouquinho mais, não cabe a gente entrar tão a fundo agora, não prejudica a performance da sua aplicação porque isso vai acontecer somente em desenvolvimento, não acontece em produção. E tem a ver com esse carinha aqui, React.strictMode, inclusive se a gente tirar esse React.strictMode e rodar nossa aplicação, a gente vai ver que inclusive os logs eles param de acontecer de forma duplicada, tá? Mas eu só tô te explicando isso pra que você não fique com dúvidas agora, mas isso realmente assim, não é importante pra agora, não se prende a isso porque não é algo importante, e eu nem quero entrar muito em explicar sobre strictMode porque não é o momento da gente pensar nisso agora, fechou? Então vamos continuar aqui que a gente tá criando nossa aplicação e tá ficando bem massa."
  },
  {
    "id": "e4c7848d-2206-4ff8-ad71-7b3a3a474602",
    "title": "Utilizando immer",
    "transcription": "O que a gente vai ver nessa aula é uma nova biblioteca, que talvez você nunca tenha utilizado, que é o Imer. O Imer é uma biblioteca, como eu já falei, deixa eu até procurar aqui Imer, vou procurar por Javascript, ImerJS, e aqui está a biblioteca. O Imer é uma biblioteca que a gente usa para trabalhar com dados imutáveis, que trabalha com o conceito de imutabilidade, que é algo muito utilizado dentro do React. O que acontece? Quando, aqui no nosso Reducer, a gente vai alterar estados, e essa alteração é muito profunda, eu preciso alterar uma única informação que está dentro de uma posição no Array e tudo mais, a gente tem que ficar fazendo esses Maps, que por muitas vezes são confusos. E o Imer possibilita que a gente trabalhe com estruturas de dados imutáveis, como se essas estruturas de dados não fossem imutáveis. Ou seja, ele permite que a gente faça alterações nas variáveis de estado do React, de Reducer do React, como se fossem variáveis tradicionais do próprio Javascript. E aí, por baixo dos panos, ele converte essas alterações que a gente fez em alterações imutáveis, para a gente não precisar se preocupar com isso. É bem legal, a gente vai ver como isso funciona na prática. Então, eu vou começar instalando o Imer aqui dentro do nosso código, e aqui no nosso Reducer, eu vou importar de dentro do Imer, um carinha chamado Produce. E esse método Produce é o que a gente vai chamar aqui dentro. Então, vamos lá. O que a gente vai fazer aqui agora? Por exemplo, essa estrutura que a gente fez aqui. Quando a gente quer alterar, adicionar um novo ciclo aqui no nosso Array de ciclos, a gente precisa, por exemplo, copiar todos os ciclos existentes e alterar um novo ciclo no final. Isso aqui a gente só precisa fazer porque a gente está usando essa estrutura imutável. Com o Imer, isso aqui fica mais simples. Vou até deixar o outro return aqui em cima. A gente vai fazer o seguinte, return Produce, eu passo qual informação eu quero modificar, e no segundo parâmetro, eu recebo uma variável draft. Esse draft é o rascunho, e dentro desse rascunho eu faço as alterações que eu quero fazer. Esse rascunho tem o mesmo formato que o meu state, até se eu passar o mouse por cima, a gente vai ver que ele é um WritableDraftCyclesState, ou seja, ele é exatamente uma variável com os mesmos valores que eu tenho do meu state. A diferença é que eu posso trabalhar com esse draft como se fosse uma estrutura de dados mutável, sem me preocupar com a imutabilidade do React. Por exemplo, se eu quero adicionar uma nova informação dentro do array de ciclos, basta eu fazer o seguinte, draft.cycles.push, que é um método que lá no começo a gente falou muito que a gente não ia utilizar porque ele é um método que não respeita a imutabilidade. E aqui eu modifiquei, adicionei um novo ciclo, e eu posso também fazer um draft.activeCycleId igual, coisa que a gente geralmente não fazia, a gente sempre estava substituindo o valor, dando um return inteiro, agora eu posso simplesmente pegar e alterar esses valores numa porrada só. E agora veja que eu posso remover esse comentário, e tudo vai funcionar normalmente. Posso adicionar um projeto, 20 minutos, e eu dou um começar, e está tudo funcionando. Nesse caso o emir acabou não tendo tantos ganhos, mas quando a gente vem para esses casos que a gente tem que usar o map, ele vai dar uma melhorada no nosso código. Olha só, eu vou retornar isso aqui agora, vou comentar, e agora vamos lá, vamos mexer nessa parte de interromper. O que a gente vai fazer aqui agora? Para eu interromper um ciclo usando o emir, eu vou dar um return, produce, state, draft, certo? E aqui o que eu quero fazer? Eu quero pegar o activeCycleId, que está dentro do draft, setar ele como nulo, e eu quero encontrar o ciclo dentro aqui do meu array, que tem o id igual o id do meu ciclo ativo, e colocar dentro dele uma informação interruptedDate como a data atual. Nesse caso, o que eu vou fazer? Aqui fora do produce, poderia ser dentro também, eu vou criar uma variável chamada currentCycleIndex, eu quero procurar o índice nesse array de ciclos do ciclo que está ativo atualmente. Como é que eu faço isso? Eu percorro o meu state.cycles, dou um findIndex, e aí procuro dentro do ciclo qual que é o ciclo que o id for igual ao activeCycleId, perfeito? Aqui eu botei uma vírgula, show. Se o meu currentCycleIndex retornar um valor abaixo de 0, eu vou retornar o estado sem nenhuma alteração. Por que? O findIndex, quando ele não encontra o ciclo ativo, nesse caso aqui, quando ele não encontrar nenhum item que satisfaça essa condição, ele vai retornar menos 1. Ou seja, se for menor que 0, ele não deveria modificar nada. Eu estou tentando interromper o ciclo ativo, mas eu não tenho nenhum ciclo ativo. Unexpected lexical declaration in case block. O meu case aqui dentro está com várias linhas. Nesse caso, é importante que eu bote chaves aqui por volta. Fechou. E aí, agora, aqui dentro, eu vou fazer draft.cycles na posição currentCycleIndex, eu vou modificar o interruptedDate para ser a data atual. Ou seja, esse código aqui, na minha humilde opinião, está muito mais fácil de entender do que esse código aqui em cima, que precisa usar um map, sei lá o que. Então, quando a gente vai trabalhar com essas estruturas, o Wimer dá uma ajuda em tanto para a gente trabalhar com esse conceito de rascunhos aqui dentro. E a gente vai fazer esse mesmo código aqui, muito parecido, para a ação de marcar o ciclo como finalizado. Então, veja só, eu vou copiar agora toda essa estrutura aqui agora, vou botar aqui dentro, e só vou trocar o interruptedDate, na verdade, pelo finishedDate. O resto, a gente pode manter igual. Salvo isso aqui agora, a gente vai ver que todo o nosso projeto continua funcionando normalmente. Posso começar, posso interromper, inclusive a ação de finalizado também já deve estar pronta. A gente só não vai conseguir testar agora porque eu não vou ficar esperando 5, 10 minutos ali, mas com certeza deve estar funcionando. E é isso, vamos continuar aqui."
  },
  {
    "id": "adf52008-0b7e-4131-ac8b-13e753c5ca96",
    "title": "Buscando transações",
    "transcription": "Agora que a gente já configurou os formulários da nossa aplicação, a gente vai fazer realmente eles terem algum tipo de ação. Então, a gente precisa que, ao digitar alguma coisa aqui na busca, por exemplo, site, e eu der um Buscar, eu preciso que essa lista aqui saia filtrada apenas com os registros que contêm o site. Então, o que a gente vai fazer? Aqui, se a gente for dar uma olhada na nossa aplicação, dentro do nosso contexto, o que eu estou fazendo aqui no final das contas é, eu tenho um estado, que ele armazena quais são as minhas transações, e assim que a aplicação carrega, eu chamo a função LoadTransactions, que busca uma lista de transações. Beleza. Só que em nenhum momento eu consigo refazer essa função aqui, ou seja, chamar essa função aqui novamente, buscando as minhas transações, ou filtrando as minhas transações, por algum tipo de string diferente. Então, o que eu posso fazer aqui para permitir que essa função LoadTransactions seja chamada novamente, mesmo após o primeiro carregamento, chamada, digamos, de forma programática por algum componente, eu posso expor essa função pelo nosso contexto. E, inclusive, eu vou trocar o nome dela para FetchTransactions. E aqui, agora, eu vou falar que o meu contexto vai devolver essa função. Essa função é simplesmente uma função assíncrona, por isso eu preciso do promise. Ela não tem retorno nenhum, então eu passo void. E agora, aqui dentro do value... Deixa eu quebrar de uma outra forma aqui para ficar melhor. Talvez assim. Eu vou passar o nosso FetchTransactions aqui. E agora, lá no meu componente do SearchForm, eu posso ter acesso, através do useContext, transactionsContext, a função FetchTransactions. E quando eu chamar essa função, ele vai realizar a busca de transações de novo e salvar o valor do estado dentro aqui do transactions. Porém, eu ainda não consigo enviar alguma string para fazer a busca. Então, o que eu posso fazer? Eu posso fazer com que essa função FetchTransactions receba uma query de busca. E aí, essa query eu vou deixar como opcional, porque num primeiro carregamento, eu não vou fazer busca nenhuma. E aqui no Fetch, eu preciso enviar, então, essa busca ali dentro. E aí, se a gente for dar uma olhada aqui no JSON Server, na documentação de full-text search, que é o tipo de busca que eu quero fazer, para eu fazer a busca, basta eu enviar um query parameter como sendo Q igual a Internet. E aqui eu estou usando a própria Fetch API do navegador. Deixa eu dar uma olhada como que a gente faz o envio de query params nas requisições usando o Fetch, porque eu já nem lembro mais como que faz isso. Ah, eu teria que setar um URL search params. Eu teria que criar uma URL. Tá bom. Vamos fazer assim, dessa forma, então. Depois a gente vai mudar isso, por isso que eu estou... Eu vou botar aqui URL igual a new URL. E aqui, if query URL.searchparams.append como sendo query. Então, se eu tiver enviado algum tipo de query, eu vou adicionar um search params, que é aquele parâmetro get, dessa forma aqui, na minha URL. E aí, aqui no lugar do Fetch, eu envio o URL, que é o URL que eu tenho aqui em cima. Vamos ver se está funcionando. Lá no search params agora, aqui, no lugar dessa promise, na verdade, eu vou executar com o await, para que o submitting fique carregando o botão ali, desabilitado o botão enquanto está sendo feito. Então, eu preciso colocar o await. Fetch transactions. E aqui eu vou passar o nosso data.query. O data.query expected zero arguments, but got one. Ah, o que acontece? Lá no meu contexto, lá em cima, eu preciso falar, então, que minha função FetchTransactions pode receber uma query. É um parâmetro opcional e é uma string. Salvo. Volto aqui no search params. Agora sim, já parou de dar erro. Voltamos aqui no Chrome. Voltamos na aplicação. E agora, se eu procurar por site e der um Enter, olha só, ele já buscou apenas as transações que tem site no nome. Se eu procurar por Ignite, salvo. Ignite Rocketseat também já trouxe. E o mais legal disso tudo é que, como a gente está atualizando com a busca, a gente está atualizando o objeto de transactions, o array de transactions que a gente tem aqui no estado, a gente pode ver que o nosso resumo aqui em cima, ele também se atualiza com base na nossa busca. Isso é legal, porque assim, se a gente quer, por exemplo, saber o resumo de entradas e saídas de uma categoria só, basta eu botar, por exemplo, a educação, dou um Enter e ele vai mostrar. É claro que aqui eu tenho poucos registros ainda, então ele acaba não mostrando muita coisa, mas eu acho que é uma feature bem útil. Mas a gente poderia separar isso depois, fazer uma requisição só para o resumo e outra depois para a busca, caso a gente preferisse que o resumo não se alterasse com essa busca. Mas por enquanto, eu acho que já está bem legal."
  },
  {
    "id": "6c37d885-55c5-49aa-ba14-30d7f06e55c8",
    "title": "Criando hook para o resumo",
    "transcription": "O que eu quero te mostrar nessa aula é um poder que a gente tem dentro do React que a gente consegue melhorar muitas vezes a escrita do nosso código criando hooks próprios. O que eu quero dizer com isso? Lembra que quando a gente foi criar aqui o componente de resumo que mostra o total de entradas, saídas e o total calculado entre esses dois valores a gente tinha várias opções de onde colocar esse cálculo que verifica qual é o valor total, como eu tinha mesmo falado. Uma delas era colocar dentro do contexto, por exemplo mas nesse caso não fazia muito sentido porque essa informação não ia ser utilizada por vários componentes da nossa aplicação então colocar isso no contexto acaba deixando nosso contexto mais pesado menos manutenível, então a gente optou por colocar essa informação diretamente dentro do componente. E está totalmente correto não tem nenhum problema fazer isso dentro do componente mas eu quero te mostrar uma outra alternativa que a gente pode fazer que também é muito legal. Veja só, no React quando a gente lida com hooks como eu estou fazendo aqui use context, quando eu lido com informações que vem através de hooks seja estado, contexto, seja um reducer, seja qualquer coisa assim o React permite a gente criar os nossos próprios hooks que nada mais são do que funções que utilizam os outros demais hooks do React então se a gente cria uma função useBanana ou use qualquer coisa e também o nome não precisa ser use, é só uma convenção e essa função dentro dela faz uso de outros hooks do React como useState, useContext, useReducer, useEffect a gente pode utilizar esse nosso hook próprio dentro dos nossos componentes e aqui é isso que eu quero te mostrar então imagine que, claro, aqui essa lógica não está tão complexa mas imagine que essa conta aqui, para calcular o total ela seja muito mais complexa sei lá, que ela tenha que usar informações que vem de uma API para talvez calcular impostos, sei lá, estou jogando qualquer informação aqui para você pensar que esse código aqui não teria, sei lá, quantas linhas a gente está aqui, talvez, 27 linhas, não, 1, 2, 3, 4, sei lá aqui tem umas 15 linhas de código mas imagina que isso aqui tivesse, sei lá, 50 linhas o nosso componente aqui ia ficar com muito conteúdo de cálculo aqui dentro que vem lá do contexto então uma dica é, a gente pode aqui na pasta source criar uma pastinha chamada hooks e aqui eu crio um hook chamado, por exemplo, useSummary e o nome que eu dou aqui, tanto faz esse hook, ele precisa ser uma função useSummary e eu posso copiar todo esse código aqui para dentro do useSummary agora eu faço a importação do useContext faço a importação do transactionsContext e aqui embaixo eu dou um returnSummary eu salvo isso aqui agora e agora eu venho e troco esse código para constSummary é igual a useSummary e pronto o nosso código agora, ele ficou muito mais simples dentro do componente porque eu abstraí a lógica aqui de cálculo do resumo em um hook separado e isso é muito útil, muito útil mesmo e você vai ver que ao longo aí da aplicação a gente vai criar alguns hooks próprios e isso é muito melhor ainda quando dentro desses hooks a gente tem cálculos complexos a gente tem uso de mais de um hook do React então imagina que aqui eu tenho um useContext tenho um useEffect também então a gente pode separar a lógica do nosso componente em vários hooks assim a gente não precisa pegar o nosso componente e dividir ele em vários componentes menores até porque a interface aqui, ela nem é tão complexa assim então bora continuar aqui o desenvolvimento da nossa aplicação a gente pode ver que está tudo funcionando normalmente"
  },
  {
    "id": "9f4b7cb1-40e3-4f02-bb2e-323c36a181e7",
    "title": "Criando um modal acessível",
    "transcription": "No React, quando a gente vai criar componentes que têm algum tipo de comportamento visual, por exemplo, modal, tooltip, popover, dropdown, esses elementos que, dado uma ação do usuário, aparece alguma coisa em tela, a gente sempre tem que cuidar, isso não é só no React necessariamente, a gente sempre tem que cuidar com acessibilidade, porque a gente até pode criar um div, aparecendo div em tela, mas a clica no botão cria uma nova div em tela, só que existem várias coisas que a gente tem que tomar cuidado com isso, porque para quem está utilizando um leitor de tela, por exemplo, simplesmente você fazer abrir uma div nova na tela não significa nada para a pessoa, você tem que anunciar para o leitor de tela que uma nova div está aparecendo, que tem esse propósito, então a gente sempre tem que cuidar com essas questões de acessibilidade. Bom, a gente pode simplesmente seguir o área, o WCICGA, que eu nem sei o nome, mas a gente pode seguir as regras do área de acessibilidade que tem na própria MDN, ou a gente pode usar uma biblioteca que traz para a gente toda essa parte de acessibilidade pronta dentro do React. Existem algumas bibliotecas mais famosas, existe o AreaKit, que é criado pelo Diego que é um brasileiro, já gravei podcast com ele e tudo mais, e o AreaKit é super legal, funciona super bem. A gente pode utilizar o HeadlessUI, que é criado pelo pessoal do Tailwind, se eu não me engano, então eles são componentes acessíveis, como eu falei, Popover, ComboBox, esses elementos que eles têm interação do usuário. O próprio ChakraUI tem esses componentes acessíveis, mas eu não recomendo muito nesse caso, porque o Chakra vai trazer uma estilização junto, e eu não quero estilização, eu quero só o comportamento primitivo, não quero o visual que traga junto. E tem, a que eu vou recomendar para você estar utilizando, que é o Radix. O Radix é uma ferramenta criada pelo pessoal da Modules, que agora foi comprada pelo pessoal da WorkOS, e o Radix é uma série de componentes primitivos, quando eu falo primitivos são componentes que imitam o funcionamento original de coisas que já existem na web, porém trazendo uma API mais flexível para a gente adicionar estilização e alguns outros comportamentos. Então, se a gente for aqui nos componentes, a gente vai ver alguns exemplos, por exemplo, Accordion, que isso aqui a gente tem no HTML, a gente consegue fazer isso aqui no HTML, lá com o Details e tudo mais, mas a gente não consegue necessariamente com o HTML, por exemplo, fazer esse tipo de animação, a gente não consegue com o HTML ter um controle de abrir e fechar de uma forma simples, sem ter que utilizar refs, referências. E com isso tudo, a gente tem aqui, por exemplo, AlertDialog, a gente tem CheckBox, caso a gente queira criar o nosso próprio elemento de CheckBox, ao invés de utilizar o nativo do HTML, que é muito difícil de adicionar uma estilização, a gente tem aqui um ContactMenu, que é quando eu clico com o botão direito, a gente tem aqui um Dialog, que é basicamente um modal, nós temos um DropDownMenu, a gente tem vários e vários elementos, e o mais legal é que todos esses elementos aqui seguem todas as regras de acessibilidade. Inclusive o que a gente vai estar utilizando aqui para fazer a construção do nosso modal de inserção de uma nova transação é o Dialog, ele é basicamente um modal. E existe um Dialog no próprio HTML, muita gente acha que não dá para criar um modal com um HTML puro, mas sim, dá sim, existe o Dialog, que é um elemento, a gente pode controlar se ele está aberto ou não, utilizando essa propriedade Open, esse atributo Open aqui dentro, até tem um exemplo, olha só, consigo abrir o modal, fechar o modal, está vendo? E ele funciona normalmente, mas tem algumas coisas que a gente não consegue fazer de uma maneira tão amigável com esse Dialog nativo, a gente não consegue, por exemplo, botar um ícone, um item aqui de fechar, um botãozinho de fechar aqui dentro, e quando eu clicar ele fecha, quer dizer, dá para fazer, mas eu tenho que criar todo um código ali para conseguir fazer isso de uma maneira imperativa, sendo que no React a gente sempre tenta programar de uma maneira declarativa, dizer se algo está aberto ou não, simplesmente passando uma propriedade, e não eu ir lá diretamente acessar o elemento na página e trocar o atributo dele. Então, nesse caso, a gente sempre vai preferir utilizar uma biblioteca que já esteja integrada ao React e traga acessibilidade com esses componentes. E aqui, então, a gente vai estar utilizando esse Dialog, a gente pode vir aqui embaixo, cada elemento desses aqui, cada componente ele é instalado de uma maneira individual, porque geralmente a gente não vai utilizar todos eles na nossa página, não faz sentido instalar todos e aumentar o bundle da aplicação, então eu vou instalar diretamente apenas o Radix UI React Dialog aqui dentro. E aí, a gente vai começar a utilizar isso aqui e entender como que funciona. Então, para isso, eu vou aonde? A gente pode ir lá no nosso header. Por que no header? Porque é no header que está o nosso botão de abrir o nosso modal. Então, a gente vai ter que partir aqui do header para colocar o nosso modal. E aí, seguindo aqui a própria documentação, o que a gente tem que fazer? Por volta do lugar onde vai ter o nosso modal, ou seja, eu vou dar um CTRL X nesse botão, a gente vai colocar, primeiramente, um Dialog Root. Então, ele importou dessa forma, o que eu vou fazer? Ele até recomenda, eu faço a importação dessa forma aqui, import asterisco sDialog, ou seja, ele vai importar tudo que é exportado de dentro dessa biblioteca aqui. Ai, eu perdi o meu CTRL X, deixa eu comentar isso aqui. E agora sim, deixa eu copiar isso aqui. Ele vai importar tudo que está exportado de dentro dessa biblioteca e vai colocar dentro de um objeto chamado Dialog. E aí, eu consigo usar os componentes dessa forma, o Dialog.root. Caso eu não queira utilizar dessa forma, a gente pode importar separadamente, por exemplo, só o root, e aí eu faço dessa forma. Mas só o root, eu acho que fica... não dá pra saber exatamente o que é isso aqui. Então, eu teria que renomear, talvez, a sDialog.root. Mas aí, no final das contas, dá na mesma e é muito mais fácil só fazer dessa forma aqui. Então, Dialog.root, isso aqui precisa ficar por volta de todo o contexto do nosso modal. Então, lembra que a gente já falou sobre contextos antes. Então, o Dialog.root precisa ficar por volta tanto do botão que vai abrir o modal, quanto do próprio modal. Então, aqui a gente já viu o botão. Agora, a gente vai colocar por volta dele esse Dialog.trigger, que é o que vai fazer o nosso modal abrir ou fechar. E uma das coisas que é interessante aqui do Dialog.trigger, aqui embaixo, é que o Dialog.trigger, por si só, ele já é um botão. Então, uma das alternativas que eu teria aqui é acessar aqui o nosso StealthComponent, importar novamente aqui de dentro do RadixUI ReactDialog e trocar o newTransactionButton por um Dialog.trigger. Isso aqui funciona. Funciona perfeitamente. Mas, dessa forma, a gente vai acabar meio que, digamos, sujando o nosso CSS com código que é específico de uma biblioteca, que é do RadixUI. E não é que necessariamente tenha um problema, mas aqui eu vou evitar. Então, o que eu posso fazer nesse caso? Só para eu mostrar mais maneiras de resolver o mesmo problema. A gente pode manter aqui como um button e lá no meu HTML, eu posso colocar o Dialog.trigger por volta do botão e passar uma propriedade para ele chamada asChild. O que esse asChild vai fazer? Esse asChild, basicamente, é uma propriedade que ele até mostra aqui, ele vai mudar para que esse Dialog.trigger aqui, ele não crie um novo botão. E sim, ele aproveite o elemento, o botão que já tem dentro da tag como sendo o trigger do modal. Se eu não colocar esse asChild, a gente vai ter dois botões. Esse botão, no final das contas, e mais um botão dentro dele. E no final das contas, isso para acessibilidade é péssimo, um botão dentro do outro. Então, vamos continuar dando uma olhada aqui na documentação. A gente vai precisar agora de um Dialog.portal. Se você não sabe o que é, o portal no React, se você procurar aqui na própria documentação, o portal é uma funcionalidade do React. O portal, ele fornece uma forma elegante de renderizar um elemento filho dentro de um outro local da DOM. Então, com o portal, o que a gente pode fazer? Eu posso fazer com que um conteúdo que eu bote aqui dentro, por exemplo, um parágrafo, vá parar em outro lugar da nossa aplicação. E por que a gente faz isso? Porque se a gente for pensar, quando o modal abrir em cima da nossa tela, até aqui pelo layout, não faz muito sentido o modal, tanto esse overlay aqui, esse fundo preto, quanto esse próprio modal aqui e os campos, eles pertencerem ao header da aplicação. Porque o header é só essa área aqui em cima, o modal não tem nada a ver com esse header aqui em cima, é só porque o botão está nele. Mas o conteúdo do modal não tem muito a ver com o header, concorda comigo? Ele é algo que fica sobreposto à aplicação, é algo que está fora de qualquer container, digamos assim, ele tem seu próprio container. Então, o portal ajuda a gente a simplesmente colocar o conteúdo desse modal, tanto o overlay quanto o conteúdo mesmo aqui, fora de todas as divs que a gente tem, digamos assim, fora do header, fora da página, é como se fosse algo à parte da nossa aplicação. Isso é bem legal, mas a gente não precisa entrar muito a fundo, depois eu posso mostrar no HTML como que isso fica no final. E aí, eu vou colocar aqui também um dialog.overlay, o dialog.overlay é basicamente esse fundo preto, que a gente tem aqui com uma opacidade um pouquinho mais baixa. E aí, por fim das contas, nós temos o nosso dialog.content, que é o conteúdo em si, ele não tem muito o que falar. E dentro desse dialog.content, a gente pode ter o que a gente quiser. E ele vem com algumas pré-definições de conteúdo. Então, se o nosso modal tiver um título, ou seja, algum texto que represente o que é aquele modal, aqui no caso a gente tem esse nova transação, então posso até colocar, é interessante a gente colocar isso dentro do nosso dialog.title, porque ele vai utilizar por baixo dos panos, o Radix vai utilizar esse title para anunciar para o leitor de tela que tipo de modal é esse que foi aberto em tela. Então, poxa, quando alguém que está ali usando o leitor de tela para usar a sua aplicação, quando o modal abrir, essa pessoa vai ouvir, depende da forma que ela está consumindo isso, mas ela vai ouvir que um novo modal abriu, e esse modal é o modal de nova transação. Então isso é super legal. Se eu tiver uma descrição também, eu posso usar o dialog.description, nesse caso não tem, e aí o dialog.close, que a gente pode colocar aqui dentro, é esse botãozinho de fechar aqui na direita. A gente pode usar ele mais de uma vez caso a gente queira também, só é importante que ele esteja dentro do dialog.root. E feito isso, a gente pode salvar e testar como que isso está funcionando. Então eu venho agora no DTMoney, se eu clico em nova transação, está vendo que abriu aqui nova transação, e aqui abriu um botãozinho, esse botãozinho aqui é o botão de fechar, se eu clico, ele fecha o dialog. É só porque como a gente não colocou conteúdo dentro do dialog.close, ele criou ali um botãozinho sem nenhum conteúdo. Mas o que eu queria te mostrar é duas coisas. Primeiro, está vendo que nenhuma estilização foi adicionada automaticamente. O Radix tem esse princípio, ele traz o componente primitivo, ou seja, sem nenhum visual, e todo CSS é a gente que vai adicionar. E o segundo ponto que eu queria te mostrar é a questão do portal. Se a gente for ver aqui no HTML gerado no fim das contas, quando eu dou um inspecionar nesse elemento, eu vou ver que o dialog aqui do Radix está fora inclusive da div.root, que é a div onde está todo o HTML da nossa aplicação, que é aquela div.root do index.html. Ou seja, o portal permitiu que a gente criasse o nosso conteúdo do modal totalmente fora do contexto da aplicação. E outra coisa legal é que eu tenho toda a acessibilidade garantida com o modal. Então, veja só, eu consigo, por exemplo, aqui eu estou com o botão focado, eu dou um enter, ele abre o modal. Se eu dou um ask, ele fecha o modal. Então, toda essa parte de teclado, toda a parte de acessibilidade já vem junto com todos os componentes aqui do Radix. É claro que a gente ainda precisa adicionar estilização para isso aqui ficar da forma mais adequada possível."
  },
  {
    "id": "c8ffbfcc-c37b-4779-9494-0831786b17c1",
    "title": "Mudando title da página",
    "transcription": "Chegou a hora de a gente resolver alguns bugs aqui e também melhorar um pouco o nosso código. Uma das coisas aqui é o seguinte, a gente tem uma variável aqui que a gente anota no estado, que é o total de segundos que se passaram desde a gente ter começado um novo ciclo. E aí o que a gente está fazendo aqui hoje é a gente está alterando, calculando a diferença de segundos que já passaram da data atual para a data que começou o ciclo dentro de um intervalo de um segundo. Isso está funcionando perfeitamente. Mas a gente percebeu que quando a gente inicia um novo ciclo e já tinha um ciclo antes existente no estado, esse código está executando de novo. Isso é normal, é o que a gente espera que aconteça, porque a gente está colocando o ActiveCycle aqui como uma dependência do UseEffect e a gente sabe que toda vez que uma variável das dependências de um UseEffect mudam, isso faz com que aquele código execute de novo. Mas uma das coisas que a gente ainda não viu sobre o UseEffect, que é muito interessante, é que de dentro do UseEffect a gente pode ter um retorno. E esse retorno sempre vai ser uma função. Então veja que eu retorno uma função mesmo que MyRowFunction, sem parâmetros nenhum. Essa função tem uma responsabilidade, que é o seguinte. Eu tinha um intervalo rodando com o ciclo que eu criei anteriormente. Ou seja, esse UseEffect executou uma vez assim que eu criei o primeiro ciclo. Então se eu venho aqui na aplicação, crio um ciclo, assim que o ciclo é criado, que o ActiveCycle recebe o valor, esse UseEffect executa. Concorda comigo? Quando eu crio um novo ciclo, esse UseEffect aqui vai executar de novo, porque a variável ActiveCycle mudou. Essa função aqui serve para quando eu executar o UseEffect de novo, porque aconteceu alguma mudança aqui nas minhas dependências, eu quero fazer algo para limpar, digamos assim, para resetar o que eu estava fazendo no UseEffect anterior para que não aconteça mais? Sim. Como a gente criou um intervalo dentro do UseEffect, cada vez que ele executa eu estou criando um novo. Eu nunca deleto os intervalos, eles estão sempre sendo criados. Essa função aqui é ótima para deletar os intervalos que eu não preciso mais. Então como eu criei um novo ciclo e isso gerou um novo intervalo, um novo setInterval, o que eu tinha anteriormente eu preciso remover. Então, olha que interessante, esse setInterval aqui eu vou guardar ele numa variável. Então eu vou chamar de intervalo. E aqui embaixo eu posso utilizar a função clearInterval passando a nossa variável interval. O problema é que essa variável é definida somente dentro do nosso if. Ou seja, se o nosso if não foi nem chamado, isso aqui não deveria nem executar. Então está dando um erro aqui embaixo porque interval não é definido, digamos assim. Ou seja, eu vou fazer o seguinte, eu vou criar a variável interval fora do if. Aqui eu vou só assinar a ela ao invés de criá-la do zero. E agora tudo volta a funcionar. O único problema é que como estou utilizando TypeScript, é importante dizer que o intervalo aqui vai ser um número. Um número porque o JavaScript anota meio que fosse um id, uma referência para aquele intervalo, para depois a gente conseguir remover eles. Feito isso, salvando aqui e voltando no Chrome, olha só. Eu crio um novo projeto, 5 minutos por exemplo, inicio e ele está rodando. Quando eu criar um projeto 2, por exemplo, que dura 10 minutos e clicar em começar, eu não sei se você percebeu, mas um dos bugs a gente resolveu. O timer está funcionando perfeitamente agora. Só que quando eu criei o novo ciclo, ele não começou dos 10 minutos que eu coloquei, ele começou já de 9 e 57, se não me engano, que era o tanto de tempo que tinha passado do timer anterior. Por que isso está acontecendo? Porque quando a gente está criando um novo ciclo, aqui na nossa função handleCreateNewCycle, a gente não está resetando o valor dessa variável de quantos segundos já se passaram. Ou seja, eu estou meio que reaproveitando o tanto de segundos que se passaram do ciclo anterior para o novo ciclo que eu criei. Ou seja, são tudo bugs que se você não testar realmente, você nem vai saber o que está acontecendo. Então aqui, quando eu crio um novo ciclo, eu posso voltar a variável de quantos segundos se passaram para 0. Isso é super interessante. Vamos lá ver agora. Eu vou criar o projeto 1. 5 minutos. Começou 5, beleza? Está rodando. Vou criar agora o projeto 2. 10 minutos. E agora ele tem que começar do 10 direto, assim que eu clicar no botão Começar. Fechou. E agora ele continua o timer sem problemas nenhum. E para a gente aproveitar que essa aula está curta, vamos criar mais uma funcionalidade legal aqui para a nossa aplicação. Uma coisa legal que eu posso criar aqui na nossa aplicação é o seguinte. Isso eu vi em outra aplicação que eu usava de Pomodoro e falei, cara, eu vou copiar isso porque é muito legal. Às vezes a aba que eu estou não é essa, eu não vou ficar com essa aba aberta, eu vou ficar trabalhando em outro projeto, sei lá, em outro projeto e aí fica só escrito Ignite Timer. Uma coisa legal pode ser, quando eu estiver com o ciclo rolando, eu colocar esse countdown aqui também na aba, eita, na aba aqui em cima, no título da aba. Isso dá para fazer também aqui sem grandes problemas. Então, o que a gente pode fazer aqui? Deixa eu até pegar a minha colinha aqui. A gente vai fazer o seguinte. Eu vou aqui embaixo criar mais um UseEffect. E aqui eu vou falar o seguinte. Toda vez que os meus minutos e os meus segundos, ou os meus segundos mudarem, eu quero atualizar o título da minha janela para uma string contendo minutos, dois pontos, segundos. Isso aqui vai funcionar. Porém, se eu dou um F5 aqui na tela, olha lá, ficou 0000. Ou seja, eu só quero executar isso aqui se eu tiver um ciclo ativo. Se não, não faz sentido. E aí eu preciso colocar também o ActiveCycle aqui dentro. E agora, olha só, quando eu iniciar um novo projeto, cinco minutos, dou um Começar, ele troca lá em cima e ele vai mudando. Ele não fica instantâneo a mudança, porque a alteração do título na janela demora um pouquinho, mas se eu troco de aba, ele vai ficar rodando lá. E você pode ver que o intervalo não está de um em um segundo. Lembra aquele negócio que eu falei, que se você não está na mesma aba, o intervalo não roda de um em um segundo? É isso. Por isso que a gente fez aquele cálculo aqui. Onde mesmo? Eu estou perdido. Aqui no UseEffect, que a gente fez esse cálculo de diferença de segundos e não usou só o menos um, menos um, menos um. Porque como a gente bem pode ver, ele está passando de dois em dois aqui até. Às vezes ele passa um, às vezes passa dois, porque realmente o intervalo aqui do que a gente bota no setInterval, a gente não pode depender dele achando que isso aqui sempre vai ser um segundo. Show, a gente aprendeu muita coisa nessa aula, já está ficando bem legal a nossa aplicação. E é isso, vamos continuando."
  },
  {
    "id": "670d3a80-7318-48be-b77f-c7752937ae30",
    "title": "Criando radio button acessível",
    "transcription": "No final das contas, esses botões de entrada e saída vão funcionar como um radial button do html porque isso aqui faz parte de um formulário e é uma entrada que o usuário faz, uma entrada de dado onde eu só posso selecionar uma opção. Então isso aqui não é um checkbox, isso aqui é um radial. E, pasme, o Radix traz um elemento de radial e aqui ele chama de radial group até porque o radial nunca faz sentido sozinho, porque depois que você seleciona um radial, imagina que ele está sozinho e não tem outras opções, você não vai conseguir desselecionar nunca, então nesse caso esse seria o melhor elemento do checkbox que a gente tem aqui, por exemplo, para fazer accept terms and conditions. Então por isso que é radial group, porque o radial sempre anda acompanhado de outros radial items, digamos assim. E a gente vai usar isso aqui para controlar a informação de qual botão foi selecionado pelo usuário. E, cara, o Radix é uma delicinha para fazer essa parte visual. Antigamente era louco porque nos meus projetos eu precisava ficar procurando uma biblioteca para cada coisa que eu fosse fazer na aplicação. Preciso um modal? Procuro uma biblioteca de modal. Preciso um select? Procuro uma biblioteca de select. Preciso um drop-down? Procuro uma biblioteca de select. E com o Radix eu tenho uma forma de criar todos esses elementos, esses componentes, com uma única biblioteca. Mas vamos lá, vamos entender como é que o radial group funciona. Eu preciso de um radial group root por volta de tudo, então eu vou usar esse transaction. Deixa eu copiar esse import aqui nos meus estilos. Opa, não copiei. Aqui no meu transaction type, que é aquela div que está por volta dos dois botões, eu vou transformar ela no meu radial group root. E aí para cada item eu preciso do radial group item. Então eu vou transformar cada um desses transaction type button em um radial group item. E ele tem esse radial group indicator, que é a bolinha. No caso, o nosso aqui não tem uma bolinha, uma coisa assim que indica que o radial está selecionado, então a gente não vai usar. O que a gente quer na verdade, no final das contas, é trocar a cor de fundo aqui do botão se ele estiver selecionado. Então eu vou salvar isso aqui agora e vamos dar uma olhadinha. Aqui ele começou a dar um erro. Deixa eu dar uma olhadinha. Overload. Property value is missing. O que acontece? Como a gente está usando um radial agora, é obrigatório que o nosso item tenha uma propriedade, que é o value. E ela é obrigatória, como eu acabei de falar, que indica qual é o valor daquele item, especificamente. Pensando num formulário, quando eu for salvar essa informação e criar a transação e a pessoa selecionou isso aqui, qual é o value que vai para esse campo? Então aqui o value eu vou passar como income mesmo. E esse aqui vai ser value outcome. Salvo isso aqui agora, voltamos aqui no DTMoney e agora a gente já pode ver que eu consigo clicar aqui nos botões, porém eles não representam nada visualmente diferente quando eu clico neles. Agora, se eu for no HTML desses botões, eu vou ver que o Radix coloca pra gente, por exemplo, quando eu clico em entrada, ele coloca pra gente automaticamente um atributo no meu button como dataStateChecked. Então eu consigo pegar esse dataStateChecked e fazer uma estilização baseada nisso. O Radix usa bastante esses data attributes, que é um conceito do Javascript, pra armazenar algumas informações sobre o estado daquele componente. Então o dataStateChecked, quando ele estiver como checked, no caso, é que o botão foi selecionado e aqui a gente pode ver que o outro botão está com dataStateUnchecked. Então eu consigo também adicionar estilizações em botões que não estão selecionados. Então, aqui embaixo, a gente vai fazer o seguinte. Eu vou começar colocando aqui uma estilização com o e-comercial dataStateChecked, ou seja, quando o meu item estiver com o atributo dataStateChecked, eu vou adicionar um CSS a mais. Qual que é esse CSS? Primeiro, eu vou setar com que a cor do texto do botão seja branco. Além disso, eu vou mudar a cor de fundo do botão. A cor de fundo vai ser situacional? Não. Ela vai depender do props.variant. Se ele for income, eu vou botar a cor de fundo como props.theme.green 500. Se não, vai ser props.theme.red 500. E também, eu vou pegar o meu SVG e vou colocar a cor dele como sendo branca também quando o botão for checked. Salve isso aqui agora. Olha só que legal. Quando eu checo, ele já faz a alteração. Aqui você pode ver que estão aparecendo essas bordas quando eu clico. Isso é por causa de uma extensão minha. Não precisa considerar isso não. Vamos lá. Agora sim, a gente já pode ver que ele está funcionando perfeitamente. O que a gente pode fazer aqui agora é, no botão que estiver com dataState como sendo unchecked, ao invés de checked, a gente vai colocar no hover dele um background um pouquinho mais claro. Então, eu vou pegar aqui props.theme.gray 600. Então, a gente vai ver que agora o botão que não está checked, ele dá uma leve clareada quando a gente passa o mouse por cima. Mas, se ele estiver com checked, ele não muda nada. Beleza? Será que dá pra gente fazer mais alguma coisa aqui? Eu acho que não. Eu acho que a gente já fez tudo o que a gente precisava fazer. Eu posso, no máximo, colocar um transition no backgroundColor de 0.2 segundos pra fazer uma transição. E é isso. Por enquanto não tem mais nada do que a gente possa adicionar nesse modal. A gente já finalizou toda a parte visual da nossa aplicação. Agora a gente vai realmente pra parte funcional, começar a integrar com a API e vai ser bem legal daqui pra frente."
  },
  {
    "id": "86ac2e1d-4901-4cff-b654-a0fbad12b42f",
    "title": "Formatação de data",
    "transcription": "Para fazer a formatação dessa data de início, eu vou utilizar também a nossa biblioteca, a Date.fns, e eu vou usar um método que tem dentro dela que se chama formatDistanceToNull. E esse método funciona da seguinte forma, eu vou botar ele aqui dentro dessas chaves, eu vou chamar o método formatDistanceToNull, eu passo a data do meu ciclo, então eu vou botar aqui cycle.startDate, e se eu salvar isso aqui agora, olha só o que ele vai mostrar aqui, ele fala a quanto tempo iniciou o ciclo, então 1 minuto. Se eu passar aqui para ele, no segundo parâmetro, um objeto e colocar a propriedade addSuffix, como sendo true, ele vai colocar, por exemplo, 2 minutos atrás. Então ele adiciona esse sufixo, então ele fala, começou a 2 minutos atrás. Mas isso aqui está em inglês, então eu quero em português, para isso eu posso fazer o seguinte, eu posso importar o idioma português do Brasil de dentro de Date.fns.local.pt.br E aqui eu passo um segundo atributo aqui para esse objeto, uma segunda propriedade chamada local, como sendo ptbr. Salvo isso aqui agora, volto no Chrome, e ele acabou reiniciando aqui o meu ciclo, então eu vou iniciar um novo aqui, projeto1, vou botar aqui 20 minutos, inicio, vou deixar ele rodando mesmo, e agora no histórico a gente vai ver que ele bota a menos de 1 minuto. E aí conforme vai passando ele vai botando a 1 minuto atrás, a 10 minutos, a 1 semana, a 1 mês, então ele faz uma formatação, por isso que o nome é formatDistance, a distância de tempo de agora até a data que ele iniciou, e aí ele faz essa formatação certinha, fica bem legal."
  },
  {
    "id": "82e0517f-67a7-4d15-a9b5-51251132ef5a",
    "title": "Realizando requisição HTTP",
    "transcription": "Agora que a gente já configurou o JsonServer, a gente vai fazer uma primeira requisição HTTP para a gente ver como se parece uma requisição vinda de um front-end para um back-end. E é importante falar que o JsonServer está fazendo o papel de back-end na nossa aplicação. E sim, ele funciona exatamente como o back-end vai funcionar na vida real. Então, tudo o que a gente fizer daqui para frente vai ser exatamente igual quando você tiver uma API para consumir, seja ela em Node, Java, PHP ou qualquer coisa assim. Então, a gente vai começar fazendo o seguinte. Já que eu tenho aqui no meu JsonServer uma lista de transações, a gente vai começar carregando essa lista de transações aqui nessa tabela. Então, bora lá. Eu vou acessar aqui a nossa página de transações. E para carregar uma lista de transações através de uma API, a gente tem que tomar alguns cuidados aqui. Primeiramente, para eu carregar essa lista de transações, eu vou ter que utilizar a API de Fetch do navegador, caso eu não queira instalar nenhuma biblioteca adicional. E essa API Fetch funciona da seguinte forma. Eu chamo o método Fetch, eu passo qual é o endereço HTTP localhost 3353 barra transactions, e ela me devolve aqui uma resposta através do conceito de promise. Então, isso aqui é uma promise, demora um pouquinho para executar, até porque a gente botou um delay, .then, ele demora um pouquinho, então, quando eu trouxer o resultado aqui, a gente vai ter acesso a esses dados. Mas, como a gente já falou milhares de outras vezes, tudo o que a gente joga diretamente aqui dentro da nossa função, do nosso componente, vai executar sempre que o componente entrar num novo fluxo de renderização. Ou seja, sempre que esse componente transactions renderizar novamente, seja por uma alteração de estado, seja por uma alteração de propriedade, ou seja, porque algum componente fora dele, algum componente pai dele atualizou, esse Fetch vai executar de novo, e não é isso que a gente quer. A gente quer que, na verdade, esse Fetch execute uma única vez e depois não execute mais. Então, para isso, a gente tem que acabar utilizando o UseEffect do React, que é uma forma de a gente conseguir disparar uma função em determinado momento. Nesse caso aqui, se a gente passa uma rede de dependências vazio, a gente tem com que essa função que eu coloco aqui dentro do UseEffect execute apenas uma única vez. E uma das coisas aqui que é importante dizer é que quando eu faço uma requisição Fetch através do nosso front-end, a resposta aqui não vai vir exatamente da maneira que eu quero. Quer ver? Vamos salvar isso aqui agora. Eu venho aqui no meu localhost, na minha aplicação, venho na aba Network, vou dar um F5 aqui, e a gente vai ver que aqui dentro, em algum lugar, se tudo deu certo... Ah, está ali. Por que eu não... Ah, tinha que dar um scroll. Está aqui, a gente consegue encontrar essa requisição de transactions, e você vai ver que tem duas requisições aqui. E isso acontece porque o React, em ambiente de desenvolvimento, ele tem esse strict mode aqui por volta do render. Isso aqui é meio que para o React conseguir fazer algumas verificações mais estritas em relação aos componentes que você cria, as propriedades que eles recebem e tudo mais. Mas só que isso, em desenvolvimento, acaba causando com que algumas coisas executem de forma repetida. E não tem problema, porque em produção isso não vai acontecer. A gente vindo aqui em console, dando um pouquinho, uma olhada ali no nosso console.log que a gente fez da resposta aqui para API, a gente vai ver que dentro dessa resposta vêm algumas informações. Porém, o resultado mesmo da resposta, esse conteúdo aqui, ele vem dentro de body. Só que o body, se a gente clicar nele, a gente vai ver que, na verdade, ele é uma readable string. String, para quem já estudou um pouquinho sobre Node... Ih, chegou uma encomenda. Pera aí, eu já volto aqui. Voltando aqui, isso aqui é uma string. Se você já estudou um pouquinho do Node, sabe que strings são maneiras de a gente conseguir enviar ou receber dados de forma particionada, aos poucos. E a gente consegue fazer isso. Mas não vem ao caso aqui. O ponto é que eu preciso converter essa string que contém os dados trazidos da nossa requisição para algum outro formato. E aqui no Fetch, a gente tem algumas APIs para fazer isso. Eu posso vir aqui, escrever response, ponto, e aqui eu vou ver que eu tenho duas opções que são as mais importantes para a gente, text e JSON. Eu posso utilizar a opção text, chamando essa função, fazer um then novamente, porque isso aqui é uma promise também, e dar um console.log aqui no nosso data. Agora, se eu salvar isso aqui, eu vou ver que no Chrome ele traz exatamente os dados aqui da nossa API. Só que, como isso aqui já é um JSON, se eu utilizar o método JSON ao invés do método text, ele vai trazer já em formato de objeto JavaScript, e assim fica muito mais fácil a gente trabalhar e lidar com esses dados aqui. Uma coisa que não é muito legal é a gente ficar criando esse ponto then dentro de outro ponto then, e por aí vai. Então, uma dica que eu dou para você é, quando a gente trabalha com promises, se dentro de um ponto then a gente retornar outra promise, que é, por exemplo, esse response.json aqui que a gente está fazendo mais um ponto then, ou seja, se daqui de dentro a gente retornar o response.json, eu consigo fazer o segundo ponto then aninhado dessa forma, e aí fica mais bonito. Eu dou um console.log data aqui, e pronto, tudo está funcionando normalmente. E uma dica, na verdade, um aviso que eu deixo para você, o React dentro do useEffect, ele não deixa a gente, tanto que não é recomendado quanto também vai dar erro ali no console, a gente transformar essa função aqui que é passada para o useEffect em uma função assíncrona. A gente pode ver até que ele vai dar erro, porque eu estou usando TypeScript, e por isso eu não consigo utilizar a sintaxe de async, await, aqui dentro do useEffect diretamente. A única forma que eu poderia, talvez, fazer isso seria da seguinte forma, eu criar dentro do useEffect uma função, por exemplo, loadTransactions, aí essa função, sim, pode ser assíncrona, e aí eu passo esse código aqui para dentro, e aí faço mais ou menos o seguinte, const response igual awaitFetch, e const data igual awaitResponse.json, e aí eu deixo só o meu console.log data, e aqui eu chamo o método loadTransactions dentro do useEffect. Isso aqui, inclusive, essa função pode estar fora do useEffect também, não tem problema. Então, isso aqui é uma maneira de a gente conseguir utilizar o async, await, aqui para fazer a nossa requisição HTTP, sem escrever esse código dentro do useEffect, porque o useEffect não pode ser assíncrono, perfeito? Salvo isso aqui, agora a gente vai ver que tem o mesmo resultado. Continuo tendo acesso aqui aos dados providos da nossa requisição. E aí, para eu conseguir mostrar esses dados em tela, eu preciso ter acesso a esses dados que vieram da API. E nesse caso, a gente vai ter um estado. O estado é a melhor e única forma de eu armazenar informações aqui dentro do React, para elas serem consumidas ali pela interface, eu conseguir percorrer essas informações, mostrar em tela e tudo mais. E aqui eu vou criar um estado, que vai começar como array vazio, até porque dentro dele vai ter uma lista de transações, então eu sempre começo ele com uma estrutura de dados do mesmo tipo da estrutura que eu vou salvar. E aqui, nesse data, eu dou um setTransactions do data. Quando eu crio estados no React, é sempre importante a gente lembrar de tipar o estado, principalmente se ele for um array ou um objeto. Então, aqui eu vou criar uma interface chamada transaction, e eu vou, basicamente, falar o que uma transaction tem. Então, ela tem um id, que é um número, ela tem uma description, que é uma string, ela tem um type, que é uma string também. Aqui no type, eu sei que ele sempre vai ser duas opções, apesar de ser um texto, eu sei que ele vai ser income ou outcome. Então, a gente não precisa escrever string, assim fica até mais fácil. Ele tem um price, que é um number, e ele tem uma category, que é uma string, e ele tem um createdAt, que é uma string também. E aqui eu posso falar que esse nosso estado vai armazenar, então, uma lista de transactions. E pronto, agora, aqui na nossa tabela, eu posso percorrer a nossa lista de transactions, utilizando o match. E para cada uma das transações, eu vou retornar todo esse table row que a gente tem aqui. Vou tirar esse que a gente ficou aqui embaixo. E nesse tr, agora, eu vou colocar as nossas informações. Então, aqui vai ser o nosso transaction.description. Aqui, no variant, a gente vai colocar o nosso transaction.type. Aqui no preço, eu vou deixar sem formatação por enquanto, mas eu vou botar o transaction.price. Aqui eu vou botar o transaction.category. E aqui eu vou botar o transaction.createdAt, ainda sem formatação também. E como a gente já aprendeu antes, quando a gente faz um map, é importante que o primeiro elemento que vem dentro do map tenha uma key com alguma informação que seja única para cada transação, para cada item da lista. Salvo agora, a gente vem para o Chrome, e olha lá, a gente já tem aqui desenvolvimento do site e hambúrguer, e essas informações estão vindo diretamente da nossa API. Se eu venho aqui no server.json e troco, por exemplo, o valor de hambúrguer de 50 para 60, salvo, volto aqui, dono F5, a gente vai ver que já mudou aqui dentro. Então, a gente já está fazendo a nossa primeira requisição, a API, aqui por dentro do React."
  },
  {
    "id": "2f0dab55-dfda-4046-b4de-aacbaad8789e",
    "title": "Componente: Header",
    "transcription": "Nessa aula, o que a gente vai fazer é começar, então, a parte da estrutura visual. Eu vou começar com esse primeiro componente aqui em cima, que é o header. Ele é super simples, é basicamente só o logo e um botão. Depois a gente vai criar um componente para esse resumo, daria para dizer assim, resumo de entradas, saídas e o total. Depois a gente vai partir aqui para a nossa tabela de listagem de transações, depois fazer a busca e depois fazer esse modal de nova transação. Eu nem vou focar tanto aqui em explicar a parte de componentização em si da aplicação, até porque é algo que eu já espero que você saiba nesse momento. Mas, bora lá então, começando a criar o nosso componente de header. Eu vou começar exportando a nossa logo aqui de dentro do Figma. Então, seleciono aqui a layer que tem o logo, venho em Export e posso exportar como SVG. Ou a gente pode vir aqui, clicar com o botão direito, Copy as SVG. Eu não copio porque é mais fácil para mim. Eu vou começar criando uma pasta chamada Assets, dentro eu vou jogar logo.svg e dou um Ctrl V aqui no que a gente copiou e pronto, nosso logo já está ali disponível. Aqui o que eu vou fazer é criar uma pasta chamada Pages, mesmo que a gente só tenha uma página na nossa aplicação, eu gosto de já deixar previamente criada uma pasta Pages, porque tem muita chance de no futuro essa aplicação ter mais rotas, mais páginas. Então, a gente já deixa meio que pré-configurado. E aqui dentro eu crio uma pasta chamada Transactions e dentro dela um arquivo index.tsx. A página Transactions vai ser essa página aqui, a página Home, digamos assim. E aí eu crio um arquivo styles.ts que vai ser a estilização dessa página e a gente vai criar também uma pasta Components aqui na raiz que vai ter os componentes. Não tem muito o que dizer. Dentro dessa pasta Components eu crio um componente Header com um arquivo index.tsx dentro e um arquivo styles.ts. E aí a gente vem aqui pra nossa página de Transactions, a gente vai simplesmente criar uma função que retorna alguma coisa, pode ser uma div por enquanto. E aqui a gente vai fazer a mesma coisa no Header, deixa eu até copiar o Header. A única diferença é que no caso do Header em si, isso aqui não vai ser uma div, vai ser uma tag Header em si. Mas como a gente está utilizando styles.components eu nem vou me preocupar em mudar aqui agora porque isso vai estar dentro dos arquivos de estilo. Aqui na nossa página de Transactions a gente vai importar aqui o nosso Header. E aqui esse div por volta pode ser div, a gente pode deixar como uma div mesmo, depois a gente muda no futuro caso a gente precise. Feito isso, salvamos isso aqui agora. Os estilos aqui da página de Transactions eu nem vou mexer ainda, isso é mais no futuro. Eu vou direto aqui para os estilos do nosso Header em si. Eu vou começar fazendo o seguinte, eu vou criar aqui um HeaderContainer. Eu sempre gosto de começar com um container por volta de tudo. Vai ser uma tag Header mesmo, do HTML. A gente vai começar colocando aqui uma background utilizando o tema. E aqui eu vou botar um gray 900, que é um cinza um pouco mais escuro do que já tem. A gente vai dar um padding de 2.5 rem no topo, 0 na lateral direita, 7.5 rem abaixo e 0 na lateral esquerda. Se eu não me engano isso aqui poderia ser reduzido a apenas 3 parâmetros. Padding, MDN, superior, horizontal, inferior. Exatamente, a gente pode fazer só assim e já vai dar certo. E aí agora eu vou criar também um HeaderContainer, que vai ser o conteúdo do Header. E por que eu não boto conteúdo direto dentro do HeaderContainer? Porque o HeaderContainer eu quero que ele ocupe a largura toda da tela do usuário. Então se o monitor do usuário for um ultra-wide, essa parte preta aqui vai ocupar sempre a largura toda. Porém o conteúdo eu quero que ele seja fixado a um máximo de largura. Vou botar aqui uns 1100, 1120, geralmente a gente não mantém muito mais do que isso. Então ele vai ficar centralizado. Então por isso que eu criei esse HeaderContainer. É ele que vai ter o conteúdo, é ele que vai estar centralizado. Vou botar um width de 100% e um max-width de 1120 pixels. Assim se a tela for menor que 1120, ela vai ter 100% da tela. Se for maior, ele limita em 1120. Aqui eu dou um margin zero-alto para centralizar e dou um padding também nas laterais para caso a tela do usuário for menor do que esse tamanho, o conteúdo não fique grudado nas laterais. Assim fica mais agradável. Vou dar um display-flex também, um justify-content-space-between e um align-item-center. Porque eu quero que o logo e o botão fiquem com espaço entre eles, um space-between, e verticalmente eles estejam alinhados ao centro. Salvo isso aqui agora. A gente vai começar a colocar os elementos aqui em tela. Então header-container, dentro header-content. E aqui eu vou ter o meu logo e eu vou ter também o nosso botão em si. Então o botão eu já posso deixar aqui previamente criado. Eu vou botar dentro dele nova transação, que é o texto que está escrito ali dentro. Não vou me preocupar em estilizar esse botão por enquanto. E aqui eu vou botar o meu logo. O logo aqui a gente vai importar. Vou botar aqui logo-image-from-assets-logo.svg E aqui eu vou colocar simplesmente uma image. No source eu boto esse logo-image. No out aqui, como é o logo, não tem necessidade de a gente escrever qualquer coisa. Eu vou deixar o out vazio, assim o leitor de tela acaba até pulando isso. Eu vou salvar isso aqui agora e vamos dar uma olhadinha como é que está ficando. Então aqui no app, faltou no lugar do H1, eu colocar a nossa transactions. Salvo isso aqui agora, volto. Beleza, já dá pra visualizar como que está ficando aqui. E já está ficando bem legal. Falta a estilização aqui do botão de nova transação. Então aqui nos estilos, eu vou começar criando aqui uma estilização para esse botão. Eu vou chamar de newTransactionButton. E a gente vai dar aqui um height de 50 pixels, um border de 0, um background prop, props-theme-green 500. A gente vai botar aqui também um color, props-theme-white, um font-weight bold. Vamos dar aqui também um padding de 0, 1.25 rem nas laterais. Border-radius de 6 pixels, um cursor pointer. E a gente vai dar aqui um hover, escurecendo um pouquinho a cor de fundo. E aqui eu vou colocar um... Aqui uma coisa legal que eu posso explicar. Vamos deixar assim por enquanto. Eu quero te explicar um negócio legal aqui que você vai ficar de cara que talvez você não sabia que acontecia. Eu vou botar o newTransactionButton aqui no lugar. A gente pode ver que já está lá a nova transação. Ficou bem certinho, né? Não é um botão difícil de configurar, por isso que ficou bem certinho. E aí, olha que legal. Se a gente colocar o transitionBackgroundColor 0.2 segundos. Se a gente colocar esse transitionBackgroundColor 0.2 segundos aqui junto com as demais estilizações do botão. Olha só, o efeito de transição acontece tanto quando eu boto o mouse por cima quanto quando eu tiro o mouse. Eu vou até botar um pouquinho mais devagar para a gente visualizar isso. Olha só, o efeito de transição acontece quando eu boto o mouse e quando eu tiro também. Quando eu boto o transition somente dentro do hover, do estado de hover aqui. Essa transição vai acontecer somente no momento que eu boto o mouse. E quando eu tiro ela não acontece. E em alguns momentos isso é até melhor. Fica até mais agradável. Então, olha só, acontece agora quando eu boto o mouse por cima e quando eu tiro, ele tira rapidinho. Então, eu vou manter assim. Eu gosto de fazer essa transição nesse efeito, mas vai de cada um. Vai de cada interface e o que a pessoa que está desenhando ali a interface prefere. Então, a gente já terminou o nosso componente de header aqui da nossa aplicação e a gente já pode partir para os demais."
  },
  {
    "id": "ce87e964-a481-48cd-a0b2-32cebfd8dd2e",
    "title": "Resetando formulário",
    "transcription": "Mais uma aula rapidinha, antes de a gente partir para o funcionamento da nossa tela, que é o seguinte, uma das coisas que a gente pode perceber é que conforme eu digito aqui os dados no meu campo, tanto de task quanto dos minutos, quando eu clico em começar, ele dá o console.log aqui embaixo, como se eu estivesse já trabalhando com esse formulário, criando o meu ciclo, claro que nada está sendo criado ainda, mas ele não reseta os campos para o valor original. E aí uma das coisas legais aqui é que o ReactHookFarm, ele devolve para a gente através do nosso UseForm aqui uma função chamada Reset, e basta eu chamar essa função Reset aqui dentro da minha função de Submit, que ele automaticamente limpa os campos para o valor original. Então, uma coisa importante aqui, o Reset funciona voltando os campos do meu formulário para os valores que eu coloquei aqui no Default Values. Se eu esquecer de colocar algum campo aqui no Default Values, por exemplo, não colocar o task com o valor vazio, ele não vai voltar o task para o valor original. Então a gente pode inclusive comentar o task aqui, se eu venho aqui, digito e dou um começar, e aumento aqui, vou botar para 30 aqui os minutos, e dou um começar, ele voltou o task. Mas ele voltou o task porque o task é um input tradicional, ele é um input nativo do HTML, eu acho que a função Reset está funcionando como, deixa eu até dar uma olhada aqui, ela está funcionando dando um Reset tradicional do HTML, mas eu não lembro exatamente em que momento eu caí e por que eu estou contando isso, que eu não tinha passado aqui o task como um valor vazio, e ele não estava Resetando, e eu perdi muito tempo. Eu acho que é quando a gente tem campos no nosso formulário que não são inputs tradicionais do HTML. Eu acho que acontece isso, mas eu posso estar errado também, então a gente vai ficar com essa dúvida no ar juntos até a gente cair nesse erro e lembrar, puto, o Diego falou um dia que acontecia isso, deve ser isso, e aí a gente vai lembrar. Então as dúvidas sempre coloca todos os campos aqui no Default Values com os valores originais deles, e aí o Reset sempre vai funcionar."
  },
  {
    "id": "98360d23-6af1-43dd-a72c-7a21da7228f2",
    "title": "Propriedades",
    "transcription": "O segundo conceito mais importante para a gente aprender aí dentro do React é o conceito de propriedades. Propriedades nada mais são do que informações que a gente pode passar para componentes. Então, o que acontece? Trazendo novamente o exemplo onde eu posso ter um feed, por exemplo, do Twitter, do Instagram, do Facebook. É muito comum eu ter vários posts, um abaixo do outro. Porém, esses posts têm informações diferentes, eles têm um conteúdo diferente. Então, o post pode ter um conteúdo diferente, uma imagem diferente, um número de likes diferente, ele pode ter um autor diferente. Porém, por mais que ele tenha um visual semelhante e faz-se justificável a criação de um componente para o post, não necessariamente todos os posts vão ser iguais porque eles têm informações diferentes. E assim como no HTML, onde a gente tem, por exemplo, a tag image. E essa tag image serve para a gente mostrar imagens em tela, porém cada imagem é diferente. Cada imagem tem um endereço diferente, por isso que eu passo para ela um atributo source. Essa imagem aqui vai ter essa URL como source. Essa outra imagem vai ter outra URL. E assim a gente pode fazer com componentes também. Então, aqui no nosso app, por exemplo, eu posso passar, assim como eu passo para tags HTML, atributos. Só que atributos, quando a gente coloca num contexto de componente do React, a gente chama de propriedades. Então, o post, por exemplo, ele pode ter um autor, que eu vou botar Diego Fernandes, e ele pode ter um conteúdo aqui. E aqui eu vou botar, por exemplo, o VS Code, se você der um lorem aqui, dá um ctrl espaço. Deixa eu tentar botar aqui embaixo. Olha só, ele cria para a gente um texto bem grande. Eu vou colocar esse texto e vou copiar aqui dentro. Eu vou deixar apenas um post em tela, aqui, por enquanto. E aí uma das coisas que eu gosto de fazer é manter o meu código sempre o máximo indentado para a esquerda. Então aqui, quando ele já começa a ficar muito grande a linha, eu gosto de separar cada propriedade em uma linha adicional. Então eu dou um enter aqui, antes de cada propriedade, dou um tab, e aí eu coloco cada propriedade aqui em uma linha. E aí lá no final, esse barra e sinal de maior aqui, eu boto na próxima linha, porém na mesma indentação da abertura aqui do componente. Então aqui abre, aqui fecha, e cada propriedade fica em uma linha. Vou salvar isso aqui agora, é claro que isso não vai ter resultado visual nenhum em tela, porque aqui no nosso post o conteúdo continua sendo apenas post. Então se eu volto lá no Google Chrome, a gente vai ver que só tem post sendo exibido. Porém agora, como eu passei propriedades author e propriedade content aqui para dentro do nosso post, eu posso acessar essas propriedades como os parâmetros da minha função. Então eu vou ter um único parâmetro chamado props, e dentro dessas props aqui eu vou receber um objeto, as minhas props vai ser um objeto, onde eu tenho o author e eu tenho o nosso content, que foram as informações enviadas. Inclusive se eu der aqui um console.log antes do return nas nossas propriedades e salvar, abre aqui um especial elemento, venho em console, dou um F5 aqui, a gente vai ver aqui author e content sendo exibido dentro do console.log como um objeto. Então agora para a gente acessar essas informações e mostrar, por exemplo, o conteúdo do post dentro desse parágrafo, eu posso vir aqui no lugar de post e escrever props.contents talvez. Se eu salvar isso aqui e voltar, não deu certo. Ele aparece o texto props.contents, mas não é isso. Eu quero o valor da variável props.contents. E para isso o que acontece? No React quando a gente quer exibir um valor de uma variável JavaScript dentro do HTML, dentro de uma tag HTML, eu preciso colocar chaves por volta. Então eu seleciono aqui, coloco chaves, e agora sim, props.contents, e se eu salvar, já está mostrando lá o nosso conteúdo, que é aquele lorem y, aquele texto aleatório. E aí aqui eu posso inclusive fazer o seguinte, posso colocar o autor como um negrito, talvez, aqui no topo do post. Então eu coloco aqui strong, e aqui eu coloco props.author. Esse código aqui começa a ficar muito bagunçado quando a gente tem mais de uma tag HTML. E aí nesses casos, o que eu faço? Sempre que o meu return tem mais de uma tag HTML, ele tem mais linhas, eu coloco parênteses aqui por volta das linhas, e aqui eu dou um enter para cada tag ficar na sua linha certinho. E aqui está vendo que ele está dando esse erro? A gente já viu porque o React acusa esse erro. Eu não posso ter um elemento abaixo do outro sem ter um elemento por volta. Então aqui vamos colocar uma div por volta por enquanto, e aí ele já para esse erro. Salvo aqui agora, e olha só, a gente tem agora aparecendo o Diego Fernandes e o conteúdo do nosso post. E aí agora, veja que aqui dentro do nosso app, eu posso mostrar um segundo post, onde o autor seja, por exemplo, Gabriel Buzi, e o nosso conteúdo seja, por exemplo, um novo post muito legal. Salvo isso aqui agora, a gente vai ver que o post continua existindo, certo? E o outro post continua existindo, porém eles têm propriedades diferentes. Eles têm autores diferentes, conteúdos diferentes, apesar deles seguirem a mesma estrutura. Ou seja, com componentes, a gente consegue reaproveitar HTML, consegue reaproveitar a estilização, consegue reaproveitar inclusive funcionamento com o JavaScript, que a gente vai ver ainda mais ao longo das aulas. Porém, a gente consegue ter diferenciação entre cada exibição desse componente em tela através das propriedades. Então, as propriedades alteram elementos visuais de um componente sem a gente precisar perder a flexibilidade de abstrair um componente em outro arquivo para reaproveitar elementos que são comuns entre esse componente. Então, geralmente estilização, que é muito comum a gente fazer uma separação, porque eu tenho vários elementos em tela que são iguais visualmente, só muda um texto, eu crio um componente. Sempre que eu precisar reaproveitar algum elemento que visualmente é muito semelhante, a criação de componentes é super legal a gente fazer nesse caso."
  },
  {
    "id": "89daa8fb-4087-4a77-9240-b318987ad984",
    "title": "Botões de entrada e saída",
    "transcription": "O que a gente vai fazer nessa aula é basicamente o visual aqui desses botões entrada e saída. A gente não vai se preocupar, por enquanto, na parte de como isso se integra ao formulário, mas pelo menos o visual aqui a gente vai fazer. Então, vamos lá. Aqui no nosso new transaction modal a gente vai começar criando aqui um container, vou chamar de transaction type, que é o tipo de transação. Isso aqui na verdade é só um componente estilizado, então deixa eu criar ele aqui dentro, tanto faz. Export, const, transaction type. O que eu fiz de errado. Meu cachorro tá latindo pra caramba. Transaction type, isso aqui pode ser uma div, e esse transaction type aqui eu vou botar nele um display grid. É um item do lado do outro, mas grid, template columns, repeat, 2, 1fr, gap 1 rem, margin top 0.5 rem, pra ele distanciar um pouquinho mais do input, acima. E aí a gente vai ter um outro componente aqui, que é o transaction type button, que esse sim vai ser cada um daqueles botões que a gente tem ali dentro. E aqui ele vai ter uma série de CSS padrão, que eu vou colocar aqui dentro, mas depois a gente vai ter uma variação entre um botão e outro, porque o estado de selecionado deles é diferente. Um fica com fundo verde, outro com fundo vermelho. Então eu vou ter que ter uma variante assim, como a gente tinha feito lá pra esse card aqui, ou pro preço, né, pro price highlight aqui que a gente tinha feito, não sei lá, tanto faz. E aqui eu vou botar então um props.theme.gray700, que vai ser a cor padrão do botão, do fundo, quando ele não estiver com selecionado. Display flex, align items center, justify content center, gap 0.5 rem, border radius, eita, o que eu fiz aqui? border radius, 6 pixels, cursor pointer, border 0, e aqui eu vou dar um color no botão de props.theme.gray100 aqui. Deixa eu ver se é o gray100 mesmo que a gente usa aqui, é o 2929, gray700, não, pô, eu quero texto, ele tá botando background, pô, por que que eu não consigo selecionar o texto, cara, não consigo selecionar o texto, agora foi, não foi, não tô conseguindo selecionar só o texto, ah, é porque ele tá selecionando de trás do countdown, olha só, ele não tá selecionando o do, deixa eu ver se eu consigo pegar por aqui, talvez, é, olha só, ele tá selecionando lá atrás, tá vendo, que estranho, figma, tá meio bugado, essa aqui é a desktop nova transação, deixa eu ver se eu consigo selecionar talvez por aqui, modal, aqui ó, modal, container, aí dentro de options, botão, entrada, ó, C4, C4, C4, C4, C4, C4, C4, C4, C4, C4, C4, C4, C4, C4, C4, C4, C4, C4, C4, C4, C4, C4, C4, C4, C4, C4, C4, C4, C4, C4, C4, C4, C4, C4, C4, C4, C4, C4, C4, C4, C4, C4, C4, C4, C4, C4, C4, C4, C4, C4, C4, C4, C4, C4, C4, C4, C4, C4, C4, C4, C4, C4, C4, C4, C4, C4, C4, C4, C4, C4, C4, C C4, C4, C4, C4, C4, C4, C4, C4, C4, C4, C4, C4, C4, C4, C4, C4, C4, C4, C4, C4, C4, C4, C4, C4, C4, C4, C4, C4, C4, C4, C4, C4, C4 C4, C4, C4, C4, C4, C4, C4, C4, C4, C4, C4, C4, C4, C4, C4, C4 C4, C4, C4, C4, C4, C4, C4, C4, C4, C4, C4, C4, C4, C4, C4, C4, C4, C4, C4, C4, C4, C4, C4, C4, C4, C4, C4, C4, C4, C4, C4, C4, C4, C4, C4, C4, C4, C4, C4, C4, C4, C4, C4, C4, C4, C4, C4, C4, C4, C4, C4, C4, C4, C4 Salvo isso aqui agora Preciso passar agora então Variant, esse aqui vai ser o Income E esse aqui Vai ser o Outcome Aqui eu vou chamar de Variant, mas você pode chamar do que você preferir Poderia ser Type Mas só que como isso aqui é um botão, Type já não daria pra ser utilizado Porque Type é uma propriedade nativa Do button no HTML Teria que ser, sei lá, Color Alguma coisa assim Tá Esse SVG aqui não pegou a cor Vamos entender o porquê aqui Ah, eu botei Gray Tem que ser Green E aqui eu vou Testar Então a entrada, a saída, já está os ícones estilizados aqui E pronto A gente já fez a parte do CSS Claro, o funcionamento ainda não está funcionando A gente não consegue selecionar Mas isso a gente vai fazer depois"
  },
  {
    "id": "e118c41a-51ba-4851-bb62-4d1e524f00d5",
    "title": "Setup do projeto",
    "transcription": "Bora lá então para a gente dar início a mais um projeto aqui dentro do Ignite. E o projeto que a gente vai estar desenvolvendo então é esse DTMoney. A ideia desse projeto é a gente exercitar bastante a parte de trabalhar com APIs. Então vamos lá. Antes de mais nada eu já vou abrir aqui o meu terminal e vou começar criando o meu projeto. E para isso, claro, a gente vai estar utilizando o VIT. Eu vou utilizar o npm create vitlatest e a gente já vai dar um nome para esse projeto. Eu vou chamar ele de 03DTMoney. E aqui eu seleciono React, React TypeScript, claro. A gente vai abrir o projeto e instalar as dependências. A instalação das dependências aqui vai ser bem rapidinho, até porque eu já tenho as dependências do React em cache. Então, show de bola, já deu certinho aqui, 8 segundos. Vou abrir agora no VSCode e a gente vai já dar uma limpada aqui na estrutura do nosso projeto. Vou começar removendo aqui assets, css. Aqui dentro do main a gente vai remover o css. Eu vou usar um named export aqui, então vou tirar o export default, que eu não gosto de utilizar. Vou usar apenas export function, dessa forma. Tiro o css aqui também, tudo isso aqui em cima, esse estado. A gente vai trocar isso aqui apenas por um hello world, salvo. E aqui eu troco a importação. Opa, o que eu fiz aqui? Meu Deus do céu, as vezes eu me confundo aqui. Mas troco aqui a importação do app para um named import também. Feito isso, eu posso salvar e a gente já pode rodar o nosso projeto para ver se está tudo certo. Então, beleza, já rodou aqui na porta 5173, que é a porta que o Vit está utilizando agora atualmente. Beleza, tem umas coisas abertas aqui, deixa eu fechar essas outras coisas aqui que não são tão importantes. E aqui a gente já vai começar a ver o que a gente precisa para começar a instalar. Então, a primeira coisa que a gente pode ver que a gente vai precisar nesse projeto é o style.components em si, que é o que a gente já utilizou anteriormente e vai utilizar de novo nesse projeto. Para isso, eu vou abrir aqui um segundo terminal e a gente vai começar instalando o style.components. E eu vou instalar também a tipagem do style.components, que ele não traz junto. E com isso, o nosso projeto agora já pode ter o style.components em si. Aqui dentro da pasta source, agora eu vou começar criando uma pasta styles e dentro dessa pasta styles, eu vou criar um arquivo global.ts, onde vai conter todos os estilos globais da nossa aplicação, os estilos que a gente vai aplicar, por exemplo, a tag body, aos textos, essas coisas assim. E dentro da pasta themes, eu vou criar um único tema por enquanto, que é o tema default. E aqui eu vou deixar para você, nessa aula, um download das cores que a gente vai estar utilizando dentro desse projeto, que não muda das cores que a gente já vem utilizando em todos os outros projetos do Ignite. A gente sempre vai seguir esse design system de cores, mas aqui no layout do Figma, que você também tem acesso, dentro dos assets você consegue ver todas as cores que a gente vai estar utilizando nesse projeto. Mas, como não é legal a gente ficar copiando uma por uma, eu vou já te entregar esse objeto com todas as cores aqui e a gente vai configurar agora para conseguir utilizar o style.components na nossa aplicação. Para isso, o que eu vou fazer aqui no meu app, onde vai ser o arquivo root da nossa aplicação, por volta de tudo, eu vou utilizar o theme provider, que é o provider de contexto do style.components, a gente já falou sobre isso antes, e ele vai prover o tema que a gente vai estar utilizando ao longo de toda a aplicação, as cores dentro dos nossos componentes. E aí dentro, aqui do global, eu vou estar configurando o nosso global style, igual a createGlobalStyle, e aqui dentro a gente vai passar algumas estilizações globais. Então, para todos os elementos, a gente vai dar um margin zero, padding zero, box size em border box. Eu vou também estilizar o focus padrão, então para o padrão Chrome coloca um focus azul, se não me engano, um outline azul, eu vou tirar o outline e vou setar o focus utilizando box shadow, zero x, zero y, zero blur, dois pixels de spread, e aqui eu vou utilizar a cor green 500. E aqui a gente pode ver que conforme a gente foi utilizar essa cor, ele não conseguiu entender que o green 500 existe dentro do nosso tema. Isso porque quando a gente está utilizando o style.components com o TypeScript, a gente já viu isso antes, eu preciso criar aqui um arquivo de tipagem, vou chamar ele de style.d.ts, e nesse arquivo a gente vai basicamente importar o style.components para a gente meio que estender a tipagem que o style.components já tem, e não sobrescrever ela, então por isso que a gente precisa importar ele ali no começo. Agora eu vou importar o nosso default theme, eu nem preciso importar porque ele vai importar automaticamente, eu vou criar aqui um theme type, é igual a type of default theme, e ele já fez a importação aqui para a gente. E agora eu faço um declare module, style.components, e dentro eu dou export interface, default theme, extend, theme type, e pronto, a gente já está pronto para continuar. Agora se eu volto aqui, a gente já pode ver que o erro parou, e uma dica legal é que no arquivo que eu deixei aqui para você copiar do tema, eu adicionei uma coisinha a mais que a gente não tinha no outro arquivo dos outros projetos, que é esse s-const aqui embaixo, e eu já vou te explicar o porquê disso. Olha só, tirando esse s-const, quando a gente vai utilizar as cores aqui do nosso tema, por exemplo, eu dou um ctrl espaço, ele entende todas as cores, a gente pode inclusive ver que tem todas as cores, inclusive a green 500 aqui. Porém, ele mostra que a cor green 500 é uma string. Sim, porque se a gente for ver aqui no tema, sim, a cor green 500, o conteúdo dela é uma string. Mas quando a gente coloca um s-const, a gente está falando que essa string, que é o valor da green 500 e de todas as outras cores, ela nunca vai mudar. Isso é muito bom porque pro TypeScript agora, quando eu salvo isso aqui e volto para aplicar, a gente vai ver que quando eu digito green 500, ele não mostra mais a string e sim mostra o hexadecimal da cor. Assim fica mais fácil quando eu estou criando o layout, eu já sei qual cor representa qual propriedade aqui dentro do nosso tema. Então assim vai ficar mais fácil para a gente estar estilizando aqui a nossa aplicação. E agora continuando aqui que a gente já fez o focus da nossa aplicação, que ele não deveria estar aqui, e sim fora do nosso asterisco, a gente vai também pegar o body da nossa aplicação, a gente vai botar a cor grey 800 aqui no fundo, a gente vai estilizar a cor do texto também utilizando a grey 100 e aqui eu vou utilizar o webkit font-smoothing anti-aliased, que é para o Chrome deixar a fonte mais sharp. Aqui eu vou pegar também o body, o input, o text-area e o button da nossa aplicação e eu vou aplicar a font-family roboto. E aqui eu consigo aplicar a font-family, a espessura e o tamanho da fonte tudo numa porrada só, basta eu seguir a seguinte ordem, primeiro a gente coloca a espessura da fonte, depois o tamanho e por fim qual a fonte a gente vai estar utilizando, no caso a roboto com a sans-serif. Aqui eu posso salvar e agora a gente vai lá no Google Fonts procurar pela fonte roboto que a gente vai estar utilizando aqui no nosso projeto e eu vou estar utilizando a fonte roboto em dois tamanhos, no tamanho 400 e no tamanho 700 aqui. E agora é só eu vir aqui do lado, copiar esse link, a gente vem no arquivo index.html, colamos o link aqui dentro, como eu estou no React eu gosto sempre de colocar aqui a barra no final e esses dois primeiros preconnect eu vou mover eles para o topo apenas depois do meta charset, para eles executarem o mais rápido possível. Como eu não tenho favicon eu posso tirar esse link hell icon aqui e o nome do projeto a gente pode trocar para dtmoney aqui dentro. Salvo isso aqui agora, a nossa fonte já vai começar a funcionar, basta eu vir aqui no app e configurar para importar o nosso global style. Voltando agora aqui no nosso projeto em si, seu dark 5, a gente já pode ver que ele aplicou a fonte roboto, o fundo agora já está cinza escuro, o texto está um cinza clarinho e o title da página já está dtmoney. Então a gente já está pronto para continuar que o style do componente já está setado aqui na nossa aplicação."
  },
  {
    "id": "3c985571-bdb4-48c7-bede-e18fc1853467",
    "title": "Separando Action Types",
    "transcription": "A primeira coisa que a gente vai fazer aqui para melhorar o nosso código, e a gente vai melhorando aos poucos para ser algo contínuo, digamos assim, é pegar essa função que está aqui dentro do useReducer, está vendo? O conteúdo dessa função aqui, que vem até aqui embaixo, acho. Deixa eu tirar daqui para ver. Isso, isso mesmo. E a gente vai começar colocando ela em outro arquivo. Então, eu vou começar aqui na minha pasta source, vou criar uma pasta chamada reducers, e dentro aqui eu vou criar um... pode ser, por enquanto eu vou chamar de cycles.ts mesmo, tá? O nome do arquivo. Eu não vou me preocupar com isso tanto, porque a gente ainda vai modificar isso. Mas, aqui dentro eu vou criar uma função, eu vou exportar ela daqui de dentro, o nome dela vai ser cyclesReducer, e aqui eu vou dar um Ctrl-V naquele código que a gente tinha copiado. Aqui vai dar alguns errinhos, porque lá eu estava usando arrow function, aqui eu estou usando uma function tradicional. Então, eu vou tirar essa flechinha aqui do final. E aqui também está dando alguns erros de tipagem. Então, eu vou pegar o cycles.state e vou mover aqui para dentro. Vou pegar aqui a nossa interface do cycle. Ela precisa ser usada em ambos, né? Então, nesse caso, eu vou continuar movendo lá para dentro. E aí aqui, eu só importo ela lá de dentro. Ele não conseguiu importar automaticamente. Então, import ./.reducers/.cycles. Eu importo aqui o meu cycle. Ah, ele não importou porque eu não exportei, né? Aí está difícil, Diego. E aqui, dentro do meu useReducer, eu vou usar a função que eu exportei lá de dentro, chamada cyclesReducer. Então, eu salvo. Pronto. A gente vai ver que o código já deu uma reduzida, e ele deveria continuar funcional. Então, 20 minutos, começar. Beleza, está tudo funcionando. E agora, a gente vai melhorar ainda mais o nosso código aqui. Uma das coisas que a gente vai ver aqui é que a gente colocou, hoje, hardcoded, digamos assim, quais são os tipos de actions que a gente pode receber aqui dentro. Então, addNewCycle, interruptCurrentCycle, markCurrentCycleAsFinished. Qual é o problema disso? Lá no meu cycles context, eu tenho algumas funções que disparam essas actions. Dispatch, eu coloco o tipo aqui dentro. E eu tenho essa string aqui, markCurrentCycleAsFinished, duplicada. Tanto aqui, ou seja, todos os lugares que eu chamar o markCurrentCycleAsFinished, eu vou escrever esse texto, vou ter que escrever esse texto. E aqui dentro, eu também tenho esse texto. Se um dia eu quiser mudar, eu vou ter que mudar em todos os lugares ao mesmo tempo. Mas esse não é bem o problema. Porque isso, com o Ctrl-F no VSCode, facilmente você resolveria. O problema é, quando eu vou em algum novo arquivo utilizar a função dispatch, e eu quero usar algum desses types, eu vou ter que ir lá no meu reducer para lembrar como que isso está escrito. E dificilmente você vai lembrar ou vai escrever do zero. Você vai ter que vir aqui, dar um Ctrl-C, volta lá e dá um Ctrl-V. Então seria bom a gente encontrar uma forma de a gente abstrair, digamos assim, para eu não precisar ficar fazendo isso do zero toda vez. E eu vou te mostrar como que eu faço isso. Aqui dentro do meu cycles, aqui em cima, eu vou começar criando, primeiramente, um enum do TypeScript. E eu vou chamar de ActionTypes. E aqui dentro eu vou, simplesmente, definir quais que vão ser todas as actions que eu tenho. Então eu tenho uma action AddNewCycle. E aqui eu vou botar ela com o valor AddNewCycle no final. Porque o enum no TypeScript, se eu não faço isso aqui, se eu faço só isso aqui, ele vai setar o valor desse carinha aqui como zero. E o próximo como um, dois, e aí quando eu usar essa variável, no meu código vai ficar tipo, ah, o Diego chamou a ação zero. Mas a ação zero não me diz nada. Eu quero que no código também fique o nome AddNewCycle. Então a gente vai repetir sempre. É chatinho, mas tudo bem. Daria para fazer uma função do TypeScript para auxiliar isso, mas tudo bem. E agora que eu tenho esse ActionTypes, aqui nos cases eu vou substituir por ActionTypes.AddNewCycle. Aqui por InterruptCurrentCycle. E aqui embaixo por MarkCurrentCycleAsFinished. E agora aqui eu vou trocar também por ActionTypes.MarkCurrentCycleAsFinished. Aqui embaixo ActionTypes.AddNewCycle. E aqui embaixo ActionTypes.InterruptCurrentCycle. Salvo aqui agora. E agora sim, a gente tem, digamos assim, um enum, um dicionário, que ele diz para a gente exatamente quais são todas as ações que a gente tem. E aí se em algum lugar do código a gente for realizar um dispatch, e a gente não lembrar dos types, basta a gente escrever ActionTypes, dar um CTRL espaço, e a gente vai lembrar de todos os types aqui que a gente pode disparar. Se a gente for ver o TypeScript, ele fica reclamando. Isso aqui é um bug do ESLint. Ele fica reclamando que essas variáveis não foram usadas, mesmo a gente sabendo que elas foram usadas. Isso aqui foi um bug que eu fiquei olhando bastante no Google. E por enquanto, para a gente não se preocupar com isso, eu vou desabilitar essa regra no ESLint. Então aqui no meu ESLint.json, eu vou definir aqui uma configuração Rules, NoUnusedVars, e eu vou botar ela como off, para ela parar de ficar acusando o erro. E depois eu vou olhar isso aí com um pouquinho mais de calma, mas isso aí com certeza é um bug do ESLint, na integração com o TypeScript. Então talvez quando você estiver vendo essa aula, nem vai mais estar dando esse bug, porque o que eu vi lá no GitHub, é que é um bug e o pessoal do TypeScript e ESLint lá falando, vamos resolver isso, mas vai saber quando. Então se o seu estiver dando problema, vem aqui e desabilita, mas é algo que vai resolver com o tempo, por isso que eu nem me preocupei tanto em a gente encontrar uma super solução para isso. E aí show de bola! A gente já separou os nossos Action Types, mas a gente ainda pode melhorar ainda mais esse código. Bora lá!"
  },
  {
    "id": "a6526085-3a84-4987-a253-d46b2e92c03d",
    "title": "Convertendo para contexto",
    "transcription": "Agora que a gente já sabe o que são contextos no React, uma coisa legal que você pode perceber é que, acessando aqui o app da nossa aplicação, tá vendo que aqui dentro a gente tem esse ThemeProvider e esse BrowserHalter aqui? Adivinha? Isso aqui são dois providers de contexto, assim como a gente criou antes um provider de contexto. Esse aqui, por exemplo, ele tá colocando todas aquelas informações do tema da nossa aplicação, todas as nossas cores, disponível para todos os componentes que estão dentro dele. No caso, como ele tá por volta de toda a aplicação, é por isso que os nossos componentes estilizados, aqui os nossos StyledComponents, tem acesso às propriedades de tema, por causa daquele contexto ali. Se isso aqui não tivesse aqui, a nossa aplicação não ia conseguir ter acesso ao tema. E mesma coisa, as nossas rotas não conseguiriam ter acesso a algumas informações importantes do contexto aqui, de roteamento, caso esse carinha aqui não tivesse por volta. Então depois que a gente aprende, a gente vai descobrindo o porquê que a gente fez algumas coisas. E agora o nosso grande desafio é mover boa parte da lógica da nossa aplicação que tá aqui na ROM para utilizar contexto. Então o que nós vamos fazer? Nós vamos começar criando aqui na ROM mesmo um CyclesContext é igual a CreateContext, e aqui eu tenho que importar do React, eu já importei. E a gente vai iniciar ele como um objeto vazio, e aqui para a gente aprimorar, lembra que antes a gente tinha feito sn aqui né, a gente não vai mais fazer isso porque não é legal usar n do TypeScript, o que a gente vai fazer? Nós vamos criar aqui uma interface chamada CyclesContextData ou Type, tanto faz, o nome que a gente vai dar, e aqui dentro a gente vai falar quais são as informações que nós vamos armazenar dentro do contexto. Eu não preciso ficar já pensando em tudo o que eu vou ter, eu posso ir adicionando aos poucos conforme eu vou necessitando. Então uma das coisas que eu posso perceber já de antemão, acessando aqui os dois componentes, tanto o Countdown quanto o NewCycleForm, é que ambos precisam do ActiveCycle. Então o ActiveCycle é necessitado aqui no NewCycleForm, e no Countdown também ele é necessitado aqui, ActiveCycle aqui, ActiveCycle aqui, ActiveCycle e por aí vai. Então o que nós vamos fazer? Aqui deixa eu até tirar essas propriedades, a gente não vai mais usar isso aqui, isso aqui também não, show, a gente volta aqui na ROM, e agora eu vou falar que dentro do nosso contexto vai existir uma propriedade chamada ActiveCycle, e essa propriedade aqui ela vai ser um Cycle, que eu tenho aqui em cima dessa interface, ou Undefined, por que ou Undefined? Porque quando eu não tiver nenhum ciclo ativo no momento, quando o usuário não iniciou nenhum ciclo, essa variável aqui ela fica como Undefined, tá vendo? Por quê? Porque ele não consegue encontrar nenhum ciclo ativo, ou seja, se eu não tenho um ciclo ativo, Undefined, então a gente vai setar dessa forma, fechou? E agora, o que a gente vai fazer aqui? Nesse objeto que eu tenho aqui, eu vou meio que, aquela mesma sintaxe que eu tinha feito do S, N, eu vou fazer o S, porém nessa tipagem que eu tenho aqui em cima, o que isso aqui vai fazer? Se eu não coloco isso aqui, quando eu passo o mouse em cima do meu CyclesContext, tá vendo que ele entende que isso aqui é um contexto vazio? E qual que é o pior problema desse contexto vazio? O pior problema é o seguinte, lá embaixo, quando eu for colocar o nosso Provider, então aqui eu posso botar ele por volta dos componentes que precisam acessar, dessa forma assim, CyclesContext. Provider, né? Então como eu sei que os dois componentes que precisam acessar informações desse contexto é o NewCycleForm e o Countdown, eu posso fazer dessa forma aqui, ou eu posso pegar isso aqui e jogar por fora aqui da Home inteira, também não é um problema, mas vamos começar aqui dessa forma. Então qual que é o problema da gente não fazer aquele S que eu tinha feito aqui em cima? Lembra? Quando eu for colocar aqui o nosso Value, e vir aqui e der um Ctrl Espaço, isso aqui tirando o que o Tab9, que é a minha extensão de inteligência artificial e algumas coisas que o VSCode coloca aqui, nada a ver com nada, eu não tenho uma sugestão, uma inteligência me falando o que eu tenho que incluir dentro desse contexto. Quando eu faço isso aqui, e eu volto aqui pra baixo e dou um Ctrl Espaço, olha só, ele já me instruiu a adicionar o ActiveCycle aqui dentro. E aí eu só clico e pronto, ele já vai parar de dar erro e o nosso contexto já está funcionando. Aqui no Countdown agora eu vou remover essas propriedades, a gente não vai mais ficar usando propriedades pra fazer compartilhamento de informações. E agora, pro nosso Countdown conseguir acessar o nosso contexto, eu preciso exportar esse contexto aqui de dentro, senão não dá pra acessar. Inclusive mais pra frente a gente vai até colocar isso aqui em outro arquivo, pra ficar mais fácil, mais organizado, mas por enquanto pode ficar aqui. A gente vai lá pro nosso Countdown agora, e a gente vai fazer o seguinte, const, aqui a gente vai usar o UseContext, lembra? E dentro a gente vai passar o nosso CyclesContext. E aqui de dentro, se eu dou um Ctrl Espaço, veja que ele já fornece o ActiveCycle aqui dentro. Novamente, se eu não tivesse isso aqui, veja que dando Ctrl Espaço aqui, não vem nada. Então é super importante usar o TypeScript ao nosso favor pra facilitar a gente na hora de escrever o código. Agora eu já tenho acesso ao ActiveCycle e assim eu já consigo fazer mais partes do meu código funcionarem. Então o meu código já começa a ficar mais claro, começa a ter menos erros, e aí a gente vai ver que tem mais algumas coisas aqui que eu preciso dentro desse meu componente que o meu contexto ainda não passa. Então a gente vai começar a adicionar agora mais informações aqui no contexto em si. Vamos lá. Eu posso adicionar também aqui o nosso ActiveCycleId, ele é uma String ou Nulo, certo? Aqui embaixo, mesma coisa. E aí a gente vai pegando e vai adicionando lá embaixo. Vem aqui e vamos adicionando dentro aqui do nosso value. E aí aqui dentro eu também já posso pegar o ActiveCycleId. Fechou? Show! Que mais informações que eu preciso? Aqui dentro a gente tem esse Minutes e esse Seconds aqui embaixo. Vamos encontrar essa variável aqui, a gente tem Minutes e Seconds, elas necessitam dessa variável Minutes e Seconds aqui, essas aqui, dessa aqui, e essa aqui ela depende da variável ActiveCycle, da TotalSeconds e da AmountSecondsPassed, que são tudo variáveis que eu já tenho aqui, ActiveCycle, AmountSecondsPassed e TotalSeconds. Então eu posso copiar tudo isso aqui, inclusive esse UseEffect, lá pra dentro do nosso cantão. Então aqui, posso botar aqui embaixo todas essas variáveis e aí aqui embaixo já para de dar erro. Beleza, a gente começa a ver que a gente está conseguindo extrair partes do código e o contexto ajuda muito a gente a não precisar ficar se incomodando na forma que a gente vai compartilhar as informações entre os componentes. Show! Tá faltando aqui agora essa função SetCycles aqui. Então ela não é definida porque essa função SetCycles, ela está aqui em cima. E aqui eu vou te dar uma dica super importante. Eu particularmente, eu não gosto de enviar a função SetCycles inteira dentro do contexto aqui. E eu vou explicar o porquê que eu não gosto. Se a gente vai enviar a função SetCycles inteira pra dentro do contexto, a gente vai ter que adicionar a tipagem dela do Typescript. E a tipagem dessa função SetCycles, olha só, quando a gente passa o mouse por cima, ela é um React.dispatch e aí com o generic React.setStateAction e aí novamente um generic... Olha, isso aqui ficaria React.dispatch React.setStateActionCycle ficaria mais ou menos isso aqui. E pra mim isso aqui é muito estranho, é muito feio. Nesses casos, ao invés de enviar a função SetCycles inteira, o que eu gosto de fazer? O que essa função aqui no fim das contas está fazendo? Ela está marcando um dos ciclos como finished, como finalizado. Então o que eu gosto de fazer é o seguinte, eu crio uma nova função, então aqui a gente dá um nome, por exemplo, markCycleAsFinished, então eu quero marcar um ciclo como finalizado e aí eu recebo o id do ciclo que eu quero marcar como finalizado e aqui dentro eu copio esse código aqui, deixo comentado aqui só pra não esquecer que ele está aqui, jogo aqui dentro e eu só troco aqui, ou melhor, eu nem preciso receber o id, porque ele usa o id do ciclo ativo. Ah, mais fácil ainda, então eu venho aqui, markCurrentCycleAsFinished. Então eu quero marcar o ciclo atual como finalizado, mais fácil ainda, salvo, já parou de dar erro, e agora eu envio essa função aqui pelo contexto, então agora fica muito mais fácil, porque olha só, eu falo que isso aqui é uma função e não tem retorno, não recebe nem parâmetros e não tem retorno nenhum, simples, e agora eu envio ela aqui pelo contexto, jogo ela aqui dentro do nosso contexto, e agora lá no meu countdown, olha só que interessante, pego a função e chamo ela aqui, cara, delicinha, isso aqui é muito bom e no começo é totalmente comum dar uns bugs no cérebro, porque você começa a ter informação que está vindo de um lugar, está indo para outro lugar, mas isso com o tempo vai ficando mais claro, e por isso que é importante fazer as coisas com calma, e se alguma coisa que eu fiz aqui talvez foi rápida demais, eu estou tentando ir mais devagar, mas se alguma coisa foi rápida demais, volta, assiste de novo, entende, né? Olha só que interessante, essa função aqui, markCurrentCycleAsFinished, ela foi definida no componente Home, porque ela usa da função setCycles, que só existe dentro do componente Home, e aí eu enviei essa função dentro do contexto, assim todos os componentes que estão dentro desse contexto tem acesso a ela, e quando o componente countdown chama essa função, ele está chamando, na verdade, a função que está aqui na Home, que vai alterar o nosso estado de ciclos, então isso é super importante entender, né, essa lógica. Show, a gente finalizou o componente de countdown, deixa eu ver aqui, ele está tendo um errinho aqui embaixo, React Hooks useEffect has a missing dependence, markCurrentCycleAsFinished, como a gente está usando mais uma função aqui dentro, no useEffect, quando a gente usa efLint, meio que ele força a gente a toda variável e função que a gente usa dentro do useEffect, colocar como uma dependência, tá, isso é meio que um padrão, então a gente coloca aqui, não tem problema nenhum, fechou, o nosso countdown já está funcional, sem problemas nenhum, a gente pode salvar, e a gente vai ver que ele já está sem problemas nenhum funcionando, e agora a gente tem a parte aqui do formulário, tá, a parte do formulário eu vou deixar comentada, por enquanto, a parte de criar um novo ciclo, vou comentar esse código aqui também, comentar esse código aqui também, e esse form aqui ó, eu vou comentar o nosso onSubmit, e aqui como eu tinha essa variável isSubmitDisabled, que ela desabilita ou não o botão aqui embaixo, eu vou comentar essa parte aqui também, por que? Porque eu quero ver se pelo menos o countdown já está sendo exibido em tela sem nenhum erro, e daí a gente parte para o newCycleForm, vou até comentar o newCycleForm aqui também, porque eu não quero ele sendo exibido em tela, então salvo, volto no Chrome, beleza, nosso countdown está aqui, não tem erro nenhum, e agora, claro, falta a gente também converter aqui o nosso newCycleForm para contexto, porque ele também precisa do ActiveCycle, aqui no nosso formulário a gente vai ter que mexer em algumas coisinhas também, então vamos lá."
  },
  {
    "id": "68a1b4a1-256d-4d9f-97a8-b56a5c034855",
    "title": "Marcando ciclo como finalizado",
    "transcription": "O que a gente vai fazer nessa aula é a última ação que a gente não fez aqui, de marcar o ciclo como finalizado. Então até agora a gente já está tratando quando eu quero adicionar um novo ciclo, quando eu quero interromper o ciclo atual. E agora, quando a action type for markCurrentCycleAsFinished, eu vou fazer algo muito parecido com interrupt, por isso eu vou até copiar e botar aqui dentro. Porém o código aqui é um pouquinho diferente, na verdade ao invés de colocar uma informação ali interrupted, eu vou botar o finishedDate. Então aqui no markCurrentCycleAsFinished, ao invés de interruptedDate, eu vou trocar o nosso finishedDate para data atual. Então eu salvo aqui agora, posso tirar esse comentário, aqui embaixo posso tirar esse também porque a gente não vai mais utilizar, e o resto vai tudo funcionar normalmente. Beleza, não tem mais nada para alterar aqui, vamos ver se tem alguma importação para remover. E aí, aproveitando que essa aula aqui seria muito curtinha, uma coisa que você pode estar vendo aqui é que tem muito if, um if depois do outro. E se você concordar comigo, quando uma action, o type dela for addNewCycle, ela nunca vai ser esses outros tipos aqui. Então aqui quando a gente está seguindo vários ifs, a gente pode facilmente trocar isso aqui para um switch. Então switch action type, e agora o código vai ficar mais legal aqui. Então case addNewCycle, a gente vai ter um case interruptCurrentCycle e um case markCurrentCycleAsFinished. E eu vou ter um default também aqui no final de tudo, caso não caia em nenhuma dessas actions aqui, que é esse returnState aqui embaixo. A gente vai colocar ele como o default aqui. E agora eu vou pegar o código que está dentro de cada if e vou mover aqui para baixo do case em si. Que é esse return, esse return aqui para o nosso interrupt, e esse último return aqui para o nosso markCurrentCycleAsFinished. Agora eu não preciso mais de nenhum if, e agora dentro do meu reducer eu tenho apenas um switch com vários cases para cada action que eu posso disparar. E aí no meu Chrome, se a gente for ver aqui, tudo vai estar funcionando sem problemas nenhum. Posso interromper aqui o ciclo e tudo continua funcionando. Ou seja, a gente já melhorou bastante aqui o nosso reducer, mas como eu falei, agora a gente vai começar a otimizar um pouquinho mais. Abstrair o código do reducer daqui de dentro e até começar a usar até algumas bibliotecas novas aqui para melhorar a maneira que a gente altera os nossos estados. Porque eu particularmente acho que esses maps aqui são altamente confusos e difíceis de dar manutenção. É muito difícil entender o que está acontecendo aqui dentro, então eu vou usar uma bibliotecazinha que vai ajudar a gente bastante com isso. Então bora lá!"
  },
  {
    "id": "5522ffc5-f6c7-4579-b498-213d77d1b14d",
    "title": "Criando carrossel",
    "transcription": "Nesta aula, o que vamos fazer é criar... Se não me engano, as camisetas antes eram um pouquinho mais largas. Ele deu uma diminuída aqui para caber os três itens. Mas a gente não quer isso. A gente quer criar um carrossel. E aí eu fico muito triste, porque no momento que eu estou gravando essa aula, existe o Radix UI, que é uma biblioteca que eu adoro. A gente já usou aqui no Ignite. Eles estão trabalhando num elemento de carrossel e ainda não está pronto. Se você vier aqui e abrir o site do Radix UI e esse componente já está pronto, eu te desafio a utilizar esse componente de carrossel aqui no lugar para a gente ter esse funcionamento. Mas, já que ele ainda não está pronto no momento que eu estou gravando essa aula, eu vou usar um outro elemento de carrossel que se chama Keen Slider. Não sei exatamente se é assim que se pronuncia. Mas eu vou instalar esse carinha aqui dentro. E é bem fácil configurar esse Keen Slider. Olha só, o que a gente vai fazer aqui dentro. Eu vou importar de dentro do Keen Slider barra React. Ele tem integração com a maioria das bibliotecas front-end. Um book chamado Use Keen Slider. E eu preciso também importar um CSS que vem de dentro da biblioteca. keenslider.min.css E aqui na nossa ROM, eu vou escrever const igual. Use Keen Slider. E eu vou passar pra ele aqui uma propriedade, uma opção chamada SlidesPairView3. Ou seja, eu quero três produtos por página, por slide. Sem o usuário precisar arrastar. E esse Use Keen Slider, na verdade, ele devolve um array. E a primeira opção do array aqui é uma referência, uma ref do React. Então, a gente vai conversar sobre refs mais pra frente. Mas o que a gente precisa entender é que refs é uma funcionalidade do React que permite a gente ter acesso a uma referência de um elemento na DOM. Então, por exemplo, lá no JavaScript, quando eu faço um document.getElementById eu tenho a referência pra um elemento na DOM. E aí eu consigo modificar funcionamento desse elemento, estilização, diretamente pelo JavaScript. Concorda comigo? Então, a ref no React é a mesma coisa. Ela é uma maneira da gente permitir que o React tenha acesso a alguma referência direta pra algum elemento dentro da DOM. Então, aqui dentro o que a gente faz? Como ele retorna um array, eu posso fazer uma desestruturação aqui no lado esquerdo. E fazer o seguinte, eu pego ref, vou chamar de SliderRef. E agora eu venho aqui embaixo, eu preciso encontrar qual que é a div que está por volta dos meus slides, que no caso é a minha HomeContainer. E eu simplesmente passo pra ela ref e SliderRef. Isso aqui vai basicamente dar acesso pro Keen Slider, né? Modificar diretamente essa div pelo JavaScript. E aí aqui eu preciso também passar algumas classes pra estilização funcionar. Então, a classe desse aqui, do container, precisa ser KeenSlider. E cada produto dentro, eu posso selecionar os três numa porrada só, eu preciso colocar a classe KeenSlider, underline, underline e slide. Isso aqui é só pro CSS aplicar, tá? Salvo isso aqui agora, voltamos aqui no Chrome. E pronto, o slide, na verdade, ele já deve estar funcionando. Talvez a gente colocar um produto a mais aqui pra visualizar. Então vamos colocar um produto a mais aqui. Beleza, o slide já tá funcionando. Só que ele acabou não mostrando aqui o produto como um todo aqui no final. O que que ele fez aqui, meus amigos de fé? Deixa eu tentar dar um zoom out pra ver. Ele tá se perdendo aqui. Deixa eu dar uma visualizada aqui, o que que possa estar acontecendo. Bom, já descobri o que que é. Na verdade, o Keen Slider, ele se perde quando a gente coloca espaçamento. Então, o que que acontece? Se eu coloco esse gap, e aqui tinha um width 100% também, que não é o problema. Mas, se eu coloco esse gap, que é o espaçamento entre os itens aqui no container, ele não entende esse gap pra contabilizar no tamanho do container do slider. E aí o container fica menor. Por isso que tava faltando aquele conteúdo lá no final. Então eu vou tirar o gap daqui de dentro. E esse padding aqui dentro do link, talvez eu acho que também faz isso. Então deixa eu testar aqui. Também, olha só, eu vou tirar o padding do produto. Agora a gente pode ver que a bordinha arredondada apareceu ali no canto. Então eu realmente tô no final. E aí, o Keen Slider aqui no app, ou melhor, na home, ele tem aqui dentro do slides, ele tem uma opção chamada spacing, que eu consigo adicionar um espaçamento. Então, se eu tinha colocado 3rem, 3rem é 16, 32, 48. Vou botar 48 aqui, salvo. E agora sim, a gente já tem os nossos produtos aqui. Só que eu acho que eles estão um pouco finos demais. Um pouco requintados demais, não, brincadeira. Mas eu vou, aqui no meu link, talvez eu possa pegar e botar um min width. Deixa eu ver hoje, deve estar com uns 400 e tanto. Deixa eu ver aqui, 484. Vou botar uns 540, talvez, de largura mínima. Deixa eu ver se funciona. Não consigo botar. Talvez width direto. Será que tem que ser um number? Hum... Tá, eu não consigo botar a largura do slide direto. Deixa eu ver aqui, vertical, centroid, breakpoints, rtl, range, auto width. Tem um aqui que multiplica os slides. Tinha um que era com larguras diferentes, mas não era auto width. Deixa eu ver se eu acho esse. Tá, acho que eu não vou achar. Variable slides. Será que esse aqui ajuda? Deixa eu dar uma olhadinha no código. Size. Size? Não é aqui não. Slides. Number. Tá. Por que ele não deixa eu colocar uma largura no slide? Dentro do slide? Não sei. Mas tá, então vamos deixar assim por enquanto. Depois eu dou uma olhada com mais calma. Mas tudo bem, não é nada preocupante. É porque ele só realmente fez o nosso slide aqui. Ah, é que ele fez KB3, por isso que ele não está aumentando o tamanho. Ele fez KB3 na tela. Esse é o problema. Mas, tudo bem. Eu acho que não é bem um problema a gente deixar assim. Tá show, eu acho que tá legal. Agora que a gente já tem o carrossel, então agora a gente pode realmente começar a dar a vida para a nossa aplicação. Fazer isso aqui realmente funcionar e não ser elementos tudo estáticos aqui dentro."
  },
  {
    "id": "00ba8dfb-6a7b-48e1-9d13-05e07ea2a023",
    "title": "Componentes",
    "transcription": "Com o nosso projeto React criado aqui, o principal conceito que a gente precisa conhecer do React antes de a gente começar a trabalhar e construir nossas interfaces é o conceito de componente. E o conceito de componente vai se estender ao longo do desenvolvimento de todas as suas aplicações utilizando o React daqui pra frente. E não só o React, porque o React fez a introdução desse conceito, mas todas as outras bibliotecas front-end hoje utilizam um tipo de conceito igual ou similar ao conceito de componente, que nada mais é uma forma de a gente desacoplar um pedacinho da nossa interface pra que aquilo se torne repetitível ou até se torne algo mais fácil de dar manutenção porque é um pedaço menor da aplicação. Então, um componente a gente pode entender como um pedacinho, uma parte da interface da nossa aplicação, que pode ser repetida várias vezes, inclusive com informações diferentes. Vamos entender aqui como funciona um componente na prática dentro do código. Então, aqui dentro desse app, o próprio app já é um componente. Como que eu identifico um componente? O componente no React nada mais é do que uma função que retorna HTML. E daí que vem a extensão dos nossos arquivos aqui ser JSX. Todos os componentes da minha aplicação React precisam ter extensão JSX. JSX nada mais é do que JavaScript mais XML. XML, se você não sabe, é aquela sintaxe que a gente tem do HTML também, a markup language que a gente usa tanto no HTML e no XML são muito semelhantes. Então, quando a gente tem um arquivo com extensão JSX, provavelmente é um arquivo que contém HTML dentro dele. Então, é um arquivo JavaScript que contém HTML. Isso é algo bem do React, apesar de que no Vue 3, por exemplo, a gente já consiga também escrever nossas aplicações utilizando JSX, assim como a gente tem no próprio React. E aí o componente, ele nada mais é, como eu falei, que uma função que retorna algum HTML. E aqui a gente pode criar mais componentes. Por exemplo, eu posso aqui dentro de source, vou criar aqui um novo arquivo chamado post.jsx. Aqui nós vamos simplesmente criar uma função chamada post e retornar alguma coisa de dentro. Por exemplo, eu posso retornar aqui somente um parágrafo post. Salvo isso aqui, volto lá no meu app, ou melhor, eu preciso exportar agora isso aqui de dentro para que seja possível importar esse arquivo lá no app. E aí existem múltiplas formas de exportar. Eu posso seguir o que o próprio React já traz aqui, o próprio Vite traz aqui no template, que é usando export, default, post. E aqui no app eu faço import post from post, ponto, barra, para indicar que ele está na mesma pasta. E aqui eu mostro o post como se fosse uma tag HTML. Ela não tem conteúdo, então eu posso botar o barra e o sinal de menor aqui já conectados no final. Se eu salvo isso aqui agora e volto lá para o meu navegador, a gente vai ver que já aparece post aqui dentro. E agora, uma das coisas interessantes da gente fazer aqui dentro é o seguinte, eu posso ter múltiplos posts aparecendo um abaixo do outro, mas aqui a gente vai ver que o React já avisa a gente de erro, o próprio TypeScript já avisa a gente de erro, porque no React eu não posso ter vários componentes um abaixo do outro, se eu não tiver um por volta deles, algum elemento por volta deles. Então aqui no nosso caso eu vou botar uma div por volta desses elementos, só para a gente parar de dar erro, então a gente já vai ver que parou de dar erro. Então eu não posso ter múltiplos elementos um abaixo do outro, direto aqui dentro do return, sem ter algo por volta deles. Salvo isso aqui agora, volto lá no app e a gente pode ver que já mostrou aqui então post, post, post, post, post, que é cada um dos posts aqui que eu mostrei. Como eu falei, existem várias formas da gente importar e exportar arquivos entre eles, particularmente eu não gosto de utilizar esse export default, eu prefiro utilizar o export tradicional. E aí existem nomenclaturas para isso, default exports versus named exports. Nos default exports, que é o que eu estou utilizando aqui agora, quais são as vantagens, que eu não vejo muito como vantagens na verdade, a grande vantagem é, você pode dar um nome para esse componente na importação e não na exportação, ou seja, se eu quero que o post aqui tenha um nome diferente, eu posso botar post component aqui e tudo vai funcionar normalmente, mesmo que aqui de dentro eu esteja exportando com o nome post. Só que isso aqui eu não vejo como uma vantagem, por quê? Porque é muito comum quando a gente está fazendo construção de múltiplos componentes, às vezes eu copiar e colar um outro componente para ser mais fácil a criação desses novos componentes. E aí é muito comum eu esquecer de alterar o nome. E aqui, se eu esquecer de alterar o nome, vamos supor que eu copiei um componente de botão e eu esqueci de alterar o nome. Nossa aplicação, como eu posso dar o nome na importação aqui, na hora de importar o componente, não vai dar erro e eu nem vou perceber que eu deixei botão escrito lá dentro do componente. E aí por isso eu prefiro utilizar named exports. E aí o que muda no named exports? Eu não vou utilizar export default e eu vou escrever a exportação logo aqui junto com a função. Então eu dou export function button. Salvo isso aqui agora, volto no app e aqui a gente pode ver que ele já vai começar a dar... Na verdade ele não vai dar erro aqui, mas se eu salvar aqui e executar, a gente vai ver que ele não vai carregar nada, não vai mostrar nada em tela. Mas voltando aqui no nosso app, agora eu preciso fazer a importação dessa forma. Coloco chaves aqui por volta e quando eu dou um ctrl espaço aqui, ele já aparece para importar o nosso button. Então eu posso ter vários buttons aqui em tela. Salvo isso aqui agora e a gente vai ver que tudo volta a funcionar. E aí se em algum momento eu esquecer de alterar ou por exemplo trocar aqui para post como estava antes, volto lá no app, a gente vai salvar e agora a gente vai ver que não funciona. Ou seja, ele não deixa o nosso código executar caso a gente tenha errado o nome de alguma coisa. Então agora sim eu tenho que voltar aqui e alterar para post. E aí sim ele vai voltar a funcionar. Ou seja, com os named exports, que é esse modelo que eu gosto de utilizar, o nome do componente aqui na função precisa ser exatamente o nome que eu importo esse componente. Assim eu evito esquecer de alterar algum nome. E aí eu vou fazer a mesma coisa aqui no app. Eu vou tirar esse export default aqui embaixo, vou trocar aqui para export, e aí lá no meu arquivo main eu vou importar o app, porém com chaves aqui por volta, que é o que a gente precisa colocar nos nossos named exports. Salvo aqui, volto para o Google Chrome e a gente já vai ver funcionando. Então a gente aprendeu o conceito de componentes, que nada mais é do que eu ter um arquivo que abstrai parte da nossa interface em outro arquivo, e isso pode ser repetido várias vezes dentro do nosso app. Então imagina que eu esteja construindo, por exemplo, o feed de um Instagram da vida, de um Facebook, eu vou ter muitos posts ali sendo exibidos. Então eu posso colocar esse post dentro de um componente para que seja mais fácil eu reaproveitar isso e criar vários posts que tem funcionamento semelhantes um abaixo do outro. Mas a gente vai ver como que a gente consegue acoplar funcionamento a esses componentes aí nas próximas aulas."
  },
  {
    "id": "9d6e8401-3394-4de1-aeaf-cb666ee1a17f",
    "title": "Listagem do histórico",
    "transcription": "Agora a gente vai partir para a listagem dos dados do nosso contexto aqui no histórico. Então, até agora a gente só fez um JSON String File aqui para ver os códigos. Eu vou remover isso aqui. E agora, aqui no Tebari, eu vou remover todas as TRs. Vou deixar apenas... O que eu fiz? Cliquei no botão errado. Vou remover todas as TRs. Vou deixar apenas uma aqui dentro. E aí, aqui agora, eu vou fazer o seguinte. E para cada um dos ciclos, eu vou retornar aquela TR ali com os TDs e tudo mais. Aqui na TR, a gente precisa passar aqui. A gente já falou sobre isso. E eu vou botar aqui do TR como sendo o id, que é a informação única que eu tenho para cada ciclo. E aí, aqui na tarefa, eu vou botar cycle.task. Aqui é a duração, então é cycle.minutesAmount. E aí eu boto minutos aqui no final, porque aqui é só o número. Aqui é a data de quando o ciclo começou. Por enquanto, eu vou botar apenas cycle.startDate.toIsString. Só para converter para uma String mesmo. Depois a gente vai formatar isso aqui direitinho. E aqui embaixo é o status. O status depende de algumas informações. Então, o que a gente vai fazer aqui? O que eu vou fazer aqui dentro desse status? Eu vou fazer o seguinte. Eu vou remover esse carinha todo aqui. E aqui dentro eu vou fazer uma condicional da seguinte forma. Se o ciclo tiver a informação finishedDate, então... E aqui veja que eu estou fazendo um if, que ele só tem o then e não tem o else. Então eu posso utilizar dois ex-comerciais. E é legal, porque o JavaScript só executa a segunda parte de um if, caso a primeira parte seja true. Então ele só vai executar isso aqui, caso isso aqui seja um valor verdadeiro. Digamos assim, um truthy. Então, se isso aqui tiver setado. Dessa forma a gente consegue mostrar esse componente somente se isso aqui for diferente de nulo, vazio, zero, qualquer coisa assim. E aí eu vou mostrar o status concluído. Vou até salvar aqui. A gente vai agora. Se eu tiver o ciclo interruptedDate, aí a status color vai ser red. E aqui eu vou botar interrompido. Vou copiar de novo aqui. Às vezes o VS Code se perde um pouco na identação aqui. E agora eu vou fazer o seguinte. Se eu não tiver finishedDate e não tiver interruptedDate, quer dizer que ele está em andamento. E aqui eu boto yellow. Aqui ele converteu o meu código para não usar parênteses. Tanto faz. Está show de bola assim também. Então se eu não tiver finishedDate e não tiver interruptedDate, quer dizer que ele ainda nem finalizou, nem foi interrompido. Se ele existe, não finalizou e não foi interrompido, ele está em andamento. Então, agora a gente salva isso aqui. Vem para o nosso histórico. E agora eu vou cadastrar aqui. Projeto 1. 20 minutos. Vou aguardar um pouquinho. Vou interromper. A gente volta aqui. Projeto 3. Vou botar aqui 30 minutos. Começo. Vou aguardar um pouquinho e vou deixar correndo. Vou para o meu histórico. E olha lá. A gente tem o Projeto 1, que foi o primeiro que eu cadastrei. Tinha 20 minutos de duração e foi interrompido. O Projeto 3, que foi esse último. Não sei porque eu pulei o 2. Desculpa. Mas o Projeto 3, que tinha 30 minutos, ele está em andamento ainda. Que é verdade. Ele ainda está rolando aqui na ROM da nossa aplicação. E a data de início aqui ainda não foi formatada, que é uma das coisas que a gente vai fazer ainda."
  },
  {
    "id": "9e5124e9-289a-4834-8c27-35870c66604b",
    "title": "Formatando preço",
    "transcription": "Nessa aula o que a gente vai fazer é formatar o preço que está sendo exibido aqui na tela, porque até então, deixa eu rodar aqui a build de Dev, até então o preço que a gente está exibindo aqui está em um formato apenas numérico, sem os dados de reais e tudo mais. Então, aqui a gente tem duas alternativas. Eu posso formatar o preço diretamente aqui dentro do SPAM, no nosso HTML, ou eu posso formatar o preço aqui no GetStaticProps. Qual que é a grande diferença? Tudo que eu colocar aqui dentro do GetStaticProps vai executar uma única vez a cada duas horas. Ou seja, eu gasto menos processamento se eu fizer algum tipo de operação aqui dentro desse método, do que fazer diretamente aqui no HTML, que vai executar toda vez que a gente rodar o projeto. Então, como o preço é uma coisa que não vai mudar, não precisa mudar, que seria diferente, por exemplo, de eu colocar a quanto tempo um post foi publicado. Imagina que isso aqui fosse uma home e mostrasse vários posts, e eu precisasse mostrar a quanto tempo esse post foi publicado. Não daria para eu colocar esse cálculo de a quanto tempo ele foi publicado dentro do GetStaticProps, porque essa informação de a quanto tempo ele foi publicado depende da data atual. Ou seja, eu não posso calcular isso uma vez a cada duas horas. Concorda comigo? O preço não. O preço não é relativo ao momento atual. Ele é fixo. E por isso a gente pode fazer essa formatação aqui dentro. Então, eu vou simplesmente recortar e vou fazer aqui um new intl numberformat ptbr style currency e currency brl. E aqui eu dou um ponto format e passo o nosso priceUnitAmount dividido por 100. Só de salvar isso aqui agora, a gente já dá um F5. E já está ali, 74,90. A gente já consegue ver o preço aqui de todos os produtos."
  },
  {
    "id": "500ddac7-bb7b-4435-9f6c-f99a97d6ac8d",
    "title": "Fundamentos do ReactJS",
    "transcription": "Nessa aula, o foco é a gente conversar um pouquinho sobre os fundamentos do React. Antes de mais nada, o React é uma biblioteca para a construção de interfaces altamente interativas. Então, quando a gente utiliza um React da vida e quando eu falo de interfaces, a gente está falando sobre tudo o que o usuário interage quando ele está utilizando a sua aplicação. E interfaces não necessariamente são apenas interfaces web. Hoje o React pode ser utilizado para fazer construção de interfaces na web, no mobile, nos dispositivos de TV, por exemplo, utilizando o React TV, e até em realidade virtual utilizando o React VR. Ou seja, o React é uma biblioteca que quando acoplada a outras bibliotecas que executam em ambientes diferentes, não só na web, pode controlar interfaces de usuário em qualquer lugar onde o usuário esteja interagindo com alguma coisa visual. O React por si só, como eu falei, é uma biblioteca, ele não é um framework. Até existem frameworks que utilizam do React por baixo dos panos, como Remix, Next, Redwood, Blitz e por aí vai. Inclusive alguns deles a gente vai ver aqui ao longo do Ignite. Mas a ideia aqui da gente falar sobre os fundamentos do React é entender o que muda na hora da gente desenvolver a nossa aplicação a partir do momento que a gente está utilizando de uma biblioteca como o React da vida, ou Vue, ou Angular, ou Svelte, ou qualquer outra parecida. Se você já está acostumado a desenvolver aplicações tradicionais sem o uso dessa biblioteca, é bom a gente dar uma olhadinha um pouco nos fundamentos antes da gente partir para o código dessa ferramenta. E aí eu separei aqui um diagrama para a gente entender algumas coisinhas que é importante a gente entender do React e de outras bibliotecas parecidas antes da gente dar sequência aqui no nosso conteúdo, que é entender sobre o conceito de SPA. SPA é um conceito que foi introduzido lá depois de 2011, 2012, acho que o AngularJS, que foi inclusive a primeira ferramenta que eu utilizei, que utilizava desse conceito, foi uma das primeiras ferramentas, foi pioneira nesse conceito. E SPA nada mais é do que um conceito, uma sigla traduzida de Single Page Application. SPA é um conceito, uma forma da gente trabalhar com a parte visual da nossa aplicação, diferente do que a gente está acostumado a trabalhar em aplicações mais tradicionais. Então, quando começou o desenvolvimento web, lá em 1900 e finalzinho da década de 80, comecinho da década de 90, não lembro exatamente qual que era a data, mas a gente iniciou o desenvolvimento web, a gente chamava da web 1.0, as páginas eram totalmente estáticas, não existia banco de dados, não existia esse conceito de a gente ter conteúdo dinâmico, conteúdo sendo carregado de acordo com o usuário autenticado, nada disso. Todos os sites eram estáticos, então a gente tinha, por exemplo, landing pages, websites, hotsites, que eram aqueles sites que a pessoa acessava e todo mundo via o mesmo conteúdo. Todos os sites eram apenas arquivos HTML e depois foi se introduzindo o CSS e tudo mais, até a gente chegar na web 2.0, onde os conteúdos eram dinâmicos. A gente começou a ter acesso ao banco de dados, começou a ter toda aquela febre de utilizar tecnologias como PHP, Ruby, Python, acho que foram as principais, Java também, para a construção de aplicações web dinâmicas. Essas aplicações web dinâmicas que a gente começou a construir lá nos anos 2000, foi até, e até hoje ainda é muito utilizado, porque não necessariamente é um conceito errado, só é uma forma diferente da gente desenvolver do que quando a gente utiliza o conceito de SPA. Quando a gente utiliza esse padrão de renderização que veio nesses anos todos, como, por exemplo, utilizar um WordPress da vida, a maioria das aplicações PHP, Magento, tudo aquilo que a gente vinha desenvolvendo, Ruby on Rails, por exemplo, GitHub utiliza ainda desse padrão. A gente tem um padrão que a gente chama de server-side rendering. E quando a gente fala sobre server-side rendering e fala sobre SPA, se a gente for traduzir, o que são essas duas coisas aqui? Isso aqui são rendering patterns, padrões de renderização. Então, sempre que eu falo tanto a SSR, SPA, eles são patterns de renderização. E aí até se a gente procurar aqui no Google sobre rendering patterns, a gente vai encontrar muitos conteúdos para a gente conversar sobre isso. Deixa eu até abrir um aqui. A gente vai ver que existem vários. Client-side rendering, server-side rendering, static rendering, incremental static generation, progressive hydration, streaming server-side rendering. Tem muita coisa, inclusive muita coisa que a gente vai ver aqui dentro do próprio Ignite. Mas para a gente dar início nisso, a gente precisa falar sobre o padrão tradicional, que é esse padrão server-side rendering. Ou seja, toda vez que o browser, o usuário, requisita uma página lá da nossa aplicação, essa página é recebida pelo nosso servidor. Esse nosso servidor contém todo o código, tanto o back-end da nossa aplicação, quanto o front-end da nossa aplicação. O back-end ali por si só interpreta, poxa, olha só, o browser está me pedindo a rota de usuários. Ele cria, faz a busca no banco de dados, cria toda a HTML para mostrar aquela listagem de usuários para o browser e devolve o HTML, CSS, JavaScript pronto do servidor para o navegador carregar. Então é muito comum nessas páginas, o que a gente vê? A gente acessa o site e enquanto esse site não processou a nossa requisição, a tela fica branca. Então se você acessa algum site e você percebe que a tela fica branca enquanto lá na aba ele está carregando, isso quer dizer, bem provavelmente, que o site está utilizando uma estratégia tradicional de server-side-rendering. Então o rendering pattern de server-side-rendering, que é a grande maioria das aplicações na web, mesmo com o conceito de SPA muito forte, a gente ainda tem muitas aplicações que não migraram e nem pretendem migrar para esse modelo de SPA. Mas a grande maioria das aplicações que estão surgindo hoje, elas estão surgindo já com esse conceito de SPA aqui, que é um conceito que foi introduzido, como eu falei, lá pelo AngularJS, mas também é utilizado por Vue, React, Svelte, Aurelia, a gente pode falar de várias outras bibliotecas aqui no mundo do front-end. O que muda com um modelo de renderização de SPA? O browser, quando ele faz acesso a uma rota, por exemplo, users, onde ele quer a listagem de usuários, o back-end dessa vez busca no banco de dados a listagem de usuários, porém o back-end não tem mais dentro dele, no servidor, todas as instruções para a construção do HTML, JavaScript e CSS da página. Ou seja, o nosso back-end não fica mais responsável pela construção visual da tela. Na verdade, o back-end vai apenas retornar quais são os dados dos usuários, olha só, eu tenho 20 usuários, está aqui o ID deles, o nome, o endereço, todas as informações que são precisas, que são necessárias para mostrar em tela. Porém, essas informações não são retornadas no formato de HTML como era no modelo tradicional de server-side rendering. Essas informações são retornadas no modelo de JSON. Se você nunca trabalhou com JSON, seria muito importante você dar uma olhadinha sobre isso. O JSON nada mais é do que uma sigla para JavaScript Object Notation, que é uma estrutura de dados, um formato da gente disponibilizar dados e trafegar dados entre duas fontes diferentes, entre uma fonte e um destino, digamos assim. E o mais legal do JSON é que ele é uma estrutura universal. Praticamente todas as tecnologias, todas as linguagens conseguem interpretar JSON. Ou seja, eu consigo enviar dados de uma aplicação Java para uma aplicação, por exemplo, Python em JSON e as duas linguagens vão conseguir entender essa informação. E aí o que acontece nesse modelo de SPA é que o backend retorna os dados dos usuários em formato de JSON e aí nós temos uma segunda aplicação. Ou seja, antes, no modelo server-side rendering, nós tínhamos apenas uma única aplicação que continha todo o backend e todo o frontend do nosso app. A partir de agora, no modelo SPA, nós temos duas aplicações divididas. Uma aplicação que contém só o backend, que faz o acesso ao banco de dados, por exemplo, e retorna os dados em JSON. E nós temos uma aplicação separada, ou até mais aplicações separadas, de acordo com quantas interfaces diferentes a gente pode ter para o usuário, que é a aplicação frontend. A aplicação responsável por obter os dados em JSON e converter aquilo para HTML, CSS e JavaScript. É aí que entra um React da vida, é aí que entram também outras tecnologias. Por exemplo, eu posso ter aqui também um frontend mobile, escrito com React Native ou escrito com Swift, escrito com Kotlin, que utiliza os dados do mesmo backend, porém agora para criar interfaces nativas para o celular e não mais HTML, CSS e JavaScript. Então, a partir do momento que a gente começa a utilizar um conceito como esse de SPA, a gente passa a ter a possibilidade de ter múltiplos frontends, por exemplo, um web, um mobile, uma API pública, um aplicativo para Android, um para iOS e por aí vai, todos consumindo a mesma fonte de dados e consumindo os dados em JSON. Porque como eu falei, o JSON é uma estrutura universal, tanto iOS quanto Android, dependente da linguagem, vai conseguir entender JSON e aí a partir desses dados criar a interface para o usuário. E assim a gente consegue ter ganhos em performance, a gente consegue ter ganhos em manutenabilidade do nosso código, mas SPA não para por aí, a gente ainda vai entender um pouquinho de aonde que a gente consegue levar a construção das nossas aplicações utilizando o conceito de SPA ao longo das próximas aulas."
  },
  {
    "id": "88cd32f9-0bb2-4a71-9162-b8d1d01d79e9",
    "title": "Imagens no Next.js",
    "transcription": "Nessa aula a gente vai conversar um pouquinho sobre imagens no Next. Se a gente for na própria documentação do Next, aqui na esquerda, em Advanced Features, nós vamos em API Reference. A gente tem duas documentações aqui, que é essa Next Image e essa Next Feature Image, mas eu queria ver, ah, tem uma documentação aqui que é mais importante. Essa aqui, Image Component and Image Optimization. O que que acontece, né? Quando a gente trabalha com imagens no front-end, em aplicações web, o que que é muito comum acontecer? Muitas vezes a gente exporta imagens que estão em formatos, tamanhos diferentes dentro de layouts, e quando a gente traz essas imagens pro front-end, pra aplicar na web, muitas vezes a gente precisa que essas imagens sejam carregadas, na verdade 100% do tempo a gente precisa que essas imagens sejam carregadas com muita performance. Pra elas estarem com muita performance, existem vários pontos que a gente tem que tomar cuidado. Por exemplo, se eu tô carregando uma imagem e essa imagem tem 1000 pixels de largura, mas na nossa página ela vai estar sendo exibida somente com 400 pixels, por que que eu tô carregando uma imagem tão grande, de 1000 pixels e usando só 400? Ou, sei lá, por que que uma imagem que não tem transparência, eu tô utilizando talvez um PNG, sendo que JPG é muito mais rápido pra carregar esse tipo de imagem. E aí a gente vai ter que ficar controlando e tomando cuidado com muitas coisas na hora da gente estar exportando essas imagens. Mas, o que o Next faz pra gente, que é fantástico, é que ele otimiza de forma automatizada todas as imagens que a gente usar na nossa aplicação. Isso quer dizer que, se eu importei uma imagem pra dentro do meu projeto e essa imagem tem 1000 pixels de largura, mas eu tô utilizando ela no meu layout com somente 400, o que o Next vai fazer é criar uma versão dessa imagem, automaticamente, que tenha somente 400 pixels de largura, pra ele usar essa imagem, carregar essa imagem e não aquela de 1000. E ele também consegue converter formatos da imagem, pra conseguir usar formatos mais recentes, consegue criar imagens responsivas, ou seja, se o usuário tá acessando a nossa aplicação através de um dispositivo mobile, não tem porque ele carregar uma imagem com o mesmo tamanho de uma pessoa que tá acessando a aplicação num dispositivo web. E pra isso, a gente tem alguns componentes pra utilizar. Mas, eu quero te mostrar como que isso funciona na prática. Fechou? Então, vamos lá. Eu vou começar pra exemplificar pra você, de uma maneira mais simples. Aqui nesse caso, como o logo do nosso projeto é um SVG, acaba que nem daria pra mostrar muito esse funcionamento acontecendo. Mas, eu vou pegar aqui a página Home inteira, vou vir aqui em Export, e vou exportar a Home em PNG. Ele vai exportar aqui Home PNG, vou salvar no desktop mesmo, não tem problema. E agora, eu vou aqui no meu desktop, encontrar a Home, e vou jogar aqui pra dentro da pasta Assets. Então tá aqui a imagem, ela tem 600kb, 1440x900. Se eu colocar aqui no meu app, vou importar aqui, deixa eu comentar isso aqui, descomentar. Vou importar como Home Image, Home PNG, e eu coloco Home Image aqui no lugar. A gente volta aqui pra nossa aplicação, e tá aqui a imagem. Se eu for aqui em Especinar Elementos, for aqui na aba Network, esperar aqui o carregamento, procurar por Home, a gente vai ver que ele importou Home PNG, e que o tamanho dessa importação aqui foi de 610kb, do tipo PNG. Beleza, agora o que eu vou fazer? Eu vou trocar a tag Image, original do HTML, por uma tag que vem de dentro do Next. E esse componente, na verdade, que vem de dentro do Next, ele se chama Image, e eu posso importar ele de dentro de Next barra Image. O único ponto que eu quero te alertar, é que no momento que eu tô gravando esse vídeo, o Next tá trabalhando uma nova API de imagens, chamada Next Future Image, que por enquanto tá experimental, mas logo vai substituir a API Next Image. Então, o que eu tô querendo te dizer com isso? Eu já vou te mostrar como isso vai acontecer, provavelmente não vai demorar muito, eu já vou te mostrar essa otimização de imagens usando esse Next Future Image. Mas talvez quando você estiver assistindo esse vídeo, se você já tá assistindo esse vídeo bem pra frente, do dia 23 de agosto de 2022, talvez esse Next Future Image nem exista mais, e agora você vai usar somente Next Image, porque já saiu do estado experimental. Então, toma cuidado com isso, porque aqui eu vou fazer algumas configurações que só precisam acontecer caso isso aqui ainda não tenha ido ao ar numa versão LTSA. Então agora, pra eu conseguir usar o Next Future Image, dentro do meu arquivo Next Config, eu preciso jogar essas linhas aqui. Então eu venho aqui no Next Config, jogo essas linhas aqui, experimental images allow future image. Salvo, e agora eu posso importar de Next barra Future barra Image, e eu uso a tag image no lugar da tag img. Agora também eu vou tirar esse src daqui, e agora eu salvo, volto no Chrome, dou um F5, e ele vai dar um erro aqui. The Next Future Image Component is experimental. Primeira coisa, eu preciso, depois que eu mudei o meu arquivo Next Config, eu preciso encerrar o servidor, rodar de novo, dou um F5, e beleza, a gente já pode ver que a imagem apareceu aqui dentro. Veja só agora, aquela imagem que eu tinha carregado previamente, agora ela foi carregada ao invés de 610kb, usando 23kb. E usando o formato WebP, que é um formato muito mais recente, e muito mais performático, tanto do que PNG ou JPG. E aqui a gente pode ver também, que ele diminuiu a qualidade da imagem automaticamente para 75%. Isso aqui é muito, muito, muito massa, isso aqui faz toda a diferença no nosso projeto. E agora, por exemplo, se eu for aqui nessa imagem e passar para ela uma largura fixa, por exemplo, eu quero que essa imagem aqui tenha 400px de largura, eu salvo isso e volto aqui na minha aplicação. Ficou um pouquinho estranho, mas não tem problema, depois a gente fala sobre isso. O que a gente pode ver, dando um Ctrl Shift R, é que ele diminuiu mais ainda o tamanho da imagem. Por quê? Porque o Next, ele cria uma versão da imagem baseada nas propriedades, no que a gente espera daquela imagem. Então se eu falo, olha essa imagem, eu vou usar ela num espaço que vai ter no máximo 400px de largura. Beleza, então o Next vai converter essa imagem automaticamente para um tamanho menor, para utilizar essa imagem, para não precisar carregar a imagem com um tamanho muito grande. Isso é muito, muito massa. Então eu fiz tudo isso, na verdade eu vou deletar essa imagem da Home, porque a gente não vai utilizar ela, vou deletar a importação e a gente vai voltar aqui para o nosso logo. E o nosso logo é um SVG, então eu salvo aqui agora, dou um F5 e a gente pode ver que o logo continua sendo exibido ali dentro. E eu posso ver que o logo foi carregado aqui também como um SVG. Aqui 4.9kb, não sei se ele diminui muito, porque o SVG está com 10 e ele diminuiu para 4.9, ainda é uma redução grande. Então como é um SVG, provavelmente o que o Next fez foi eliminar coisas aqui do nosso SVG que não são importantes visualmente. Então ele deu uma minificada, digamos assim, para ficar mais leve. Eu posso inclusive vir aqui em Response, eu vou ver, esse aqui foi o SVG que ele gerou. E é isso, a gente falou um pouquinho sobre imagens, então sempre que a gente for trabalhar com imagens do Next, a gente sempre vai optar por utilizar o componente do Next Image AI."
  },
  {
    "id": "91d6afef-b18b-417f-aff7-7f404a1e0d7a",
    "title": "Ciclo completo",
    "transcription": "Quando o nosso ciclo está chegando ao final, não está acontecendo nada, então alguma coisa a gente tem que fazer. Então, aqui no VS Code, vamos dar uma olhadinha aqui no nosso código, a gente tem hoje esse UseEffect, que fica percorrendo 7 intervalos e fica calculando a diferença de segundos. E o que eu preciso fazer aqui? Se a diferença em segundos da data que o ciclo foi criado para a data atual for igual ou maior do que o total de segundos, que eu inclusive tenho uma variável aqui embaixo, ou seja, o total de segundos que aquele ciclo deveria ter, que é 1 minuto vezes 60, quer dizer que acabou. Então, o que a gente vai fazer aqui dentro? Eu vou pegar isso aqui e vou colocar em uma variável, eu vou chamar de DifferenceInSeconds, na verdade isso aqui já é o nome da função, então... Vou colocar alguma coisa que seja equivalente. E aqui eu vou fazer o seguinte, aqui o código vai continuar igual, se a diferença de segundos for maior ou igual, e aí deixa eu puxar essa variável TotalSeconds aqui para cima do UseEffect, para eu ter acesso a ela, for maior ou igual ao total de segundos que eu tenho, e aí como eu estou usando uma variável externa aqui, também preciso incluir ela aqui, então TotalSeconds, se for maior que o número de total de segundos, então eu preciso falar que aquele ciclo foi encerrado, certo? Então, para falar que o ciclo foi encerrado, eu vou usar uma lógica muito semelhante com o que a gente fez, para falar que o ciclo foi interrompido. Então, é a mesma lógica que eu vou colocar aqui dentro, só que a diferença é que ao invés de atualizar uma informação com InterruptedDate, eu vou colocar uma outra informação chamada FinishedDate, que também é opcional, porque ela vai guardar o valor que o ciclo, quando o ciclo foi encerrado, somente se ele foi encerrado, por isso que ela pode ser nula. E aqui então a gente vai trocar para FinishedDate. Se isso aqui aconteceu, não tem porque eu atualizar mais a nossa variável, então essa variável aqui ela vai atualizar somente no caso else aqui, ou seja, eu só vou atualizar o tanto de segundos que passou, se eu ainda não completei o total de segundos, ou seja, se o total de segundos que eu percorri, já foi igual ou maior que o número de tempo que o meu ciclo tem, eu marco como completo. Se não, se eu não completei ainda, não cheguei a zero, eu continuo abaixando. Essa lógica aqui me parece ok. E aqui, super interessante, eu já detectei um erro bem legal aqui. Veja que está dando um aviso aqui embaixo, que ele fala o seguinte, eu estou utilizando as dependências ActiveCycleId, as variáveis, e a variável Cycles, que são variáveis externas da UseEffect, e eu não coloquei elas aqui embaixo. O ActiveCycleId realmente faz sentido, colocar ele aqui embaixo. O nosso Cycles que eu uso aqui dentro, eu cometi um erro que inclusive eu falei para você, que é quando a gente atualiza um estado, e esse estado depende do seu valor anterior, que é o caso aqui, a gente escrever isso em um formato de função. Então, o certo seria eu fazer isso aqui, colocar o state aqui no lugar do Cycles. E isso serve também lá embaixo no interrupt, mesma coisa aqui, a gente faz state, e aqui troca para state, salva, e o Slint corrige para a gente os últimos errinhos ali. Beleza, só que agora o que está acontecendo? Quando eu completei aqui o nosso ciclo, não necessariamente eu quero que o meu intervalo continue executando. Então, eu acho que aqui de dentro dessa função, eu consigo também dar um ClearInterval no nosso intervalo aqui para a gente parar de executar ele. Vamos testar agora. O que eu vou fazer aqui? Para a gente conseguir testar isso, e não ter que ficar esperando 5 minutos, lá no meu formulário aqui onde eu tenho a validação e tudo mais, eu vou falar que o mínimo de minutos de um ciclo é 1 minuto, e aqui embaixo no Input também vou definir como mínimo 1. E aí, vamos voltar aqui no código, projeto 1, boto 1 aqui, e dou um Começar, e agora eu vou aguardar aqui um pouquinho, deixa eu até pausar o vídeo aqui, para a gente ver quando isso aqui terminar se deu certo. Show! Chegou aqui no 0, o que aconteceu? Ele continuou mostrando 1 aqui, e isso é basicamente porque aqui na ROM eu estou... tem um console.log aqui que eu tenho que tirar, mas aqui na ROM eu estou basicamente fazendo o seguinte, quando eu estou fazendo o seguinte, quando o novo cálculo de diferença é igual, eu não estou mais atualizando o tanto que passou, aí não está mais refletindo na interface. Então, o que eu posso fazer nesse caso, é aqui dentro, dar um SetAmountSecondsPassed, e eu vou fazer o seguinte, o que eu posso fazer nesse caso, é aqui dentro, dar um SetAmountSecondsPassed, como total seconds, para ele ficar zerado nesse caso, e aí isso aqui vai ficar zerado. E aí, de resto, eu acho que eu não preciso fazer mais nada, aí o ciclo foi encerrado, e aí está perfeito. Então é isso, agora a gente tem que pensar, ele já até inclusive atualizou aqui, agora a gente tem que pensar só, se eu quero, quando chegar no final, que ele chegar a 0 segundos, se eu quero mostrar uma mensagem de sucesso, alguma coisa assim, a gente pode pensar em alguma coisa juntos, mas por enquanto está ótimo, a gente já conseguiu incrementar o nosso código bastante. Mas antes da gente pensar em como a gente pode melhorar isso aqui, continuar adicionando novas funcionalidades, tem mais algumas coisas que a gente precisa fazer na estrutura do nosso código, antes da gente prosseguir. Porque até se a gente for olhar aqui para o nosso código, esse componente aqui da Home, está ficando bem, como eu falei lá no começo do módulo, está ficando bem, bem, bem complexo, bem comprido e complexo. Então a gente já tem aqui, se a gente for contar tudo aqui, quase 200 linhas de código e já está difícil identificar o que é o que aqui dentro, porque tem muito código. Então eu acho que antes a gente tem que dar uma melhorada aqui para poder continuar."
  },
  {
    "id": "750716ec-65e6-4d09-b3c2-34a86dcf97d7",
    "title": "Finalizando Sidebar",
    "transcription": "Nessa aula a gente vai finalizar o nosso componente de sidebar aqui, então bora lá. Além disso, dos elementos que a gente já colocou em tela aqui na nossa sidebar, como o nome e o cargo, ficou faltando só a imagem de perfil do usuário aqui. Então, bora adicionar essa imagem de perfil também. Então, aqui antes do strong, a gente vai colocar o nosso avatar do usuário, digamos assim, que é uma imagem. Então, vamos colocar aqui image. Aqui no search da image, é importante que seja uma foto sua. Então, a dica que eu dou pra você é o seguinte, se você tiver um perfil do GitHub, você pode usar a sua foto de perfil do GitHub só fazendo o seguinte, GitHub.com barra o seu usuário, no caso o meu aqui é Diego3G, e é só botar um ponto png no final, olha só. Ele já carrega a sua imagem de perfil do GitHub. Mas você pode usar a sua imagem de perfil, o endereço da sua imagem de perfil do Twitter, de qualquer outro lugar. É só copiar o endereço e colocar aqui dentro do search. No meu caso, eu vou botar https.github.com barra diego3g.png. Novamente, como é uma imagem que vem como input do usuário, dinâmica, para cada usuário da nossa aplicação, nesse caso, a gente não coloca texto alternativo. E agora, vamos salvar, vamos ver como é que ficou lá. Quebrou a aplicação toda, eu sabia, lidar com imagem é sempre assim. E agora a gente tem que redimensionar ela pra ficar no tamanho certinho. Eu volto aqui em sidebar.module.css, e aqui a gente vai fazer o seguinte. Dentro do profile, a minha imagem de avatar, ou eu poderia inclusive colocar aqui um class name pra ficar mais fácil, styles.avatar. Salvo, e agora aqui eu posso utilizar ou .profile.avatar ou .avatar, tanto faz, os dois vão funcionar. Mas aqui no avatar, a gente vai começar definindo uma largura de 3rem, uma altura de 3rem e um border-radius 8px. No border-radius, é um dos poucos casos que eu, nas bordas em gerais, é um caso que eu não utilizo o rem pra calcular. Muito dificilmente eu utilizo o rem pra calcular, porque dificilmente você vai querer deixar alguma coisa mais arredondada ou menos arredondada, porque o usuário aumentou ou diminuiu o tamanho da fonte do dispositivo. Mas, então geralmente a gente usa rem pra coisas que representam tamanhos na tela. Largura, altura, tamanho de fonte, por aí vai. Então, volto aqui, já tá ali minha imagem de perfil, porém a gente precisa botar ela aqui um pouquinho mais pra cima. E também tá faltando uma bordinha ali nela. Então aqui eu vou botar um border, 4px, solid, var, gray, 800. Isso aqui vai fazer com que ela tenha uma borda. Deixa eu jogar ela um pouquinho mais pra cima pra gente visualizar como que isso fica. Então aqui no nosso profile, aqui em cima, eu vou jogar aqui um margin-top, menos 2rem por enquanto. Depois a gente bota um valor mais real. Ele já jogou lá pra cima, tá vendo? E aí ficou com aquela bordinha cinza ali por volta. Agora aqui no avatar, eu vou usar também, porque ele tem uma borda cinza por volta e depois uma borda verde. Então eu vou usar border e depois vou usar o outline. 2px, solid, var, green, 500. Salvo, e aí a gente já pode ver ali que deu certo. E aí aqui agora a gente pode ver que como eu coloquei muita borda e coloquei muito outline, o tamanho da imagem ficou bem menor. Ficou bem menor inclusive que o tamanho que tá aqui. Porque ele comprimiu a nossa imagem. E aí a gente tem duas formas de resolver. Eu posso vir aqui no avatar e botar um box-sizing. Initial, por exemplo. Salvo. E agora ele volta pro formato que tava antes. Então o box-sizing initial, diferente do box-sizing border-box, que foi o que a gente definiu em todos os elementos aqui. Ele faz com que quando eu adiciono borda, pad, margem, outline em um elemento, isso ocupe um espaço a mais. E não esprema o elemento pra que aquilo caiba também dentro do container. Então isso aqui é uma forma de resolver. Outra forma de resolver seria, por exemplo, utilizando um cálculo no CSS. Então vamos resolver dessa segunda forma pra você ver como a gente pode usar cálculos aqui no CSS também. Então aqui, por exemplo, no width e no height, eu posso, ao invés de colocar 3rem, fazer um cálculo. 3rem mais o tanto de borda que eu tenho aqui embaixo. Então é 4 pixels de um lado mais 4 de outro, dá 8. Mais 2 de um, mais 2 de outro, dá 12. Então aqui eu boto 3rem mais 12 pixels. Salvo e o resultado é igual. E aí aqui no nosso profile, que eu coloquei o margem top menos 2rem, não necessariamente é menos 2rem aqui. Aqui eu também posso fazer um cálculo pra posicionar ele que fique bem centralizado. Então aqui eu boto, por exemplo, um calc 1.5rem, que é metade de 3, menos 6, que é metade de 12. Só que aqui, se eu salvar, a gente vai ver que ele deu margem do topo, mas eu quero que ele volte. Eu quero, na verdade, que é uma margem negativa que eu quero. E aqui eu não posso botar um menos aqui na frente, senão não vai funcionar. Nesses casos, o que a gente faz, a gente faz o seguinte, 0 pixels menos isso aqui. Então ele vai começar de 0 e vai reduzir isso aqui, então vai ficar negativo. Salvo isso aqui, ele já se posicionou ali pra cima. Beleza, a gente já está com o nosso elemento de avatar posicionado em tela. E agora a gente vai estilizar o restante dos nossos elementos de texto do perfil. Então eu vou começar estilizando o nosso Strong, que é o nome do usuário. Vou botar um margem top 1rem, color var gray 100, é um cinza bem clarinho. E aqui um line height 1.6, ou 160%. Novamente, peguei isso aqui lá de dentro do Figma. É super importante a gente cuidar pra que cada estilização fique exatamente igual ao layout. Salvo, já está aqui o meu nome, Diego Fernandes. E agora, profile.span, que é o cargo. A gente vai botar um font-size aqui, 0.875 rem. Por que é 0.875 rem? Porque 0.875 vezes 16 dá 14, que é o tamanho que eu quero. Então aqui é 14 pixels. Aqui eu vou colocar color var gray 400, line height também 1.6. Salvo, e já está ali o WebDeveloper, que é o cargo. Finalizamos o nosso feed? Finalizamos, falta o nosso ícone aqui dentro. Então, pro ícone, a gente vai usar uma biblioteca de ícones. Quando a gente trabalha com ícones dentro da web, dificilmente a gente vai usar imagens. Porque imagens é ruim. Se cada ícone que eu tiver aqui na minha aplicação, ainda mais aplicações grandes, eu tiver que exportar uma imagem pra cada ícone, é muita coisa. Dá muito trabalho, e fora que eu gero muito carregamento na nossa página. Então, geralmente a gente usa uma biblioteca. Particularmente nesse layout aqui, o Jonas utilizou uma biblioteca chamada Phosphor Icons. Posso até entrar aqui nessa Phosphor Icons. Clico aqui em Explore Icons, eu vou ver todos os ícones que ele tem. Então, por exemplo, esse que eu estou usando ali é o Pencil, se eu não me engano. Aqui, é o Pencil Line, que é o ícone que eu vou estar utilizando ali. Pra utilizar essa biblioteca dentro do React, eu posso clicar aqui em GitHub. Aqui embaixo, nós vamos navegar até na seção que vem React. E aqui, a gente vai instalar a biblioteca Phosphor React no nosso projeto. Então, eu venho aqui no Visual Studio Code. Aqui no terminal, abro mais um terminal aqui na direita. NPM install, ou só NPM i Phosphor React. Instalo essa biblioteca aqui dentro. Agora eu volto lá na minha sidebar, e aqui em cima eu vou fazer o seguinte. Import from Phosphor React. E aqui, se eu der um CTRL espaço, ele já vai mostrar todas as opções de ícones dessa biblioteca que eu posso importar. Como é uma biblioteca que eu acabei de instalar, às vezes demora um pouquinho pra ele carregar, mas já tá aqui, todos os ícones que eu posso utilizar. No nosso caso, lembra que é o Pencil Line que eu quero aqui pro nosso projeto. E agora eu venho aqui, antes do texto editar seu perfil, eu coloco o nosso Pencil Line aqui. Salvo isso aqui agora, volto lá, e eu posso ver que o ícone já foi posicionado ali dentro. Beleza, com o ícone posicionado ali dentro, agora a gente vai fazer o seguinte. Eu volto lá pra estilização da minha sidebar, footer A, aqui. E nós vamos fazer o seguinte. Aqui, como eu usei o display flex, como eu quero separar o ícone um pouquinho do texto, eu posso botar aqui um gap de 0.75 rem. Isso aqui vai dar um espaçamento de 12 pixels entre o ícone e o texto. Eu salvo, ele já dá um espaçamento ali. O ícone tá um pouco pequeno, né? Aqui, se eu for ver na propriedade Phosphor React, eu posso passar algumas propriedades pra esse ícone. Por exemplo, Size, que é o tamanho, a cor, Weight, porque ele tem vários tipos de espessura. Se eu voltar aqui na biblioteca, Explore Icons, aqui tá vendo que é o Regular. Eu tenho vários tipos, Bold, Regular, Thin, Light, Thin, Fill, Duotone. Então, aqui a gente pode selecionar também espessuras pro ícone. Mas, nesse caso, eu quero somente o tamanho. Então, se eu for aqui no Feed, clicar aqui em cima do ícone, no frame, ele tem um tamanho de 20. Tá vendo? E aí a gente pode botar aqui Size 20, por exemplo. Salvo isso aqui agora, volto na minha aplicação, e já tá ali o ícone. Só que aí o meu texto parou de caber dentro do botão. Não tá mais cabendo o texto editar seu perfil aqui dentro. Vamos tentar entender o porquê que isso tá acontecendo aqui. Então, eu tenho o meu A, passo o mouse por cima, editar o perfil. O ícone aqui tá com Weight 20 e Height 20. O espaçamento, deixa eu ver se eu diminuir um pouquinho o espaçamento entre eles. Botar um 0.5, ó, daí já cabe. Então, eu vou fazer isso aí. Vou diminuir um pouquinho o espaçamento aqui, pra ele ficar um pouco maior. Vou diminuir um pouquinho o espaçamento aqui, pra 0.5, entre o ícone e o texto. E aí já tá legal. Outra coisa que a gente vai fazer aqui, se eu navegar aqui pra esquerda, o Jonas deixou pronto qual que deve ser o hover. Quando eu passo o mouse por cima, ele deve trocar a cor aqui de fundo do botão. Então ele troca aqui pra 00875F. Deixa eu ver se é a mesma cor que a gente tem aqui. Exatamente, o mesmo verde que a gente tem aqui. Então, a gente vai fazer aqui o ponto, o sidebar, footer a hover, background var green 500. E a cor do texto, nesses casos, vai ficar branca, totalmente branca. Então, var white. Perfeito, salvo aqui agora, vamos ver. Beleza, já deu certo. Só ficou meio seco demais, então a gente pode colocar talvez uma animação. Vou colocar aqui um transition. Transition. A color 0.2 segundos e o background color também 0.2 segundos. Salvo, vamos ver. Então beleza, já ficou ali uma transição. Ficou melhor. Aqui a gente poderia... Bom, eu acho que tá bom por enquanto. Acho que um pouquinho mais rápido na verdade. Eu achei que ficou um pouco lento ainda, eu gosto de transição mais rapidinha assim. Show. Ficou legal assim. Então agora, a gente já terminou aqui a nossa sidebar. E agora sim, a gente vai pro conteúdo aqui do nosso feed, onde tem os posts em si. E aí a gente vai aprender bastante coisa diferente que não é só CSS, que é muito do que a gente tá fazendo agora."
  },
  {
    "id": "b5b84b93-a00e-4f4f-8e77-0535cbf2f398",
    "title": "Estilizações do Comentário",
    "transcription": "O que a gente vai fazer nessa aula, então, é a estilização aqui dos nossos comentários. E pra isso, eu vou começar acessando o nosso Comment Module, CSS, aqui. E no comentário a gente vai começar usando um margin-top, 1.5 rem, um display flex, pra ficar o avatar e o conteúdo do comentário um ao lado do outro, e um gap de 1 rem. Aqui eu nem vou mostrar como tá ficando, porque uma das coisas que eu vou fazer já desde agora, é lá no comentário a nossa imagem, que tá dentro de comment. Eu vou fazer o seguinte, comment, e aí eu vou pegar a primeira imagem, ou eu poderia botar um class name nela pra facilitar, mas logo a gente vai mudar um pouco esse esquema do avatar, então por isso que eu nem tô mexendo muito. Mas aqui essa imagem, eu vou lá no nosso componente aqui de post, por exemplo, e vamos copiar aqui o CSS que eu já tinha colocado pro avatar lá. A única coisa é que aqui, nesse do comentário, não tem aquela borda verde. Então a gente vai retirar todo esse outline, border, deixar só o border-radials, e aqui no width e no height a gente vai botar 3 rem. Salvo. E aí isso aqui já deu uma diminuída no avatar, já vai facilitar a gente um monte pra visualizar a estilização do comentário em si. E agora a gente vai partir pro restante aqui da nossa estilização. Então o nosso comment-box, nós vamos simplesmente dar um flex1. Isso aqui vai fazer com que essa div que tá do lado do avatar, que é essa aqui ó, que tem todas essas informações, ela ocupe o máximo de espaço possível. Então como eu tenho uma div por volta dela que tem display-flex, quando eu coloco flex1 em algum elemento dentro dela, a gente faz com que essa div stique o máximo possível do tamanho. E agora a gente vai ter o nosso comment-content. Esse comment-content é aquele que vai ter um background com uma cor cinza mais clarinha, só pra destacar do fundo aqui ó. Ele vai ter também um border-radials 8 pixels e um padding de 1 rem. Então salvo, já dá pra ver que tá ficando bem legal. Agora a gente vai pro nosso cabeçalho aqui do comment-content. Vou dar um display-flex também, align-items-center e justify-content-space-between. Alexa, para... Eu hein? Tá. Voltando aqui, a gente já tem... Me perdi total no Papai Noel em Boston agora, mas a gente vai estilizar agora o author-and-time, que é o nome do autor do comentário e do horário. E aqui a gente vai... A gente vai dar um display-flex, porém flex-direction-column. Novamente, a mesma coisa que a gente fez aqui no post, a gente não precisa fazer isso aqui, caso a gente pegue o author-and-time-strong e o author-and-time-time e coloque um display-block neles. Se a gente fizer isso aqui, aí isso aqui não é necessário. E o time, aqui ele é menor ainda. Ele é 12, se não me engano, então 0.75. Align-height, 1.6 também. E color-var-grey-black. E aqui a gente vai dar um display-flex, porém flex-direction-column. Novamente, a mesma coisa que a gente fez aqui no post, a gente vai dar um display-flex, porém flex-direction-column. E color-var-grey-400. Salvo. Olha só, já ficou bem legal. Agora esse nosso botão aqui, a gente vai pegar aqui pelo header, comment-content-header-button, e a gente vai botar nele aqui um background-transparent, pra ele não ficar com aquela cor de fundo. Vou tirar a borda também, então aqui já ficou agora, só que ele tá preto ainda, então color-var-grey-400. Já ficou cinza ali. Aqui, uma outra coisa interessante é o seguinte, eu vou botar um cursor-pointer nele, e aí uma das coisas interessantes da gente falar sobre botões que são apenas ícones é o seguinte, olha só, tá perfeito, né? Passo o mouse por cima, olhando assim tá perfeito. Só que olha só, se eu for navegando pelo tab, tá vendo que agora quando eu dei o focus aqui no botão pelo tab, a borda aqui ficou um pouco maior do que o botão em si? Isso acontece porque a altura de um botão, ela não é definida pelo conteúdo do botão. Ou seja, o ícone até faz o botão crescer, mas como esse ícone aqui, ele não tá ocupando uma altura, digamos assim, suficiente, o botão segue sempre a altura dele pelo line-height desse botão. E aí tem duas formas de a gente fazer essa altura ficar menor. Eu posso botar, por exemplo, um line-height zero, tá vendo, dessa forma, ou um font-size zero também resolveria. E aí a borda já fica coladinha ali. Nesse caso, vou usar o line-height zero, a borda já fica coladinha. Outra coisa, eu gosto que a borda aqui, mesmo sendo a borda só do focus, ela fique um pouquinho arredondada, então eu vou tacar um border-radius aqui, de quatro pixels nesse botão, pra ficar arredondado, pode ser até dois pixels, não precisa ser nem tanto. E assim eu acho que fica mais bonito, eu gosto de dar atenção em cada detalhe que a gente faz na nossa interface. Se eu for ver aqui no layout, o Jonas colocou pra quando a gente estiver botando o focus, o hover, ele fique vermelho, então vamos copiar essa cor vermelha que a gente ainda não tem no nosso CSS, e aqui eu vou criar uma cor, colocando a nossa cor vermelha aqui. E aí aqui no botão, quando nós dermos hover, nós vamos colocar aqui uma color, que agora já está aqui aplicada. Beleza, deixa eu dar uma olhadinha aqui no layout, esse botão aqui, eu acho que a gente só tem que aumentar um pouquinho o tamanho do ícone, então vamos aqui no nosso trash, no trash tá 20, deixa eu ver quanto que tá aqui no figma, então a gente seleciona aqui o frame, tá 24, por isso que eu tava sentindo que tava um pouquinho estranho. Então, beleza, agora já tá melhor aqui. Aqui outra coisa importante, lembrando né, tem que ficar sempre igual ao figma, por isso que eu sou bem chato com isso. Aqui ó, se eu seleciono esse header, a gente vai ver que o botão, eu apontando aqui na tela, a gente vai ver que o botão ali de deletar, ele tá centralizado no cabeçalho, mas não é isso, até se eu for ver no layout, ele tá bem pra cima aqui. Então vamos lá, comment module, aqui no header, a gente botou align item center, aqui eu vou botar flex start. Salvo. Ah, beleza, agora ele já tá bem lá em cima, posicionado certinho como a gente queria. Vamos lá, falta o conteúdo e o botão de aplaudir ali embaixo. Então, aqui embaixo eu vou pegar o nosso comment content p, que é o conteúdo do comentário, margin top 1rem e color var grey 300, aqui, show, já deu um distanciamento. E agora pra finalizar, a gente pega nosso comment box footer, margin top 1rem também, pra distanciar o botão aqui do aplaudir, e agora a gente vai estilizar o botão que tá ali dentro. E esse botão aqui, ele recebe um background transparent, border 0 sempre, pra gente resetar o estilo padrão que botões tem no HTML, color var grey 400, show, cursor pointer, pra dar o botãozinho aqui, o de click, aqui também, eita, o que eu fiz aqui, display flex e align item center, assim eu faço com que o ícone, o texto e o span, todos eles fiquem na mesma linha horizontal, se eu não tivesse esse align, olha aqui, ele tava meio, meio uma escadinha assim. E agora, quando o usuário der um hover aqui nesse botão, eu vou mudar a cor de texto dele pra green 300. Então, olha aí, já tá trocando. Aí aqui agora, o que eu quero fazer? Esse nosso ícone aqui, eu preciso distanciar ele um pouquinho do nosso aplaudir, então, todos os ícones que eu importo aqui no React, eles são SVGs no final das contas, tá? Então, eu posso pegar, por exemplo, o SVG que tá dentro do botão, e eu posso dar um margin right aqui, 0.75 rem, por exemplo, pra ele dar uma distanciada aqui do botão de aplaudir. Ficou até meio grande aqui, vou botar um pouquinho menos, 0.5 rem, tá show assim. E agora, a gente vai fazer o seguinte, eu vou pegar o nosso span, vou adicionar um before nele, porque eu quero que antes aqui do 20, um before antes dele, eu quero colocar esse símbolozinho aqui do ponto e dar um espaçamento. Então, aqui a gente vai fazer o seguinte, eu vou dar um padding, 0 em cima e embaixo, nas laterais 0.25 rem, lembrando que isso aqui, eu não tô adicionando esse padding no span, e sim no elemento before, se você nunca utilizou esse before, eu já vou te mostrar o que é esse before, e eu vou botar aqui um content, que eu procurei no Google, que é a barra invertida 2022. Isso aqui é aquele pontinho, um símbolo no HTML. Então, eu salvo, volto lá e pronto, já tá o nosso pontinho ali. O before, ele funciona como se eu tivesse criando um elemento dentro do span. Então, o span tá aqui, se eu for até aqui do lado, não tem estilização nenhuma, tá vendo? Dentro dele, ele cria esse before, tá vendo? Então, esse before é o que tá com a minha estilização. E aí, nesse before, eu consigo colocar o conteúdo em texto, se eu quiser estilizar, é como se eu tivesse adicionando um novo elemento dentro do span em si. E aí, pronto, o nosso botão aqui de aplaudir já tá finalizado. Posso só colocar aquela mesma coisa que eu fiz no outro elemento, colocar um border radius aqui de 2 pixels pro focus ficar redondinho também, né? Show! A gente finalizou então agora toda a parte estrutural e de CSS aqui da nossa aplicação. E agora a gente pode começar a dar vida pra nossa aplicação, fazer ela realmente funcionar."
  },
  {
    "id": "45c23ca3-9640-4f6e-8df5-7d709c5c4069",
    "title": "Realizando likes nos comentários",
    "transcription": "Nessa aula a gente vai criar a funcionalidade de like aqui nos comentários ou como o Jonas chamou no layout de aplaudir. E por que a gente botou aplaudir e não botou like? Porque aqui na nossa aplicação a pessoa vai poder dar quantos likes ela quiser no comentário, não é só um like por comentário, é tudo livre. E vamos lá, aqui dentro do nosso Visual Studio Code, então vamos aqui no comentário, que é onde tem aqui os likes, o número de likes, e aí como o like é algo que vai mudar de acordo com alguma ação do usuário, quando ele clicar no botão, a gente precisa armazenar isso no estado. Então aqui dentro do comment, eu vou criar um likeCount, e aí uma função para alterar isso aqui, setLikeCount, useState, aqui eu dou um ctrl espaço, ele já dá a opção de importar automaticamente do react, e aqui qual que é o valor inicial que a gente vai dar para o número de likes? Zero. Sempre importante, iniciar o estado com alguma informação que seja do mesmo tipo que a informação que a gente vai armazenar ali. Então se eu vou começar, se os meus likes vão de 0, 1, 2, 3, eu não vou começar isso aqui com uma string vazia, não tem lógica, porque ele vai de 0, 1, 2, 3, certo? E agora, vou criar aqui, ou melhor, quando o usuário clicar nesse botão aqui, handleLikeComment, e aí vou criar uma função aqui em cima, essa função precisa aumentar o número de likes aqui no nosso comentário. Então agora, eu posso vir aqui, dar um setLikeCount, e agora eu preciso saber quantos likes eu já tenho, para adicionar mais um. Para eu saber quantos likes eu já tenho, eu posso utilizar o próprio valor que eu tenho aqui no estado. Então eu vou pegar o valor que eu já tenho de likes, mais um. E agora, se aqui no lugar do 20, eu mostrar a nossa variável likeCount, e salvar isso aqui, eu volto aqui no Chrome, clico em Aplaudir, a gente vai ver que ele já vai aumentando 5, 6, 7, 8, e eu posso ficar dando quantos likes eu quiser aqui dentro do nosso comentário, perfeito? Pronto, a gente finalizou a nossa funcionalidade de like aqui. Porém, eu quero aproveitar essa aula para a gente conhecer um conceito super importante aqui do React, não é nenhum conceito, mas na verdade, algo que a gente pode ou não pode fazer, que é o seguinte. Imagina que, ao invés de criar essa função aqui em cima, handleLikeComment, eu gostaria de chamar a função setLikeCount diretamente aqui dentro do onClick, ou seja, eu quero que assim que o usuário clique aqui nesse botão, eu aumente o número de likes chamando a função setLikeCount, ou seja, muita gente que está iniciando faz o seguinte, setLikeCount, likeCount, mais um. Vou salvar isso aqui agora, voltamos aqui no Google Chrome, vou dar F5, inspecionar o elemento, já está dando erro pra caramba, too many rehandlers, React limits the number of handlers to prevent an infinite loop, já começou a explodir erro pra caramba na nossa aplicação. Desculpa. Qual que é o problema desse código aqui? Quando a gente estava criando uma função antes e passando dessa forma aqui, qual que era o tipo da informação que eu estava passando para o meu onClick? Uma função, concorda comigo? Isso aqui é uma função. Se eu fizer isso aqui no final, isso aqui continua sendo uma função? Não. Isso aqui passa a ser a execução de uma função. A partir do momento que eu faço isso dentro do meu onClick, o React não vai esperar o clique acontecer, ele vai executar isso aqui automaticamente na hora que ele ler esse código. Ou seja, todos os eventos do React, como onClick, onSubmit, eles esperam uma função como propriedade, como valor. Por isso que a gente não pode fazer isso aqui dentro do onClick, porque aqui eu estou executando uma função. E se eu estou executando essa função setLikeCount, assim que o React ler esse código, e essa função aumenta o número de likes, e toda vez que o número de likes muda, que é um estado do React, esse componente renderiza de novo, ou seja, todo o código desse componente executa de novo, ele vai executar isso aqui de novo, que altera o estado. O estado faz uma nova renderização, aí ele lê de novo e executa de novo, por isso que ele entrou em loop. Ou seja, se eu quero chamar a função setLikeCount diretamente aqui no onClick, a única forma que eu tenho de fazer isso é criando uma arrow function aqui dentro, ou seja, agora assim, veja que isso aqui é uma função, isso aqui não é a execução de uma função. Se eu salvo isso aqui agora, a gente pode inclusive testar que funciona. Diego, existe diferença de eu fazer isso aqui, pra fazer isso aqui que a gente fez aqui em cima? Funcional não. Por questões de legibilidade, eu prefiro isso aqui, criar uma função separada e chamar essa função aqui dentro. Talvez em alguns casos não seja possível, mas na maioria que os casos forem possíveis, tenta fazer isso. Salvo isso aqui agora, nossos comentários aqui, a gente já volta a conseguir dar likes nele sem problemas nenhum. Então sempre lembre disso, todos os eventos onSubmit, onClick, onBlur, onHover, onInvalid, qualquer evento, eles sempre precisam receber como valor uma função, e nunca a execução dessa função, senão a gente vai cair em problemas aí que às vezes a gente vai perder muito tempo procurando a solução."
  },
  {
    "id": "814e355d-e65e-488f-8389-3c534def1023",
    "title": "Cabeçalho da aplicação",
    "transcription": "Para a gente visualizar melhor que o app é carregado em todas as páginas, uma das coisas que a gente pode fazer aqui é, por exemplo, aqui no return, colocar, além do componente, algum outro tipo de retorno. Então a gente pode colocar, por exemplo, uma div aqui por volta do nosso componente, e aqui dentro, se eu escrever, por exemplo, test e salvar isso aqui, eu vou ver que ele aparece teste na página home, e também, se eu entro aqui em uma outra página, por exemplo, a página de sucesso, ele também aparece teste aqui, se eu entro na página de produto, ele também aparece teste aqui. Então tudo o que eu colocar no app, a gente pode entender como sendo algo global, que vai ficar em todas as páginas. E uma das coisas que a gente pode perceber nessa aplicação, é que esse cabeçalho que tem o logo, Ignite Shop, ele é compartilhado em todas as páginas, literalmente. Então a gente vai criar esse cabeçalho aqui pra gente ver como é que funciona. Então o que eu vou fazer? Eu preciso basicamente uma div, uma tag header, e eu preciso dentro dela uma tag image. E pra isso eu vou também aqui selecionar o logo do Ignite Shop, dou um copy as svg, vou criar dentro da pasta src uma pasta assets, e dentro vou criar logo svg e colo o nosso logo aqui dentro. E aí agora eu vou importar logo image from . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . ."
  },
  {
    "id": "29112ca5-ede0-4768-aa98-62a5b095fb95",
    "title": "Fundamentos do TypeScript",
    "transcription": "O que a gente vai começar a ver nessa aula é sobre o uso de Typescript aqui dentro do nosso projeto React. Mas, antes da gente começar a integrar Typescript aqui dentro do projeto, a gente precisa entender o que é Typescript e porque que faz sentido utilizar essa tecnologia nos nossos projetos e não simplesmente escrever código JavaScript como a gente já está acostumado ou acostumado. Typescript, antes de mais nada, nasceu como um superset, um conjunto ferramental em cima da linguagem JavaScript pra você conseguir adicionar tipagem estática em cima de uma linguagem como JavaScript que tem tipagem dinâmica. E aí, se você não sabe o que é tipagem estática ou dinâmica, no JavaScript, por exemplo, nós podemos pegar uma variável, por exemplo, const name Diego, e no momento que a gente quiser trocar o valor dessa variável pra 3, por exemplo. E... Names depreciaram minha variável do meu próprio código, mas beleza. A gente pode alterar o tipo da informação que a gente armazena nas variáveis no momento que a gente quiser. Isso é bom, porque traz flexibilidade, traz dinamismo, a gente mesmo disse, tipagem dinâmica. Mas é ruim, porque abre portas pra gente cometer muitos erros aqui dentro da nossa aplicação. Além dessa questão do Typescript ajudar a gente a não cometer erros, principalmente na questão do tipo das variáveis, antes uma coisa era uma string e agora eu vou lá e jogo um número no lugar e sei lá o que vai acontecer. Além disso, o que eu acho que é o principal, o Typescript ajuda a gente muito no momento de desenvolvimento da nossa aplicação, porque ele traz inteligência pro nosso editor de código. E a gente vai ver como isso funciona na prática. Imagine que no seu código você tenha uma função que recebe uma lista de usuários e ela deve retornar a soma da idade de todos esses usuários. Então, eu vou dar um nome pra essa função de sumAge, ela recebe aqui uma lista de usuários e agora ela vai, pra somar a idade dos usuários, tem várias formas de fazer, uma é utilizando o reduce, mas aqui pra ficar mais claro eu não vou usar o reduce, porque ele acaba deixando a nossa sintaxe um pouquinho mais complexa de entender, principalmente pra quem nunca utilizou muito o reduce. Então, eu vou botar assim const sum, começa em zero, e aí eu vou percorrer cada usuário da lista de usuários e vou fazer sum mais igual user.age e no final eu retorno essa soma aqui. Como esse código aqui é Javascript, primeira coisa que eu falei lá, o Javascript não bloqueia a gente, na hora que a gente for chamar essa função, de enviar uma informação num formato errado. Então, se eu enviar aqui, por exemplo, uma string escrito test, o Javascript não vai reclamar. A gente só vai descobrir que isso aqui deu erro na hora que a gente executar a nossa aplicação. Outra coisa é o seguinte, quando eu percorri a minha lista de usuários aqui, eu assumi que dentro de cada usuário vá existir uma informação chamada age, mas nesse caso aqui, como é um exemplo, se não fosse um exemplo, eu teria que saber se essa informação age aqui, ela realmente tem um nome age, se ela realmente vem aqui como uma propriedade do usuário, se ela não está dentro, talvez, se na verdade não vem a data de nascimento do usuário e eu preciso calcular a idade. Ou seja, aqui como é um exemplo, eu assumi que a informação que vem aqui dentro é age, mas num cenário real, eu teria que olhar, procurar no meu código, onde esse usuário é definido, dar um console.log para aí ver onde está esse campo age. Vou trocar aqui agora a linguagem de Javascript para Typescript para a gente ver algumas coisinhas aqui que o Typescript já começa a avisar a gente. Vamos lá, primeira coisa, a gente começou a ver que ele deixou alguns sublinhados aqui no nosso código. Primeiro aqui, nós estamos criando uma constante e mudando o valor dela, não pode, a gente troca aqui o let. E aqui eu não sei se você sabe dessa curiosidade de onde vem o nome let e const, const é constante, e o let vem de let it change, como o var que é de variável já estava sendo utilizado, o let vem de let it change, deixe isso mudar, ela vai mudar. Então let sum é igual a zero e aqui eu estou somando. A gente pode ver outro sublinhado aqui que é no users, passo o mouse aqui em users e ele fala, opa, o parâmetro users implicitamente, ou seja, de forma automática, tem um tipo N, mas o melhor tipo pode ser inferido do seu uso. O que essa mensagem aqui está falando? O Typescript não consegue saber que tipo de informação é users, se é uma string, se é um número, se é um array, se não é. Para ele isso aqui é N, N no inglês é qualquer, qualquer tipo, ele não sabe o que é. E é por isso que eu posso enviar para essa função qualquer coisa, um número, posso enviar um array vazio, posso enviar um objeto vazio, posso enviar um true, tudo vai funcionar. Não é isso que a gente quer. Por isso com o Typescript eu posso criar tipagens falando exatamente o que cada variável, cada parâmetro da minha função espera. Por exemplo, aqui eu vou criar uma interface, nesse caso aqui não precisa ser uma interface, na verdade, não pode ser, uma interface falando, olha, cada usuário da minha aplicação, ele tem um nome, ele tem uma biografia e tem uma idade, que é um número. Agora eu venho aqui no meu parâmetro users, coloco dois pontos para indicar a tipagem e falo, esse parâmetro users aqui, ele tem o formato user, porém é um array de usuários, não é só um usuário. Nesse caso, quando é um array de usuários, eu coloco coxetes aqui no final, abre e fecha coxetes, ou eu escrevo array dessa forma por volta, só que eu acho muito feio, aí eu escrevo dessa forma que fica melhor. Agora veja que interessante, ao chamar a função sumAge, ele não deixa mais eu enviar true, ele não deixa mais eu enviar string, ele não deixa mais eu enviar um número, eu só posso enviar para essa função um array de usuários. E o mais legal, se eu coloco um array vazio, ele permite, porque em nenhum momento eu estou falando aqui na função que o array precisa ser preenchido com alguma coisa, quando eu for colocar um novo usuário aqui dentro, veja que eu coloquei um objeto aqui para indicar que é um novo usuário, ele já deu erro. Opa, passando o mouse por cima ele fala, opa, o objeto vazio está faltando propriedades do user, name, bio e age, ou seja, esse objeto que eu estou passando para essa função não tem as propriedades aqui que eu preciso do usuário. E aí se eu dou um enter aqui dentro desse objeto e dou um ctrl espaço, lembra que eu falei que o TypeScript transforma, deixa o seu editor mais inteligente. Se eu dou um ctrl espaço aqui, ele fala para mim quais são as informações que eu tenho que botar nesse usuário. Então, eu já sei que eu posso botar name, Diego, ainda está dando erro, se eu passo o mouse por cima, está faltando aqui o bio e o age, biografia, vou botar aqui qualquer coisa, sitio, e age que é o último, 27. E já parou de dar erro. Massa né? Outra coisa muito legal do TypeScript é que a gente não precisa colocar tipo em tudo. Por exemplo, se eu criar aqui uma variável fora dessa função, que o nome dela é sumOfAllUserAges, a soma de todas as idades dos usuários. Eu não preciso vir aqui e falar, opa, essa variável aqui vai ser um número. Eu posso, mas eu não preciso. Por quê? Porque o TypeScript tem um funcionamento interno que a gente chama de inferência de tipos. O que é a inferência de tipos? Veja só. Essa função aqui, ela recebe uma lista de usuários. Dessa lista de usuários, ela está criando uma variável sum, que é zero, ou seja, é um número. Ela percorre a lista de usuários e para cada usuário, ela aumenta o valor de sum, que é um número, ao valor da idade do usuário, que também é um número. E no final, ela retorna um número. Se eu chamo essa função aqui, o que ela me retorna? Um número. O TypeScript já sabe disso. É como se ele lesse o código da função e ele, ah, já entendi, no final ela me retorna um número. Então, eu não preciso passar isso aqui. Ou seja, se o TypeScript não estiver sinalizando para você com aqueles três pontinhos, como a gente tinha visto aqui em cima no Users, quer dizer que ele entendeu automaticamente o tipo de uma informação. Se eu passo o mouse por cima de sum of all user ages, já está ali o número. A gente já sabe que isso aqui é um número. Eu não preciso me preocupar em colocar a tipagem. E é muito legal isso porque dentro aqui, por exemplo, da função, quando eu for utilizar aqui o nosso objeto user, que vem da listagem de usuários, e eu dou um user ponto, ele também já me retorna quais são as informações que eu tenho no usuário. Ou seja, com o TypeScript, a gente ganha em perceber os erros antes, sem precisar executar a nossa aplicação, já aqui no editor, e a gente ganha também inteligência na nossa IDE, no nosso editor. Assim, a gente consegue escrever um código com muito mais segurança, com mais confiança, e a gente vai seguros que o código que a gente está escrevendo vai para a produção, vai funcionar sem erros. Cara, isso aqui é muito legal porque se eu tentasse, por exemplo, somar o nome do usuário, ele ia dar erro já. A gente já pode ver que ele começou a dar erro. Por quê? Porque eu estou tentando adicionar uma string, o nome aqui no caso é uma string, para uma variável que é um número. O sum aqui é um número. Não faz sentido. Ou seja, o TypeScript avisa para a gente dos erros antes deles acontecerem. E TypeScript era uma daquelas coisas que até um ano, dois anos atrás, dependendo de quando você está vendo esse vídeo, eu até diria que é algo opcional para você estudar. Mas a partir de hoje não. TypeScript se tornou uma ferramenta fundamental, eu utilizo em todos os projetos, sem exceção, sejam projetos React, React Native, sejam projetos Node. Porque o TypeScript tem, claro, uma curva de aprendizado no início, mas depois que você pega o jeito, principalmente dessas coisas simples, a produtividade na hora de escrever código é muito maior do que escrevendo código com JavaScript sem tipagem."
  },
  {
    "id": "b72b53c9-c629-404e-ab97-efc19a15504a",
    "title": "Componente: Avatar",
    "transcription": "Uma coisa que você pode ter percebido durante a construção da nossa página, no layout, é que os componentes de avatar que a gente tem aqui, aqui e aqui no comentário são muito parecidos. A única diferença é que aqui nos comentários a gente não tem a bordinha. Dentro do React existe dois grandes momentos onde a gente cria um componente. É até importante você anotar isso. Existe o primeiro momento, que é o mais fácil de identificar, que é quando alguma coisa repete muito em tela. Quando alguma coisa você percebe que aquilo está repetindo, e geralmente com o mesmo visual, com o mesmo comportamento, o mesmo funcionamento, provavelmente isso deveria virar um componente. O segundo ponto onde você vai criar um componente é quando você consegue tirar algo de um componente maior sem que aquele componente maior pare de funcionar. Assim você deixa aquele componente maior mais limpo com a funcionalidade mais clara de receber manutenção. Então, por exemplo, e a gente vai passar por esses exemplos, claro, ao longo dos vários projetos que a gente vai desenvolver. Mas imagina um exemplo onde eu tenha... Deixa eu pensar aqui a melhor forma de dar um exemplo que seja realmente muito bom, para você não ter dúvidas. Imagina que, por exemplo, eu tenha uma tela. Uma tela que lista todos os meus usuários, certo? E aí nessa tela de listagem de todos os meus usuários do banco de dados, lá em cima eu tenho um botão para eu conseguir fazer upload de usuários através de um Excel da vida. Isso é muito comum em sistemas. Se você já trabalhou em algum sistema, um RP, um CRM, geralmente a gente tem uma listagem, tem uma opção para o usuário fazer upload de um arquivo CSV, XLS, para a pessoa fazer um upload em massa de usuários ou de qualquer outra coisa. E aí, esse botão de upload tem um funcionamento específico dele. Então, a gente precisa identificar quando a pessoa clicou no botão de upload para abrir a caixa para ela selecionar um arquivo. Quando ela seleciona um arquivo, a gente tem que fazer o upload desse arquivo lá para o nosso back-end, para ele fazer o processamento, cadastrar isso no banco de dados. Ou seja, o botão de upload tem todo um funcionamento que não interfere na listagem de usuários. Ou seja, isso é o caso 2 que eu estava falando. Você consegue pegar esse botão de upload, colocar ele dentro de um componente, mesmo que ele não seja reutilizado em vários outros lugares da aplicação. Mas você consegue botar ele dentro de um componente, porque assim a nossa listagem de usuários fica mais limpa. Se a pessoa quer dar manutenção na listagem de usuários, ela não precisa ter na tela dela toda a lógica de upload de arquivos CSV, XLS. Ou seja, a gente reparte essa nossa lógica em outro componente para que quando a gente for dar manutenção especificamente no upload do arquivo, CSV ou XLS, qualquer coisa assim, a gente também não veja o código da parte de listagem de usuários. Então, existem esses dois grandes momentos que a gente vai criar componentes dentro da nossa aplicação React. Primeiro, quando algo está repetindo muito. E o muito não precisa ser tantas vezes. Até que no nosso caso da aplicação, aplicação muito pequena, a gente vê o avatar repetindo 3 vezes com uma estilização igual ou praticamente igual. Isso aqui, no tamanho de aplicação que a gente tem aqui agora, já é justificável uma criação de componente. Porque me parece muito que se esse projeto aqui continuasse crescendo com mais e mais telas e mais funcionalidades, me parece que só do tanto de vezes que o componente avatar apareceu aqui, ele apareceria muito mais com certeza. Então, a gente tem esse primeiro caso. E o segundo é quando a gente consegue desacoplar um pedaço da lógica e da estrutura e do visual de algum componente para outro componente menor, para assim a gente ter um código menor para dar manutenção em duas coisas diferentes. Então, é claro que isso vai ficando muito mais claro conforme você vai desenvolvendo mais projetos e mais projetos e mais projetos. Mas já deixo o adendo aqui. Você tem que cuidar também, como qualquer coisa em programação, enquanto a gente fala de otimização prematura, porque não necessariamente todo momento você precisa criar um componente novo só porque duas coisas se parecem. Parece que você está repetindo. Calma. Às vezes esse conceito de DRY que a gente fala, o Don't Repeat Yourself, ele não precisa ser tão levado a sério assim, tão à risca, porque o DRY muitas vezes parece que a gente precisa evitar qualquer tipo de repetição de código. Mas muitas vezes não. Muitas vezes a gente tenta evitar repetição de código e a gente acaba criando um monstrinho, porque a gente cria ali... Pô, olha só. Eu tenho dois botões aqui. Eu repeti eles. Me parece que eles são semelhantes. Por que eles são semelhantes? Porque eles têm um texto dentro e uma caixa por volta? Tá, mas um tem ícone, o outro não tem. Um não tem preenchimento, o outro tem. Ou seja, às vezes coisas que parecem semelhantes para a gente, não necessariamente elas precisam virar um componente. Se eu fosse criar um componente para esse botão, eu teria que criar muitas variações com ícone, sem ícone. Preciso criar um botão que tenha fundo, outro que não tem fundo. E aí, novamente, eu acabo criando um monstrinho, que às vezes é mais fácil eu não ter um componente do que ter um componente que recebe muitas e muitas variações. Então, isso é um grande aprendizado para você, e você vai levar ao longo de toda a sua carreira desenvolvendo projetos com React. E agora, então, depois dessa explicação, a gente vai sim criar esse componente de avatar. Então, bora lá. Vou aqui no meu VSCode, aqui dentro de Components, eu vou criar o meu avatar.jsx e o meu avatar.module.css. Aqui no nosso avatar, para manter ele o mais simples possível, eu vou copiar um avatar que a gente já tenha em algum outro lugar. Por exemplo, na sidebar, eu tenho aqui o meu avatar. Recorto a imagem daqui de dentro, coloco aqui dentro do avatar. No caso aqui, o nosso source, eu quero que ele não seja fixo, ou seja, cada vez que a pessoa utilizar esse componente de avatar, ela pode passar um avatar diferente. Não faz sentido eu ter um componente de avatar que a foto é sempre a mesma. É claro que aqui, por enquanto, os dados são estáticos, mas se a gente fosse integrar isso com o back-end, não seria. Cada post seria de um usuário diferente. Então, isso aqui, por exemplo, é uma das coisas que a gente quer que nesse componente aqui seja variável. E a gente já descobriu esse conceito, já conheceu esse conceito antes, que é utilizar o conceito de propriedades. Então, aqui eu posso receber propriedades nesse componente, e aqui no source, por exemplo, eu posso usar uma propriedade, por exemplo, também source, que eu envio para esse avatar. E agora, assim, aqui na sidebar, quando eu for utilizar o componente de avatar, que aqui ele já dá, inclusive, a opção para eu fazer um autoimport desse componente, já fez a importação, eu passo para ele agora o nosso source, opa, aqui, que é o endereço do nosso avatar. Então, agora eu salvo isso aqui agora, o nosso componente já está pronto. Se eu voltar lá na nossa aplicação, a gente vai ver que, bom, alguma coisa está dando errado. Vamos dar uma olhadinha aqui no console do navegador. Styles is not defined. Aqui dentro do avatar, então, eu estou utilizando class name styles avatar, só que isso aqui não existe ainda. Então, inclusive, a gente pode remover aqui só para testar, dar um F5 aqui na nossa aplicação, e a gente vai ver aqui que o avatar agora já está mostrando, só que ele não aplicou os estilos. Mas a gente já está conseguindo aplicar o avatar. Inclusive, aqui da sidebar, eu posso trocar o nome do usuário aqui. Qual usuário que eu posso botar aqui? Vou botar algum usuário da Rocket. Vamos procurar algum usuário massa aí para a gente colocar. Vou botar aqui Mike Brito. Mikebrito.png. Então, já aparece a foto do Mike ali. O componente avatar recebe uma propriedade source, ou seja, sempre que a gente quer que um componente tenha algum elemento visual diferente de acordo com aonde ele é aplicado, a gente usa uma propriedade. Aqui agora no nosso CSS, eu vou criar aqui uma estilização para o avatar, e a gente vai trazer a estilização que hoje está aqui no sidebar, aqui dentro de avatar. Vamos tirar daqui. E eu jogo agora aqui para dentro do nosso avatar. Salvo. E agora aplico o CSS aqui. Então, import styles.from.avatar.module.css. E aqui, class name styles.avatar. Salvo. E olha lá, já está a fotinha do Mike Brito totalmente normal. Agora a gente vai utilizar esse mesmo componente aqui no post. Então, vamos lá no post. Aqui em cima o avatar está aqui. Eu vou só substituir toda essa parte do class name. Vou deixar o source. E aqui eu vou usar avatar. Ele já dá novamente a importação automática. Só clicar em cima. Ele já fez a importação do avatar. Salvo. E já está funcionando aqui com a foto do Diego. Se eu troco para Mike Brito novamente, já troca aqui também. Então, aqui... Deixa eu fechar o aplicativo de mensagem aqui. Às vezes eu esqueço de fechar as coisas antes de começar a gravar. E fica aí um monte de coisa aberta. Mas, beleza. Agora, a gente pode tirar aqui do post também a estilização do avatar. Então, vamos procurar aqui. Author image. Aqui, olha. Vou tirar toda essa estilização do avatar aqui. Ele vai continuar normal. Porque agora a gente está usando um componente. Agora, lá no meu comentário, eu tenho um avatar também. Aqui em cima. Então, a gente vai novamente trocar a image por avatar. Salvo. E agora vem o problema. No caso dos comentários, o nosso avatar não tem a borda verdinha. Então, a gente precisa novamente, no caso do avatar nos comentários, ter um visual diferente. E aí, a gente precisa relembrar. Porque a gente já sabe como fazer isso. Talvez você não esteja lembrando. Talvez você não esteja lembrando. Mas, quando a gente quer que um elemento tenha algo visualmente diferente, ou o funcionamento dele seja diferente, dependendo de onde ele for colocado na aplicação, eu preciso usar propriedades. As propriedades são a única forma que eu tenho, do contexto onde aquele componente foi colocado, avisar para o componente. Olha, eu quero que você tenha isso. Não tenha isso. Eu quero que você tenha esse funcionamento. Eu quero que você não tenha. Então, é a única maneira de a gente comunicar os componentes aqui no React. São as propriedades. Então, aqui no caso, por exemplo, do comentário, eu poderia enviar uma propriedade para esse avatar, falando que eu não quero que ele tenha a borda, por exemplo. E aqui sou eu que dou o nome das propriedades. Então, eu falo, por exemplo, vou mandar uma propriedade chamada HasBorder. E aqui eu vou enviar ela como FALSE. Super importante, quando eu for trabalhar com booleanos, como eu estou mandando aqui uma propriedade que pode ser TRUE ou FALSE, eu colocar as chaves por volta, porque os booleanos não existem no HTML. Então, eu não posso fazer isso aqui, FALSE. Senão, ele vai entender isso aqui como um texto. Então, aqui eu mando uma propriedade, por exemplo, HasBorder FALSE. E agora, eu salvo isso, venho aqui no meu avatar, e agora eu tenho acesso a essa propriedade HasBorder. E aí, o que eu poderia fazer aqui? Para quando ele tiver a propriedade HasBorder, eu colocar a borda. Quando ele não tiver, eu não coloco a borda. A gente pode vir aqui no nosso CSS, pegar toda essa parte aqui da borda, e vamos criar aqui um avatar WithBorder. E vamos colocar esse estilo aqui. O avatar sem a borda, a gente volta para o original, que é essa estilização aqui. E agora, a gente faz o seguinte. Aqui dentro da classe, eu faço um IF. Se as minhas propriedades contém HasBorder, eu vou mostrar o styles.avatarWithBorder. Se não, styles.avatarTradicional. E aqui, como ficou bem grande, eu gosto novamente de separar cada propriedade em uma linha, porque fica mais legível. Vamos testar. Eu vou salvar isso aqui agora, volto... Ficou tudo sem borda. Por quê? Porque lá no post, por exemplo, eu não mandei aqui a propriedade HasBorder. E como ela não tem nenhum valor default, ele não vai mostrar a borda. Então, eu teria que vir aqui no post, por exemplo, e falar HasBorder true. Se eu faço isso aqui, a gente vai ver que aqui no post, agora eu já tenho a minha borda. Ou melhor, no React, quando eu quero enviar uma propriedade que o valor dela é true, o booleano true, eu posso omitir o envio do valor. Eu passo só HasBorder. O React já vai entender que isso aqui é uma propriedade, que é HasBorder, e que o valor dela é true. Eu não preciso nem enviar valor. Olha só, eu salvo e continua funcionando. Dá para melhorar isso aqui. Imagine que, por padrão, eu queira que todo avatar que não receber a propriedade HasBorder como falsa tenha essa propriedade como true, por padrão. Então, eu posso remover isso aqui. E aí, eu venho lá no meu avatar. E aqui, eu posso fazer isso aqui de duas formas. Então, eu posso criar, por exemplo, uma constante. HasBorder é igual, se a propriedade HasBorder existir, se não... Ou melhor, se a propriedade HasBorder... Agora eu me perdi. Se a propriedade HasBorder for diferente de falsa, quer dizer que ele tem borda. Ou seja, se a propriedade não for nem enviada, ela também é diferente de falsa. E aí, eu posso usar isso aqui. E vai funcionar. Agora, aqui já tem borda, aqui tem borda e aqui não tem borda. Dá para melhorar. Quer saber como? Eu posso, por exemplo, usar o conceito de desestruturação no JavaScript. O que é o conceito de desestruturação no JavaScript, caso você nunca tenha usado? Se eu tenho um objeto, nome, igual a Diego, por exemplo, const usuário igual name Diego, nesse formato aqui, eu consigo pegar o nome do usuário fazendo isso aqui. Isso aqui a gente chama de desestruturação. Eu boto um objeto do lado esquerdo da minha operação, e aqui eu estou falando que eu quero arrancar o nome de dentro desse objeto. E sabe o que é o mais legal da desestruturação? É que a gente pode usar desestruturação aqui nas propriedades. Então, por exemplo, se eu colocar aqui no lugar de props eu posso falar, olha, eu quero buscar apenas as propriedades hasBorder, quero buscar a propriedade src, e aí aqui embaixo vai ficar somente src, e aqui vai ficar hasBorder, e aqui eu posso definir valores default, ou seja, se essa propriedade não tiver nenhum valor, o valor default dela vai ser true. Então, quando a gente aplica desestruturação, a gente consegue aplicar valores default aqui para as nossas propriedades. E agora eu salvo isso aqui agora, volto, e está tudo funcionando normal. E cara, nessa aula a gente aprendeu muita coisa interessante que você vai trabalhar muito aí nas suas aplicações React."
  },
  {
    "id": "98ee71a0-80a7-4068-b29e-f328f5aac324",
    "title": "Configurando Stitches",
    "transcription": "O que a gente vai fazer nessa aula é instalar e configurar uma das bibliotecas que a gente vai estar utilizando aqui ao longo do projeto para a parte de estilização, que é o Stitches. O Stitches, se você nunca ouviu falar, ele é, digamos, uma alternativa ao Styled Components, porém, ele tem uma API, uma forma de escrever as estilizações de uma maneira um pouquinho diferente, que, na minha opinião, é melhor do que a forma que o Styled Components tem, principalmente para a gente lidar com componentes visuais que tem muitas variações de estilo, baseado em propriedades. Então, imagina que a gente tenha um botão, e esse botão, que é o nosso componente, ele tem muitas variações, ele pode ser de várias cores, de vários tamanhos, com ícone, sem ícone. Quando a gente tem esses tipos de componentes que têm muitas variações, no Styled Components a gente acaba tendo uma sintaxe de escrever essas variações lá dentro do CSS, um pouco estranha, na minha opinião. E aí o Stitches vem para resolver esse problema. E a ideia do Stitches é que ele funciona também muito bem junto com o Next, com a função de server-side-rendering do Next, e tudo mais. A gente vai entender um pouquinho como que isso funciona ao longo, enquanto a gente vai instalando ele. Eu vou copiar aqui o script de instalação. Eu vou parar o servidor Next, porque a gente vai ter que instalar bibliotecas novas. Então, vou instalar o Stitches React. E aí agora, a gente vai simplesmente, aqui na pasta source, criar uma pasta styles. E dentro dessa pasta styles aqui, eu vou criar um index.ts. Aqui dentro agora, eu vou importar uma função de dentro da biblioteca Stitches React, chamada createStitches. Essa createStitches aqui, ela vai devolver para a gente uma série de configurações. Logo, eu falo um pouquinho sobre isso. Mas, ao chamar essa função createStitches, eu consigo configurar algumas coisas aqui dentro da nossa aplicação. Então, o Stitches permite que a gente tenha, por exemplo, um tema global. Então, a gente consegue aqui na variável theme, por exemplo, falar que a gente tem um tema de cores. E aqui dentro de theme, veja que eu posso configurar praticamente valores de temas para a grande maioria das variáveis do CSS. Então, para sombras, border-radius, line-height, letter-spacing, font-size, font-weight, qualquer tipo de font, colors, border-width. Então, ele traz para a gente, basicamente, todas as propriedades que a gente pode configurar em projetos CSS. Mas aqui em colors, eu posso simplesmente criar minhas próprias cores. Então, aqui dentro eu posso falar, olha, eu quero que exista uma cor chamada rocket-seat. E essa cor, ela tenha o valor 8257e6, um hexadecimal. E agora, o que a gente vai fazer? Esse config, eu preciso exportar ele para que eu consiga importar isso em outros lugares da nossa aplicação. Mas, eu posso exportar isso de algumas formas. Eu posso vir aqui, de dentro desse config, eu tenho várias coisas. Eu preciso exportar tudo isso aqui, que está aqui dentro. Então, tem várias formas de eu fazer. Para mim, a mais simples é eu vir aqui no próprio const e fazer o seguinte, export. E aqui no lugar de escrever config, eu faço uma desestruturação. Olha que legal. E aqui eu já pego e faço todas as exportações. Então, eu vou exportar daqui de dentro o próprio config. Vou exportar o style, que a gente vai precisar estar utilizando. Global CSS. Keyframes. Get CSS Text. Theme. E Create Theme. São as propriedades que a gente vai exportar daqui de dentro. E também faltou uma última aqui, que eu vou exportar, que se chama CSS em si. Então, isso daqui são todas as propriedades que a gente vai exportar aqui dentro do speeches. E agora, para a gente testar como que o speeches funciona. Olha que interessante. A gente vai lá no nosso componente index.tsx. E aqui dentro, eu vou dar o exemplo que eu acabei de mostrar. Imagina que a gente queira criar um componente estilizado, que é um botão. Assim como no styled components, a gente vai fazer a criação desse botão como um componente separado. Então, eu vou criar aqui, por exemplo, uma constante, button. E lá no styled components, a gente fazia styled.button. Aqui no speeches, a gente também vai importar o styled. Cuida, porque o styled tem que ser esse que vem da nossa pasta styles, e não da biblioteca speeches-react. E aqui eu não vou escrever .button. Eu vou colocar parênteses, porque o styled é uma função. O primeiro parâmetro é qual a tag HTML. Nesse caso, button. E o segundo parâmetro é um objeto com estilizações. Aqui começa a mudar um pouco as coisas, porque no speeches, a gente escreve as estilizações como sendo um objeto JavaScript. Ou seja, a sintaxe também vai precisar ser uma sintaxe igual ao JavaScript. Ou seja, ao invés de eu escrever, por exemplo, background-color, eu escrevo background-color com C maiúsculo. No caso do speeches, ele tem todo o suporte ao TypeScript. Então, se eu dou um ctrl-espaço aqui, ele vai trazer também para a gente. Digitando aqui, ele já traz para a gente todas as propriedades que eu posso utilizar. Então, background-color. E aqui, agora, eu posso, por exemplo, escrever purple. Ou, se a gente não escrever nada aqui e dar um ctrl-espaço, veja que aqui embaixo, está vendo que ele está botando $rocketseat. Ele automaticamente entendeu aquela variável que a gente criou aqui, chamada rocketseat. E toda vez que eu for escrever uma propriedade, o valor de uma propriedade que é uma cor dentro do speeches, ou seja, uma background-color, uma border-color, qualquer coisa que seja cor, a gente pode, e ele vai aparecer para a gente, essa opção aqui, rocketseat. Todo o restante que está aparecendo aqui é porque eu uso o Tab9. Então, ele tenta trazer para a gente alguns completes aqui. Mas, no caso, eu vou estar utilizando rocketseat. E agora, eu vou trocar aqui esse H1 pelo nosso button. E dentro, eu vou escrever, por exemplo, enviar. Só para a gente ver como que isso funciona. Eu salvo, rodo npm run dev, abro aqui o Google Chrome, venho lá, dou um F5, e a gente pode ver que o nosso botão já está aparecendo ali dentro. E aqui eu posso fazer qualquer outro tipo de customização. Eu posso escrever, por exemplo, border-radius. Como o border-radius é numérico, eu não sou obrigado, eu posso, mas eu não sou obrigado a colocar uma string e escrever 8 pixels. Eu posso escrever, por exemplo, 8. E ele vai converter isso aqui para pixels automaticamente. Salvo. E olha só, ele já aplicou 8. Eu acho que ficou um pouquinho demais aqui, né? Vou botar 4. Posso botar um border-0, por exemplo. Posso colocar aqui um padding. No caso do padding, eu posso colocar o padding específico, digamos, para um lado ou para o outro, left, right, ou eu posso colocar como uma string e aí eu passo o valor de todos os lados. Então eu quero que seja 4 pixels em cima, 8 pixels nas laterais. E aí salvo, o botão já está estilizado. E aqui o legal do Stitches é que eu posso trabalhar também com a parte de encadeamento. Então imagina que eu tenha, por exemplo, dentro do botão um span escrito test. A gente pode ver que o test já apareceu aqui dentro. Se eu quero estilizar esse span que está dentro do nosso botão, basta eu fazer o seguinte, eu coloco entre aspas span, ou melhor, nem precisa, né? span, dois pontos. E aqui eu dou, por exemplo, um font-weight bold. Salvo. E a gente pode ver que agora o span aqui já ficou em negrito. Então eu estou fazendo o encadeamento de estilização do span dentro do botão. E eu posso trabalhar também aqui, por exemplo, com hover. E aí nesse caso a gente coloca o e-comercial. O e-comercial indica o próprio elemento, o próprio botão. Dois pontos, hover, o estado de hover aqui. E aí eu vou trocar, por exemplo, a cor de fundo, ou eu posso aplicar aqui um filter, brightness 0.8. Acho que é assim que se escreve. Salvo. E agora quando eu passo o mouse por cima, ele dá uma escurecida no botão. Então a gente vai trabalhar aqui com stitches praticamente da mesma forma que a gente trabalha com o styled components. Mas tem algumas coisinhas diferentes, né? Então ao longo do tempo a gente vai ver sobre isso aí. Mas antes da gente finalizar essa aula, é importante a gente entender uma coisa aqui que é super importante do Next, que a gente já falou antes, mas que quando a gente começa a trabalhar com estilização, isso começa a ficar um pouquinho mais importante da gente falar sobre. Então o que acontece? Olha só. Se eu dar um F5 aqui na minha página, eu vou ver que sempre que o CSS está sendo aplicado, sem problemas nenhum. Mas se eu for aqui no inspecionar elementos, for aqui nessa engrenagem e desabilitar o JavaScript da nossa página e dar um F5, eu vou ver que o CSS aqui não foi aplicado, digamos assim, por completo. A nossa cor, por exemplo, roxa lá do fundo, não foi aplicado. Aqui o font-weight bold também não foi aplicado. Isso aqui está um botão tradicional do HTML. A gente não tem nada de CSS aqui aplicado no nosso botão. E aí, por que isso acontece? Porque a grande maioria das bibliotecas de CSS que a gente trabalha no React, são bibliotecas que estilizam o nosso componente em runtime. Runtime quer dizer tempo de execução. Ou seja, elas aplicam o CSS nos nossos elementos, nos nossos componentes, somente no lado do front-end, ou seja, no navegador do usuário. O Next trabalha com esse conceito de server-side rendering, ou seja, a gente pode ver que mesmo eu desabilitando o JavaScript, o conteúdo da minha página continua sendo exibido em tela. Diferente de caso você pegue uma aplicação escrita com o Vite, ou com o Create React App, ou que não tenha Next no geral, esse código aqui da interface, na verdade ele nem vai aparecer nesses casos quando você desabilita JavaScript, porque todo o código da interface é criado em runtime. No Next, como eu já expliquei lá no Figma, com aquele nosso flowchart, deixa eu ver se até eu acho aqui, falando um pouquinho sobre o Next. No Next, quando o usuário acessa a nossa página, na verdade o usuário está acessando um servidor em Node. E esse servidor Node, que é o servidor do Next, é ele que monta toda a nossa interface pelo lado do servidor e ele retorna o HTML completinho aqui para o browser. Por isso que a gente consegue visualizar a interface da nossa aplicação, o HTML da nossa aplicação, mesmo com o JavaScript do browser desabilitado, porque não é ele que está montando a interface, e sim quem está montando a interface é esse servidor Node aqui que está rodando, e aí por isso que a interface já chega pronta para a gente. Mas para o CSS também funcionar nesse modelo, para a gente também conseguir ter o CSS funcionando nessa camada aqui do servidor Next, e não só aqui na camada do front-end diretamente, do runtime, a gente precisa configurar algo no Stitches, e aí na própria documentação do Stitches, se a gente vier aqui na esquerda e procurar por server-side-rendering, ele já indica para a gente quando a gente estiver utilizando o Next para fazer essa configuração. Olha só, a gente vai abrir aqui o document, que é aquele arquivo que a gente já tinha mexido anteriormente, e aqui dentro nós vamos colocar dentro da tag head uma tag style, o id dela precisa ser stitches, e aí dentro dessa tag a gente vai colocar uma propriedade chamada DangerouslySetInnerHTML, e aqui dentro eu boto um objeto, eu boto um objeto, underline, underline, HTML, dois pontos, e aqui eu passo a função getCSSText, que vem lá do nosso arquivo styles que a gente criou previamente. Essa função getCSSText, o que ela vai fazer no final das contas? Quando o usuário carregar a nossa página aqui, ela vai pelo lado do back-end, pelo lado aqui do nosso servidor Next, ela vai carregar essa página aqui dentro, montar essa página aqui dentro, ver qual que é todo o código CSS necessário para aquela página, e retornar dessa função. E aí ele vai escrever esse código CSS dentro de uma tag style. Quer ver como é que funciona? Vamos olhar na prática. Então eu vou reiniciar o meu servidor aqui Next, abro aqui, vou dar um F5, e agora a gente pode ver que os estilos foram aplicados, mesmo com o JavaScript desabilitado, e se eu for aqui no inspecionar elementos, dentro da tag head, e procurar aqui pelo style com id stitches, veja que todo o CSS que é necessário para mostrar esse botão, toda a parte aqui do hover, toda a parte do span com font-weight bold, a cor aqui da rocket seat, tudo isso foi aplicado dentro dessa tag style aqui. Então é muito legal porque a gente consegue também trazer o CSS pronto do lado do servidor. Isso tem muitas vantagens. Uma das vantagens, claro, é que a gente pode ver a nossa página visualmente bonita, mesmo com o JavaScript desabilitado, mas a principal vantagem não é essa. A principal vantagem é que o lado aqui do servidor, ele provavelmente é muito mais rápido para criar esse CSS do que necessariamente o runtime, que é o browser do usuário que está acessando a sua aplicação. Então a aplicação, ela ganha performance com a gente fazendo essa renderização, tanto do CSS quanto do HTML, pelo lado aqui do nosso servidor."
  },
  {
    "id": "59af30b1-568a-4482-9c29-5241160a9173",
    "title": "Criando countdown",
    "transcription": "O que a gente vai fazer nessa aula é o nosso countdown. Então, agora que a gente já tem o ciclo ativo na nossa aplicação, quando eu tiver esse ciclo ativo, eu vou fazer com que o timer aqui vá reduzindo. Uma coisa importante é, a pessoa insere hoje o número de minutos do ciclo, porém, a gente vai reduzir o número que já passou aqui do ciclo em segundos, vai passar um segundo depois do outro. Então, eu preciso de alguma forma conseguir manusear esse countdown aqui em segundos e não minutos. Então, uma das coisas que eu vou fazer aqui na nossa aplicação é o seguinte, olha só. Eu vou criar aqui uma variável que vai converter o número de minutos que eu tenho no meu ciclo, que é inserido pelo usuário, em segundos, porque é mais fácil eu trabalhar com segundos do que minutos, porque o timer vai reduzir de segundo em segundo. Então, eu vou criar aqui uma variável chamada total, total seconds, por exemplo, e aí eu tenho que lembrar que o meu ciclo pode estar ativo ou não. Quando a pessoa dá um F5 na tela, não fica com nenhum ciclo ativo. Então, se eu tiver um ciclo ativo, essa variável aqui vai ser o número de minutos do ciclo, vezes 60, porque cada minuto tem 60 segundos. Se eu não tiver um ciclo ativo, essa variável aqui vai ser zero. E agora, como a gente acaba reduzindo de um em um segundo, o que eu vou fazer? Eu vou criar um novo estado aqui em cima, chamado amountSecondsPassed. O que essa variável vai armazenar? O tanto de segundos que já se passaram desde que o ciclo foi criado, desde que o ciclo está ativo. Assim, a gente consegue ir reduzindo desse total de segundos aqui, menos o tanto de segundos que já passou, a gente mostra na interface a informação atualizada. É uma estratégia. Existem várias. Essa é uma das estratégias que a gente vai utilizar para criar o nosso cantão. E aqui, então, eu vou criar mais uma variável, chamada currentSeconds, que é exatamente essa conta, o tanto que já passou, digamos assim. E aí, mesma coisa. Se eu tiver um ciclo ativo, vai ser o total de segundos, menos quantos segundos já se passaram. Se não, vai ser zero. Perfeito? Agora que eu tenho o número de segundos atual, que é o número de total menos o que já se passaram, eu preciso converter essa variável de currentSeconds aqui de uma maneira que eu consiga exibir em tela. Porque em tela, eu preciso exibir como minutos e segundos. Então, vamos lá. O que a gente vai fazer? Eu vou calcular, a partir do total de segundos, quantos minutos eu tenho dentro desse total de segundos aqui. Para isso, eu vou fazer o seguinte. Eu pego o total de segundos e divido por 60. Porém, isso aqui pode dar uma conta quebrada. Então, vamos lá. Pegando a calculadora aqui. Se eu tenho 25 minutos, transformo isso aqui em segundos, dá 1.500. Se eu fizer essa conta aqui e dividir por 60, beleza, vai dar 25. Porém, se já passou um segundo, e ao invés de 1.500, agora eu tenho 1.499, se eu dividir isso aqui por 60, dá 24,98, ou seja, dá um número quebrado. Eu não posso ter isso, eu não tenho como mostrar esse número aqui na minha tela. Só que, isso aqui é uma boa pegadinha de prova de matemática, de ensino fundamental. Mas, dentro de 1.499 segundos, quantos minutos eu tenho? Se eu dividir por 60, quantos minutos eu tenho? Cheios, 24. O outro minuto falta um segundo, então eu só tenho 24 minutos, ou seja, eu sempre posso arredondar essa divisão aqui para baixo. Então, eu uso o método math.floor. O floor, que indica chão, ele sempre vai arredondar o número para baixo. Diferente do ceil, que é para sempre para o teto, e diferente do round, que é acima de 0.5 ou igual a 0.5 para cima, abaixo, para baixo. Então, a gente usa o floor, que é sempre para baixo. Então, eu já tenho o número de minutos que existe dentro do meu número de segundos, e agora eu calculo quantos segundos eu tenho do resto dessa divisão. Então, currentSeconds, usando o operador de resto, ele vai pegar, olha, se eu dividir todos os segundos que eu tenho por 60, quantos segundos sobram que não cabem em mais uma divisão? Isso aqui é padrão de quem já pegou matéria de algoritmos, fez faculdade de programação, sabe que uma das primeiras atividades é o operador de resto em divisão. Beleza, agora eu já tenho o número de minutos, já tenho o número de segundos, e a gente precisa mostrar isso em tela. Se não bastasse, o meu número de minutos aqui embaixo na tela, ele precisa ter um zero antes, o primeiro carácter do minuto e o segundo carácter do minuto, o primeiro carácter do segundo e o segundo carácter do segundo, eles são divididos em duas tags diferentes. Então, vou precisar quebrar essa informação em duas também. Mas aí a gente cai no problema, por quê? Quando o meu minuto ou o meu segundo chegar abaixo de 10, ele vai ter um carácter só. Por exemplo, 9 só tem um carácter. Então, eu precisaria que, nesses casos, ele ficasse como 09 e não 9, senão vai ser muito difícil eu manipular isso ali na interface, vou ter que fazer muito if aqui dentro. Então, a gente vai fazer o seguinte, eu vou criar mais uma variável chamada minutes, pode ser apenas, e o que eu vou fazer nessa variável? Eu vou converter o meu minutes amount, que é o número de minutos, que é uma variável numérica mesmo, para uma string, porque com isso eu vou utilizar um método chamado padStart. O padStart nada mais é do que um método que preenche uma string até um tamanho específico, caso ela não tenha aquele tamanho ainda, com algum carácter. Então, por exemplo, a variável de minutos, eu quero que ela tenha dois caracteres. Se ela não tiver dois caracteres, no caso ela tenha apenas um carácter, eu vou incluir zeros no começo, ou seja, no start da string, até completar dois caracteres. E eu vou fazer a mesma coisa com segundos. Então, pego seconds amount e faço a mesma coisa. E agora, para mostrar em tela, eu vou lá, aqui no primeiro zero, e vou transformar isso aqui agora em minutes zero. Eu posso trabalhar com strings como se fossem vetores. Quando eu faço isso, eu pego a letra que está na primeira posição, como se fosse um array, a primeira letra da string. Vou fazer aqui, pegar a segunda. Aqui embaixo a gente troca para seconds. E aqui também, zero e um. A gente fez bastante coisa sem testar ainda a nossa aplicação. A gente ainda não vai estar com o nosso timer totalmente funcionando, reduzindo ali. Mas a gente vai ver que agora, quando eu iniciar aqui um novo projeto e colocar aqui uma duração em minutos, por exemplo, 60 minutos e dar um começar, já mostrou 60 minutos aqui embaixo. Certinho, não deu erro nenhum no console. E agora a nossa atividade, a nossa tarefa está em fazer isso aqui reduzir. E tem várias formas de a gente fazer isso aqui reduzir, mas eu vou deixar você pensando aí em alguns segundos e a gente faz isso na próxima aula."
  },
  {
    "id": "f3334efe-b0fa-4bd0-80b2-82fac3aa4c81",
    "title": "CSS Modules",
    "transcription": "Nessa aula a gente vai conhecer o projeto que a gente vai desenvolver para conhecer os fundamentos do React aqui durante esse módulo. E o projeto que a gente vai desenvolver é basicamente um feed, assim como eu estava dando nos exemplos agora das aulas anteriores. Então, a gente vai desenvolver esse feed aqui, totalmente do zero, toda a parte do CSS, HTML. E esse feed, ele já foi criado, o layout, ele está no Figma. E eu vou deixar aqui como link dessa aula para você conseguir acessar esse layout, inclusive duplicar esse layout e utilizar. Aí você pode fazer modificações, trocar cores, como você preferir. Mas é importante você acessar esse link e duplicar esse layout na sua conta do Figma, que é gratuita, para você conseguir fazer algumas operações que eu vou fazer aqui dentro do Figma. Como, por exemplo, visualizar cores, exportar imagens e tudo mais que a gente vai utilizar. Então, esse feed aqui tem algumas funcionalidades, mas ele não vai ter ainda funcionalidades tão complexas, digamos assim. Ele vai mais ajudar a gente a exercitar sobre componentes, propriedades e alguns outros conceitos que a gente precisa aprender. E também estilização dentro do React em si. Nessa aula, especificamente, a gente não vai entrar a fundo em desenvolver. Eu só vou colocar aqui um único objetivo para a gente nessa aula, que é a gente conseguir fazer com que o nosso feed tenha um fundo escuro. Uma estilização de fundo escuro, super simples. Dá para a gente fazer isso com CSS super tranquilo. E a gente vai desenvolver esse cabeçalho aqui, esse header, que só tem basicamente o logo do Ignite. E aqui eu não vou nem escrever esse Ignite Feed, eu vou deixar só o logo mesmo para a gente visualizar. Então, vamos lá. Aqui dentro do React existem inúmeras formas de a gente estilizar as nossas aplicações, mas por padrão a gente pode utilizar CSS. Então, eu posso criar aqui, por exemplo, um arquivo styles.css dentro da pasta source. Colocar aqui, por exemplo, que o body da minha aplicação vai ter um fundo escuro. Então, 12, 12, 14, eu joguei uma cor qualquer aqui. E se eu importar esse arquivo CSS agora, já vai sair funcionando. Mas uma das coisas que é importante a gente dizer é que no React eu não vou fazer nenhuma importação de CSS aqui pelo HTML. Eu não faço importação do CSS dessa forma. Todas as importações sempre vão partir dos arquivos JavaScript. Então, aqui eu posso acessar, por exemplo, o app.jsx, poderia ser qualquer outro arquivo, e importar o meu estilo aqui dentro. E aqui eu não preciso dar um nome para ele, por exemplo, import styles from. Eu posso dar direto import e o caminho do arquivo de estilos. Então, aqui nesse caso, ./.styles.css. Eu salvo isso aqui agora, vou na minha aplicação e a gente pode ver que ela já está com o fundo escuro. E aqui eu poderia, inclusive, trocar a cor do texto para uma cor branca. E aqui eu poderia adicionar várias outras estilizações para a nossa aplicação. Porém, uma das coisas que a gente precisa cuidar aqui quando a gente está estilizando aplicações React é algo que a gente chama de escopo. O que é escopo? Se você já estudou JavaScript a fundo, você já deve ter ouvido falar, por exemplo, escopo de uma função. Variáveis que a gente define dentro da função não são compartilhadas com o restante, com as outras funções. Então, no JavaScript, por exemplo, eu consigo declarar uma variável x dentro de uma função. E essa variável x existe somente dentro daquela função. E aqui no React, para a parte de estilização, é muito comum a gente cuidar com escopos atrelados ao componente. O que eu quero dizer com isso? Se eu estou colocando uma estilização dentro da minha aplicação, imagina que eu queira estilizar esse componente post para que o autor aqui tenha um estilo diferente, o conteúdo seja diferente. Na maioria das vezes, eu não vou querer que essa estilização que eu faça dentro do componente post afete outros componentes da minha aplicação. Ou seja, a gente chama isso de Scoped CSS, ou traduzindo para o português dev, o CSS escopado, digamos assim. Então, eu consigo fazer com que o CSS seja específico de um componente e não afete outras partes do meu código. E para isso, a gente pode utilizar uma ferramenta que a gente chama de CSS Modules. E aí, aqui eu posso entrar no próprio repositório do CSS Modules, mas a gente não vai precisar instalar nada. Isso aqui só meio que dá a documentação de como utilizar o CSS Modules. Porém, o próprio Vite já traz suporte automático para CSS Modules. E aí, o que a gente vai fazer aqui para testar isso? Eu vou começar criando aqui uma pastinha chamada Components, para a gente começar a separar um pouquinho melhor os arquivos da nossa aplicação. Dentro dessa pasta Components, eu vou criar um arquivo chamado header.jsx. Esse header é para simular esse cabeçalho aqui que a gente vai desenvolver. Perfeito? Aqui dentro, eu vou simplesmente exportar um componente chamado header. E uma das coisas importantes dizer é que todos os componentes sempre devem começar com a primeira letra maiúscula, para não confundir com elementos do próprio HTML. Então, por exemplo, se eu tenho aqui um componente header com H maiúsculo, eu uso ele com H maiúsculo, para não confundir com, por exemplo, o header que existe também no HTML, porém com H minúsculo. Então, isso é muito importante. A gente sempre cuidar para usar componentes React com a primeira letra maiúscula e elementos HTML sempre totalmente minúsculos. Perfeito? Aqui dentro, eu vou escrever simplesmente um strong ignite-feed. Depois a gente vai colocar a imagem aqui do logo, mas por enquanto só para a gente visualizar. Perfeito? Aí dentro da pasta Components também, eu vou criar um arquivo CSS para o meu header. Então, header.css. Perfeito? Porém, como eu quero que esse CSS fique totalmente atrelado ao componente header e ele não interfira em outros elementos, ao invés da extensão eu colocar .css, eu vou colocar .module.css. E aqui dentro, eu posso agora criar uma classe header, por exemplo. E aí, quando a gente trabalha com CSS modules, a gente tenta, na maioria das vezes, utilizar somente classes e não utilizar IDs ou utilizar qualquer outro tipo de seleção dentro do CSS. E aqui nesse header, eu vou colocar um background cinza um pouco mais clarinho para a gente visualizar se isso aqui está funcionando. Além disso, eu vou colocar aqui uma altura de 80 pixels só para a gente testar. Claro que nenhum valor desse aqui vai permanecer depois, a gente vai alterar olhando pelo layout qual que é as medidas corretas. Salvo isso, eu volto agora aqui no header. E agora, você pode estar pensando, pô, eu venho aqui agora, importo o meu header.module.css e aplico aqui a class header. Correto? Não. Não está correto por dois motivos aqui. Primeiro, no React, a gente não utiliza class dentro dos elementos HTML. Por quê? Porque como a gente está dentro de um arquivo JavaScript, existe a classe JavaScript. E aí, para o React não se perder em relação a esses nomes, a gente acaba dando o nome disso aqui de className. É a mesma coisa que a classe no HTML, só o nome é diferente. A gente sempre vai utilizar className. E não se preocupe, se você esquecer e usar class, ele até vai funcionar, mas ele vai te avisar no console do navegador falando, olha, você esqueceu aqui, deveria ser className. Então, não se preocupe em esquecer em alguns momentos, isso vai ser normal. E agora, isso aqui vai funcionar? Vamos testar. Vou salvar isso aqui agora, volto lá no Google Chrome, entro aqui no Vite. A gente não está vendo o nosso header, porque eu não estou mostrando ele em nenhum lugar. Então, vamos lá no nosso app. E aqui, antes do primeiro post, eu vou colocar o nosso header. E aí, uma das coisas legais de usar o Vast Code é que se eu boto aqui o sinal de menor e começo a escrever header, ele já dá a opção de importar o header de forma automática. Então, ele já fez a importação do header e eu já coloquei o header aqui dentro do nosso HTML. Salvo isso aqui agora, volto. E aí, deu um erro. Ele deu fail to resolve import header. Tá, eu errei o nome, né? Então, volto aqui, não tem SS no final. Salvo, volto. E beleza, tá aqui o Ignite Feed. Porém, não parece que ele pegou nenhuma estilização, né? Deixa eu dar um inspecionar elemento aqui. A gente pode olhar até aqui na direita. Não tem nenhuma estilização aqui diferente, só tem o font-weight bold, mas nenhuma estilização foi aplicada. Isso porque quando a gente está utilizando o CSS Modules, diferente de quando a gente importa um arquivo que não tem o module aqui, como foi o caso desse styles.css, eu preciso sim dar um nome para os meus estilos. Então, eu não vou só importar o arquivo. Eu vou importar, por exemplo, styles.from. E agora, dentro desse meu styles aqui, é onde está o meu CSS, a minha estilização. E agora, o que eu faço? Olha que interessante. Se eu vier aqui e der um console.log nesse styles aqui, vamos ver o que vem dentro dessa variável. Venho aqui no console. Olha só. Ela veio aqui, uma variável header, ou melhor, esse console.log que eu fiz, styles, é um objeto. E dentro dele tem uma propriedade chamada header. E o valor dela é uma coisa muito louca, que é um hash gerado de forma totalmente automática. O que é esse hash gerado de forma automática aqui? Isso aqui é a classe que eu tenho que colocar aqui no meu elemento. Então, o que a gente vai fazer aqui agora? Ao invés de simplesmente colocar class name header, nesse caso aqui eu vou botar chaves. Lembra que eu boto chaves quando eu quero botar uma variável JavaScript dentro do meu HTML. Então, aqui a minha class name eu quero que ela venha de uma variável JavaScript, que é styles.header. Esse ponto header aqui, por que eu botei header aqui? É a mesma classe que eu exponho aqui dentro. Se aqui dentro eu chamasse de header container, por exemplo, aqui teria que ser também header container. Mas eu vou voltar, vou deixar apenas como header pra gente visualizar. Volto nos dois arquivos, salvo. Salvo isso aqui, vou tirar o console.log. Se eu salvo agora e volto, a gente pode ver que tá vendo que o IgniteFeed agora aqui, ele já tá com o fundo com o cinza mais claro. Então, pra gente visualizar isso aqui até melhor, eu vou tirar essa class name aqui do strong. Vou colocar um elemento HTML aqui por volta, veja que agora eu botei header. Porém, esse header ele é o elemento HTML, não o componente, por causa da letra minúscula. E no header eu vou colocar o meu class name styles.header. Salvo isso aqui agora e a gente pode ver que já apareceu lá o nosso cabeçalho. E aí, se eu inspeciono o elemento aqui do meu header, eu vejo que ele já tá aqui com as estilizações. Então, eu tenho o background 333 e tenho o height 80 pixels, que foi o que a gente colocou. E aí, por que ele colocou esse nome esquisito? Por que ele gerou essa classe pra gente? Lembra que eu falei que um dos motivos da gente utilizar os CSS Modules aqui na nossa aplicação, é a gente evitar com que estilizações de um componente afetem outros componentes. Então, se eu tô estilizando a classe header aqui nesse cabeçalho, eu posso utilizar a mesma classe header em outros lugares da minha aplicação e esses outros lugares não vão sofrer a estilização que esse header aqui recebeu. Isso é super importante, principalmente quando a gente for trabalhar com aplicações bem grandes, pra gente não ter interferência de estilos na nossa aplicação. E aí, como é que o CSS Modules resolve isso pra gente? Ele gera, automaticamente, pra cada classe que a gente tá estilizando, um hash, uma classe com números e letras, um hexadecimal aleatório, pra que a gente tenha, então, uma classe única pra cada vez que a gente for utilizar a estilização do header aqui dentro da nossa aplicação. Então, gerando esses hexadecimais aleatórios aqui, ele evita com que eu tenha várias, com que eu tenha classes que são reutilizadas e que acabem interferindo em outros lugares na nossa aplicação. E, basicamente, é assim que a gente vai estilizar toda a nossa aplicação daqui pra frente. Eu não vou terminar o nosso header aqui nessa aula, a gente vai estilizar ele ao longo das próximas aulas."
  },
  {
    "id": "8fd967ad-3bcc-4f33-9729-ee8f25c4bf2d",
    "title": "Componente: Header",
    "transcription": "Nessa aula o que a gente vai fazer então é o nosso header aqui realmente da nossa página. E aí, voltando até aqui, a gente pode ver que se eu der um F5 na minha aplicação, ela já aplicou os estilos que eu tinha aqui, que eu apliquei no meu global. Só deixa eu salvar de novo, a fonte já alterou aqui. E agora a gente, deixa eu dar um CTRL 0 para resetar o zoom, e agora a gente vai modificar aqui o nosso header. E aí vamos lá, eu vou começar aqui no Visual Studio Code, lá no meu componente header dentro do CSS, a gente já tem uma classe aqui para o header. E aqui no lugar do background onde a gente tinha colocado simplesmente 333, eu vou trocar isso aqui para var gray 800. Então a gente vai usar uma cor com cinza um pouquinho mais clara. Se eu salvar eu posso ver que já foi aplicado aqui dentro. E agora, como todo o conteúdo aqui do header vai estar centralizado, tanto verticalmente quanto horizontalmente, eu vou aplicar aqui nesse header um display flex e um justify content center. Eu não preciso colocar o align items center aqui, porque ao invés de setar um height fixo, eu vou colocar um padding no header, em cima e embaixo, ou seja, ele distanciar um pouquinho o conteúdo do topo e de baixo. E eu vou botar isso aqui de 1.25 rem em cima e embaixo e nas laterais de 0. O que é 1.25 rem, Diego? Se 1 rem é 16 pixels, 0.25 rem, que é o restante que sobra ali, é isso aqui dividido por 4, ou seja, 4 pixels. Ou seja, isso aqui no total vai dar 20 pixels. Por que eu coloquei 1.25? Porque se a gente for no layout, fazer o cálculo aqui de distância, dá praticamente 20 aqui. Só não deu 20 aqui provavelmente porque eu selecionei um elemento interno, eu deveria ter selecionado o elemento externo aqui na nossa árvore. Vamos pegar aqui o ignite symbol, está com 20 lá de distância. Então é isso que a gente tem que colocar, a gente tem que seguir o que está no layout, senão depois os designers vão matar a gente. Salvo isso aqui agora, volto lá no header, e a gente vai ver que já está o ignite feed aqui centralizado, mas não é isso que eu quero mostrar, eu quero mostrar o logo do ignite. Então aqui no Figma nós vamos selecionar aqui do lado ignite symbol, nas camadas, que vai selecionar só o símbolo aqui, só o logo do ignite. E aqui na direita nós viemos em export. Clica no mais aqui, seleciona SVG, eu vou utilizar formato de vetor, bem melhor nesses casos, e eu clico em export. Ele já exportou o SVG para mim, copio esse SVG, venho aqui na pasta onde está o meu projeto, então meu projeto está dentro de ignite-aulas-01-fundamentos-react. Aqui dentro de src eu vou criar uma pasta chamada images, ou pode ser assets, tanto faz, e dentro dela eu vou colocar a minha imagem. E agora eu vou só renomear essa imagem para o nome dela ser ignite-logo.svg. Até o nome das imagens é importante que você sempre mantenha um nome que seja bem relacionado com o que a gente está mostrando em tela. E agora eu volto aqui no meu componente header, e a gente precisa mostrar essa imagem aí em tela. E como é que a gente vai fazer isso? Existem várias formas de eu mostrar uma imagem em tela, mas vamos lá. Eu vou começar importando aqui de dentro, eu vou chamar de ignite-logo-from, aqui eu preciso dar um ponto, ponto, barra, assets, barra, e aqui o nome da imagem é ignite-logo.svg. Novamente, veja que assim como o CSS, aqui no React a gente também faz a importação das imagens por dentro do JavaScript. Isso pode ser a grande maior diferença que você vai ter trabalhando com React comparado com o HTML tradicional. A gente importa imagens, CSS, todos os arquivos a partir do JavaScript. E aqui agora, se eu der um console.log nessa ignite-logo, a gente salva isso aqui, volto lá na minha página do inspecionar, venho em console, olha só, ele mostrou pra gente um caminho. E é esse caminho aqui que a gente precisa colocar no search da imagem. Então eu venho, coloco aqui uma imagem, search, e aqui como eu quero colocar uma variável, eu preciso botar chaves ignite-logo, e aqui posso botar até um texto alternativo, logotipo do ignite. Salvo. E agora nossa imagem já está aparecendo lá dentro. Essa imagem ela ficou talvez um pouquinho grande, então eu gostaria de diminuir o tamanho dela. E pra isso, lá por dentro do próprio header module CSS, aqui pelo próprio CSS, eu posso fazer o seguinte, eu posso pegar o header e eu quero estilizar a imagem que está dentro do header. A gente pode fazer isso aqui dentro do CSS modules da mesma forma que a gente faz no CSS tradicional. E aqui eu vou setar pra ela um height de 2rem, ou seja, isso aqui vai simbolizar 32 pixels se a pessoa não aumentou nem diminuiu o tamanho da fonte pelo sistema. Salvo. Agora a gente pode ver que a imagem já deu uma diminuída. Não ficou exatamente igual o figma aqui, mas eu até já tinha conversado com o Jonas, que foi quem criou o layout aqui, pra dar uma diminuída. Eu acho que assim vai ficar mais amigável no fim das contas, beleza? Então agora a gente finalizou aqui o nosso componente header da nossa aplicação."
  },
  {
    "id": "e5b20a1d-c8a7-4934-a1ee-336e226c0763",
    "title": "Aplicando responsividade",
    "transcription": "Pra gente fechar com chave de ouro aqui a parte da interface da nossa aplicação, antes da gente entrar no funcionamento, que aí sim vai ter mais uma porrada de conteúdo novo e de ensinamentos novos pra gente ter aqui durante esse desenvolvimento dessa aplicação, a gente vai deixar nossa aplicação responsiva. Hoje, se eu venho aqui em inspecionar, jogo aqui pra baixo um pouquinho, venho aqui do ladinho, no responsivo, e diminuo aqui pro tamanho de tela de um iPhone qualquer, aqui, XR, nossa aplicação não fica tão legal, né, porque a sidebar aqui acaba ocupando um espaço desnecessário. Então, o que eu vou fazer aqui? Quando a aplicação, quando o tamanho de tela for um pouco menor, eu quero que a nossa sidebar fique acima do feed aqui, e não do lado. Isso vai ser super simples a gente fazer. Aqui no nosso app.module.css, que é onde está definido o grid, que define o tamanho que a nossa sidebar ocupa e o próprio feed aqui, a gente pode simplesmente aplicar uma regra aqui. Então, eu vou dar um media.maxwidth 768 pixels, ou seja, quando a tela for menor que 768 pixels, que é um tamanho legal pra gente pegar dispositivos mobile, o que eu vou fazer? Eu vou pegar o meu wrapper, que é o que a gente tem aqui em cima, e eu vou dar um grid.templateColumns 1fr. Ou seja, agora o meu grid não vai mais ter duas colunas, ele vai ter apenas uma coluna que ocupa a largura toda. Eu salvo isso aqui agora, volto pro Chrome, e olha só, aqui deixa eu até dar um pouquinho de zoom, a gente já pode ver que tudo ficou perfeitinho aqui dentro. Os comentários, a gente poderia diminuir um pouquinho a foto, jogar pra cima, mas por enquanto pra mim está bem aceitável, digamos, da maneira que ficou. E aí, uma das coisas que é legal eu mostrar aqui pra você é que lembra que a gente está utilizando unidades relativas em tudo aqui, então a gente usa o RAM pra tudo aqui. Isso dá pra gente um poder muito legal quando a gente vai trabalhar com responsividade. Já que a gente está usando o RAM em tudo aqui na nossa página, tudo na nossa página se redimensiona automaticamente com base no font-size do nosso HTML, da nossa página. O RAM é uma unidade relativa ao tamanho da fonte da página, ou seja, se o usuário no dispositivo dele aumenta o tamanho da fonte, tudo aumenta. Se ele diminui o tamanho da fonte, tudo diminui. Ou seja, se eu fizer aqui, falando que dentro do ambiente do HTML, ou melhor, dentro do ambiente mobile, eu reduzir o tamanho do font-size do HTML, aqui, por exemplo, hipoteticamente, só eu vou jogar 12 pixels, só pra gente ver a diferença. Então, de 16 vai sair pra 12. Olha só, tudo diminuiu junto. Você percebeu? Então, tudo onde a gente usou o RAM diminuiu junto. Então, os nomes aqui estão menores. Está até pequeno demais, né? Eu não quero usar 12. Vou botar 14 aqui pra ser um pouquinho maior. Olha só. Mas começou a caber mais coisa em tela. Não sei se você percebeu. Tudo diminuiu. Isso é incrível. O RAM dá pra gente esse acesso da gente conseguir controlar essa flexibilização do tamanho da interface através das nossas media queries ali do CSS. Só que eu não posso utilizar um valor em pixel. Eu preciso utilizar aqui um valor em percentual. Porque se eu usar em pixel, a gente vai estar colocando um valor bruto e aí vai parar de funcionar aquela questão do usuário podendo no dispositivo dele aumentar e diminuir a fonte, porque daí está pixel, é bruto. Isso aqui o usuário não consegue mudar. Então, a gente precisa usar em percentual. Então, a gente precisa fazer uma regrinha de três básica, né? Pensando que 16 é o 100% e a gente quer 14, quanto que isso aqui significa? E aí a gente pode fazer 14 vezes 100 dividido por 16. Então, o nosso font-size em percentual precisa ser 87,5%. Então, 87,5% vai ser o nosso font-size aqui no mobile e assim a gente faz com que no mobile eu tenha tudo da minha tela menor. Vamos ver como que isso faz diferença. Olha só. Eu vou clicar aqui no HTML, beleza? Aqui no HTML, no Especinar Elementos. E a gente vai ver que aqui embaixo está o nosso font-size 87,5%. Deixa eu até diminuir um pouquinho. Eu vou desabilitar ele. Tudo cresceu. E não foi só o tamanho da fonte que cresceu, tá? Você vai ver que tudo cresceu. Até o espaçamento aqui, entre o botão, olha ali. Tudo cresce. Vamos pegar aqui que é mais fácil visualizar que tem mais elementos. Eu tiro o font-size, tudo cresce. É muito legal isso, né? Porque no mobile fica legal, mas no web é legal a gente ter os textos e os tamanhos, os espaçamentos maiores porque a gente tem mais espaço de tela. Então, trabalhar com responsividade dentro de aplicações web, ele geralmente vai ser um conjunto de utilizar unidades de medida relativa junto com as nossas media queries, reposicionando os elementos, usando Grid, Flex e por aí vai. Mas, pô, muito legal a gente consumir esse conteúdo e saber como a gente pode deixar as nossas aplicações responsivas."
  },
  {
    "id": "6ee624cb-53a2-4da6-9088-d15bb9b26ec1",
    "title": "TypeScript no formulário",
    "transcription": "O que a gente vai fazer nessa aula é integrar o nosso formulário melhor com o TypeScript. Por quê? Hoje, se a gente for aqui no nosso código e passar o mouse em cima desse data aqui que a gente está utilizando na função de submit do formulário, mesmo tirando esse N que eu forcei aqui, eu passo o mouse em cima do data, eu vou ver que ele não sabe qual é o formato. Ele continua sendo N. Ele não entende, a gente não consegue inferir de forma automática qual que é a tipagem desse data, qual que é o conteúdo dele. E se a gente for olhar o código, na verdade, a gente consegue meio que deduzir qual seria o conteúdo do data, porque a gente sabe quais inputs existem na nossa aplicação. Então tem o input de task, eu dei o nome de task, e tem o input de minutos, que eu dei o nome de minutesAmount, ou seja, esse data deveria ser um objeto que contém esses dois campos. E eu posso criar isso na mão mesmo. Então eu posso, por exemplo, criar aqui um interface, e aí eu posso chamar de newCycleFormData, por exemplo. O nome aqui é irrelevante, mas é importante dar um nome que seja coerente. E aqui eu posso falar, claro, eu tenho uma task, que é uma string, e eu tenho o minutesAmount, que é um número. Ambos são obrigatórios. E aí eu posso vir aqui, dar dois pontos, e pronto. A gente já tem o nosso newCycleFormData. E aí eu passo o mouse por cima, eu já consigo usar data.minutesAmount ou data.task. Só que tem outra coisa que é interessante, é que aqui no useForm uma das propriedades que a gente pode passar para esse objeto de configuração, ela se chama defaultValues, e ela traz a possibilidade de a gente passar qual que é o valor inicial de cada campo. E aqui eu vou passar para os dois campos, tanto para o task quanto para o nosso minutesAmount, um valor inicial. Então para o task eu vou passar o valor em branco, e para o minutesAmount eu vou passar o valor de zero. Mas uma das coisas que eu posso ver aqui, eu vou até recortar esse código, vou manter no ctrl-x aqui, é que se eu dou um ctrl-espaço aqui dentro de defaultValues, ele não sabe, ele dá aqui algumas sugestões do Vascode, mas nada realmente. Mas seria legal se aqui no defaultValues ele já me falasse, olha, tu tem o campo task e tu tem o campo minutesAmount. E a gente consegue fazer isso fazendo da seguinte forma, aqui no useForm eu consigo passar aqui um generic para ele, então o sinal de menor e maior aqui no useForm, e uma das dicas que eu te dou para saber quando a gente pode passar isso para alguma função, eu posso passar o mouse por cima do useForm, e eu vou ver que aqui na definição da função tem um sinal de menor e um sinal de maior, aqui o primeiro parâmetro, o primeiro generic que eu posso passar, ele é um objeto, um formato de objeto, que é exatamente o que eu quero enviar para ele, que é essa interface, e o segundo ele está como N aqui, isso aqui são os valores padrão, digamos assim. Se eu clicar ctrl e for para dentro do useForm, aí eu consigo ter até mais informações. O primeiro generic que eu passo, ele é o formato dos valores dos campos, e aí se eu for clicando ctrl, aqui eu posso ir procurando, entrando mais a fundo. E o segundo aqui é o context, que por enquanto a gente não vai utilizar, então por padrão ele já vem N, então não tem muito o que a gente entrar. Então aqui dentro eu posso passar o sinal de menor e maior, passando o nosso newCycleFormData, e aqui agora no default values, quando eu dou um ctrl espaço, ele já traz aqui task e minus amount, então eu consigo definir da mesma forma que a gente tinha feito antes. Muito legal, agora a gente já tem uma interface para fazer isso, e tudo vai continuar funcionando sem problemas nenhum. Mas não sei se você lembra que eu falei que um dos motivos de eu gostar de utilizar a biblioteca Zod, é pela integração dela maior com o TypeScript. E se a gente for parar para pensar e olhar o nosso código mesmo, e é importante dizer que o nosso código agora não está errado de forma alguma, isso aqui está perfeito, a gente poder parar por aqui e continuar sem problemas nenhum. Mas eu quero mostrar mais uma funcionalidade legal aqui do Zod, especificamente, que é o seguinte, você concorda comigo que olhando só para esse código aqui, vamos até colar em outra tela, só olhando para esse código aqui, eu consigo inferir, eu consigo dizer que o nosso formulário tem um campo task, que é uma string, é obrigatória, porque tem que ter no mínimo um caractere, e eu tenho um campo MinusAmount, que é um número, e que também é obrigatório? Você concorda comigo que só olhando para isso aqui, sem precisar nem olhar para o formulário, a gente consegue definir isso? Legal. Se sim, o Zod tem uma função que a gente consegue usar de dentro dele, que ele extrai a tipagem do nosso formulário, ou seja, isso aqui, de dentro do nosso esquema de variáveis, ou seja, isso aqui, de dentro do nosso esquema de validação, ou seja, ele cria isso aqui para a gente, a partir disso que a gente já tinha criado previamente. Vamos testar? Então, agora, ao invés de usar uma interface, e nesses casos eu prefiro utilizar a interface quando eu vou definir o objeto de validação, e prefiro utilizar o type quando eu vou criar uma tipagem, algo do TypeScript a partir de outra referência, a partir de uma outra variável, ou qualquer coisa assim, que é o caso aqui. Então aqui, eu vou dar o mesmo nome, e eu vou falar que agora o meu newCycleFormData ele é o seguinte, Zod.Infer, ou seja, eu estou inferindo o ato, o verbo, inferir dentro do TypeScript, ele vem, ele basicamente descreve, é definido automaticamente, ou automagicamente, digamos assim. Então, sempre que a gente fala sobre, estou inferindo algo, eu estou automatizando um processo de falar qual que é a tipagem de alguma coisa. E aqui, nesse Zod.Infer, ele recebe, isso aqui é do TypeScript, específico do TypeScript, isso aqui não é uma função JavaScript, isso aqui é só uma tipagem mesmo do TypeScript, não tem nada de JavaScript, então eu vou usar um sinal de menor e maior aqui, e eu vou passar para ele o nosso newCycleFormValidationSchema. Uma das coisas que a gente já viu antes é que eu não posso utilizar uma variável JavaScript, que é esse caso aqui, dentro do TypeScript, o TypeScript não consegue entender. Eu preciso sempre converter, digamos assim, a minha variável JavaScript em uma tipagem, em algo específico do TypeScript, e para isso eu sempre uso o typeof. Sempre que eu estou querendo referenciar uma variável JavaScript dentro do TypeScript, eu preciso usar o typeof antes dela. E agora, olha que legal, se eu passo o mouse em cima do newCycleFormData, eu vejo que ele já tem aqui o task e o minute amount. E ele inferiu isso, ele retirou isso aqui de dentro do meu esquema de validação. E aí eu não preciso mais dessa interface, se eu colocar um novo campo na minha validação, por exemplo, imagina que eu tenho aqui quem é o responsável pela tarefa. Então eu boto o nome owner, zod.string. Automaticamente o meu newCycleFormData já assume que eu tenho o owner aqui dentro, e conforme eu vou adicionando aqui mais e mais propriedades, como por exemplo, setar o owner como opcional, ele já inferiu automaticamente que o owner agora pode ser nulo, pode não existir, no caso pode ser um defined ou pode ser uma string. Então isso é muito legal, a gente criar isso a partir aqui do objeto. E isso, claro, está na documentação do próprio Zod, inclusive eu estava com a documentação aqui aberta para garantir que eu ia mostrar da melhor forma. E isso que é legal do Zod, eu gosto dessa integração que ele tem com o TypeScript, mas como eu falei, se você quiser manter da outra forma, usando a interface, sem fazer esse processo de inferir, não tem problema, vai funcionar da mesma forma, os dois estão certos e funciona igual, digamos assim. E assim a gente integrou o nosso formulário totalmente com o TypeScript, e agora realmente a gente precisa começar a trabalhar com esses dados, alimentar a nossa aplicação, dar o start aqui no nosso counter, quando a gente clicar em iniciar, então agora começa a entrar a parte legal mesmo."
  },
  {
    "id": "6aace8d8-f6f2-4784-8472-995b697e3dcc",
    "title": "React Hook Form",
    "transcription": "Agora, para fazer os nossos formulários funcionarem aqui, a gente vai utilizar uma biblioteca de formulários no React muito legal, que ela se chama React Hook Form. Essa React Hook Form consegue trabalhar com os nossos formulários tanto de uma maneira controlled, tanto quanto de uma maneira uncontrolled. Ou seja, a gente consegue ter o melhor dos dois mundos. A gente consegue ter performance sem abrir mão da flexibilidade, da fluidez, da interatividade com os campos do nosso formulário. E aqui, a gente pode seguir o guia de Getting Started. Ela é muito simples, não tem muito frufru aqui de ficar integrando qualquer outra biblioteca. Ela é super simples, mas eu vou fazer tudo do zero com você aqui no nosso projeto. Então, para isso, deixa eu abrir aqui um novo terminal. Ou melhor, deixa eu dividir o terminal que eu já tenho aqui em dois. Fica melhor aqui. E nós vamos instalar aqui a biblioteca React Hook Form. Vou aguardar aqui o processo de instalação, bem rapidinho. E agora, aqui dentro da página que tem o nosso formulário, a gente vai começar importando aqui de dentro do React Hook Form. Beleza, já deu boa. A gente vai começar importando uma biblioteca chamada... uma biblioteca não, uma função chamada UseForm. Como o próprio nome da biblioteca já diz, React Hook Form, quando vem esse nome, hook, a gente lembra dos hooks do React. Os hooks nada mais são do que essas funções que têm esse prefixo use, que elas acoplam uma funcionalidade em um componente existente. Então, como por exemplo, useState, useEffect. Quando tem esse use, isso é um hook, a gente está acoplando. Inclusive, mais para frente, a gente vai criar os nossos próprios hooks para ver como que isso funciona. Mas esse useForm agora nada mais é do que uma função que eu chamo aqui dentro do meu componente, da Home em si, e essa função aqui, ela me devolve algumas informações. Então, eu consigo fazer aqui uma constante, form, igual a useForm. E aqui esse form, na verdade, ele é um objeto onde tem várias funções dentro dele, várias variáveis que eu posso utilizar para criar o meu formulário. Então, como isso aqui retorna, o useForm retorna um objeto, a gente pode usar a desestruturação, ou seja, colocar a sintaxe de objeto do lado esquerdo da operação para eu extrair algumas variáveis e algumas funções do retorno desse método aqui. E aqui a gente pode ver, dando um control espaço, todas as funções e variáveis que eu posso buscar dali de dentro. Grande parte delas são funções. A função mais importante para a gente aqui no caso é a register e a função handleSubmit. Essas aqui são as duas funções... Opa, handleSubmit não, handleSubmit. São essas duas funções aqui que a gente precisa. Essa register aqui, o que é? Nada mais é do que um método que vai adicionar um input ao nosso formulário. Então, quando eu dou esse useForm, é como se eu estivesse criando um novo formulário na minha aplicação. E a função register, ela fala quais são os campos que eu vou ter no meu formulário. E a sintaxe do register aqui, ela é um pouquinho complexa de entender, mas a gente vai passar e vai basicamente mostrar o que esse register aqui está fazendo. Eu vou basicamente aqui nos meus inputs do formulário fazer o seguinte, olha só que interessante. Eu vou dar um enter aqui embaixo do último, no caso, o placeholder. Eu vou adicionar aqui uma sintaxe de objeto, está vendo? Olha só, colocar as chaves aqui. E eu vou dar ponto, ponto, ponto, register. Isso aqui é uma função, então eu passo parâmetros e dou um nome para o meu input. Então, aqui eu vou chamar de task, por exemplo. E aqui eu vou tirar esse name porque ele não é mais obrigatório por causa que o register já coloca esse nome para a gente, então a gente não precisa colocar. E agora essa sintaxe aqui, talvez ela foi um pouquinho complexa de você entender, mas vamos por partes. O register é uma função que retorna basicamente o retorno dessa função aqui. Vamos colocar isso aqui entre comentários, só um minutinho. Então, isso aqui, imagina que a função register recebe o nome do input, como a gente mesmo está passando aqui embaixo, o nome do input, e ela retorna daqui de dentro alguns métodos, que são os métodos que a gente utiliza para trabalhar com inputs no JavaScript. Então, essa função register devolve métodos como onChange, que é uma função também, ela retorna o onBlur, que são vários métodos que a biblioteca React Hook Form utiliza para conseguir monitorar os valores dos inputs. Então, onFocus, tem várias e várias funções aqui que essa register devolve. Como ela retorna vários métodos, a gente vai utilizar essa sintaxe de spread operator para basicamente transformar cada um dos métodos do retorno dessa função register em um atributo, em uma propriedade para esse meu input. Então, é basicamente a mesma coisa que se eu estivesse botando onChange, onBlur, onFocus. Inclusive, se eu chamar essa função register aqui fora, olha só, registerTask, e der um ponto aqui no final, como é um objeto, olha só, é basicamente tudo isso aqui que ela devolve. Olha só, onChange, onBlur, hasRequired, como a biblioteca React Hook Form controla para a gente também validação, então, olha só, min, minLength, max, maxLength, disabled, name, onBlur, pattern. Então, várias coisas aqui que o nosso input pode utilizar. Então, o ponto, ponto, ponto meio que está pegando todas essas coisas retornadas, todas essas informações retornadas aqui pelo register e acoplando no nosso input como se fossem propriedades. Isso é muito legal, é uma sintaxe que você vai poder, inclusive, utilizar nos seus próprios componentes, conforme você for criando. E agora a gente vai fazer a mesma coisa aqui no nosso MinutesAmount input. Então, aqui a gente vai colocar o register e o nome eu vou chamar de MinutesAmount, nesse caso aqui. E aí, outra coisa importante agora é o nosso HandleSubmit que a gente criou aqui em cima. Então, a gente já tem um método aqui chamado HandleSubmit, então é importante a gente não usar o método com o mesmo nome. Então, eu vou chamar aqui esse método de HandleCreateNewCycle. E agora, como que a gente faz para usar esse método HandleSubmit aqui? A gente vai, basicamente, aqui no nosso OnSubmit do formulário, nós vamos escrever HandleSubmit, que é o nome do método de submit que vem do useForm e passar para ele, entre parênteses, como um parâmetro, a nossa função de submit. Então, fica uma sintaxe também meio estranha, a gente está passando uma função como argumento de uma outra função, mas é assim que o React Hook Form lida para a gente. E agora aqui dentro, eu posso receber como argumento dessa função o data. O data são os dados dos nossos inputs do nosso formulário. Então, se eu der um console.log aqui no nosso data, mesmo que por enquanto ele esteja com erro aqui, vamos colocar que o tipo dele aqui é N, só por enquanto, tá? Juro que logo a gente vai mudar isso aqui, mas só se eu der um console.log aqui no data, olha só, a gente volta lá no Chrome, vamos dar um F5 aqui. Está dando um errinho? Vamos dar uma olhada aqui, task is not defined. Aqui embaixo, a gente tem esse disabled com task, né? Então, como a gente mudou, não está mais usando o estado, a gente não tem mais o estado que anota o input da task, isso aqui parou de funcionar. Então, eu vou comentar isso aqui por enquanto, só para a gente não ter erro e daqui a pouco a gente volta nisso. Então, show, voltamos aqui na nossa aplicação e agora, olha só, eu vou preencher aqui projeto1, por exemplo, e vou botar aqui duração de 20 minutos. Quando eu clicar aqui em começar, olha só, ele já mostrou aqui no nosso console os dados ali, de task, projeto1 e minutesAmount20. Duas coisas super importantes aqui, a gente pode ver que ele retornou o minutesAmount como 20, porém ele retornou como uma string, mas a gente sabe que isso aqui é um número, não é uma string. Então, uma das coisas legais é que o ReactHookForm, aqui no método register, a gente pode passar um segundo parâmetro depois do nome do input, que é um objeto de configurações. E nesse objeto de configurações, eu posso passar uma variável, que é uma propriedade chamada valueAsNumber, que eu passo true ou false. Se eu colocar isso aqui como true, quando eu der o submit agora, ela vai vir como, deixa eu dar um F5 aqui, ela vai vir como número agora, e não mais como uma string. Então, a gente já consegue ter essa informação num tipo primitivo de variável que a gente realmente quer utilizar. E beleza, a gente conseguiu criar aqui o nosso formulário. Mas como é que eu vou fazer esse disabled aqui embaixo que a gente tem? Então, vamos ver como é que a gente pode fazer isso. Por exemplo, imagine que eu queira desabilitar ou habilitar esse botão de submit aqui, baseado se a informação de task ali está preenchida ou não. O que eu posso fazer? Olha só que legal. Aqui em cima, eu posso importar de dentro do useForm uma função chamada watch. E watch, em inglês, nada mais é do que assistir, observar alguma coisa. E aí eu posso falar o seguinte, olha só. Eu quero observar o campo task, que foi o nome que eu dei aqui dentro do register. E agora eu consigo saber o valor do meu campo de task em tempo real. E aí eu posso fazer o seguinte. Eu vou observar o campo de task. Se o campo de task for diferente de vazio, eu quero habilitar o botão. Concorda comigo? Então, o que eu posso fazer? Eu posso ir lá embaixo no meu botão, voltar a função aqui e pronto, tudo vai funcionar. Então aqui, conforme eu vou digitar, já habilitou o botão. Então eu consigo observar os campos do meu formulário para fazer alterações na minha interface sem problemas nenhum. Aqui a última dica antes da gente fechar o vídeo. Eu, particularmente, gosto muito de criar variáveis auxiliares. Variáveis auxiliares nada mais são do que variáveis que não alteram a funcionalidade do código. Elas não vão prejudicar a gente em performance, mas elas melhoram a legibilidade do código. O que eu quero dizer com isso? Aqui dentro, a gente está simplesmente criando uma variável task que está observando o campo de task. Isso não me diz nada. Para uma pessoa que lê esse código aqui, ela vai, pelo menos, ter que correr até lá embaixo para entender o porquê que a gente está utilizando essa task em si. Então, aqui, o que eu gosto de fazer? Eu gosto de criar variáveis meio que para facilitar para quem está lendo o código. Então, por exemplo, eu vou criar uma variável aqui chamada isSubmitDisabled, ou seja, o submit desse formulário está desabilitado ou não? Ele vai estar desabilitado quando eu não tenho nada dentro da minha task. E agora, aqui embaixo, eu uso a variável isSubmitDisabled, ou seja, para quem pegar esse código, logo no começo, a pessoa já vai entender que a gente está desabilitando o submit quando a task não estiver presente. Eu, particularmente, gosto muito de fazer isso. Eu acho que traz uma legibilidade muito legal para o nosso código. E agora, o nosso formulário já está funcionando, mas, claro, ainda sem validação. A gente ainda só está dando um console.log aqui nos dados, a gente não está cadastrando nada, mas é o que a gente vai começar a fazer a partir de agora."
  },
  {
    "id": "61341b7e-0491-4fe3-94cc-b6e15d1ff256",
    "title": "Estilizações do Post",
    "transcription": "Nessa aula então a gente vai estilizar o nosso componente de post aqui com os elementos que a gente já criou previamente. Então aqui eu vou começar no nosso post.module.css fazendo as estilizações. A gente vai começar com o post, aqui eu vou começar setando um background var grey 800, que é a mesma cor de fundo que a gente está usando para a sidebar e para o cabeçalho. Vou botar também um border-radius 8 pixels e a gente vai colocar um padding de 2.5 rem, aqui que dá 40 pixels, acho que é isso, show. Então ele já dá um espaçamento ali. E agora uma das coisas que eu gosto de fazer, que eu vou fazer aqui na verdade, é que os posters eles são espaçados aqui um do outro, mas esse espaçamento só deve existir quando eu tenho mais um post. Se eu não tenho mais um post embaixo do post atual, não tem porque ter um espaçamento para baixo. Ou no caso, se eu não tenho um post antes do post que eu estou estilizando, também não faz sentido ter um espaçamento em cima. Então uma das técnicas que eu gosto de usar aqui no CSS é usar o sinal do mais. O mais basicamente ele fala o seguinte, eu quero estilizar todo o post que contenha um outro post abaixo dele. Na verdade é o contrário, eu quero estilizar todo post que antes dele tenha um post também. E aí eu posso botar aqui por exemplo um margin-top 2 rem. Isso aqui só vai aplicar então para posts que tenham outro post antes dele. Ou seja, o primeiro post aqui não vai sofrer essa margem, só que os outros já vai receber a margem automaticamente. Daria para fazer isso aqui com first-child, last-child, daria para fazer com gap, dá para fazer de milhares de formas. Eu estou mostrando uma forma delas, mas CSS é uma das coisas que dá para fazer de inúmeras formas diferentes. Eu vou estilizar o conteúdo do post aqui que é mais simples, para depois a gente ir para o header aqui que vai dar um pouco mais de trabalho. Então no conteúdo a gente vai setar um line-height 1.6, color var grey 300 e um margin-top 1.5 rem. E aí nós vamos também pegar aqui o nosso parágrafo dentro do conteúdo e dar um margin-top 1 rem. E nós vamos pegar os links dentro do nosso conteúdo, aqui pode ser a ou pa, também vai funcionar os dois. E aqui a gente vai dar um font-weight bold, color var green 500 e um text-decoration non. Salvo, pronto, o conteúdo do post já está estilizado da forma que a gente precisava. Aqui a gente pode fazer o seguinte, dar uma olhadinha aqui do lado, tem um tom de verde aqui que é um pouquinho mais claro, que é esse aqui. Eu vou copiar esse tom de verde aqui, que é um pouquinho mais claro, a gente vai lá no nosso global, vamos criar aqui o green 300 por exemplo, que é um pouco mais claro e colar aquele tom de verde mais claro. Salvo, e agora aqui no hover do nosso link, a gente vai trocar a cor dele para green 300 aqui. Então vamos ver, salvo, volto aqui no app, beleza, já deu uma diferença. Aqui eu deveria ter colocado agora uma âncora, porque senão ele está no hover em todos. E aqui precisa de um espaçamento entre o emoji e a nossa âncora, aqui ela ficou junto. Se eu tentar dar um espaço aqui na mão, está vendo que não funciona. Isso é uma das coisas importantes de a gente aproveitar e entender aqui do React. Inclusive, se a gente pegar aqui e colocar uma âncora, esse último parágrafo aqui que é o da hashtag, se a gente colocar uma âncora por hashtag, deixa eu selecionar todas, colocar aqui um href, o que acontece? A gente vai ver que elas ficaram juntas. Por quê? Porque o HTML que a gente escreve aqui dentro do JSX, quando a gente coloca espaços aqui no final, esses espaços aqui não contam na hora de mostrar na interface. E isso é meio chatinho, e dentro do React só tem uma forma de a gente conseguir adicionar espaços, espaços reais entre elementos, como se fosse barras de espaço ali, que não seja pelo CSS, que é fazendo da seguinte forma, olha só. Eu tenho que colocar chaves, uma string, e aí eu boto um espaço. Então é como se eu estivesse colocando um texto JavaScript aqui dentro, que é só um espaço em branco. E isso aqui fica meio feio, concordo com você. Por isso, a melhor forma, na verdade, seria a gente fazer isso aqui com CSS. Mas, por enquanto, aqui como é só um elemento de texto, eu vou botar aqui um espaço no final dessa hashtag novo projeto, aqui, depois da hashtag NLW, e também aqui, depois do emoji, e antes da âncora com o link Jane Design Dr Care. Salvo, e agora aqui a gente já ficou com o espaço, aqui não ficou com o espaço, não sei porquê. Deixa eu tentar adicionar um pouquinho mais de espaço. Esse emoji aqui que está bugado, com certeza, cara. Ah, emoji é o caramba, eu vou arrancar esse negócio de emoji aqui. Show, ficou perfeito, hein. Agora sim. E agora aqui no nosso conteúdo, então a gente já consegue dar o hover por hashtag agora, né, fica bem melhor. Agora vamos para o cabeçalho aqui do nosso post, então eu vou começar aqui estilizando o nosso post. E eu vou estilizar o, deixa eu ver aqui, eu criei só como header. Aqui eu poderia botar uma classe ou estilizar direto o header do post. Eu vou fazer o seguinte, eu vou estilizar aqui post header, mas uma das coisas que a gente tem que cuidar quando a gente faz essas estilizações assim só pelo nome da tag do HTML, é porque isso aqui vai estilizar todos os headers que a gente tem dentro do post. Por enquanto eu só tenho um, mas mais pra frente eu posso ter mais. Então, na maioria das vezes quando eu faço essa estilização aqui, olha, eu quero estilizar o header, a tag header, que está dentro do post, eu geralmente coloco um sinal de maior aqui. Porque assim, o CSS vai buscar apenas as tags headers que estão no primeiro nível dentro do post. Ou seja, se eu tiver uma tag header aqui dentro, ele não vai estilizar, ele não vai pegar essa estilização. Ele vai pegar só a header que está diretamente dentro do nosso post. Então, quando eu uso estilização por tag HTML, se for um elemento grande como é o post, por exemplo, eu geralmente uso esse sinal de maior aqui pra evitar cagadas futuras, digamos assim. Mas a gente poderia também botar uma class name aqui no header que funcionaria sem problemas nenhum. Aqui no header agora eu vou botar aqui um display flex, align items center e justify content space between. Isso aqui vai fazer com que bote o publicado a uma hora totalmente pra direita e o restante totalmente pra esquerda, que ainda está meio grande. Vamos lá, vamos continuar aqui. Agora eu vou estilizar a nossa tag time ali, que é o publicado a uma hora. Esse aí é bem tranquilo, a gente vai dar um font-size de 0.875 pixels, que dá 14. E color var grey 400. Salvo. Ah, eu botei 0.875 pixels, mas era RAM, claro, unidade relativa, acontece. E agora a gente vai estilizar aqui o nosso author, que é o restante das informações. Então no author aqui a gente vai colocar um display flex, align items center também, e um gap de 1 RAM. Isso aqui vai fazer com que o nome e o cargo venham pra direita da imagem, centralizados, e tenham um espaçamento de 16 pixels entre eles, 1 RAM. A gente vai pegar aqui o nosso author info agora, que é o nome e o cargo, e a gente vai também dar um display flex, pode ser, e um flex direction column, pra forçar que eles sempre fiquem um abaixo do outro. Como eu estou usando tags strong e span, que por padrão elas tem display inline, por padrão elas iriam ficar uma do lado da outra, então eu posso forçar isso com o display flex. Ou, se eu não quiser usar o display flex, que é uma solução também, eu posso pegar aqui o author info strong, que eu vou ter que estilizar, e o span, e tiro isso aqui e jogo só um display block em um deles, ou nos dois até. E aí também isso aqui já vai forçar que eles quebrem a linha, que eles não fiquem inline. E agora aqui no nosso strong eu vou colocar uma color, var gray 100, line height 1.6, e no nosso span botar um font size 0.875 hem, color var gray 400, e line height 1.6 também. Salvo isso aqui agora, show, o nosso nome e o cargo ali já está certinho aqui do lado, falta essa imagem aqui que está grande pra caramba, e a gente vai estilizar isso agora. Então dentro de author eu vou pegar a nossa imagem, e aqui a imagem tem a estilização igual a da sidebar, então eu vou lá na sidebar procurar aqui pelo avatar que a gente tinha criado, e vou copiar o mesmo css aqui pra dentro. Então salvo, beleza, nossa imagem já ficou ali com o css aplicado. O nosso header e o nosso conteúdo então já estão estilizados exatamente como a gente gostaria, aqui igualzinho o figma, só falta aqui do post então a nossa seção de comentários, mas a aplicação já está ficando bem legal aqui."
  },
  {
    "id": "b3717e3d-2991-4906-82b4-c107296be1a1",
    "title": "Criação do projeto",
    "transcription": "O que a gente vai começar fazendo aqui no nosso novo projeto aqui dentro do Ignite é, claro, criar o projeto utilizando o VIT. Então, para isso, eu vou simplesmente aqui dentro na pasta onde eu tenho as aulas, onde eu já tenho o meu primeiro projeto, eu vou começar dando um npm create VIT arroba latest, para ele pegar a última versão sempre. Aqui a gente vai dar um nome para o projeto. Eu vou chamar de 02 Ignite Timer, que vai ser o nome do projeto que a gente vai estar criando. Além disso, eu vou selecionar aqui React, React TypeScript, e pronto, já estamos com o projeto criado. Vamos abrir isso aqui agora no Vast Code, para a gente já começar a visualizar. E a gente já conhece a estrutura de um projeto React, então a gente não precisa passar necessariamente por cada arquivo, mas eu vou começar aqui na pasta Search dando uma limpada, removendo alguns arquivos que a gente não vai utilizar. Então, CSS, SVG, outro CSS, SVG de novo. Vou remover tudo isso aqui. Aqui no main a gente pode também remover todas as importações que a gente não está utilizando, que é no caso o CSS. Aqui no app também vou remover o SVG, o CSS. Aqui no return a gente vai remover todo o conteúdo. E ele está com bastante erro aqui, simplesmente porque a gente não instalou as dependências. Então, aqui agora, depois de remover tudo, eu vou também no meu terminal. Pera aí que ele pediu para eu atualizar a versão do OU+.sh. Vou dar um npm install, e pronto. Todas as minhas dependências do projeto já vão ser instaladas. Outra coisa que eu gosto de fazer, eu não gosto de utilizar export default. Então, eu prefiro sempre utilizar named exports, até para não esquecer de trocar o nome de alguma importação em algum momento que eu estiver copiando arquivos. Então, eu troco aqui o export do app, apenas para export, e não export default. E aqui a gente muda sempre a importação para utilizar chaves e nunca fazer importação sem nome. Pronto, o nosso projeto já está todo configurado. Aqui no index, a gente pode remover por enquanto esse link do favicon, até porque a gente não tem nenhum favicon. E aqui no title, vamos trocar para ignite timer. De resto, podemos aqui rodar o nosso projeto para ver se ele já está funcional. Então, abrir aqui no navegador. Beleza, já tem aqui um projeto em branco por enquanto. E bota branco nisso, vocês podem ver que minha cara está até... Nossa, quase cego. Mas agora a gente vai começar criando o nosso projeto em cima dessa estrutura que a gente já deixou previamente criada."
  },
  {
    "id": "30e8e53e-ae4c-4193-bd8d-997a30d3951e",
    "title": "Componente: Sidebar",
    "transcription": "O que a gente vai fazer nessa aula é a parte do corpo agora aqui da nossa aplicação. E se a gente for ver aqui, hoje no corpo aqui da nossa aplicação, a gente tem basicamente uma sidebar. E nós temos aqui a parte onde ficam os posts, que posso chamar de feed ou timeline, qualquer coisa assim. A gente vai começar desenvolvendo a sidebar em si. Mas antes de desenvolver a sidebar, eu preciso separar essas duas áreas, já deixar o espaço pré-determinado para essas duas áreas existirem. E aí o que eu vou fazer? Lá no meu app.jsx, hoje eu tenho aqui o meu header e dentro eu tenho esses dois posts. Eu vou mudar um pouquinho aqui o que eu vou fazer. Eu vou fazer o seguinte. Aqui abaixo do header, e aqui eu dei um ctrl-x, eu não deletei, eu mantei isso no ctrl-v depois para botar em tela de novo. Aqui eu vou criar uma div, vou botar um class name nela de wrapper. Mas aqui eu também vou utilizar o css-modules, então eu vou criar aqui na pasta src um app.module.css. E aqui agora eu posso ter o import do global e posso, ao mesmo tempo, ter o import de algo que não é global. Por exemplo, import styles from app.module.css. E agora aqui dentro eu vou criar o wrapper. E aí uma das coisas legais é que o Vascode, se a gente procurar, ele tem uma extensão chamada css-modules que eu posso instalar. E ela facilita o seguinte, como agora eu já tenho aqui uma classe wrapper dentro do meu css, lá no meu app, quando eu for escrever aqui, styles. ele já traz que eu tenho um wrapper. Então ele já identifica automaticamente quais são os class names que eu tenho dentro desse módulo de css. Então aqui eu boto o wrapper. E aqui dentro eu vou ter a minha sidebar. Então eu vou ter um espaço pra sidebar aqui, por enquanto eu vou colocar apenas um aside. E embaixo eu vou ter o meu main, que vai ser onde vão ficar os meus posts. Então aqui dentro do main eu vou colocar os meus posts que eu tinha lá antes. E aqui dentro dessa side, aqui é onde vai ficar a minha sidebar, eu vou apenas escrever sidebar aqui dentro. E agora aqui no meu wrapper, no css do wrapper em si, eu vou fazer o seguinte. Eu vou falar que esse wrapper ele sempre vai ter 100% da largura. Eu acho que eu nem preciso colocar isso porque a div, por padrão, ela já é display block, então ela sempre tem 100% da largura. O que eu vou colocar aqui é que ela vai ter uma largura máxima de 70rem, e aí 70 vezes 16 aqui dá 1120. Como que eu peguei esse número? Novamente. Eu vim aqui e vi que esse box aqui tinha 832 de largura. E ele tinha um distanciamento de 32 da sidebar. E a sidebar tinha 256. Aí eu somei todas essas larguras e deu 1120. E aí como eu estou usando rem, eu fiz 1120 dividido por 16 e deu 70. E aí por isso que eu cheguei nesse tamanho aqui. E aí aqui eu vou botar margin 2rem em cima e embaixo. E nas laterais eu vou botar como alto, isso vai fazer com que fique centralizado na tela esse wrapper aqui. E aí aqui eu vou botar um padding de 0, 1rem. Isso aqui vai fazer com que se eu diminua a tela pra um tamanho menor que 70rem, o conteúdo não fique colado nas laterais. Ele dê um espaçamentozinho entre as laterais aqui de 16 pixels, só pra não ficar com aquela sensação de que o conteúdo ocupou a tela toda ali. E aqui agora eu vou usar um display grid. Vou dar um grid template columns. E aqui eu vou falar que a minha primeira coluna, que é a da sidebar, ela tem uma largura fixa de 256 pixels. E a segunda coluna, que é o nosso conteúdo, esse ele vai se adaptar pra quanto couber na tela. Então eu uso aqui 1fr, que é a unidade que a gente usa no grid pra dizer que algo vai ter um tamanho flexível. Aqui eu vou botar um gap de 2rem, ou seja, o espaçamento entre as colunas de 32 pixels. 2rem, 16 x 2, 32. Sempre fazer essas contas, é importante. E aqui eu vou dar um align items flex start. Isso aqui vai fazer com que a sidebar e a nossa div aqui que tem os posts, o nosso main, sempre fiquem alinhados pro topo. Se não, o padrão não é ficar alinhado pro topo. O padrão é tentar esticar os dois pra que eles tenham o mesmo tamanho. Então se a gente não colocar aquilo ali, ele vai tentar forçar a nossa sidebar ter a mesma altura desse main que tem os posts. Mas a gente sabe que não dá. A sidebar tem que ficar com esse tamanho fixo dela menor. O padrão aqui nesse caso que ele tem é o stretch. Mas a gente precisa usar o flex start. Salvo aqui agora, vamos dar uma olhada como é que ficou. Olha só. A gente já começa a visualizar, até se eu inspecionar aqui uma coisa bem legal, não sei se você conhece do Chrome. Ele já fala pra gente quando algo tá usando grid e quando algo tá usando flex. Se eu clico aqui no grid, ele já mostra ali em tela o grid nosso certinho. Inclusive eu posso vir aqui do lado, onde tá o display grid, clico aqui nesses pontinhos que tem aqui do lado. E ele permite a gente testar. Então por exemplo aquela opção de align items flex start que eu coloquei ali manualmente, pro padrão ela é esse stretch aqui. E aí a gente pode ir testando o que a gente gostaria de fazer. Isso é bem legal. Mas o que eu queria mostrar é isso aqui, passando o mouse por cima ele mostra ali exatamente como que tá o grid da nossa página. E aí, agora a gente vai pro nosso componente de sidebar. Então aqui em components eu vou criar sidebar.jsx. E vou criar aqui o nosso sidebar.module.css. Aqui dentro do componente do jsx eu vou exportar um componente chamado sidebar. E aqui no nosso sidebar module eu vou começar apenas com uma classe sidebar em si. E aí agora aqui dentro eu vou ter o meu aside class name. Opa, precisamos esquecer aqui de importar os meus estilos. Então import styles from sidebar.module.css. E aqui no class name, só de eu escrever styles ponto, ele já dá a opção aqui do sidebar. Então agora, vou salvar isso aqui agora. Nós vamos voltar lá pro meu app.jsx. E agora aqui no lugar de colocar esse aside, eu vou colocar o nosso componente sidebar. Então, não sei se você tá percebendo, mas o React, ele é... A interface é formada por uma soma de vários pequenos componentes. A gente vai separando a nossa aplicação em vários pequenos pedacinhos. Então, o componente do cabeçalho, o componente da sidebar, cada post é um componente. Ou seja, cada coisinha da nossa aplicação é um componente. E quando esses componentes são unidos, isso forma a nossa interface. Então, tudo que a gente for conseguindo aqui desacoplar e abstrair em componentes, a gente vai fazendo. Então, a nossa sidebar já tá aqui. Não tem nada em tela, né? Então, vamos voltar aqui pro CSS da nossa sidebar. Vamos começar colocando alguns elementos dentro da nossa sidebar, até pra gente visualizar. Então, aqui eu posso ver que na nossa sidebar eu tenho uma imagem de cover, né? Assim como tem nessas imagens do Twitter, YouTube, Facebook, aquela imagem de capa. Eu tenho aqui a foto de perfil do usuário, o nome, o cargo e um botão aqui de editar o seu perfil. Eu não vou colocar todos os elementos em tela ainda, até pra gente visualizar. Mas, vamos lá. Aqui dentro do aside, eu vou começar colocando aquela imagem de cover aqui, essa imagem de capa. E aqui a gente pode escolher. Eu vou deixar você escolher uma imagem que você mais goste. Por exemplo, uma dica. Você pode vir aqui no Unsplash, que é um repositório de imagens gratuitas. Procurar por developer, por exemplo. Escolher uma imagem que você goste aqui. Por exemplo, eu vou escolher essa imagem aqui. Clico no mais pra ela carregar. Clico com o botão direito. Copy image address. Colo aqui em outra aba. E ela já vai abrir. E aí pra gente não precisar carregar essa imagem tão grande, a gente vai ver que tem alguns parâmetros aqui na URL. Largura, altura. Eu vou botar aqui pra ela carregar com uma largura de no máximo 500 pixels. Pode ser. Então a gente vai ver que ela já carrega diferente. Então o W eu troquei pra 500. E eu vou diminuir a qualidade. Hoje tá 80%. Eu vou botar 60% aqui. Posso até diminuir mais, porque como a imagem vai ficar pequenininha, quase que não vai dar pra ver. E a qualidade dá uma melhorada bastante. Então eu diminuí a qualidade aqui pra botar 50%. Show. Copio agora esse endereço aqui em cima. E agora aqui no source da image eu vou colar esse endereço. O texto alternativo dessa imagem, nesse caso, a gente não vai colocar. Porque como isso aqui é uma imagem que geralmente é escolhida pelo usuário que tá utilizando a nossa aplicação, a gente não vai conseguir, a não ser que a gente tenha uma inteligência artificial, determinar qual que é o conteúdo da imagem pra colocar no texto alternativo. E nesses casos é melhor não colocar texto alternativo nenhum. Beleza. Além da imagem aqui, eu vou também criar aqui uma div pra ser o perfil do nosso usuário. Então eu vou botar aqui um className styles.profile, mesmo que não exista esse profile ainda lá dentro dos CSS, a gente vai criar ele daqui a pouco. E dentro desse profile aqui, por enquanto eu vou colocar um strong, que é o nome do usuário. E vou botar um span que vai ser o cargo. Vou botar aqui webDeveloper. E lá no final a gente tem aquele botão. Eu vou botar isso dentro de um footer. O botão eu vou botar ele como um link mesmo, não vou colocar ele como um button. Porque a gente não vai criar essa funcionalidade de editar o seu perfil, mas isso aqui me parece muito que na verdade, quando o usuário clicar nisso aqui, ele vai ser redirecionado pra alguma página pra alterar o perfil dele. Então nesse caso eu vou deixar como um link mesmo. Aqui no href eu vou botar aqui só uma hashtag. E dentro eu vou botar editar seu perfil. Tem o ícone que daqui a pouco a gente vai colocar também, mas por enquanto é isso. Salvo isso, volto lá na nossa aplicação e a gente já pode ver que algumas coisas já estão aparecendo por aqui. E aí a gente volta aqui pro nosso sidebar módulo e vou começar a fazer algumas estilizações. Na sidebar em si, eu vou botar um background com a variável gray 800, que é o mesmo que a gente usa no cabeçalho. Um borderRadius 8 pixels e um overflow hidden. Esse overflow hidden vai fazer com que elementos, por exemplo se eu não colocar isso aqui, a gente vai ver que o cantinho aqui da imagem, ele não fica arredondado. Mesmo o container da imagem sendo arredondado. Então se eu boto overflow hidden, os elementos dentro, eles só vão ocupar o tamanho da sidebar. A gente pode ver até que a imagem parou de ocupar um espaço maior que a sidebar. A gente esconde todo o overflow, tudo que do elemento, o conteúdo do elemento sai do tamanho do container. E aqui a gente vai estilizar aquela nossa imagem de cover. Vou botar aqui até uma classe nela. className styles.cover Vou quebrar isso aqui como eu já falei antes, que eu gosto de quebrar em várias linhas e aqui também. Pra ficar mais fácil visualizar. Volto lá e agora na nossa coverImage, eu vou definir que ela tem uma largura de 100%. Eu vou definir um height fixo de 72 pixels. E aqui eu vou dar um objectFitCover. O que acontece? Se eu não colocar esse objectFitCover, a gente vai ver que ele distorceu a imagem. Então ele comprimiu ali a imagem pra caber no espaço que eu falei. Se eu boto o objectFitCover, ele não vai distorcer a imagem. Mas ele vai cortar pedaços da imagem, digamos assim, só que ele não vai distorcer. Ele vai mostrar o centro da imagem ali e o resto ele corta, digamos assim. Ele só não mostra, mas a imagem não é distorcida. E agora a gente pode continuar. Posso começar mexendo aqui no nosso perfil. Então no perfil eu vou dar um displayFlex. FlexDirectionColumn, pra o nome do usuário e o cargo ficar um abaixo do outro. E aqui posso botar um AlignItemsCenter. Salvo. A gente já pode ver como ficou aqui. E aí a gente pode ir estilizando. Tem muita coisa ainda pra gente estilizar aqui. Mas... Vamos lá, uma outra coisa que eu posso fazer aqui é estilizar um pouco do nosso footer. O footer eu não criei uma classe, então eu posso estilizar como SideBarFooter. Como eu só vou ter um único footer aqui na minha SideBar, não tem problema estilizar dessa forma. E aí aqui eu vou botar, por exemplo, a BorderTop, 1px, solid, com a cor grey, 600. Posso botar um MarginTop de 1.5 rem, 20 pixels. Padding, 1.5 rem em cima, 2 rem nas laterais, 2 rem abaixo. Novamente, tudo isso são valores que estão dentro do Figma. A gente pode ir lá no Figma e visualizar. Seleciona o botão... Cadê o botão? Aqui, dá um Alt, a gente vê... Opa, eu peguei o ícone, não era o ícone que eu queria. Aqui, dá um Alt, eu vejo que ele tem 32 nas laterais, 32 embaixo, ou seja, 2 rem. Só que acima é 24. Então, 1.5 não dá 20, na verdade dá 24. 1.25 que dá 20. É normal às vezes a gente se perder nessas contas. E agora, salvo, vamos ver como está ficando o nosso app. Já deu uma distanciada. E a gente pode continuar. Vamos pegar aqui o SideBar, Footer, A. Vamos pegar o link que a gente tem dentro. E aí vamos começar. Aqui a estilização fica maior. Então eu quero uma largura de 100% nesse link. Quero que ele tenha um background transparente. Quero que a cor do texto seja aquele Green 500 que a gente tinha colocado. Vai salvando e vai vendo. Olha, já está ficando mais legal. Boto aqui um Border 1 pixel, solid, com a mesma cor Green 500. Vamos colocar o que mais? Border Radius 8 pixels. Vamos botar aqui um Height fixo de 50 pixels. Vamos botar aqui um Padding 0, 1.5 rem. Um Font Weight Bold. Display Block. Estou só vendo aqui na minha colinha os CSS que eu já... Text Decoration None. Então olha só, a gente vai salvando, a gente já vai vendo. Botei esse Display Block, eu não preciso do Width 100% porque ele já aplica automaticamente. O que mais? Vamos botar aqui um Display Flex. Vou jogar aqui tanto um Align Items Center quanto um Justify Content Center para o conteúdo do botão ficar totalmente alinhado ao centro. E é isso. Então a gente já tem o nosso botão aqui, mas ainda tem mais algumas coisas para a gente estilizar aqui na nossa sidebar."
  },
  {
    "id": "c0206163-7045-4596-a868-e806ffa4356a",
    "title": "Entendendo a key",
    "transcription": "Se a gente abrir a nossa aplicação e for no inspecionar elementos na aba console, a gente vai ver que está resultando em alguns erros aqui, e são dois erros que na verdade eles tem a mesma descrição, então vamos dar uma lida aqui neles, até traduzindo aqui, então ele manda, aviso, cada filho ou cada filho, quando a gente fala child ou parent aqui dentro do react, a gente está se referindo a componentes, child são componentes, filhos, ou seja, por exemplo, aqui no app, o header é um componente filho do app, porque ele está dentro do componente app, o app é um componente parent, ou seja, pai ou mãe do header, beleza? Então a gente sempre tem que olhar, entender essas nomenclaturas para conseguir entender os erros, porque ele fala aqui, cada child, ou seja, cada componente que está dentro de uma lista, precisa ter, deveria ter, uma chave key, uma prop key única, e aí só olhando aqui pelo erro, é claro que a gente pode clicar aqui no link do próprio react, e ele vai cair aqui numa explicação sobre as keys, é importante a gente entender o que é isso, e vamos começar primeiro resolvendo o erro, e depois a gente passa para a solução. Então ele dá o erro em dois lugares, se a gente voltar aqui na nossa aplicação, primeiro dentro do render method novamente, o que é render method? Método de renderização, nada mais é do que esse return, então o método de renderização é o que está dentro do return, então check the render method of app, ou seja, a gente vai aqui dentro do app, e aqui dentro do app, qual que é o lugar onde a gente tem uma lista? Aqui correto? Nós temos uma lista de posts, nós estamos fazendo uma listagem de posts, ou seja, lista aqui dentro do erro, simboliza qualquer coisa onde a gente tenha uma iteração, uma estrutura de repetição, ou seja, eu percorro uma lista de posts e mostro algo em tela, e aí o que o react pede para a gente, é que quando a gente está fazendo uso de uma lista, de uma iteração com um map, cada componente, ou até elemento, o primeiro componente que venha aqui dentro, ele tenha uma propriedade, e essa propriedade a gente não precisa usar ela dentro do componente, ela é uma propriedade só para o react, chamada key, sendo passada para esse componente, o que é essa propriedade key? Ela recebe, ela aceita qualquer valor, seja número, strings, qualquer coisa, só que a gente precisa passar para ela qual é a informação única de cada um dos posts, ou seja, de cada um dos itens da minha lista, ou seja, qual é a informação do post, nesse caso, porque é o item que eu estou percorrendo na lista, que me dá uma fácil identificação para eu saber qual post é qual, e aqui eu não sei se você lembra, mas a gente tinha criado no array de posts um id, e a gente não tinha utilizado, a gente pode usar o id, aqui por exemplo, se eu salvo isso aqui agora, e volto aqui no f5, a gente vai ver que um dos erros já saiu, sobrou apenas outro erro aqui, que está dentro do post agora, se a gente abre o componente de post, qual que é o lugar aqui nesse componente, que também nós temos uma lista, nós temos uma iteração, aqui, correto? Nós estamos percorrendo o conteúdo do post, e para cada linha de conteúdo, nós estamos retornando alguma coisa, aqui eu também preciso colocar aqui, Diego, mas olha só, agora a gente tem um if, se o tipo da linha for parágrafo, eu mostro alguma coisa, se não, eu mostro outra, aonde que vai aqui, agora aqui? Você concorda comigo que sempre vamos mostrar isso, ou isso? Nesse caso, aqui precisa ir em ambos, porque ambos parágrafos podem aparecer em tela, tá então quer dizer que aqui, eu não boto aqui na âncora, não, a gente só bota aqui no primeiro elemento que aparecer do retorno de um map, então o p, aqui no caso, independente da condição, se ele cair nesse if ou nesse if, ele é o primeiro elemento retornado de dentro do nosso método map, ou seja, aqui, precise nele, qual que é a informação que eu tenho agora, nessas linhas aqui de conteúdo do post, que me ajude a identificar cada linha unicamente, nesse caso aqui é complexo, porque eu não tenho um id, talvez se isso aqui fosse uma aplicação real, eu estivesse integrando com back-end, talvez eu realmente tivesse um id aqui, mas eu não tenho, então aqui, você pode utilizar, por exemplo, o conteúdo da linha, dificilmente a gente vai ter duas linhas com o mesmo conteúdo, então eu vou usar aqui o line.content, por exemplo, ah Diego, mas é um texto grande, tem problema? Não tem problema, melhor seria se a gente tivesse um id, claro, porque aí a gente realmente garantiria que não ia repetir, mas por enquanto a gente pode usar a linha, se eu salvo isso aqui e dou um f5, continua dando erro, provavelmente porque a gente tem sim conteúdo repetido, duas linhas aqui que tem o mesmo valor, então, o que a gente pode fazer aqui, vamos lá, aqui dá pra gente fazer algo bem legal pra demonstrar isso, hoje, se eu for ver aqui e dar um inspecionar elemento aqui dentro do nosso parágrafo, uma das coisas que a gente pode ver aqui, é que eu não consigo visualizar essa propriedade key dentro do parágrafo, porque essa propriedade key, ela é algo interno do React, o React não expõe isso no HTML, ele não mostra aqui, como que a gente pode fazer pra visualizar essa key, visualizar aqui os componentes do React, no fim das contas você vai ver que você não vê nenhum componente do React aqui no final, é só o HTML, porque o React no final ele gera só o HTML, uma das coisas que a gente pode fazer é instalar uma extensão no nosso navegador chamada React DevTools, mais pra frente a gente vai falar bastante ainda sobre ela, mas por enquanto a gente vai utilizar ela só pra inspecionar o nosso HTML, essa extensão tem pra Chrome, Firefox, você consegue instalar no Edge também através da Chrome DevStore, no Brave, em qualquer outro navegador, quando você instalar essa extensão, você fecha aqui o inspecionar elemento, abre ele de novo, e ele vai abrir essas duas abinhas novas aqui no cantinho, a gente pode clicar aqui na aba Components, e essa aba Components ela vai abrir parecido com o que a gente tem aqui na aba Elements do HTML, porém ao invés de mostrar o HTML, ele mostra os componentes do React, então olha só, eu tenho o meu componente App, lembra? Que é exatamente esse componente App que eu tenho aqui, o header lá em cima, o sidebar ali no ladinho, eu tenho o post1 aqui, o post2, então cada componente do React, ele é mostrado aqui dentro, e aí se a gente abrir aqui o post1, for aqui, dentro de Comment, que é o nosso comentário, e lá dentro do Comment, deixa eu até dar um inspecionar aqui, ou melhor, no texto, não é no comentário, aqui a gente também não vai conseguir ver aqui porque esse nosso texto aqui ele não é um componente, então a gente acaba não tendo acesso a isso, então deixa eu ver a melhor forma que a gente poderia fazer isso aqui. Bom, depois de dar uma investigada aqui, eu percebi que na verdade a gente, aqui no post, tem dois lugares que a gente está fazendo uma lista, tem aqui, na parte do conteúdo, e aqui não tem problema, até algo importante de se falar, não tem problema se aqui, nesse caso aqui, o conteúdo, por exemplo, de dois posts diferentes, for igual, para o React não é um problema, aqui ela precisa ser única dentro da renderização de um componente, então por exemplo, aqui ela precisa ser única, nesse caso aqui para o conteúdo, dentro do contexto desse componente aqui, se aqui embaixo vai ter outro componente com a mesma aqui, não tem problema, então por isso que aqui o conteúdo, ele não vai dar erro, a gente não precisa mudar em nada aqui, o problema é que lá embaixo, a gente também tem mais uma lista de comentários, que eu tinha esquecido, e nessa lista de comentários a gente também precisa colocar aqui uma key, passando, o comentário que também eu vou colocar, como a gente não tem um id, eu vou colocar o próprio texto do comentário com uma key, vou salvar aqui agora, a gente vem no console da F5, e a gente vai ver que já não tem mais nenhum erro aqui acontecendo, e agora, a gente já fez funcionar, mas a gente precisa entender o porquê que isso aconteceu, porquê que isso está funcionando, e porquê que a gente não pode colocar aqui duplicadas, porquê que isso existe, desculpa, e aí uma das coisas também que você pode ter passado pela sua cabeça é, Diego, a gente está fazendo um map, no array, o array, ele tem um índice dele, que vem 0, 1, 2, 3, 4, porquê que eu não uso esse índice aqui, como a minha key, então vamos lá, eu poderia fazer isso aqui, botar um parênteses aqui por volta do comment, pegar o índice de cada item do array que eu estou percorrendo, e usar o índice como key, se eu salvar vai funcionar? Vai funcionar. É bom fazer isso? Não é bom, e eu já vou te explicar o porquê, então vamos voltar aqui para o original, como estava, usando o comentário como key, eu vou abrir um novo arquivo aqui, e aqui a gente vai falar sobre a key no React, primeiramente, porquê única? Alguns conceitos que a gente aprendeu no React, eles são extremamente importantes para a gente entender o porquê que a key, aqui nesse caso, precisa ser única, a gente aprendeu os conceitos de estado, o conceito de propriedades, e aprendeu também o conceito de componentes, porquê que eu estou falando desses três conceitos? Existem três principais momentos, existem outros, mas existem três principais momentos em que um componente é renderizado novamente no React, e vamos lá, super importante a gente entender, quando eu falo renderizado novamente, quer dizer o seguinte, o conteúdo do componente, a interface do componente, ela é recalculada, a gente vai entender um pouco mais sobre isso mais pra frente com as próximas aulas, mas por enquanto a gente precisa entender isso, lembra que eu falei que toda vez que a gente altera aqui a lista de comentários, chama o método setComments, colocando um novo comentário no final, esse comentário aparece em tela, ou seja, isso aqui, essa operação, ela é recalculada pra mostrar um novo comentário em tela, e é isso que eu falo que é renderizado novamente, ou seja, eu estou mudando o estado, e por isso quando eu mudo o estado, eu preciso renderizar o meu componente de novo, ou seja, quando o estado altera, todo o código do componente, sempre que uma dessas variáveis aqui muda, o newCommentsText ou o comments, tudo isso aqui é executado de novo. Diego, isso não é não performático? Calma, a gente vai falar sobre isso mais pra frente. Segundo momento, quando o componente é renderizado novamente no React, quando a propriedade altera, ou seja, aqui no componente post, por exemplo, eu recebo uma propriedade author, uma propriedade publishedAt e uma propriedade content. Se qualquer uma dessas propriedades aqui tiverem o seu valor alterado, o post vai renderizar de novo, ou seja, ele vai recalcular todo o código dele aqui do zero. Terceiro ponto, quando o componente é renderizado novamente, quando um componente pai renderiza novamente. Isso aqui é importante de entender, porque se aqui no meu post eu tenho dois estados, por exemplo, quando eu faço a alteração desses estados, você concorda comigo que todo esse código aqui, como eu mesmo tinha falado, é executado novamente, ou seja, acontece um novo fluxo de renderização no React. Como esse componente post aqui é pai de todos os componentes de comentário, os componentes de comentário também são recalculados em tela. Mesmo que não tenha mudado nada entre eles, eles são recalculados em tela, ou seja, esses são os três principais momentos quando a gente tem um fluxo de renderização acontecendo dentro do React. E por que a gente está falando sobre isso? Quando a gente fala sobre listas, é aí que a gente cai no famoso, poxa, esse fluxo de renderização do React não pode ser lento? Pode! Principalmente se você tiver uma lista com muitos comentários. Imagina um post, ou sei lá, como a gente está trabalhando com uma timeline aqui, imagina que no nosso app nós não tenhamos dois posts, e sim 500 posts. Se a gente precisar alterar algum estado aqui desse app, renderizar ele de novo, por qualquer um daqueles três motivos que eu tinha colocado aqui, e essa lista de 500 posts precisar ser recalculada do total zero, isso quer dizer todo o HTML dos 500 posts tendo que ser criado do zero, sendo comparado post a post. Isso aqui vai demorar muito tempo. E por mais que às vezes muito tempo signifique para o React aqui 300 milissegundos, 400 milissegundos, isso já é muito tempo, principalmente na percepção do usuário que está utilizando aí a sua aplicação. E é por isso que a gente adiciona aqui. Quando a gente adiciona a key aqui dentro do post, a gente fala, olha, quando eu mostrei aqui os meus posts em tela, eu tinha o post 1, 2, 3 e 4, pensando que isso aqui é cada uma das keys que eu estou passando aqui para o post, que no caso poderiam ser strings, números ou qualquer coisa assim. E aí, se em algum momento o React precisar renderizar esse componente aqui de novo, ele não vai mais processar e renderizar todos os posts do total zero. Ele vai simplesmente comparar aqui, dos que já estavam na tela antes, com os novos, possíveis novos posts que possam ter que vir na interface. E aí ele vai ver, opa, olha só, estou renderizando essa lista aqui de novo, estou renderizando esse componente de novo, porque eu tenho um post novo, e aí ele recebe lá, tá, quais são os posts? 1, 2, 3, 4, 5, beleza, o 1 eu já tinha, não preciso, o 2 eu já tinha, não preciso, o 3 eu já tinha, não preciso, o 4 eu já tinha, não preciso, opa, já encontrei o único post que eu preciso mostrar em tela, que é o 5, porque o resto já estava. Então aqui ajuda o React a entender o que que já estava em tela e o que que não estava em tela. Beleza, a gente veio aqui para o primeiro ponto de entender o porquê daqui e o porquê que ela precisa ser única, porque se eu tivesse duas keys, por exemplo, aqui, repetidas, é muito difícil para o React saber, pô, qual que já estava em tela, qual que não estava, então elas precisam ser únicas. Agora, por que não posso usar o índice do array, que a gente viu? O índice do array também é único, então se eu tiver, por exemplo, uma listagem de posts aqui, e essa listagem de posts, vamos supor que sejam só os ids dos posts, 4 e 5, se eu for usar os índices aqui desse array, concorda comigo que o índice dessa posição é 0, depois é 1, é 2, é 3 e é 4, certo? Então se eu estou exibindo os posts em tela, a ordem dos meus índices é assim, e aí imagine que esses posts aqui estejam armazenados num estado ali do componente, ou vindo através de uma propriedade. E aí, por algum motivo muito louco, porque aqui a gente está falando de posts, então o motivo teria que ser um pouco mais maluco, mas a gente pode, a gente usa listas em qualquer lugar, mas imagine que por algum motivo eu troque de posição o item 5 com o item 3. Quando o React percebe que a gente mudou a variável posts, mesmo que seja trocando de posição, ele vai fazer o que? Opa, preciso renderizar meu componente de novo. Só que eu mudei os posts de posição, mas isso não vai fazer os meus índices mudarem de posição, concorda? Essa mudança de posição dos posts não vai fazer o terceiro item do meu array agora ser o item de índice 4. Ele vai continuar sendo de índice 2, ou seja, você concorda comigo que eu só mudei os posts de posição, mas os índices não mudaram de posição. Isso é péssimo, porque o React vai chegar aqui quando ele bater no índice 2 e vai ver opa, não é mais o mesmo post de antes, claro, porque antes o índice 2 era o post 3, agora é o 5. E aí o React vai, opa, preciso criar tudo do zero, porque parece que mudou o array, mas não mudou, a gente só trocou de posição. E se a gente tivesse utilizado um id, por exemplo, imaginando que a gente tivesse usado um id mesmo e os ids fossem as chaves, quando eu mudaria esse post aqui de posição, ele mudaria o id também de posição. E assim o React ia, opa, 1, 2, ah, o 5, agora tá o 5, beleza, então não preciso mudar, 4, 3, show. Então é por isso que a gente não pode utilizar o índice do array como chave e nem números aleatórios gerados ali no momento, a gente precisa usar realmente uma informação que a gente consiga identificar cada item daquela lista unicamente, mesmo se a pessoa dar um F5 na tela, aquele valor tem que se manter o mesmo, mesmo se a gente adicionar mais itens na lista, remover itens, mudar de posição, aquele valor nunca pode mudar."
  },
  {
    "id": "1919088b-1d45-46c2-8c92-749bebbcba9f",
    "title": "Formulário de comentários",
    "transcription": "O que a gente vai fazer nessa aula é a parte de comentários, pelo menos o formulário de comentários, para depois a gente construir essa parte de listagem dos comentários. Então, são coisas diferentes. Vamos começar com o formulário. Aqui no nosso post. No post, por enquanto, a gente tem o cabeçalho. Nós temos o conteúdo do post. E abaixo disso, a gente vai querer a seção de comentários. Então, a gente vai dar um enter depois da nossa div do conteúdo. E essa parte de comentários eu vou criar como um form. Vou tirar o action. Vou colocar apenas um class name. Styles.CommentForm, talvez. Pode ser. E aqui eu vou dar um enter. E aí dentro a gente vai ter um strong. Deixe seu feedback. Nós vamos ter um textarea. Meu Jesus, ele vem com um monte de propriedade aqui. Não precisa nada disso. Pode até fechar na própria tag, assim, hoje em dia. Antigamente não podia. E aqui dentro do textarea, eu vou colocar... O que eu vou colocar aqui? Colocar apenas um placeholder. Escrito deixe um comentário. E abaixo dele eu vou colocar um button. Type submit. Escrito comentário. Salvo isso aqui agora. Vamos lá para o nosso postmodule.css. Vamos começar editando agora o estilo do nosso comment form. E aí deixa eu pegar aqui minha colinha. Comment form, exatamente. A gente vai começar definindo aqui. Então, um width de 100%. A tag form, por padrão, ela não tem. Width 100%. Margem top 1.5 rem. Padding top 1.5 rem. Border top 1 pixel solid var gray 600. Então, esse margin e padding top é só para a gente conseguir criar esse distanciamento aqui. Então, eu quero que tenha um distanciamento da borda. Ou seja, interno, padding. E daqui para cá, margin. Então, a gente fica aqui com esse distanciamento e com esse distanciamento aqui. Agora a gente vai pegar aqui o nosso comment form. E vamos pegar o strong que está dentro dele. Aqui eu vou usar o sinal de maior também. Só para evitar no futuro a gente estilizar outros strong que tem ali dentro do comment form. Line height 1.6. Color var gray 100. Então, já está ali. Deixe seu feedback. Agora a gente vai estilizar o nosso text area. Esse aqui eu não preciso colocar o sinal de maior. Dificilmente a gente vai ter mais uma text area aqui dentro dessa seção de comentários. Vou botar nela também um width de 100%. Um background var gray 900. Vamos ver como é que está ficando. Já dá para ver que está ficando diferente. Aqui a gente bota border 0. Resize none. Eu não quero permitir que o usuário redimensione a text area. Aqui a gente vai dar um height de 6rem. Já está ficando legal. Um padding de 1rem. Um border radius aqui de 8px. Então, border radius 8px. Nós vamos colocar aqui um color var gray 100 do texto digitado. Aqui o line height é um pouquinho menor, 1.4. E um margin top de 1rem para fechar. Então, salvamos. Olha só. Já ficou bem legal aqui a nossa text area. E agora falta o nosso botão aqui de comentar. Então, vamos lá. Aqui vamos pegar a nossa text area. Vou pegar o nosso botão. E aqui o nosso botão vai ter um padding. 1rem em cima e embaixo. 1.5rem nas laterais. Ou melhor, aqui é só botão. Ou eu posso fazer botão 2.submit. Se eu não me engano, eu teria que fazer type igual a submit. Vamos fazer assim. Acho que fica até melhor. Aqui eu vou fazer um margin top, 1rem. Border radius 8px. Border 0px. Background var green 500. Color var white. Font weight bold. Cursor pointer. Vamos salvar aqui, ver como está ficando. O meu teclado às vezes dá uma bugada. E ele começa a digitar tudo como se eu estivesse com o command apertado. Aqui já está o nosso botão de comentar. Então, já ficou certinho aqui na nossa tela. Ele ainda não está com o hover. Então, o hover desse aqui vai ser bem simples. Quando o usuário passar o mouse por cima, eu vou só trocar a cor de fundo dele para aquele verde mais clarinho, que é o green 300. Já altera aqui. E aqui eu posso botar inclusive um transition no background color de 0.1 segundos. Só para ele fazer essa transição um pouquinho mais devagar. Show! Botão de comentário aqui está finalizado. Mas agora a gente tem alguns desafios antes de finalizar essa aula. Primeiro, aqui ele já deixou mostrando para a gente que quando o usuário está digitando alguma coisa na textarea, olha só, quando não tem nada sendo digitado, ela não fica com aquela bordinha verde. Agora, quando está sendo digitado, fica com a bordinha verde. Isso aqui a gente chama do focus dentro do CSS. Por padrão, o HTML e o CSS deixam uma borda branca. Mistura aqui uma borda branca, meio rosa, por causa do meu sistema operacional. Então a gente vai sobrescrever isso para escolher o nosso formato de focus. Hoje a gente pode ver que se eu venho aqui e dou um tab, todos os elementos, quando eu dou um tab, eles ficam com a borda branca. Só que eu gosto de sobrescrever isso. Só que eu sobrescrevo tudo de uma vez só. Então eu abro aqui o nosso global.css e aqui em cima, após o root, eu vou escrever dois pontos focus. E aqui eu vou botar outline transparent. Isso aqui deve tirar o focus padrão, ele já tirou aquela bordinha branca de tudo. E agora, para não ficar sem nada, eu uso um box shadow, 0, 0, 0, 2 pixels, var, brand, 500. Ou poderia ser também um outline. Aqui a gente já pode ver que o focus já ficou em todos os elementos a bordinha verde. Aqui no botão ele não fica tão legal, porque ele fica o mesmo verde do botão, então ele acaba dando essa sensação um pouquinho diferente. E aí uma das coisas que a gente pode fazer nesse botão, deixa eu até testar aqui. Se eu botar outline, 2 pixels, solid red, por exemplo, eu teria que dar um offset aqui. Mas por enquanto deixa assim, eu acho que não é tanto uma preocupação, mas mais pra frente a gente pode melhorar isso. Então agora quando eu dou focus aqui na nossa textarea, a gente já tem essa bordinha verde de 2 pixels. E aí uma das outras coisas, a gente pode ver que esse botão aqui de publicar, que o botão é publicar e não comentar, ele só aparece quando o usuário também tá com o focus. Tá vendo que aqui ele não aparece aqui embaixo, porque o usuário não tá digitando nada. Então eu quero que ele apareça somente quando o usuário tiver com a nossa textarea aqui focada. E dá pra gente fazer isso só com CSS. O que a gente vai fazer aqui dentro do nosso CSS? Por padrão, eu vou pegar o nosso botão aqui, e eu vou colocar que ele tem visibility hidden, e eu vou colocar aqui um max height de 0. Se a gente salvar isso aqui agora, olha só, ele já não aparece mais na tela. E... deixa eu ver aqui o que a gente pode... aqui só que ainda assim ele ocupa o espaço. Visibility hidden, max height 0. Como é que essas propriedades que eu coloquei de visibility e max height, eles não estão funcionando pro botão? Porque ele acaba ocupando o espaço, até se eu dou um inspecionar aqui, ele mostra como se o botão ainda estivesse ali. Então eu vou usar uma outra técnica, aí você tá pensando, ah Diego, tá com um display none ali que vai funcionar. Sim, se eu usar aqui um display none, ele funciona. Mas o display none não é muito bom pra acessibilidade, na maioria das vezes a gente tem que cuidar na hora de utilizar ele. Então o que eu vou fazer aqui na verdade, eu vou criar uma div, pode ser um footer aqui, por volta do botão. E aí aqui agora eu vou pegar o comment form footer, e eu vou botar nele essas duas tags aqui. Essas duas propriedades, visibility hidden e max height 0. E aí já vai funcionar o botão não aparece. E agora eu posso fazer o seguinte, eu posso dar um comment form, dois pontos, focus within. Esse focus within, ele é diferente do focus tradicional do CSS, ele basicamente me fala, olha, se houver um foco em qualquer input ou text area, ou qualquer elemento dentro do comment form, eu quero aplicar alguma estilização no footer, ou em algum outro elemento de dentro desse container. E aí eu quero botar visibility como visible, e o max height aqui, ele tem um padrão que é none. Salvo, e agora olha só, quando eu dou o focus no input, o nosso botão aparece. Quando eu tiro, ele some. E assim, se eu dou um focus também no publicar, ele não some. Porque o focus within, ele não serve pra focus apenas na text area. Ele serve pra foco em qualquer elemento que esteja dentro do nosso comment form ali. Então, agora a gente já está aqui com a nossa sessão de comentários finalizada. O que falta mesmo agora é a gente criar a parte estrutural e visual dessa listagem de comentários aqui embaixo."
  },
  {
    "id": "972fa395-b397-4193-9f72-194da0008604",
    "title": "Salvando um objeto no Reducer",
    "transcription": "Uma das coisas mais legais da gente estar utilizando Reducers aqui, e agora talvez a sua cabeça vá fazer um... Hummm, tá, entendi agora e o negócio é massa. O que que acontece? Tem muitas vezes aqui na nossa aplicação que você vai ver o seguinte, tá? Eu altero, isso aqui é como a aplicação estava antes, né? Eu vou usar o código que está nos comentários. Eu estava sempre, ó, alterando ciclos, e eu sempre alterava o id do ciclo ativo logo depois. Tá vendo? Olha só, eu altero ciclos e altero o id do ciclo ativo. Quando eu interrompia, a mesma coisa, ó, eu alterava os ciclos e alterava o id do ciclo ativo. Então eu precisava fazer duas alterações no estado, uma após a outra. E muitas vezes até eu tinha que alterar três coisas do estado ao mesmo tempo. Os ciclos, o id do ciclo ativo, o tanto de segundos que passou. Ou seja, tinham estados que eles eram correlacionados, e que eu precisava alterar eles ao mesmo tempo, e pra isso eu precisava chamar funções diferentes e tudo mais. Só que olha que legal, quando a gente usa um reducer, eu não tenho a obrigatoriedade de salvar dentro desse reducer somente uma informação, digamos assim, só a lista de ciclos. Eu posso salvar várias informações aqui dentro e manter e alterar várias informações. Então isso é muito legal. Olha só o seguinte, por exemplo, eu posso vir aqui em cima, vou criar uma interface chamada CyclesState, que vai ser o estado, digamos assim, dos meus ciclos. Digamos, o tipo da informação que eu vou salvar dentro do reducer. E olha que legal, agora eu vou dizer que isso aqui é um objeto, ou seja, eu vou salvar um objeto dentro do meu reducer, não direto o array de ciclos. E aqui eu vou falar que eu vou ter dentro dele um array de ciclos, igual o que eu tenho hoje. Porém, dentro do meu reducer, eu vou salvar também já o meu ciclo ativo. Então o meu ActiveCycleId, que vai ser uma string, ou nulo caso ele não esteja preenchido. E agora, aqui no meu state, eu vou trocar para CyclesState, e aqui eu tenho que mudar um pouquinho a lógica, principalmente desse retorno. Porque agora, para eu adicionar um novo ciclo aqui dentro, não é mais eu retornar um array daqui de dentro, eu preciso retornar um objeto. Aqui dentro do objeto, eu preciso copiar todos os dados que eu já tenho no meu objeto, ou seja, no meu estado, para que eu não mude o valor do ActiveCycleId quando eu estou adicionando um novo ciclo. Logo a gente vai dar uma olhada nisso. E aí eu preciso, aqui dentro, atualizar o meu valor dos ciclos, falando que o meu ciclo é uma cópia dos ciclos que eu já tenho no meu state, adicionando um novo ciclo no final. Deu um erro aqui, vamos ver. TypeNever is missing the following properties from type. CyclesN, esse retorno aqui, ele está copiando tudo que eu tenho do meu state, que é o CyclesState, e alterando aqui a variável Cycles. Esse Cycles aqui é Cycle. Esse newCycle, ele está como N, que talvez possa ser um problema. Esses erros do TypeScript. Inclusive, sabia que tem um site que ajuda você a entender os erros do TypeScript? Deixa eu ver se eu consigo encontrar esse site aqui. É TypeScriptErrorTranslator, acho que era assim. Esse cara aqui mesmo. Você coloca o erro do TypeScript, dá um Submit, e ele tenta desmembrar o erro, explicando o que está acontecendo. Isso é muito legal, porque os erros do TypeScript, muitas vezes, não estão tão claros. Mas tudo bem, a gente não vai usar isso aqui agora, porque eu quero entender o que isso aqui está acontecendo. A gente está retornando um objeto aqui. Vamos tentar cortar por partes. Se eu copio o objeto inteiro, ou se eu retorno o objeto assim, ele continua dando erro. O que acontece? A gente mudou o nosso formato do CycleState, porém aqui, está vendo esse Array aqui embaixo? Era o valor inicial do nosso estado. A gente ainda está retornando ele como um Array. Então agora eu preciso retornar como objeto, porque o valor inicial. E aqui eu passo Cycles. Aqui sim, eu inicio ele como objeto com um Array vazio. E o ActiveCycleId, eu vou reiniciar ele como nulo. E agora sim, agora já parou de dar erro, já está bem massa. E agora, o que acontece? Tanto o valor dos ciclos, quanto o valor do Id do ciclo ativo, vão ser controlados por um único estado, digamos assim, que é o meu Reducer. Eu não preciso ter vários estados dentro do meu componente para controlar o valor de várias informações, se essas informações pertencem ao mesmo assunto. Aqui então, agora, no lugar de Cycles, eu não vou mais utilizar Cycles diretamente, porque senão vai ficar muito genérico o nome. Eu vou chamar isso aqui de CycleState. E aqui de dentro do meu CycleState, eu posso buscar informações específicas, como os ciclos e o meu ActiveCycleId. Então, eu não preciso desse estado aqui para controlar o ActiveCycleId. E agora a gente vai começar a sobrescrever algumas coisas aqui. Então, eu vou mover isso aqui para baixo, para deixar o UseState em cima. Eu prefiro que os hooks aqui, UseState e UseReducer, sejam a primeira coisa do componente. E aqui embaixo, vamos ver, SetSecondsPass não mudou nada. Aqui embaixo agora, isso aqui não mudou nada. Aqui no CreateNewCycle. Aqui no CreateNewCycle, antes, a gente estava pegando o id do ciclo criado e setando como o id do ciclo ativo. Não preciso mais colocar isso aqui agora. É só eu vir aqui no meu Reducer e fazer o seguinte. Além de eu mexer na variável Cycles, agora eu vou mexer na variável ActiveCycleId, falando que o novo valor dela vai ser o Action.Payload.NewCycle.Id. Ou seja, eu estou pegando o id do novo ciclo que eu estou inserindo e estou setando ele como o ciclo ativo já. Tudo numa porrada só, eu não preciso executar duas funções. E por mais que o código, vou confessar que ele ainda está um pouco embaralhado, um pouco confuso, mas a gente vai melhorar isso bastante ao longo das próximas aulas. Então, por enquanto, tenta ir entendendo aí conforme for, depois a gente vai melhorando. E agora, aqui no Interrupt, mesma coisa. Mesma coisa, quando eu estou fazendo uma interrupção, quando eu estou interrompendo o ciclo, eu também estou alterando o id do ciclo ativo para NULL. Então, eu vou tirar isso daqui e olha só que legal. Agora eu vou lá no meu Reducer e vou fazer o seguinte. Se o Action.Type for igual a InterruptCurrentCycle, e aí vamos ver o que ele fazia aqui. Ele pegava o ciclo ativo e cadastrava uma data dentro do InterruptedDate. Então, a gente vai fazer mais ou menos a mesma coisa aqui dentro. Eu vou retornar daqui de dentro. O que eu vou fazer? Eu vou modificar o valor dos meus ciclos, já vou fazer isso, porém, o que eu quero fazer aqui dentro também é trocar o meu ActiveCycleId para NULL. Certo? E agora, aqui nesse Cycles, a gente vai copiar mais ou menos o código que a gente já tinha antes. Então, eu vou lá procurar aqui o código, deixa eu tirar o comentário, vou copiar esse State.Maps, tiro isso daqui, e aqui agora, no meu ciclos, eu vou jogar isso aqui, porém, só vou substituir algumas variáveis. Então, aqui não vai ser StateJet, vai ser State.Cycles.Map, e aí, para cada ciclo, eu vejo se o id é igual ao ActiveCycleId, só que esse ActiveCycleId também vem de dentro do meu State. E aí, eu boto o InterruptedAt, se não, eu retorno. Beleza, o código está aqui. Então, vamos salvar aqui agora, e a parte de interromper o ciclo também deve estar funcionando. Então, eu venho aqui em Projeto 1, 20 minutos, começar. Beleza, está rodando. Se eu clico em Interromper aqui agora, interrompeu sem problemas nenhum. A gente pode ver até que ele voltou aqui para o timer zerado, que é uma ação que acontece quando eu mudo o ActiveCycleId para nulo. Então, cara, isso aqui é muito legal. Reducer é uma parada muito legal, e você não vai ver isso sendo utilizado somente dentro do escopo do React nesse contexto. Reducer, digamos assim, é uma... Não dá para chamar o Reducer já diretamente de arquitetura, mas é um padrão, é um pattern, usado para várias coisas. Em várias ferramentas diferentes, em várias bibliotecas diferentes, em vários contextos diferentes, você vai conhecer esse pattern de Reducer. Então, é super importante. Se você não conhecia ele ainda, você vai conhecer mais um pouquinho, e a gente vai construir coisas fantásticas com ele a partir de agora. Bora lá!"
  },
  {
    "id": "0eea3cf5-e2c1-4826-bca5-549b334acd3f",
    "title": "Separando Actions",
    "transcription": "Eita, comecei a gravar e esqueci da minha câmera aqui. Mas outra coisa que eu gosto de fazer bastante aqui, quando eu utilizo o Reducers, é abstrair também as chamadas das nossas actions. Então, o que que acontece? Quando a gente realiza, por exemplo, chama aqui a action de Add New Cycle, a gente sabe que aqui no Payload eu preciso enviar um novo ciclo. Mas se em algum outro lugar da aplicação eu chamar o Dispatch, da mesma forma, passando o type ActionTypes.AddNewCycle e vier aqui no Payload, por exemplo, pode ser que no momento que eu estou escrevendo isso aqui eu pense, cara, o que que eu tinha que enviar mesmo no Payload? Bah, não lembra. Aí tu vai ter que procurar algum outro lugar que tu chamou Add New Cycle pra ver, ah não, eu preciso enviar um novo ciclo aqui dentro, o nome tem que ser... porque aqui eu posso enviar o que eu quiser. E não vai dar erro. Porque o meu Reducer não está validando a chamada do Dispatch. Então, a gente vai ter que cuidar um pouquinho disso aqui. Então, o que que eu gosto de fazer? E agora já indo para o momento final, digamos, de estruturação aqui do Reducer. Ao invés de o nome do arquivo ser Cycles, eu gosto de criar Cycles. Aqui eu vou até renomear. Criar Cycles como uma pasta. Dentro, ter um arquivo chamado Reducer. Então, Reducers, Cycles, Reducer. Aqui dentro é aquele arquivo que a gente já tinha. Isso aqui não muda nada. Só tenho que arrumar a importação aqui pra importar agora do arquivo chamado Reducer. E agora aqui dentro eu crio um arquivo chamado Actions. E aqui eu vou passar esse Export in Action Types lá pra dentro. Aqui agora, esse Action Types vai vir de outro lugar. Então, eu arrumo aqui a importação. Tanto no meu contexto quanto lá no meu Reducer. Também tem que importar aqui. Action Types. E agora aqui dentro de Actions, o que que eu vou fazer? Eu vou criar aqui dentro uma função pra cada Action. Então, por exemplo, AddNewCycle. E eu vou dar só um sufixo aqui pra ela de Action. AddNewCycleAction. E aqui, essa função nada mais vai do que retornar exatamente o conteúdo aqui do meu dispatch pra quando eu quero adicionar um novo ciclo. Então, eu vou até copiar aqui. E boto aqui. E agora, como essa Action, pra criar um novo ciclo, eu preciso enviar qual que é esse novo ciclo, eu vou receber um parâmetro aqui, que é o meu novo ciclo. O tipo dele vai ser Cycle, que eu posso importar lá do meu Reducer. E aí, pronto. Minha Action tá pronta. E aí eu posso criar pro restante também. Então aqui, posso até substituir já esse código aqui por AddNewCycleAction, passando o meu newCycle. Perfeito. A gente vem aqui, copia agora o conteúdo desse dispatch aqui do MarkCurrentCycleAsFinished e vai criar uma outra aqui. Posso até duplicar. Ela vai se chamar... deixa eu ver o nome que eu tinha dado aqui pra ela. Pode ser MarkCurrentCycleAsFinished. Ela não precisa nem receber parâmetro. Só falta o Action aqui no final. E ela retorna isso aqui. Eu nem preciso enviar o Payload aqui, o ActiveCycleID, porque isso eu já tenho lá dentro. Então aqui eu não preciso enviar nada, na verdade. Isso aqui eu preciso fazer o return. E agora lá no meu Reducer, aqui nesse MarkCurrentActionAsFinished, ele já tá pegando o ActiveCycleID do próprio Reducer, então eu não preciso enviar como parâmetro. E aqui eu só troco pra MarkCurrentCycleAsFinishedAction. Eu botei o Action aqui no final, só pra não bater com o mesmo nome que eu tô usando pra essas funções aqui. Então a gente vai ver que... só pra não ficar igual. E aqui agora, o nosso último, que é o Interrupt, certo? InterruptCurrentCycleAction. E aqui eu vou chamar o nosso InterruptCurrentCycle. Também não preciso enviar Payload. Trocamos aqui pra InterruptCurrentCycleAction. Salvo. Venho lá no meu Reducer. Deixa eu ver se ele tá usando já. Tá usando. Então agora, novamente, deve estar tudo funcionando normal. Projeto 1. 20 minutos. Começar. E a gente vai ver que tá funcionando tudo certinho. Aqui dentro das Actions... Deixa eu ver... Eu acho que por enquanto tá bom. A gente já foi bastante pra frente, não precisamos mais modificar aqui muita coisa."
  },
  {
    "id": "40a8e2b0-c134-4d68-b4f3-9c81149c2932",
    "title": "Componente: Post",
    "transcription": "O que a gente vai fazer nessa aula é o nosso componente de post aqui, então essa sessão, e a gente vai começar criando esse elemento, o componente de post em si, o cabeçalho do componente de post e também o conteúdo. A parte de comentário vamos deixar para uma próxima aula, senão a gente também vai levar muito tempo aqui. E para a gente começar criando nosso componente de post, a gente já tinha criado um componente de post aqui que está na pasta search, a gente utilizado esse componente para explicar os conceitos de componente e propriedade, mas a gente não vai utilizar ele, então vou deletar esse arquivo e lá na pasta components eu vou criar um arquivo chamado post.jsx e post.module.css Você pode estar percebendo que a gente está colocando todos os arquivos aqui dentro de uma mesma pasta components, e talvez já te dê vontade de começar a separar isso em mais pastas, mas uma das coisas que é importante e a gente como deve é tentar evitar otimização prematura. Na grande maioria dos projetos, às vezes a gente tenta criar uma estrutura de pastas mais robusta do que aquele projeto precisa, piorando a manutenabilidade do projeto ao invés de ajudar. Então nesse projeto, para o tamanho que ele vai ficar, não tem problema todos os arquivos ficarem dentro de uma única pasta, e na maioria das vezes as nossas pastas do projeto em algum momento elas vão ter muitos arquivos lá dentro, ou pelo menos muitas pastas, e esse não deveria ser o problema, não é isso que vai causar uma manutenção pior do projeto. O que vai causar uma manutenção pior do projeto é o conteúdo desses arquivos, a nomenclatura que você dá no nome dos arquivos, porque de restante, se for fácil a pessoa encontrar o que ela está querendo dar manutenção, o que ela está querendo modificar dentro do projeto, o resto é tranquilo. Então aqui dentro, no post, a gente vai começar exportando uma função, post, aqui eu vou retornar por enquanto apenas um h1, hello world, e aqui no post.module.css eu já vou deixar uma classe post pronta. Aqui no nosso app a gente já estava utilizando post antes para demonstrar o conceito de propriedade, só que a importação aqui ela estava importando do ponto barra post, ou seja, ele ia procurar um componente post dentro da pasta onde está o app, porém agora o componente está dentro da pasta components, então a gente tem que colocar aqui o components barra post para ele fazer a importação. Vou salvar, a gente já pode ver que o hello world já está aparecendo aqui. Essa sidebar também eu vou mover aqui pra cima para ficar as importações de componentes tudo juntinho aqui em cima. Show de bola, agora aqui dentro do nosso post a gente vai começar a criar a estrutura. E aí como que eu crio meus componentes aqui dentro do React? Geralmente eu começo com a estrutura HTML, então eu olho aqui para o Figma e penso o que eu vou precisar de HTML para mostrar isso aqui em tela. Depois que eu passo da estrutura HTML eu vou para o CSS, para depois ir para a parte funcional que seria como que o usuário interage com esse post em si. Então é geralmente assim HTML, estilização e funcionamento. Então pra gente começar a fazer esse post eu vejo que eu vou precisar de um cabeçalho. Dentro aqui do cabeçalho eu vou precisar de uma imagem de avatar que é bem parecida com essa imagem que eu tenho aqui na sidebar, nome do usuário, cargo e eu tenho aqui do lado a data de publicação desse post. Então eu tenho um cabeçalho do post que contempla todos esses elementos aqui, o conteúdo do post e depois aqui a gente tem a parte de comentários. Então vamos lá, eu vou começar usando o post como um article do HTML e aí agora vou importar aqui os meus estilos de dentro de post.module.css. Aqui no article nós vamos utilizar um class name styles ponto e ele já deu a opção aqui da gente utilizar o post. E aqui dentro do article nós vamos criar um header que é o cabeçalho do post, que é onde vai ficar o avatar, o nome, o cargo e a data de publicação. Aqui dentro do header, pra criar, isso aqui é uma coisinha chata né, pra criar essa parte aqui que tem o avatar de um lado e aí duas informações no outro, que não é uma só, eu vou ter que fazer isso aqui com uma div por volta disso aqui, porque senão vai ser mais difícil alinhar. Então vou ter que ter uma div aqui por volta do avatar e dessas duas informações e depois uma div por volta desses dois aqui, pra ser mais fácil alinhar, senão a gente vai ter que usar um grid, vai ter que usar alguma coisa um pouco mais complexa. Então eu vou começar com uma div, essa aqui eu vou botar um class name aqui, isso é uma das coisas pra gente cuidar né, você viu ali como eu me descuidei, eu escrevi styles ponto author, dessa forma assim dentro do class name, mas isso aqui já ia dar um erro, que às vezes eu ia ter que ficar procurando por muito tempo, então não é com aspas aqui, e sim com chaves, é uma variável né, javascript. Aqui dentro do author agora eu vou precisar daquela minha imagem de avatar, e aqui eu posso botar novamente https://github.com barra diego3g.png, você pode copiar a mesma imagem de avatar que você utilizou lá na sidebar, certo? Aqui eu posso botar um class name styles.avatar, aqui agora eu vou precisar mais uma div, que ela vai ficar por fora do nome e do cargo do usuário, do autor, eu vou chamar de author-info aqui eu vou ter um strong, que é o nome, vou botar Diego Fernandes, e eu vou ter um span, que é o cargo, que eu vou botar aqui web-developer. Fechado, agora que a gente já tem aqui o autor, por volta da div, depois da div do autor inteira aqui ó, eu vou colocar esse publicado a uma hora, e aí existe uma tag especial do html, quando a gente está se referindo a datas, tempos, digamos assim, que é a tag time, essa tag time aqui, ela é muito legal, por quê? Porque a gente consegue colocar no conteúdo dela, por exemplo, publicado a uma hora, que é o que está escrito aqui, só que publicado a uma hora, não fala pra gente exatamente quando que foi publicado, né, então a gente sabe que esse post aqui saiu a uma hora atrás, mas não sabe a data exata, e muitas vezes a gente quer permitir que o usuário, até por questões de acessibilidade ou SEO da nossa página, saiba exatamente quando que esse post foi publicado. Essa tag time, ela permite que a gente passe pra ela uma propriedade aqui, um atributo, chamado date-time, tá, e aqui eu tenho mais um ensinamento super importante pra gente ter no react, tá, uma das coisas que o react muda quando a gente usa os elementos aqui do html, é que até nos atributos dos elementos html, se esses atributos aqui, eles forem nomes compostos, como é esse caso, que o date-time são duas palavras diferentes e não uma só, a gente também utiliza a letra maiúscula, usa esse padrão de camel cave, né, a primeira letra maiúscula nas palavras seguintes aqui também, né, então por exemplo, a gente tem o svg, né, que a gente tem lá, aqui por exemplo, a gente tem no svg o fill rule, por exemplo, lá nos paths, aqui ó, nesse caso aqui, se fosse html tradicional, a gente usa dessa forma, assim, a gente pode usar, até com ifim, se não me engano, só que com o react, a gente não tem ifim e a gente não deixa as palavras juntas, assim ó, a gente bota também com a primeira letra maiúscula, então sempre que você vê que tem algum atributo do html que ele é composto por mais de uma palavra, as palavras sequentes, ela sempre tem a primeira letra maiúscula, e aqui eu posso botar como a data real, então posso botar, por exemplo, 2022 05 11 8 00, ou só, como se fosse a data de publicação real desse post aqui, né, e aí, se eu salvo isso aqui, a gente vai ver lá em tela, que ele fica ali ó, publicado a uma hora, só que dentro da inspeção aqui do html, a gente tem a data real do post, e outra coisa legal, que eu gosto de fazer também, quando a gente tem esses indicadores publicados, é, publicado a uma hora atrás, uma das coisas que eu gosto de fazer, é aqui nesse time, colocar um title, e aí botar, por exemplo, 11 de maio às 8 e 13, por exemplo, salvo isso aqui agora, por que que eu gosto de fazer isso aqui? Para o usuário, que está vendo aqui o feed, caso ele queira saber exatamente quando que o post foi publicado, ele pode só passar o mouse por cima aqui do publicado a uma hora, aguarda um pouquinho, e ele fala exatamente, ele é 11 de maio às 8 e 13, então é interessante, porque esse publicado a uma hora, assim, por mais que ele traga uma sensação boa para quem está usando, de tipo, saber exatamente, ah tá, uma hora atrás foi publicado, ele pode dar o efeito contrário, principalmente se você tem posts mais longos, ah, publicado a um mês atrás, tá, mas, quando? Qual data? Quando que foi publicado isso, né? Então assim a gente consegue saber exatamente quando que esse post foi publicado, isso é bem interessante a gente fazer e cuidar bastante, né? E agora que a gente já terminou o nosso header, abaixo do nosso header aqui, eu vou colocar uma div, o class name dela eu vou botar como styles, pode ser content, que é o conteúdo do post, e aqui dentro desse conteúdo do post, cada linha aqui de conteúdo, né, eu vou botar dentro de um p, então aqui ó, eu vou clicar com o botão direito, copy as text, colo aqui, dentro do nosso, ah, the file contains one or more unusual file terminators constructor, line, line, separator, paragraph, it's recommended to remove, tá, remove, remove, beleza, então eu copiei aqui o conteúdo, vou só arrumar a identação, e agora em cada linha dessa aqui eu vou botar um parágrafo, então aqui a gente vai selecionar, existe outra forma de fazer, né, aqui no meu Vascode, por exemplo, eu posso selecionar um pouquinho dessa linha, um pouquinho, um pouco dessa linha, um pouco dessa, opa, eu posso botar vários cursores na verdade aqui, né, como é que é, com alt, é isso, clico alt, ó, coloco vários cursores no começo de cada linha, digito o p aqui pra abertura, shift, copio o p de fechamento, vou pro final da linha, com o command pro final, ou com o end, no caso se você está no Windows ou no Linux, e dou um ctrl v, e assim cada linha agora ela tem um parágrafo, e aí aqui ó, nesse link do site e nas hashtags, eu vou colocar uma âncora por volta, então href, não precisa ter href nenhum, é só pra, e aqui nos hashtags em si, a gente vai colocar também uma âncora, pode ser uma âncora por volta de tudo tá, até pra facilitar, claro que no mundo real seria um link por hashtag, mas como aqui o conteúdo do post ainda está estático, não tem porque a gente se preocupar com isso, salvo isso agora, e a gente já pode ver aqui como ficou. Então a estrutura HTML do nosso post aqui tá pronta, agora a gente precisa partir pra estilização dele."
  },
  {
    "id": "084a931c-d7ee-4a67-8b17-ab79aa8400c7",
    "title": "Separando componentes",
    "transcription": "Nessa aula o que a gente vai fazer aqui é começar a separar esse componente da ROM em mais componentes. Porque se a gente for ver aqui hoje no nosso código, tudo o que a gente tem da ROM, seja o countdown, o formulário, tudo a gente está colocando dentro de um único componente. E por mais que agora, como a gente está trabalhando diariamente, aula após aula, na mesma aplicação a gente não se perca olhando para esse código, é muito comum quando a gente estiver mais avançado e trabalhando com outras aplicações ou até quando essa aplicação aqui tiver dezenas de páginas, a gente não lembrar mais exatamente sobre toda a estrutura que a gente criou aqui dentro desse componente. E por isso, uma das coisas aconselhadas a se fazer é quando um componente começa a crescer muito, a gente começa a repartir ele em componentes menores. E tem dois grandes momentos e duas formas de a gente repartir componentes e transformar um componente maior em componentes menores. A primeira forma, que é a mais comum, de quem começa a trabalhar com React, que é quando você percebe que algum componente está sendo utilizado muitas vezes dentro da sua aplicação e aí você percebe que aquele é um componente, quando você tem algo repetido. E um outro momento, uma forma de você repartir um componente maior em componentes menores, é quando você percebe que existem partes de um componente maior que podem funcionar sozinhas, sem depender do restante. Então, por exemplo, aqui a gente tem o Countdown, que é um componente que tem apenas o intuito de exibir quanto tempo já se passou desde que começou o timer. Meu cachorro está muito reclamando que ele quer sair da sala. Boa! E outra forma de você saber, o Countdown tem essa responsabilidade de mostrar o timer e a gente tem aqui em cima um componente formulário. Se a gente for pensar bem, eu não preciso, em todos os momentos da minha aplicação, que o meu Countdown, por exemplo, inicie com base no formulário. E nem o formulário necessariamente precisa do Countdown. São coisas que, sim, compõem uma interface maior, mas elas não são dependentes entre si. Então, o Countdown, por exemplo, pode ser um momento que eu posso arrancar ele da aplicação e o meu formulário vai continuar funcionando sem problemas nenhum. E, novamente, o meu formulário eu posso também arrancar ele da aplicação e eu posso criar uma outra forma de inicializar o meu Countdown que não seja no formulário. Ou seja, são coisas que podem ser desacopladas. Então, quando a gente percebe na nossa aplicação que a gente consegue separar um componente em pequenas partezinhas que podem funcionar separadamente, de forma isolada, esse é um bom momento de a gente criar esses componentes menores. E aqui a gente vai começar criando duas pastas dentro da Home. Eu vou criar uma pasta chamada New Cycle Form e dentro eu vou criar um arquivo index.tsx, que vai ser o meu componente, e um styles.ts. E eu vou criar uma outra pasta chamada Countdown, também com um index.tsx ali dentro e um styles.ts. E agora a gente vai pegar aqui o código HTML do Form Container e eu vou jogar lá dentro do meu New Cycle Form. Então aqui dentro eu vou exportar uma função, New Cycle Form, vou retornar aqui dentro o meu Form Container, e aqui agora eu vou jogar pra dentro dos estilos, tudo que é relacionado ao formulário que está lá nos estilos da Home. Então aqui a gente vai pegar o Form Container, o Base Input, o Task Input, Minutes Input Amount, esses estilos aqui, eu vou jogar para os styles aqui do New Cycle Form. E aí agora eu vou importar esses estilos aqui dentro. Então a gente vai começar com o Form Container, a gente tem aqui o Task Input também, o Minutes Amount Input, e é isso, o restante a gente não precisa. É claro que vão ficar alguns erros aqui, mas o intuito agora não é a gente resolver os erros, e sim só separar os componentes em componentes menores. Aqui dentro também está faltando importar o styles, por isso que está dando erro aqui. Perfeito, agora a gente vai para o Countdown, então eu copio aqui o Countdown Container, vamos criar aqui o componente Countdown, e aqui eu vou colocar o nosso Countdown Container, importei um caractere aqui que não precisava. E aqui agora eu vou copiar para os estilos, então o meu Countdown Container e o meu Separator, que são os componentes que eu uso lá dentro, o restante eu não estou utilizando. Aqui eu importo o Style Component, e aqui no Countdown eu importo o Countdown Container, e importo também o meu Separator ali de dentro. E aqui, novamente, a gente vai estar com erros porque essas variáveis não existem dentro desse componente, mas logo a gente vai resolver isso. E lá no meu Index, que sobrou aqui da ROM, eu vou simplesmente aqui no meu Form importar o meu New Cycle Form aqui dentro, e abaixo dele o Countdown. E a minha aplicação vai estar com erros, ela não vai estar executando, por isso a gente nem vai testar, porque está cheio de erros, mas assim pelo menos a gente já deu uma limpada aqui nos nossos componentes, já começou a estruturar em outros componentes menores. E claro, a gente precisa separar a parte funcional também do JavaScript e não só a visual, que é o HTML e CSS, entre esses componentes que a gente criou aqui. Então, bora lá! Só antes da gente mover aqui também a parte da lógica e ir para a próxima aula, uma das coisas que eu vou fazer, que isso aqui é um padrão meu, é que eu gosto de criar, quando eu tenho alguns componentes, que eles são específicos de uma página, como eu fiz aqui, eu criei esses componentes direto dentro da ROM, é um padrão meu, e aí pode ser que você curta ou não, eu gosto de criar uma pastinha Componentes, por volta, e aí eu jogo esses componentes aqui dentro. E aí aqui no index, eu só tenho que trocar a importação, nesse caso ele já trocou aqui a importação, para usar o caminho de componentes ali. Então, componentes que eles são globais, que a gente vai utilizar em vários locais da aplicação, eu jogo dentro da pasta Componentes, que está diretamente dentro da pasta Source, componentes que são locais de uma página específica, eu jogo dentro de uma pasta Componentes, aqui dentro da própria página."
  },
  {
    "id": "b596968a-cc88-4d7f-86e9-34960a80784e",
    "title": "Contexto entre rotas",
    "transcription": "O que faremos aqui agora? É o seguinte, até agora a gente colocou o nosso contexto aqui de ciclos da nossa aplicação aqui na nossa home, então aqui na home page nós temos o nosso contexto aqui de ciclos que está provendo essas informações aqui para o componente countdown e para o new cycle farm. Mas nós temos uma página na nossa aplicação que é a página de histórico e essa página de histórico também precisa saber sobre os ciclos. E aí que vem, como o nosso provider do cycles context está aqui dentro da home, aqui dentro, só por volta desses dois componentes aqui, não tem como eu acessar as informações desse contexto aqui lá na página do histórico. E aí quais são as minhas alternativas? Como essa aplicação não vai salvar no banco de dados, nem nada disso, se fosse uma aplicação que eu me comunicasse com um back-end, digamos assim, e salvasse as informações dos ciclos num banco de dados, numa API, aí beleza, porque aí quando a gente trocasse de página aqui para a página do histórico, eu faria uma chamada para a API, buscaria todos os ciclos e traria aqui dentro, não precisaria de alguma forma, de alguma estrutura aqui no React, uma funcionalidade compartilhar informações entre a home e o histórico, porque elas seriam duas páginas totalmente descoladas. Mas como aqui eu não tenho uma API, eu não tenho nada disso, e o intuito realmente aqui é não ter, porque algumas aplicações não necessariamente precisam de uma API, eu preciso de alguma forma compartilhar essa informação da home, dos nossos ciclos, entre essas duas páginas, isso aqui, essa variável ciclos, porque essa variável ciclos é a única coisa que eu preciso aqui. Com essa variável ciclos aqui dentro, eu consigo listar tudo isso aqui, o nome do ciclo, a duração, quando que ele foi iniciado e o status que a gente consegue a partir disso aqui, interrupt the date, finish the date, e se não tiver nenhum desses aqui, quer dizer que ele ainda está em andamento. Então, vamos lá, como é que eu vou conseguir compartilhar isso aqui lá com o meu componente de histórico? Se a gente for usar a regra de contexto, que a gente já conhece, eu teria que mover esse cycles context provider aqui para algum lugar que ele ficasse por fora, por volta de todos os componentes que precisam das informações desse contexto. Então, se eu tirar ele daqui, eu dou um CTRL X, tiro ele daqui também, e dentro aqui certinho, se eu tirei ele daqui, e agora eu preciso colocar ele em algum lugar na nossa aplicação, que tanto a página home quanto a página history vão ter acesso, o único lugar para eu colocar isso aqui é aqui no meu app, inclusive tem um desgraça no arquivo que já era para ter sido deletado, mas aqui no meu app. Aqui no meu app é o lugar onde eu coloquei o roteamento da aplicação, ou seja, a página home e a history estão aqui. E aí, só para não colocar aqui dentro do componente de router, porque a ideia é que ele fique somente responsável pela navegação, eu posso pegar e colocar aqui por volta. Então eu venho aqui por volta das rotas e coloco o nosso cycles context provider, e aqui embaixo da rota eu fecho o nosso cycles context provider. Mas aí ele está faltando um monte de coisa aqui, então eu teria que vir aqui no index, pegar esse contexto daqui, mover para lá também, importar aqui o create context, e aqui eu teria que mover tudo isso aqui que a gente tem aqui para dentro do app. Mas aí imagina, se eu fizer isso aqui com vários contextos da minha aplicação, o meu app aqui vai ficar uma esgraceira de código, muito código aqui dentro misturado de vários contextos diferentes da aplicação, e vai ser muito difícil eu me achar nesse código. Por isso, o que eu gosto particularmente de fazer? Eu gosto de criar uma pastinha separada para os meus contextos, e aqui eu crio um cycles context.tsx. Aqui dentro, o que eu vou fazer? Eu vou criar o meu contexto aqui dentro, eu vou colocar tudo o que tem relação com o meu contexto aqui dentro. Então olha só, eu vou importar aqui o create context do React, esse cycles context.type está lá na home, então a gente pega isso aqui, aqui eu preciso desse cycle, vou pegar lá da home também. E agora o meu contexto está aqui. Certo? Só que aqui no app, mesmo que o meu contexto esteja ali, eu vou ter que continuar colocando o código da home, essas funções, tudo isso aqui dentro do app. Ou seja, acabou que não ajudou muito. Mas, o que a gente pode fazer é o seguinte, aqui nesse cycles context, olha só, eu posso aqui de dentro criar um componente chamado cycles context provider. Ele é um componente que visualmente não vai ter nada, nenhum funcionamento. E aí, aqui dentro, o que a gente vai fazer? Eu vou colocar esse código aqui, cycles context provider, aqui dentro. E agora, aqui, eu vou trazer todo o código da home para preencher aqui, para tirar esses erros. Então a gente vai lá na home, eu vou começar copiando essas três variáveis aqui, e boto aqui em cima. Vou importar o useState, aqui que está faltando, show, já parou. Opa, joguei no app, esquece, não era aqui no app não, era aqui no cycles context. Aqui, importo o useState. Beleza, já parou de dar alguns erros ainda aqui, mas ainda falta eu puxar algumas funções. Então, do formulário não precisa, isso aqui precisa. Então a gente vai mover lá para dentro do contexto também. Beleza, faltam essas duas aqui, setSecondsPassed e markCurrentCycleAsFinished. Então a gente vem aqui para a home e copia essas duas funções aqui, coloca aqui, deixa eu minimizar elas. Beleza, já não tem mais nenhum erro aqui. Porém, na nossa home, aqui, a gente tem agora duas funções que ficaram aqui, que elas usam daquelas funções setCycle, setActiveCycleId e tudo mais. Então, para facilitar, o que eu vou fazer é mover essas duas funções aqui. Também lá para dentro do meu contexto. Aqui eu vou trocar o nome delas, vou chamar de createNewCycle. E aqui, interruptCurrentCycle. E eu vou enviar essas funções aqui no meu contexto. Então aqui, createNewCycle. Para criar um novo cycle, eu preciso de alguns dados. E aí eu vou criar uma interface, createCycleData. A gente já vai falar um pouquinho sobre isso. E ela vai ter os mesmos dados que eu tenho lá na minha home, que é esse nosso newCycleFormData. Que é taskString e minusAmountNumber. Então, taskString e minusAmountNumber. E aí, uma das perguntas que você pode estar tendo é por que eu não estou usando aqui a mesma interface, tanto aqui na home, o mesmo tipo, exportar ele de alguma forma, reaproveitar entre os dois arquivos. Porque eles pertencem a camadas diferentes, digamos assim. O que eu quero dizer? Imagine que, em algum momento, eu possa criar na minha aplicação algum ciclo. Chamar essa função de criação de ciclo, sem ser pelo formulário. Ou imagine que, em algum momento, eu remova totalmente a biblioteca React Hook Form e o Zod, a biblioteca de validação da minha aplicação. Eu não quero que isso interfira no meu contexto. Lembra que eu falei que o meu contexto tem que ser meio que desacoplado de bibliotecas externas? Para que um dia, se eu mude as bibliotecas externas, isso não afete aqui dentro do contexto. Eu não preciso mudar tanto o código. Então, lá na home, essa tipagem aqui está totalmente conectada com o Zod. Então, não tem problema aqui ela estar conectada. Porque, aqui, React Hook Form é a interface, ele precisa estar presente. Se um dia mudar, eu vou ter que mudar esse arquivo de qualquer jeito. Porque o React Hook Form já está usando aqui em vários lugares. Mas, lá no contexto, eu não vou importar o Zod só para reaproveitar a tipagem ou usar uma tipagem que é específica da nossa biblioteca de formulários aqui dentro do meu contexto. Então, aqui, mesmo que eu tenha que recriar essa interface, que pareça repetição de código, muitas vezes é melhor repetir o código do que fazer um emaranhado de importações e exportações entre os arquivos. Beleza, o Create New Cycle já está funcionando. A gente vai enviar agora isso aqui para o contexto. E o último aqui que é o Interrupt Current Cycle. Essa aqui não recebe parâmetros, então é mais fácil. E não tem retorno também. Então, a gente coloca aqui embaixo. E aqui, onde tem o New Cycle Form Data, a gente coloca o nosso Create Cycle Data. Beleza? Só tem um erro que sobrou nesse arquivo, que é o Reset. Eu vou deixar comentado por enquanto, a gente já vai falar. A gente não vai deixar de falar sobre isso aqui. Salva isso aqui agora. O nosso arquivo está prontinho. E agora, o que eu vou fazer? Eu vou lá no meu app. E aqui, por volta do meu router, eu vou colocar o nosso CyclesContextProvider, que é o componente que eu acabei de criar ali dentro do nosso arquivo de contexto. Porém, tem um problema. Se eu passo o mouse aqui no CyclesContextProvider, ele está falando o seguinte. Que é um erro que, para ser bem sincero, não fala nada com nada, se você não sabe um pouco mais a fundo do React e do TypeScript. Mas, traduzindo aqui de uma maneira humana de entender isso aqui, o que quer dizer? Está vendo que aqui, para esse contexto, eu estou passando um elemento dentro da tag? Então, veja que eu não estou colocando o meu CyclesContextProvider dessa forma, onde a tag fecha nela mesma. Eu estou passando algo dentro dela. E quando eu passo algo dentro de um componente, aqui no meu CyclesContextProvider, eu preciso falar, dentro aqui do meu return, aonde que esse conteúdo que eu estou passando aqui como filho desse componente superior vai ser acoplado. Então, a gente chama isso no React de children. Então, aqui em cima, nas minhas propriedades, existe uma propriedade especial do React que é a propriedade children. E ela é criada pelo próprio React e o conteúdo dela vai ser tudo o que a gente passar dentro do nosso componente. E aí eu posso utilizar o nosso children aqui embaixo. A gente vê que já para de dar erro, ele só está dando erro aqui por causa do TypeScript. Então, já para satisfazer o TypeScript, a gente vai criar aqui uma interface CyclesContextProviderProps, falando quais são as propriedades que esse componente recebe. E ele recebe apenas uma propriedade children. E aí, para colocar a tipagem aqui do children no React, a gente usa um carinha chamado ReactNode. ReactNode nada mais é do que qualquer HTML válido, qualquer JSX válido. Então, quando eu boto ReactNode aqui dentro, quer dizer que eu posso colocar div, posso colocar outro componente, posso colocar só um texto. Tudo o que é válido pelo React ser escrito aqui dentro do HTML, o ReactNode é a tipagem para aquilo. Salvo isso aqui agora, a gente está bem perto de finalizar. E agora tem algumas importações para arrumar. Então, aqui no Countdown, por exemplo, quando eu dou useContext no CyclesContext, não está mais no mesmo caminho. Então, eu dou um Ctrl Espaço de novo aqui e faço a importação correta. Mesma coisa no new CycleForm. Tiro aqui e faço a importação do contexto do lugar correto. E lá na nossa Home, está dando erro aqui em vários lugares. A gente vai aqui também utilizar do contexto. Então, aqui eu dou useContext, CyclesContext e não CyclesContextProvider. E aqui eu vou pegar a função createNewCycle, vou pegar a função interruptCurrentCycle. E agora a gente vai fazer o seguinte, aqui no HandleSummit eu posso passar a função createNewCycle. Aqui embaixo interruptCurrentCycle. E aqui, como eu preciso do activeCycle também, posso pegar do meu contexto também. Fechou. Tem mais algum erro aqui? Ah, o reset. Por enquanto deixa eu comentar isso aqui, só para ver se o resto está funcionando. Aqui em cima ficou alguns códigos, importações que eu não uso mais. Volto no Google Chrome, vamos lá. Agora a gente vem aqui no localhost, começa um projeto, 15 minutos, começa. Está funcionando, sem problemas nenhum. E agora, se eu precisar acessar qualquer coisa do meu contexto lá na página de histórico, eu vou conseguir também. Porque agora o meu contexto está por volta das duas páginas, porque ele está por volta de todo o roteamento da aplicação. Então sempre que a gente precisar que uma informação esteja disponível para várias rotas da nossa aplicação, a gente coloca o provider do nosso contexto sempre no app, sempre no componente que está por volta dessas rotas. E aí só para a gente finalizar, aqui no nosso CyclesContext, a gente vai pegar agora a nossa informação de ciclos, adicionar ela também dentro do contexto. Aqui embaixo a gente vai enviar ela. E agora lá no histórico eu posso fazer aqui um useContext no nosso CyclesContext. E agora eu tenho acesso à minha variável de ciclos aqui dentro. Inclusive posso botar aqui um pré. E aí eu jogo um json.stringFileCyclesNull e 2, só para ele formatar certinho para eu conseguir visualizar isso. E agora olha só, já aparece aqui o projeto que eu iniciei, o tanto de minutos, a data de finalização. Se eu venho aqui e inicio um outro projeto com 20 minutos, começo... Opa, deu um erro aqui. Então se eu inicio o projeto 2 com 20 minutos, começo ele, clico aqui em interromper, volto no histórico, já está a data que eu interrompi aqui também. Então a gente já consegue comunicar os componentes e está ficando bem legal a nossa aplicação."
  },
  {
    "id": "78ee7138-0f5b-48fb-8f3a-b832ca77af87",
    "title": "Componente: Heading",
    "transcription": "Nessa aula, a gente vai criar o nosso componente de Heading, e ele é muito parecido com o componente de Text, por isso eu posso basicamente copiar o conteúdo aqui do componente e a gente vai simplesmente colar ele aqui. E aí o Heading, a única diferença é que eu vou utilizar ele por padrão um H2. Por que por padrão eu boto ele um H2 e não um H1? Porque a gente só pode ter um H1 por página, enquanto H2, comumente a gente pode ter vários na página. Então eu não coloco como um H1, e aí se a pessoa quiser colocar como um H1 na hora de usar, ela passa um H1 ali na hora de definição do próprio componente. E aí aqui a gente vai deixar o font-family default mesmo, o line-height a gente vai diminuir um pouquinho, quando são Headings, cabeçalhos, a gente não trabalha com line-height muito grande, a color a gente vai deixar essa mesmo, e aqui nas variantes a gente vai mudar um pouquinho, porque eu não quero que, na verdade, as variantes sejam as mesmas entre os cabeçalhos. Porque muito dificilmente a gente vai ter um cabeçalho com uma fonte, por exemplo, XXS, muito pequeno. Então o que a gente vai fazer? A gente vai trabalhar aqui com fontes maiores, então eu vou falar que se a pessoa passar a variante Small, por exemplo, a font-size desse Heading já vai ser a XL, ou seja, bem maior. A Medium, por exemplo, vai ser a 2XL, a Large vai ser a 4XL, a 2XL vai ser a 5, e aí a gente vai aumentando, a 3 vai ser a 6, a 4, a 5 e a 6 vão ser a 7, a 8 e a 9. E aí aqui agora, Type of Heading, o default, vou passar a Medium mesmo, a gente salva isso aqui agora, vem aqui, a gente vai criar aqui o Heading.stories.tsx, praticamente o mesmo conteúdo aqui do Text, só o tigran aqui, que a gente não vai colocar ele tão grande, então vou botar aqui como Custom Title. Aqui onde está escrito, todos os lugares que estão escritos Text, a gente pode trocar para Heading, e aqui a gente pode colocar o Custom Tag e a gente vai trocar o As aqui para H1. E aqui eu vou até te mostrar uma outra coisa legal, vou botar aqui a 8-1-heading, deixa eu salvar isso aqui agora, ver se a documentação está ficando ali ó, does not provide an export name Heading, ah tá, aqui dentro a gente não exportou o Heading, então agora pronto. Custom Title, e no Custom Tag aqui ó, ele já aparece H1 Heading, ele tem que estar com a Tag H1 nesse caso, show de bola. E a gente pode trocar, como eu falei, a Tag por qualquer outra Tag em si. E aqui eu quero te mostrar um negócio legal, ah, Heading Props, deixa eu ver, Heading Props, show, tá rodando, eu tinha feito alguma coisa errada, show. Uma coisa legal é que, ah, bugou alguma coisa aqui, ah, tá, não sei porque ele bugou isso aqui, tá bugando mas tá funcionando, deixa talvez eu dar, vou parar o servidor aqui, vou dar um Reload Window no meu Vast Code, ah, Yarn, melhor, npm, RunDev, ah, Import ID will always be undefined because the file tokens this index has no export, nossa, lá vai, ah, acho que tá bugado isso aqui, ah, meu Deus, bugou tudo agora, no meio da aula, não tem problema, vamos tentar entender o que tá rolando aqui. Uma das coisas que pode ser comum acontecer são realmente esses bugs durante a execução aqui dos pacotes, isso aqui na verdade é bem comum, principalmente quando a gente tá usando a própria pasta dist como sendo a nossa pasta aqui, tanto de build quanto de desenvolvimento. Então, uma das coisas que talvez seja legal a gente fazer, deixa eu até aproveitar essa aula pra gente fazer isso aqui, é criar uma limpeza de cache aqui dentro, então por enquanto eu vou fazer isso manualmente, então eu vou deletar todas as pastas dist aqui, tanto de tokens quanto do React, do storybook static também, pra ele gerar tudo do zero, e a gente vai rodar a storybook, aqui não tem, aqui tem cache do storybook, deixa eu deletar esse cache aqui do storybook também, e a gente vai rodar um npm rundev novamente, ah, could not resolve ignite UI tokens, deixa eu dar um npm install aqui pra garantir que ele instalou tudo, vamos aguardar um pouquinho, fazer a instalação, beleza, hoje a internet tá rápida. Então, npm rundev, vamos aguardar de novo aqui ele fazer o carregamento, normal, não adianta ter muita pressa, show, tá funcionando agora, H1 heading, vamos ver se parou de dar o erro lá dentro dos stories, ignite UI react, restart TS server, deixa eu ver se ele tá conseguindo encontrar, tá, agora parou de dar erro. Então, às vezes é bom a gente dar uma limpada no cache, inclusive mais pra frente eu vou até anotar aqui pra gente criar um script pra fazer essa limpeza de cache de forma mais automática, mas o que eu queria te mostrar aqui é que na própria criação aqui dos nossos stories, dentro do storybook, a gente consegue adicionar um texto complementar, digamos assim, dentro dessa área docs aqui pra facilitar o entendimento, então por exemplo esse H1 heading aqui ele não quer dizer muita coisa, então aqui dentro, abaixo de args, a gente pode passar parameters, docs, description, story, e aqui a gente passa o texto que a gente quiser, por exemplo, por padrão, o heading sempre será um H2, veja que eu coloquei H2 entre acento grave aqui atrás, porque isso aqui pode ser um markdown, e aí eu boto aqui, mas podemos alterar isso com a propriedade pass, salvo isso aqui agora, quando eu volto ele já coloca essa documentação aqui dentro, e aí a gente pode adicionar texto, isso aqui é um markdown, como eu falei, a gente pode adicionar o que a gente preferir aqui dentro pra mostrar aqui dentro, inclusive eu posso adicionar também JSX caso eu queira mostrar alguma coisa aqui mais trabalhada."
  },
  {
    "id": "5e132cea-e863-498a-ba87-7be79141d334",
    "title": "Componente: Text",
    "transcription": "Nessa aula o que a gente vai fazer é o nosso componente de texto. Então vamos lá. O componente de texto não vai ser só um componente estilizado. Na verdade ele vai ser sim. Então a gente pode criar da mesma forma que a gente criou o box. Então eu vou criar aqui um text.tsx. E aqui eu vou simplesmente, novamente, exportar um text que é igual a um style. Vou usar o parágrafo por padrão. E aí depois eu vou mostrar um negócio bem legal que dá pra fazer com o Stitches. Mesmo que a gente defina aqui o parágrafo por padrão, no Stitches a gente consegue mudar a tag. Então aqui, por exemplo, no box. Onde a gente colocou aqui o componente box em si. Se eu tivesse usado aqui o box, por exemplo, em algum outro lugar, só pra mostrar. Todo o componente do Stitches, ele pode receber uma propriedade chamada s, pra gente trocar a tag. Então se eu não quero que seja div e seja a, por exemplo, eu consigo mudar isso. Mas se eu vou, a gente vai mostrar isso aqui no texto mesmo. Então aqui o font-family, eu vou colocar default, line-height, base. A gente vai botar aqui um margem zero, pra tirar aquela margem que vem com o parágrafo por padrão. E a cor padrão também é sem, mas a gente pode mudar depois. E aí no componente de texto, a gente vai criar uma variante. Que é basicamente o tamanho do texto. E aí, esse tamanho de texto, a gente vai seguir mais ou menos os tokens de font-sizes. Então eu vou copiar aqui os tokens. Na verdade eu quero copiar somente o que vem antes dos dois pontos. Então eu vou selecionar aqui todas as linhas, pego o que vem antes dos dois pontos e copio. E aqui agora eu vou colar tudo isso aqui. Deixa eu só reposicionar. Botar aqui o editor na linha. Copiar de novo. E aqui eu vou dar um dois pontos. Font-size. E a gente vai botar só com o sinal de dólar na frente. Porém eu preciso sem as aspas. Então, deixa eu fazer de novo aqui. Sem as aspas, então eu precisaria, na verdade, o que eu vou fazer? Eu vou pegar esse aqui e copiar primeiro. E agora eu venho aqui e copio esses valores aqui. E agora faltou a vírgula no final da linha. Eu nem sei o que eu estou fazendo com o teclado, mas é isso, funcionou. Então a gente consegue setar todos os tamanhos de fontes desse texto através de uma propriedade. Então agora quando a gente usa text a gente pode passar size pra ele e passar, por exemplo, large. E aí a gente customiza o tamanho desse texto em si. E aqui eu vou falar que por padrão a variante size é median. Então por padrão ele vai usar o font-size median aqui. Vou salvar. A gente vai criar agora o nosso textstories.tsx. Vamos copiar aqui o do box. E agora nesse nosso texto aqui eu vou chamar de typography text. Aqui é text, aqui faltou exportar as props. Então export, interface, text props, extend, component props do react, type of text. E aqui a gente vai pegar também aqui no index. A gente precisa exportar tudo que vem do text. E aqui pronto, então agora sim a gente consegue botar text. E aqui text props, text props. Children, aqui por padrão a gente vai colocar... Esse é, talvez, example text pra deixar tudo em inglês certinho. Ou melhor, a gente pode colocar aqui dentro um lorem. Deixa eu copiar aqui, lorem. E aí eu copio esse texto todo e coloco dentro de aspas. E aí show. Agora se a gente voltar aqui dentro, já está aqui o typography text. E o texto já está aparecendo ali dentro sem problemas nenhum. E aí como eu falei, vou até criar aqui pra gente ver. Por padrão o texto é um parágrafo. Eu vou criar aqui uma outra story chamada custom tag. Pra gente mostrar que dá pra criar textos com outra tag. Então aqui no argumento a gente vai passar... Vou trocar o children aqui pra strong text. Então imagina que eu queira trocar agora nesse story aqui a tag p, por na verdade uma tag strong. Então basta eu enviar aqui a tag, a propriedade s, strong, salvo. E olha lá, ele já ficou com uma strong. E aqui a gente pode ver que ele não conseguiu reconhecer as propriedades aqui do text props. E aí vamos lá. Se eu não me engano, aqui quando eu uso o component props, eu preciso talvez usar o component props que vem dois stitches. E aí ele deveria reconhecer. Mas se ele não reconhecer, não tem problema. Deixa eu lembrar certinho aqui. Styled... Deixa eu lembrar aqui, a gente vai entrando juntos. Então essa função styled aqui, ela devolve... Tá, ela pode receber. Perfeito. Ela devolve um styled component. Esse styled component. Utilize stringed elements, keys, component props with half, transform props. Deixa eu ver se eu consigo achar. Eu acho que eu não vou conseguir achar aqui. Bom, então o que a gente pode fazer? Aqui, tanto no elemento text quanto no box, a gente pode falar que esse elemento aqui recebe uma propriedade s, que ela é opcional. E a gente bota aqui que ela é um element type que vem de dentro do react. E assim, dessa forma, ele já vai conseguir receber sem problemas nenhum. A gente pode fazer isso no box também aqui. Podemos até padronizar isso aqui já. Ah não, eu tinha feito isso no box, o component props. Será que o component props agora... Aff, eu tinha feito no errado. Deixa eu ver se o component props do stitches já implementa isso. Se não, a gente faz do zero. Porque eu tinha botado no box e não no text. Então salvo aqui agora. Voltamos aqui. Ah, deixa eu tirar isso aqui. Deixa eu tirar isso aqui pra garantir. Eu acho que agora foi. Deixa eu dar um restart até no test server pra ver se não é um falso positivo. É, realmente é um falso positivo. Ele não... realmente não foi. Então a gente vai tipar isso manualmente como eu tinha feito. Então a gente vai botar o s, element type, aqui dentro. E o component props pode vir do próprio react. Então aqui também voltamos pra estaca zero, element type. E o component props também vai vir do próprio react. E aí como eu falei, agora a gente consegue passar essa tag s. Essa propriedade s que vai trocar a tag. No final das contas, ele vira uma tag strong. Isso aqui é muito legal pra gente poder aplicar o texto em todos os lugares possíveis. E agora voltando lá no nosso componente box. A gente vai trocar aqui esse span por um componente text que vem do próprio ignite-ui-react. E aí a gente já vai ver que ele vai ficar com o texto aqui dentro já com a fonte, com a cor certinho."
  },
  {
    "id": "d68920f0-109a-4120-87c6-daa174d98949",
    "title": "Display name dos componentes",
    "transcription": "Uma das coisas que a gente pode perceber aqui nos nossos componentes, aqui dentro do Storybook, é que quando eu clico aqui, por exemplo, em Button, e eu venho aqui em Primary, dentro de Docs, e clico aqui em Show Code, ele mostra Styled Button. Ou até pior, quando eu clico, por exemplo, no Multistep, e aqui dentro eu venho em Code, ele mostra apenas como Styled Div, ele não mostra como o nome do componente mesmo, que deveria ser o Multistep em si. Então, o que a gente vai fazer? Aqui dentro de Packages, dentro de React, dentro dos nossos componentes, em cada um dos componentes que a gente cria, por exemplo, o próprio TextArea, uma das coisas que a gente pode fazer, pode ser aqui embaixo no final mesmo, é usar o TextArea. E aqui a gente tem uma opção chamada Display Name. A gente pode ver inclusive aqui. Eu posso basicamente selecionar qual é o nome que eu quero que esse componente apareça dentro ali do código, dentro do Storybook. Então, aqui eu coloquei como TextArea. A partir desse momento, se eu venho aqui agora no TextArea e mostro o Show Code, aqui ele ainda ficou como Styled Div. Ah, tá, porque esse Styled Div aqui, na verdade, é o Decorator, que a gente colocou por volta, que é a nossa Box. Mas o TextArea aqui, ele ficou como TextArea. Eu vou agora então na nossa Box e vou fazer a mesma coisa. Box.DisplayName.Box. Quando eu salvo aqui agora, veja que ele trocou para a Box. A gente vem no Text.DisplayName.Text, salva. E olha só, agora já ficou Text.Box, já ficou o TextArea aqui dentro. E a gente vai fazer isso nos demais. Então, aqui no nosso Heading.DisplayName.Heading. Vamos até copiar isso aqui. A gente vem no nosso Button. A gente vai fazer a mesma coisa aqui dentro. E agora a gente vai para os outros. Então, aqui no TextInput, a gente vai fazer também. Então, TextInput.DisplayName.TextInput. O Multistep aqui dentro, a gente vai fazer a mesma coisa. CheckBox por último, quer dizer, penúltimo. E o Avatar a gente também salva aqui dentro. E agora eu posso ver que navegando aqui, por exemplo, no Multistep, eu já tenho aqui Box, Multistep, dentro do Avatar também. Já está tudo certinho, Avatar mostrando. E pronto, a gente corrigiu o DisplayName dos componentes. E esse DisplayName, por mais que ele funcione para o Storybook, ele também funciona para caso você esteja utilizando a extensão do React DevTools, onde a gente consegue ver a composição dos elementos aqui, do nosso elemento, o nome que aparece aqui do componente dentro dessa aba de componentes aqui do DevTools. Então, é importante para a gente saber exatamente qual componente para não aparecer aqui, por exemplo, só div ou style div que não remete a nenhum componente específico dentro da nossa aplicação."
  },
  {
    "id": "e6492c9b-e387-42b1-969e-fa428d9b2704",
    "title": "Addon de acessibilidade",
    "transcription": "Uma das coisas mais importantes quando a gente está criando um design system é a gente conseguir manter uma padronização, mas também conseguir manter uma acessibilidade legal dentro dos nossos componentes. Então, por exemplo, o nosso botão. Como que eu sei que esse botão aqui tem um contraste ok para uma pessoa que às vezes tem algum tipo de deficiência visual? Então, existe um plugin dentro do storybook de acessibility. Então, a gente consegue botar o A11y, ele significa accessibility, porque existem 11 letras aqui no meio da palavra. E aí, a gente vai procurar aqui esse storybook addon, ally, a gente vai instalar esse carinha aqui. A gente está usando npm, por isso que eu não copiei aqui da mesma forma. Então, vou acessar packages, docs, npm install. Meu Deus, o que está travando? Storybook, addon, accessibility. A gente vai aguardar aqui um pouquinho e aí eu vou colocar essa opção dentro da nossa config do storybook. Então, aqui dentro de main, a gente vem aqui dentro e joga. Storybook, addon, accessibility. Salva isso aqui agora e eu vou rodar o meu npm run dev novamente. A gente aguarda um pouquinho. Não tem muita configuração para fazer nesse addon. Ele simplesmente cria aqui uma abinha accessibility. Então, deixa ele carregar aqui o nosso botão. E agora, aqui nessa aba de accessibility, veja que ele já mostra para a gente quais regras estão passando. Então, olha só, a parte de contraste, tudo isso ele já mostra para a gente qual é o nosso contraste aqui dentro do botão. E a gente consegue ver isso nos demais. Olha só, esse botão aqui, por exemplo, ele falou que ele não teve contraste suficiente. Porque a cor é verde e ele está entendendo que, na verdade, a cor de fundo da nossa aplicação é branca. Mas a cor de fundo da nossa aplicação não é branca. A cor de fundo da nossa aplicação, aqui nesse caso, é cinza. Mas como a gente não setou uma cor de fundo aqui no botão, ele acabou entendendo que a cor de fundo aqui é branca. E realmente até faz sentido. Porque como eu não coloquei, como eu coloquei a cor de fundo desse botão transparente, esse botão poderia ser aplicado em qualquer contexto, em qualquer background. Até inclusive em um background branco e aí não passaria o nosso contraste. Então, a gente consegue olhar isso para vários elementos aqui. Por exemplo, checkbox. Buttons must have discernible text. Então, ele fala que o nosso botão aqui não tem um area label. Mas aqui não necessariamente é um problema, porque aqui o botão está sendo utilizado apenas como um checkbox. E logo depois dele eu já tenho esse Accept Terms of Use. Mas a gente conseguiria passar para o checkbox aqui um area label, informando o que significa esse checkbox em si e não usar esse texto aqui na direita. E assim a gente consegue ver todos os nossos problemas possíveis de acessibilidade aqui dentro da nossa aplicação."
  },
  {
    "id": "e50d4feb-ff37-47a9-bc1d-14a745bed855",
    "title": "Componente: MultiStep",
    "transcription": "Nessa aula a gente vai finalizar o nosso último componente aqui do nosso Design System. E é claro, espero muito que esse Design System cresça depois e que você também use base para criar os seus próprios projetos e adicione muitos outros componentes. Mas a gente vai criar esse componente aqui do Multistep, que é esse carinha aqui em cima, passo 1 até tanto. Só que a gente vai fazer ele bem customizável, a gente não vai fazer que ele tenha apenas 5 passos, a pessoa vai poder selecionar quantos passos ela quiser. Então vai ser bem legal, vai dar para fazer bastante customização. Eu vou fechar tudo aqui porque tem muita coisa aberta, e nem era tanta coisa aberta assim não. Eu vou fazer o seguinte, eu vou começar criando uma pastinha chamada Multistep, e dentro um index.tsx e um styles.ts aqui dentro. E agora, aqui no styles, eu vou simplesmente começar criando um Multistep container, eu geralmente começo com um container. E pode ser uma div mesmo, depois a gente pode mudar caso seja necessário. E aí aqui eu crio o meu Multistep, que retorna meu Multistep container. E aqui também já vou deixar exportado uma interface, Multistep props, por enquanto vazia mesmo, não tem problema. E aí aqui no meu index, a gente vai exportar Multistep, e aqui em cima a gente vai criar o meu Multistep Stories.tsx. Aqui posso remover praticamente tudo aqui do meu componente, e aqui eu vou colocar isso aqui também dentro de form, porque geralmente o Multistep vai estar relacionado a um formulário. E aqui onde está TextInput, troco tudo para Multistep em si. Por enquanto essa label aqui, eu vou deixar tudo assim mesmo, só vou tirar esse texto que a gente não vai usar. E o resto eu vou deixar assim, depois eu mexo. A ideia não é muito a gente mexer agora, eu só quero ver como é que vai aparecer aqui. Vai aparecer como uma box mesmo vazia, porque a div não tem nada. Então aqui agora dentro de Multistep, a gente vai customizar aqui o nosso componente. E aí o que eu quero fazer? Olha só que interessante. Eu quero fazer com que o meu Multistep receba basicamente duas propriedades. O Size, que é o tamanho, ou seja, quantos steps eu tenho no total. E o CurrentStep, que pode ser opcional, porque ele é um número. E aí o que eu vou fazer? Aqui eu vou receber essa Multistep Props. E eu vou basicamente falar, vou pegar o Size, vou pegar o meu CurrentStep. E eu vou usar essas variáveis aqui dentro para fazer algumas coisas novas. Então, primeira coisa que eu vou fazer. Preciso criar esse carinha aqui em cima, o passo 1 de 4, por exemplo. Isso aqui eu vou criar um novo componente estilizado. Eu vou botar ele como label. E aqui é legal porque a gente consegue reaproveitar outros componentes que a gente já tenha criado previamente. Então aqui, por exemplo, eu posso usar o meu próprio elemento Text, que eu já tinha utilizado, e só reestilizar ele, digamos assim, usar novos estilos em cima dele. Então eu quero trocar a cor para Gray 200. E eu quero também que o font-size dele seja XS. E aqui eu posso, na verdade, fazer talvez um Default Variant, passando o Size como XS. Vamos ver se dessa forma aqui vai funcionar, para não ter que passar o font-size XS aqui dentro. Então agora eu volto aqui no meu Multistep, coloco a minha label aqui dentro, passo 1 de 4. Salvo, voltamos aqui dentro, funcionou. Ele já está com o tamanho de fonte XS aqui, que ele usa uma variável do próprio CSS para ficar mais performático. E agora a gente vai customizar. Esse 1 aqui não vai ser 1. Na verdade, ele vai ser o próprio CurrentStep. E o 4 vai ser o meu Size. Então já está lá. Agora aqui no nosso Multistep, o que eu vou fazer? Eu vou definir aqui por padrão, nos argumentos aqui da nossa... Opa, já tem um args aqui em cima. O Size eu vou definir como padrão 4 e o CurrentStep como padrão 1. Então, se não for em formato, ele fica ali 1 de 4. Aqui embaixo, inclusive, ele já dá para a gente a opção de customizar isso caso a gente queira. É só mudar aqui. E aí ele deu erro. Mas não tem problema. Depois a gente vai mexer nisso aqui. Ele está dando erro porque eu apaguei antes de mexer. Mas tudo bem. Voltamos aqui no Index. E agora aqui na nossa Label, a gente vai ter um outro componente aqui que se chama Steps. Esse componente Steps aqui, ele vai ser também uma Div. E ele vai ter o seguinte. Display. Grid. Gap. 2. Porque ele vai espaçar cada um desses carinhas, desses branquinhos aqui. E vai ter o Margin. Top. 1. Para distanciar um pouquinho dessa Label. E agora, aqui vem a mágica. Para eu definir qual que é as Template Columns desse Grid. Falar quantas colunas esse Grid tem. Eu preciso saber da informação de qual que é o Size. Então, eu quero basicamente fazer o seguinte aqui dentro. Repeat. 4, que seria o Size. 1fr, que é uma medida flexível. Então, se eu deixo só dessa forma, eu sempre vou ter 4 passos. Só que eu quero que esse 4 aqui, ele venha de uma variável. E ele pode ser qualquer valor, por isso não faz sentido criar variantes. Eu até poderia criar uma variante, por exemplo. Size. Só que aí eu teria que criar cada tamanho. 2. Teria que criar o tamanho 3. 4. E aí por diante. Só que, pô, isso aqui eu queria que fosse qualquer tamanho. Então, quando a gente precisa fazer isso com o Stitches. Receber uma variável, digamos, do JSX dentro do Stitches. A gente faz isso com variáveis CSS. Então, olha só, o que a gente vai fazer. Aqui no nosso... Deixa eu fechar aqui alguns arquivos da minha cola aqui, para eu não me perder. Mas, aqui dentro do Steps, quando a gente usa ele. Eu vou definir CSS. O Stitches, lembra, todos os elementos do Stitches recebem essa propriedade CSS. Eu posso passar novas propriedades CSS aqui dentro. E aqui eu vou fazer o seguinte. Eu boto com aspas uma variável. Steps. Size. 2. Size. E agora, aqui dentro dos meus estilos. No lugar do 4, eu posso usar var. Steps. Size. Salvo aqui agora. Volto aqui no Chrome. Dou um inspect. Vejo que eu tenho uma div aqui embaixo. E veja só. Ela recebeu a propriedade Steps. Size. Como sendo 4. E aqui no Grid. Template. Columns. Já está aqui certinho. Posso até no Computed. Para ver que no Template. Columns. Eu tenho 4 colunas. Eu ainda não consigo vê-las através aqui. Porque eu não botei nada dentro do elemento do componente Steps. Então, dentro do componente Steps. Na verdade. Eu vou ter um Step. Uma div aqui para cada Step que eu tiver. Então. O que eu vou fazer aqui. Olha só que interessante. Eu vou usar a propriedade Array. .from. E aqui eu passo. Length. Size. Ou seja. Eu estou criando um novo Array. Isso aqui ele vai criar um Array com 4 posições. E aqui. Na segunda propriedade do Array. From. Eu consigo passar uma função. Que ela vai ser percorrida por todo o Array. E ela traz o conteúdo do Array. E na segunda posição. O índice. Como eu criei um Array. Com um Array zerado. O conteúdo ele vai estar zerado. Ele não vai ter nada dentro. Mas o índice no Array sempre existe. 0, 1, 2. E aqui eu vou retornar. i mais 1. O que ele fez aqui. Basicamente essa função aqui. Quando eu chamo isso aqui. Com Array. Length. 4. Ela cria um Array. Dessa forma para mim. Então. Basicamente estou criando um Array do 0. Tem várias formas de criar um Array. Mas isso aqui. É uma das formas. E agora aqui no final. Eu dou um Map. Step. E aqui dentro. Eu dou um Return. Vou criar uma nova Div. Aqui. Para o meu Step. Então deixa eu importar ela aqui dentro. E aqui. Ela vai ter uma Key. Que é o Step em si. Sempre que eu faço um Map. No JSX. Eu preciso ter a Key. E aqui. Agora. Eu vou estilizar. Esse carinha. Aqui dentro. Então. Esse carinha aqui. Deixa eu até pegar a estilização dele aqui. Ele vai ter a seguinte estilização. O Height. 1. Que vai ser 4 pixels. O Border. Radius. Opa. Border. Radius. Eu vou usar a opção. Pixel. Que é 1 pixel de Border Radius. Background Color. Gray. 600. Salvo. E agora. A gente pode ver que ele já criou. Ali. Os 4 passos. E agora. Falta eu definir. Por exemplo. Se eu estou no passo 1. Esse primeiro aqui. Ele tem que ficar branquinho. Então. Se eu estou no passo 2. O segundo tem que ficar branquinho. E por aí vai. Então. Eu vou até criar uma outra variante. Aqui dentro dos meus Stories. Chamada. Full. Que eu vou passar. Opa. Não é aqui nesse componente. Ah não. É nesse componente sim. Essa variante Full. Ela vai passar nos argumentos. Que o meu Current Step. É 4. Que é o final. Então. Olha só. Passa o 4 de 4. Porém. Ele não fica branquinho. O que eu vou fazer aqui agora. Vamos lá. No Step. Eu vou definir. Uma variante. Chamada. Active. E quando ela estiver True. Eu vou definir. A Background Color. Desse carinha. Como Gray. 100. E agora. Veja que aqui. Eu consigo passar no meu Step. Uma propriedade chamada. Active. Que é um booleano. E para eu calcular. Essa propriedade. Eu vou definir. Se o Current Step. Ou seja. Se o passo atual. É maior. Ou igual. Ao número. Desse Step. Aqui. Então. Se estiver no 4. Todos os elementos. Até o 4. Vão ficar. Active. Current Step. Possivelmente. Indefinido. Então. Eu vou definir. Que o valor padrão dele. É. 1. Não tem como. Começar do passo 0. Então. É 1. Salvo. Volto. E pronto. Olha aqui. Passo 4 de 4. Todos estão selecionados. E no Primary aqui. Apenas o primeiro está selecionado. Porque é o passo 1 de 4. E assim. A gente finalizou. Nosso último componente. Aqui. "
  },
  {
    "id": "738934f4-ace3-47e5-a0dd-b94217317ebb",
    "title": "Componente: TextArea",
    "transcription": "Nessa aula, a gente vai criar o nosso componente de TextArea, que ele é muito parecido com o TextInput. Então, a gente vai seguir uma abordagem muito semelhante. Porém, o TextArea em si, ele não precisa ser um componente dessa forma, igual o TextInput. Ele pode ser apenas um componente estilizado, porque ele nada mais vai ser do que uma TextArea do próprio HTML, porém estilizado. Então, aqui eu vou começar exportando o TextArea, que é igual a Style, que vem de dentro de ./.styles. TextArea. E aqui, a gente vai adicionar algumas estilizações. Eu vou copiar como base as estilizações aqui desse nosso TextInputContainer, e aí a gente vai mudando o que a gente não quer. Então, aqui vai ter assim, isso aqui também. Aqui agora, a gente vai adicionar as propriedades de texto. Então, o font-family, default. Font-size, vou usar o font-size small. Color, a gente vai usar white, porque esse container aqui agora já vai ser o próprio TextArea em si, né, diferente do Input. Além disso, vou botar aqui um font-weight regular. A gente vai dar um resize vertical. E vamos definir uma min-height de 80, uma altura mínima de 80. Vou tirar esse display e esse align. E aqui, agora, quando ela estiver com focus, troca a border-color, e não coloca o outline, que vem nela por padrão. A gente vai criar também uma opção disable, que vai colocar opacity 0.5, e cursor not allowed. E aqui, o nosso placeholder, que vai ter um color gray 400. E agora, aqui embaixo, export, interface, text-area, props, extends, component-props, do React, type of TextArea. Eu salvo isso aqui agora, vamos lá criar o nosso Stories agora. Então, aqui, text-area, stories.tsx. A gente vem aqui, text-area. E agora, todo lugar aqui que está escrito text-input, eu seleciono e troco para text-area. A gente vai seguir essa mesma ideia aqui de criar o decorator. Então, deixa eu importar o box e o text que eu até tirei aqui. E aqui, no lugar de email-address, eu vou botar observations, porque a text-area não vai ser para email, provavelmente. Pera aí que aqui no index faltou eu exportar a text-area daqui de dentro, do meu pacote React. Components. Ah, eu queria com text-input. Text-area. Agora sim. Salvo, salvo. Aqui, logo, ele já vai resolver esse problema. E aí, a gente vai ter uma primary. Type your add any observations. Não vai ter com prefixo, só vai ter primary e disabled mesmo. Então, agora a gente volta aqui no Chrome, text-area. Does not provide an export named React text-area. Deixa eu dar uma olhada aqui. Export const text-area. Beleza, está tudo certo. Tá, então... Deixa eu tentar rodar o npm run dev novamente. Beleza, já está aqui a nossa text-area. Ele deu um bugzinho ali. Então, está aqui a text-area, já com nossa label. Quando eu clico, já vai certinho ali. E aqui, no nosso disabled, já está aqui a text-area, que a gente não consegue clicar. E a gente pode até controlar o estado de disabled aqui pelos controles do próprio storybook. Então, pronto. Finalizamos mais um componente aqui dentro do nosso design system."
  },
  {
    "id": "01e2ff22-668d-45ad-b2f5-38781d6b3726",
    "title": "Componente: TextInput",
    "transcription": "Nessa aula que a gente vai fazer nosso componente de Text Input. Para isso, a gente vai começar criando, então, o Text Input. Aqui ele pode ser... ele não vai ser só um componente utilizado, então vou criar uma pastinha, porque ele vai ter uma certa lógica dentro do componente. Então aqui eu vou criar o index.tsx, styles.tx e aqui já vou deixar mais ou menos estruturado. A gente vai ter um Text Input Container e vai usar aqui o style. Vou botar como uma div mesmo, por enquanto, vou salvar. E aí além do Text Input Container, depois a gente vai ter mais coisas, mas aqui no Text Input eu vou simplesmente exportar Text Input e dentro do return eu vou botar Text Input Container. E vou salvar dessa forma aqui por enquanto. E agora eu vou fazer aqui uma interface Text Input Props. Por enquanto eu vou deixar ela vazia, só para exportar ela daqui de dentro. E agora aqui no nosso index eu vou exportar tudo de dentro do Text Input. E agora eu vou lá no meu Stories aqui e a gente vai configurar. Vou copiar aqui um outro Stories qualquer, pode ser o de Text. E vou botar aqui Text Input.Stories.tsx. Ele vai ficar dentro de form mesmo. E aqui vai ser Text Input. Aqui eu vou importar. Vamos selecionar todos os lugares que estão escritos Text. Deixa eu só botar um D aqui no meio para não selecionar. Vou selecionar Text Input. Eita, não está rodando NPM Rundown. Eu parei de rodar sem querer. Por isso que ele está dando erro aqui do importação. Deixa eu tirar esse D aqui do meio. E agora o Text Input não vai ser Children. Então a gente apaga isso aqui. E eu vou deixar apenas um Primary dessa forma sem passar qualquer propriedade. E aí a gente pode ver que aqui dentro não aconteceu nada, porque por enquanto a gente só botou uma div vazia. E aí por que eu criei um componente aqui para o Text Input? Porque uma das coisas, até se a gente for perceber lá no layout do Ignite Call, quando a gente vem aqui na versão web, um desses Text Input, que é esse primeiro aqui, ele tem esse... eu não sei exatamente como chamar esse call.com, talvez prefixo. Esse prefixo aqui que ele não é editável. Então eu quero criar uma variante desse meu Text Input que pode receber um prefixo, onde o usuário só vai digitar o que vier depois do prefixo. Então ele só vai digitar essa parte aqui. Então vamos lá. Aqui no Text Input Props, eu vou falar que ele pode receber um prefixo, mas ele é opcional, por isso que eu boto ponto de interrogação. E aqui eu vou pegar essas props, vou pegar o prefixo, e aí aqui dentro do Text Input eu vou fazer o seguinte. Olha, se houver um prefixo, então eu sempre boto aqui, quando eu vou fazer algum tipo de condicional dentro do React, eu sempre boto para um valor que não é booleano os dois sinais de exclamação, para transformar isso aqui num booleano, porque se eu fizer só dessa forma assim, ele vai mostrar o prefixo em tela, e não é o que a gente quer. A gente quer, se houver um prefixo, eu quero mostrar um novo componente que eu vou criar aqui dentro. Vou criar aqui como uma span por enquanto. Vou salvar. Perdi o componente. E aí eu vou mostrar prefix, que importa dos styles, e dentro prefix. E aí, por último, eu vou ter o meu componente de Input em si. O Input não vai ser esse Text Input Container, que está aqui por volta, porque no final das contas, o Text Input Container vai ser a caixa preta. O Input vai estar aqui dentro, mas ele vai estar transparente, para que eu consiga colocar esse prefixo aqui na esquerda, e mesmo assim o Input está ocupando essa parte aqui. Então aqui agora eu vou importar o Input. E agora, as propriedades que eu recebo aqui do Text Input Props, elas serão propriedades do nosso Input. Então eu venho aqui, Component Props, React, Type of Input, e aí eu pego todas essas propriedades aqui, e repasso para o meu Input. Então, Placeholder, toda a parte de Name, ID, tudo isso vai ser passado direto para o Input, e não para o meu Text Input Container. Show! Agora que eu já salvei isso aqui, a gente vem aqui nos styles, ou melhor, se eu vier aqui no meu Storybook, a gente já consegue ver o Input aqui dentro. Ele não tem prefixo, né? A gente pode criar até mais um aqui chamado with prefix, e aí a gente passa args prefix call.com. E aí o with prefix, ele está ali o call.com e o Input está logo na direita. Mas aí a gente tem que agora, claro, estilizar tudo isso aqui para ficar bem bonitinho. Então, no Text Input Container, a gente vai começar com o background-color, grey, 900, um padding 3, 4, 12 em cima e embaixo e 16 nas laterais. A gente vai botar um border-radius, small. Vamos botar também um box-sizing, border-box. A gente vai colocar um border, 2 pixels, solid, grey, 900 também. E aqui veja que essa borda está com a mesma cor do fundo, porque depois eu quero alterar essa borda aqui, colocando ela de outra cor quando o usuário estiver com o focus no input. Mas eu já deixo a borda pré-setada para quando eu adicionar a borda depois não ficar pulando o input de lugar. Senão a gente tem que ficar trabalhando com box-shadow, essas coisas assim. Mas a gente pode trabalhar com borda que fica legal também. Então aqui a gente vai dar um display-flex e eu vou dar um align-items aqui, baseline. É diferente do align-items-center, apesar de ser muito parecido, porque ele vai alinhar horizontalmente com base no texto. Então na linha base do texto aqui, a parte de baixo do texto. Então se esse call.com, por exemplo, tiver com uma fonte menor, não tem problema. Todos eles vão ficar alinhados nessa parte aqui de baixo do texto em si. E aqui agora, como eu falei, eu vou fazer o seguinte. Quando eu tiver, e aqui usando já o novo operador do CSS, o REST. Quando eu tiver dentro desse container um input com focus, daria para fazer também um focus-within. Funcionaria também, mas eu quero usar o novo operador REST, porque ele é muito massa, dá para fazer muita coisa. A gente consegue fazer seleções de estados de elementos filhos dentro de um elemento pai. Então mudar a estilização do elemento pai com base em algum estado do componente filho. Então quando o input tiver com focus, esse text-input-container aqui, ele vai receber a border-color-ignite-300, que é aquela verdinha. E aí, olha só que legal, REST, quando eu tiver um input que esteja desabilitado, ali dentro, eu vou trocar o password disso aqui para 0.5 e vou colocar um cursor not allowed. Aqui era vírgula, e aí eu vou inclusive já criar uma variante disabled, para a gente visualizar como que isso aqui funciona. Vou salvar isso aqui agora, e a gente pode ver que ele já está desabilitado ali dentro. Show de bola, agora a gente vai começar a trabalhar aqui no restante dos nossos elementos aqui dentro. O prefix vai ser bem simples na verdade, vai ter apenas um font-family-default, um font-size-small, um color-gray-400 e um font-weight-regular mesmo. Salvo. Show, já está ali, já dá para visualizar, ficou bem legal. Agora no nosso input em si, é o que vai ter um pouquinho mais de utilização. Ele também vai ter essas duas propriedades aqui, font-family-default, font-size-small, só que ele também vai ter uma color-white. O font-weight aqui vai ser regular também, a gente vai usar o mesmo tamanho. O background dele aqui vai ser transparent, porque eu não quero que ele tenha background, aqui também tem que tirar a borda dele. E vamos colocar nele também o width 100%, para ele ocupar toda a largura aqui. E aí a gente pode ver que ele ficou com esse focus do input, então a gente vai, quando o elemento estiver com focus, eu vou dar um outline 0 aqui nele, e pronto, já está aqui o nosso input. E aí só para finalizar, eu vou fazer quando esse input aqui estiver disabled, também vou dar um cursor not allowed nele, e também vou estilizar rapidamente o placeholder aqui do input, colocando um color-gray-400. E aí aqui nos stories também, para a gente visualizar isso aqui, eu vou colocar como argumento padrão, não vou colocar padrão não, vou botar aqui no próprio primary, arts, placeholder, type your name. Salvo, voltamos aqui no primary, já conseguimos ver aqui, type your name, o disabled, não dá para clicar e não tem nada escrito, width prefix está aqui, cal.com, e a pessoa consegue digitar o restante ali na direita. Então esse aqui é basicamente o nosso input, só que eu não vou deixar o input jogado, eu quero te explicar uma outra coisa que a gente consegue fazer aqui no storybook, que é o seguinte, eu não sei se você lembra, mas aqui dentro do box, eu coloquei como argumento, o children, um JSX, só que olha só o que a gente pode fazer aqui dentro do storybook também, além do argumento, aqui a gente tem uma outra opção que se chama decorators. O decorator é uma forma de eu customizar, digamos assim, essa view aqui, que mostra o nosso componente, eu consigo colocar outros elementos na view, além do nosso componente, sem ser filho do componente, sem ser o children do componente. Então olha só que legal, aqui dentro de decorators eu posso passar várias funções que são componentes, então imagine que isso aqui são componentes, componentes no final das contas são funções que devolvem algum JSX. E essas funções aqui elas recebem como parâmetro o story, o story aqui é basicamente uma função que ela vai renderizar o meu input. Então olha só, se aqui dentro agora eu colocar, por exemplo, uma box, importar ela do ignite.ui.react, e dentro aqui eu chamar story, chamando o sinal de menor e maior, olha só, o nosso input agora ele vai parar dentro de uma box, todas as renderizações do meu input ficam dentro de uma box. Só que além da box, o que eu vou fazer? Eu vou colocar aqui, olha só que legal, um text que eu vou importar de dentro de ignite.ui.react, e aqui eu vou botar alguma coisa, por exemplo, nome de... vou botar aqui username, para ficar um pouco mais fácil, ou email address, eu acho que o pessoal usa assim. E aqui no text eu vou passar um size small, usando a variante que a gente já tinha configurado, então olha só como que está ficando. E aqui na box, olha que legal, eu consigo usar aquela propriedade s que a gente tinha configurado antes, e falar que essa box aqui não vai ser uma div, vai ser uma label. Então eu passo s label, e agora olha só, quando eu clico no email ele já seleciona o input, por enquanto está um pouquinho bugado aqui, mas aqui na box eu consigo também passar um custom css. Então o stitches, todos os elementos que a gente cria com stitches, ele recebe essa propriedade css, onde a gente pode passar novas propriedades aqui dentro. Então eu posso passar, por exemplo, nessa box, um display flex, posso passar um flex direction column, gap 2, para distanciar essa label do input um pouquinho, e salvo. E olha só, pronto, já está ali a nossa label, quando eu clico nela já seleciona o input, e o massa é que o decorator ele se aplica em todos os stories aqui. Então tanto disabled quanto with prefix, todos eles aqui recebem os mesmos decorators aqui dentro. E aí a gente terminou o nosso componente de input."
  },
  {
    "id": "5d10c1ad-425d-4fbf-bea6-ef4a85808d99",
    "title": "Componente: Box",
    "transcription": "O que a gente vai fazer nessa aula é começar então a codar os nossos componentes aqui do Design System dentro do nosso projeto, e a gente vai sempre codar o componente dentro da pasta React, e aí a gente vai fazer a documentação dele dentro da pasta Docs aqui, então vai ser sempre um conjunto, digamos assim. Então eu vou começar aqui na pasta React dentro de Source, criando uma pasta Components, e a gente vai criar o nosso primeiro componente, que eu julgo ser o mais simples, que é o componente Box. Então vou começar criando um arquivo Box.tsx, não ts, porque ele vai ter jsx. Na verdade esse aqui nem vai ter, mas tudo bem, pode ser a extensão tsx mesmo. E eu digo que ele nem vai ter porque esse Box, como ele vai ser apenas uma div estilizada, digamos assim, a gente nem precisa criar todo o componente. A gente pode exportar direto o componente que vem de dentro do stitches, usando aqui a função styled, importando ela aqui de ./.styles, a gente bota aqui o nome do componente, div, o elemento que vai ser a div. E aí agora eu já vou pegar aqui no meu projeto, vou dar um npm run dev, como a gente configurou o TurboRê, porque ele já vai sair rodando o script de dev aqui em todos os pacotes. E pronto, agora eu vou lá na minha documentação, dentro de Stories, e a gente vai criar aqui o nosso Box.stories .tsx. E aí nesse Box.stories.tsx, a gente vai criar aqui a estrutura base, posso até copiar a estrutura base que eu tenho no meu button pra gente reaproveitar. E aqui agora eu vou importar Box, aqui vai ser Box, aqui eu vou usar surfaces, .box. Aqui a gente não exportou as propriedades, então aqui eu vou dar um export, pode ser uma interface ou pode ser um type, tanto faz. Eu gosto de usar bastante interface. Box.props, Extents, Component.props, do React, de Box. Type of Box. Show de bola. Agora eu tenho aqui também acesso ao Box.props, na verdade não está exportado, então aqui no index que a gente colocou esse botão, o que que eu vou fazer? Eu vou apagar o Stories aqui do botão, porque a gente vai fazer do zero depois, e aqui eu vou dar um export, tudo from .components-box. Então eu estou basicamente repassando a exportação do componente Box aqui desse arquivo, e agora teoricamente aqui a importação já deve voltar a funcionar. E aqui agora a gente vai botar aqui Box.props, Children aqui por enquanto eu não vou colocar nada, e aí a gente vai ter apenas uma aqui que eu vou chamar de Primary mesmo, Box.props. E aqui como essa Box ela precisa ter alguma coisa dentro dela, geralmente vai ter um título, um parágrafo ou qualquer coisa ali dentro, aqui nesse Primary, na verdade não precisa nem ser aqui, pode ser no global mesmo, a gente vai colocar um Children, e aqui nesse Children a gente pode colocar um fragment do React, e dentro dele colocar um título, por exemplo, e um texto. Por enquanto eu vou botar somente um texto, então testando o elemento Box, só pra gente visualizar alguma coisa em tela. Salvo isso aqui agora, aqui em Surfaces já consigo ver o Box, já aparece aqui testando o elemento Box, e agora a gente vai adicionar o estilo aqui pra nossa Box em si. Então essa nossa Box eu vou colocar nela um Padding de 16, um Border Radius MD, aqui a gente vai colocar também um Background Color Gray 800, ela vai ter também uma borda de 1 pixel, Solid Gray 600. Aqui a gente vai colocar nela um Width de 100%, porém um Max Width, ou melhor, eu vou colocar o Max Width de 100%. Na verdade isso aqui é uma div, eu acho que eu nem preciso presetar o Width e o Max Width, a gente vai deixar assim mesmo. Agora eu volto, a gente já pode ver que a nossa Box já tá aparecendo lá. Deixa eu ver se ficou tudo certinho aqui a estilização, então eu dou um vejo aqui no... Beleza, aplicou o Border Color. Aqui a borda quase não dá pra ver, porque ela ficou a mesma cor do fundo aqui, né? E aqui o texto, como a gente pode ver, ele acabou ficando preto ali, né? E ele também acabou ficando parecendo que ele tem um Padding a mais verticalmente, mas isso é por causa que o elemento P que eu coloquei ali dentro, ele vem um Padding junto com ele, né? Então aqui eu posso trocar o P por um Span, e pronto, já fica melhor. Aqui eu nem vou me preocupar em colocar por enquanto uma estilização nesse texto, porque mais pra frente a gente vai criar o nosso componente de texto no Design System, e aí a gente usa esse próprio componente de texto aqui pra botar dentro do Box, e aí já fica mais fácil, porque a gente mata dois coelhos aí com uma... que nem dizia meu amigo aí, dois leões com uma caixa d'água só. Mas, fechou então, a gente já terminou o nosso primeiro componente, a parte dos Stories, e a gente vai continuar pros demais."
  },
  {
    "id": "ddcddd41-8c77-436b-96bc-b71ea2b3764a",
    "title": "Componente: Avatar",
    "transcription": "O que a gente vai fazer nessa aula é criar o nosso componente de avatar. Então, bora lá. A gente vai começar criando o avatar aqui. Ele não vai ser um componente, apenas um componente estilizado. Então, eu vou criar uma pastinha pra ele. E dentro eu vou criar um index.tsx e um styles.ts separado. E aqui no index eu vou exportar uma função chamada avatar. Aqui ela vai retornar alguma coisa. E a gente vai começar até pelos styles aqui pra ser um pouquinho mais fácil. Então, eu vou começar exportando um avatar container, styled, div, aqui por enquanto. A gente salva isso. E aqui dentro eu vou colocar um avatar container. E aí agora, o avatar em si, a gente vai fazê-lo um pouquinho diferente. Por quê? Uma das coisas que é muito comum a gente precisar dentro de uma imagem de avatar é uma imagem de fallback. Ou não só uma imagem de fallback, alguma coisa de fallback pra mostrar caso o avatar da pessoa não tenha conseguido ser carregado ou esteja nulo, por exemplo. E é legal porque o Radix, que é algo que está muito próximo do Stitches que a gente está utilizando, tem um componente de avatar que ele tem um placeholder, um fallback, digamos assim, onde a gente consegue mostrar alguma coisa enquanto a imagem ainda não carregou ou caso ela não tenha conseguido ser carregada. E aí a gente vai instalar isso aqui pra eu te mostrar como é que funciona. Então, eu vou abrir aqui um terminal à parte. Vou entrar aqui dentro de packages react e vou instalar isso aqui dentro do pacote react. Não vou instalar lá na raiz porque a gente vai usar isso aqui somente no pacote react em si. E aí, enquanto a minha internet, bom, agora sim, instalou, a gente vai agora voltar aqui nos styles e ao invés de uma div aqui, eu vou usar esse componente que vem de dentro do Radix. Eita, import, opa, import tudo as avatar. Escrevi errado. Radix react avatar. E aqui no lugar da div, a gente vai usar avatar root e aí a gente vai exportar mais três carinhas aqui de dentro. Mais dois carinhas, na verdade. O avatar image, que ele é igual um style avatar image. E nós vamos ter aqui o avatar fallback, que é o que quando não carregar é o que vai ser mostrado. No avatar root, a gente vai colocar aqui um border-radius pool, um display inline block, width por padrão 12. A gente não vai ter vários tamanhos de avatar, então eu vou deixar apenas um tamanho. É claro que se você tivesse um avatar com vários tamanhos, é só a gente criar aqui a mesma coisa que a gente fez para o texto. Por exemplo, uma variant small, uma variant medium, por exemplo. E aí essa aqui poderia ser a variant medium e a gente poderia ter uma small com tamanho menor. Mas nesse caso eu não vou ter. Então aqui também eu vou botar um overflow hidden para que todo o conteúdo desse avatar container fique escondido para o border-radius funcionar até para os elementos que estão dentro deles. Para a imagem, aqui é muito simples, eu vou fazer só ela ocupar todo o espaço possível aqui dentro. Então a gente vai botar aqui também um object-fit-cover para a imagem não distorcer. E aqui a gente pode, como já tem o overflow hidden, eu não precisaria colocar um border-radius. Mas uma dica que eu posso te dar também, é quando você quer repetir algum valor CSS do elemento pai dentro do elemento filho, você pode botar um border-radius, por exemplo, em here, não sei exatamente como é que pronuncia essa palavra, mas ele vai herdar o border-radius do elemento pai. E aí no fallback, aqui, a gente vai fazer também um width e um height de 100%, só que aqui eu vou fazer um pouquinho diferente. Vou dar um display-flex, align-items, center, justify-content, center, background-color, gray, 600. Aqui a gente vai botar color, do caso do texto, gray, 800. E aqui vou colocar SVG, para caso a gente tenha um ícone dentro do avatar, ele ter um width 6 e um height 6. 6 vezes 4, 24 pixels, então, que vai ficar o tamanho aqui do nosso SVG. E aqui no nosso avatar, então agora, a gente vai fazer o seguinte. Eu vou ter o meu avatar-container, dentro dele eu vou ter o meu avatar-image, que eu importei do lugar errado, tem que ser dos styles. E abaixo do avatar-image, eu vou ter o meu avatar-fallback. Dentro do avatar-fallback, eu vou colocar um ícone, que vai vir de dentro do phosphor-icons. Então, deixa eu instalar o meu pacote phosphor-react, aqui dentro do nosso projeto react. E agora eu vou importar user, de dentro do phosphor-react. E meu VS Code deu uma travadinha. Quando eu instalar um pacote novo, às vezes meu VS Code buga, não sei o porquê, mas é isso. E aqui no avatar-fallback, eu vou passar uma propriedade para ele chamada delay-milliseconds para 600. O que isso vai fazer? Ele vai esperar pelo menos 600 milissegundos, ou 0.6 segundos, para mostrar o fallback, mesmo que a imagem ainda não tenha carregado. Então, por que eu fiz isso? Para ele não mostrar o fallback já no começo, quando a página carregou. Porque pode ser que a imagem do usuário ainda vá carregar. Então, seria ruim mostrar o fallback e depois mostrar a imagem do usuário. Basicamente, os avatares piscariam em tela, diria assim. Então, a gente coloca um delay aqui, para ela demorar um pouquinho para mostrar. E aí, outra coisa, a gente precisa que esse avatar-image aqui possa receber as demais propriedades. Porque isso aqui é uma tag-image. Então, ele tem que receber src, alt e tudo mais. Então, o que eu vou fazer aqui em cima? Eu vou ter uma interface, inclusive ela vai ser exportada. Avatar-props. Ela vai estender component-props de dentro do React. Type of avatar-image, e não avatar-container, porque é o image que eu quero receber propriedades. E aí, aqui agora, eu vou usar as minhas props. E aqui eu passo todas as props para dentro do meu image. E agora, a gente vai fazer o uso disso aqui, lá dentro da documentação, para ver como ficou. Então, a gente vai criar aqui o nosso avatar, stories.tsx. E aqui a gente vai trocar isso aqui para data-display. Eu estou usando o mesmo padrão que a gente usa na Rocket. Faltou exportar aqui, né, do pacote React, no arquivo index. Exportar aqui o avatar, não esquecer. E aqui agora, a gente vai trocando tudo onde está escrito o text para avatar. Vou deixar apenas o primary. Aqui nos args, eu posso deixar um src padrão. Então, vou botar aqui https://github.com.png vai trazer a minha foto de perfil. E vou botar um texto alternativo também. Diego Fernandes. E aí, no primary, eu não vou mudar nada. E aí, eu vou criar uma opção aqui chamada withPawBack. E aí, aqui dentro, eu vou passar o meu src com defined, para ele falhar no carregamento da imagem. E aí, agora, a gente volta aqui. E em data-display, avatar. Deu um errinho. Isso aqui acontece normalmente. A gente tem que vir aqui, parar de executar e rodar o storybook de novo. Às vezes o storybook se perde aqui um pouco nas importações. E aí, teoricamente... Ah, agora sim, já está aí. A gente já consegue ver. Só que o withPawBack aqui... Não ficou legal, né? Deixa eu ver o que eu errei aqui dentro. Tá, eu importei o avatar.fallback direto do react-avatar. E tem que ser aqui, avatar.fallback dos meus estilos. Agora sim, ele já ficou ali certinho. Aqui acaba que não dá pra ver muito bem, porque o fundo, a cor é quase a mesma coisa. Mas, confie em mim, ficou legal. E aqui a gente consegue mexer no src, consegue mexer em tudo. Então, a gente tem essa facilidade. Um ponto aqui só, é que... Opa, chegou alguma coisa aqui. Mas é isso, nosso avatar está finalizado. Bora pro vídeo. O Yoda ficou louco aqui, enquanto chegou a comida."
  },
  {
    "id": "6e150e64-8aa2-44e0-8007-815a63b190b1",
    "title": "Configurando TurboRepo",
    "transcription": "Nessa aula a gente vai configurar uma das ferramentas mais fantásticas que vai te surpreender com certeza aqui, que é o Turbo Repo. Só antes da gente configurar essa ferramenta, eu percebi que aqui dentro de packages, dentro de s, a gente configura aqui no package.json, esse private, aqui eu tinha botado o true com aspas por volta e eu botei agora o true sem as aspas por volta, beleza? Esse é um ponto que a gente tem que corrigir. Antes da gente configurar o Turbo Repo, uma das dependências que o Turbo Repo pede aqui, eu já vou te falar o que é o Turbo Repo, calma, é que a gente tenha o git configurado no nosso repositório. Então eu vou dar um git init aqui na raiz e eu vou pegar o git ignore e eu vou ignorar node-modules aqui. Eu também vou ignorar aqui, quando a gente roda a build, ele cria essa pasta dist. Então eu vou ignorar a pasta dist e a build2-storybook em si, eu posso até abrir aqui o packages.docs e rodar npm run build. E vai criar aqui uma pasta storybook-static. Então deixa eu parar, nem quero rodar build, mas eu vou criar aqui um git ignore dentro da pasta docs e vou ignorar storybook-static, que é a pasta de build aqui do storybook. O resto a gente não precisa colocar no git ignore. Agora eu vou fechar todos os arquivos, vou dar um collapse aqui nas folders, volto aqui na raiz e a gente vai começar instalando o Turbo na sua versão latest como uma dependência de desenvolvimento. O Turbo Repo serve para dois propósitos principais, ele serve principalmente para quando a gente está trabalhando com monorepo, ele serve para duas coisas, primeiro, a gente conseguir executar scripts em todos os pacotes ao mesmo tempo. Então hoje, por exemplo, quando a gente está desenvolvendo o nosso projeto, a gente tem que rodar o script de dev, tanto no pacote tokens, para caso a gente mude alguma coisa e ele gerar a nova build, quanto no pacote react, o script de dev tanto no pacote react quanto no pacote docs, todos eles tem um script de dev. Então a gente precisa executar esse script ao mesmo tempo em todos os pacotes, o Turbo Repo ajuda com isso. Outra coisa que o Turbo Repo ajuda, já como o próprio nome diz, Turbo, ele ajuda a gente a acelerar o processo de build da nossa aplicação. Então o que acontece, o Turbo Repo quando a gente roda a build da nossa aplicação, ele guarda um cache dessa build dentro da nossa pasta de NodeModules, um cache local, e aí a próxima vez que a gente rodar a build, ele vai automaticamente detectar os arquivos que mudaram e ele vai fazer, digamos, uma build incremental, ele vai apenas alterar na build que ele já gerou anteriormente as coisas que foram alteradas, ao invés de gerar a build de total zero. Isso deixa a nossa build muito mais rápida, a gente vai ver como que isso funciona. Pra gente começar a configurar o Turbo Repo aqui dentro, eu vou fazer o seguinte, eu vou criar aqui um arquivo chamado turbo.json, e aqui dentro eu vou começar passando uma flag aqui chamada esquema.https, ele tem vários esquemas prontos aqui, mas a gente vai usar o do turborepo.org.esquema.json. Esse esquema aqui é uma coisa que qualquer arquivo JSON pode ter, e quando a gente coloca esse esquema, o nosso JSON fica mais inteligente, então olha só, ele já começa a falar pra gente, digamos, um IntelliSense, um autocomplete, do que a gente pode colocar dentro desse JSON. Aqui eu vou botar pipeline, a nossa primeira pipeline, o nosso primeiro script, digamos assim, que a gente vai rodar, e eu vou criar um script de dev aqui dentro. O script de dev, eu não quero que ele tenha cache, então eu vou botar cache como falso. Então o que eu estou falando pro Turbo Repo? Olha, o script de dev, eu não quero que você guarde um cache, porque a ideia do script de dev é eu rodar em desenvolvimento até ele não ter cache, ele rodar sempre com a versão mais atualizada do código. E agora aqui no package.json, eu vou criar um script chamado dev, e eu vou rodar turbo run dev, e vou passar uma flag pra ele chamada parallel. Por quê? Porque eu quero que todos os scripts aqui, eles executem em paralelo, os scripts de dev. Eu não quero que ele aguarde um script terminar pra então executar o outro. Então eu vou salvar isso aqui agora, eu posso executar npm run dev, e a gente vai ver que ele vai executar o script de dev aqui de todos os pacotes ao mesmo tempo. Então o pacote de tokens, o pacote react e o pacote de docs. Tudo está rodando ao mesmo tempo. Se eu alterar alguma coisa aqui dentro de tokens, por exemplo, vir aqui e colocar uma cor nova, black2, e salvar, a gente vai ver aqui que ele já rodou a build do pacote de tokens novamente, e ele também já roda o pacote de docs de novo, porque como o pacote de tokens mudou, o pacote de dev aqui de docs, depende desse pacote de tokens, ele atualiza também. Então o nosso script de build aqui está rodando. Mas agora a gente vai pra script de dev, na verdade. E agora sempre que a gente quiser desenvolver alguma coisa aqui dentro, a gente sempre vai rodar apenas esse script de dev aqui na raiz, e ele vai rodar tudo, inclusive o storybook aqui. E agora a gente vai pro nosso segundo script, que é o script de build, que eu vou executar turbo run build. Esse aqui eu não vou colocar pra ele executar em paralelo. E aqui agora eu vou criar a minha segunda pipeline build. E agora aqui dentro dessa pipeline, eu vou passar algumas opções a mais. Primeiro delas, outputs. Eu vou falar quais são as pastas geradas pelos scripts de build. Então os pacotes aqui, react, tokens, eles geram essa pasta dist. Então eu deixo aqui, dist barra asterisco. O storybook, ele gera essa pasta storybook static. Então eu vou trocar aqui build por storybook traço static. E aqui eu vou passar um outro carinha chamado depends on, e aqui dentro eu vou passar o sinal do till e build. O que isso aqui vai fazer? Tem algumas builds que elas dependem de build de outros scripts. O que eu quero dizer com isso? Por exemplo, o react aqui, ele usa o pacote de tokens, o pacote do typescript, o pacote do slint. Ou seja, esse pacote do react, a build desse pacote aqui, depende da build do projeto de tokens. Assim como a build do projeto do storybook, ela depende da build do projeto react e também da build do projeto de tokens. Então quando eu coloco esse depends on, ele vai basicamente rodar o comando de build dos projetos que dependem de outras builds, somente quando essas outras builds finalizarem. Deu pra entender? Acho que deu, né? E agora a gente vai rodar um npm run build aqui dentro do nosso projeto. Na raiz, tá? Isso que é importante. Ele vai gerar a build de todos os projetos. A gente vai ver que essa primeira build aqui vai demorar um tempinho a mais, até porque ele não criou um cache ainda local do TurboRepo. Só que as próximas builds vão ser extremamente mais rápidas. Então a gente aguarda aqui um pouquinho. Show de bola. Veja, demorou 17 segundos. Se eu rodo a build de novo, agora que ele já tem o cache, veja que agora... Opa, peraí, ele deu cache miss. Deixa eu ver certinho, git ignore. React. Deixa eu ver que eu posso ter esquecido alguma coisa. Ah, tem uma coisa que eu esqueci. Esse repositório Turbo, que é o que ele gera, ele precisa estar também no git ignore. Então, Turbo aqui, a gente bota no git ignore. E agora sim, vou dar um npm run build. Agora vamos esperar um pouquinho. Remote caching disabled, não tem problema. Vamos aguardar um pouco de novo, porque ele vai ter que gerar a build. Eu acho que foi esse o motivo de ter dado o problema. Vamos aguardar um pouco novamente. E show, agora se eu rodo a build de novo, veja, ele demorou 160 milissegundos agora para fazer a build completa do nosso projeto. Ou seja, ele guarda um cache local e a nossa build fica muito mais rápida. Com o Turbo Repo, a gente consegue guardar esse cache também online. E aí todas as pessoas do nosso time usam o mesmo cache. Mas não tem tanta necessidade disso no tamanho do projeto que está aqui agora. Mas você pode procurar no próprio site do Turbo Repo sobre Remote Caching. Você consegue fazer a integração com a própria Verso. Eles entregam isso de graça. Você pode fazer o Remote Caching em vários outros providers também. Até dentro da Amazon, Google, Azure e por aí vai."
  },
  {
    "id": "9855c61f-6536-48bd-b976-be2f4b5f5432",
    "title": "Documentação de cores",
    "transcription": "O Storybook tem duas maneiras de a gente criar documentações. A gente pode criar documentações no formato do TypeScript, então com o TSX, mas a gente também pode criar documentações usando o MDX, que caso você não saiba, o MDX é uma mistura de Markdown mais JSX, ou seja, a gente consegue ter no mesmo arquivo código Markdown e código JSX, código React, digamos assim, importações de componentes e tudo mais. Para a gente trabalhar com o MDX só é importante que você... eu acho que hoje em dia o VSCode já suporta, a gente não precisa mais acho que instalar o Language Support do MDX, eu acho que o próprio VSCode já suporta, então não tem muito que instalar plugin nenhum não. O que a gente vai fazer aqui agora é só para não misturar as documentações, eu vou criar uma pastinha chamada Pages, e aqui dentro do main, dentro do Storybook, eu vou falar que as minhas documentações que terminam com a extensão MDX vão estar na pasta Pages e não na pasta Stories. E agora dentro da pasta Pages eu vou começar criando uma página inicial que é a minha Home, então vou criar Home.Stories.MDX, e para eu te mostrar um pouquinho como funciona essa documentação, o que é o seguinte, no MDX a gente consegue botar Markdown, então veja, por exemplo, eu quero colocar um H1, eu boto uma hashtag aqui, escrevo Ignite UI, e posso colocar um texto, Design System do Ignite, e aqui eu posso fazer o que eu quiser, inclusive colocar HTML, se eu quero colocar, por exemplo, uma Anchor, eu posso trabalhar tanto com HTML quanto Markdown dentro do mesmo elemento. E aí, aqui como a gente lembra no Stories, eu tinha esse Export Default aqui em cima que falava o título da página, conseguia passar argumentos. Quando eu trabalho com o MDX, eu faço isso de uma maneira diferente, eu importo meta de dentro de storybook-addon-docs, só cuidado que aqui eu não tenho muita inteligência, o MDX infelizmente não traz um suporte para o TypeScript Server rodar aqui dentro, então ele não consegue carregar inteligência, algumas coisas assim. E aqui eu preciso botar meta como sendo um componente, e eu passo title Home. E aqui eu consigo passar outras informações, a gente consegue até procurar aqui na própria documentação do storybook, aqui na API de MDX, para ver alguns exemplos. Então eu consigo passar o título, consigo passar componente também, então a documentação MDX pode ser usada também para documentar componentes como a gente fez isso aqui. Tudo isso aqui poderia estar escrito no formato MDX, só que quando é uma documentação de componentes, eu particularmente prefiro escrever no formato de TypeScript, porque daí tem toda essa parte de inteligência e tudo mais, que fica muito mais fácil. Agora que a gente já criou a documentação aqui do Home, voltando aqui no nosso storybook, ele não conseguiu identificar essa documentação, porque a gente trocou aqui no main o caminho, e aí o main quando a gente troca precisa rodar o storybook de novo, para ele carregar de novo. E agora olha aqui, já apareceu o Home aqui dentro, e está escrito Ignite UI. Mas como a gente pode ver, aqui o canvas ficou branco, ele não colocou automaticamente o canvas preto. Então o que a gente vai fazer? Aqui dentro do preview.js, a gente tem essa exportação Parameters aqui dentro. Eu consigo aqui de dentro importar, de dentro de storybook-theming, eu consigo importar os meus temas. E aqui embaixo, abaixo de Control, eu consigo passar docs-theme-themes.dark. E agora eu salvo isso aqui. E agora pronto, já está aqui com o fundo escuro, ele já aplicou o fundo escuro também na documentação. Então por padrão ele acaba não colocando esse fundo escuro quando é uma documentação aqui do MDX, mas pronto, agora toda a nossa documentação já está com o fundo escuro, também com o texto branco, e prontinho. Agora o que a gente vai começar a fazer aqui agora, usando esse formato de MDX até, é criar a documentação dos tokens. Uma das coisas mais importantes de um design system, além dos componentes em si, é documentar os nossos tokens, que a gente criou aqui dentro da pasta tokens em si. Então tokens de cores, espaçamento, fontes, e é isso que a gente vai fazer aqui agora. Então o que eu vou fazer aqui agora? Eu vou começar criando uma pasta tokens aqui dentro de Pages, e aqui dentro eu vou criar uma callers.stories.mdx, que é onde a gente vai criar a documentação dos nossos tokens de cores. Aqui eu vou importar mais ou menos a mesma coisa, só que no título eu vou colocar tokens barra callers, e por Storybook, cada vez que eu coloco barra, ele vai criar um submenu aqui dentro. Então a gente pode usar a barra para ir criando vários níveis de menu, ali dentro da nossa sidebar aqui. Aqui no título eu vou botar simplesmente callers, e eu posso colocar uma documentação, essas são as cores utilizadas no Ignite UI, e aqui eu preciso ter alguma forma de mostrar essas cores. Se eu só salvo isso aqui agora, vai aparecer aqui o tokens callers, mas as cores em si não aparecem aqui. E aqui eu vou fazer algo bem legal, olha só. Eu vou criar uma pastinha Components, aqui dentro de Source, e eu vou criar aqui um callers grid. E aqui nesse callers grid, a gente vai basicamente criar uma estrutura visual para eu mostrar as cores do meu projeto. Então olha só o que eu vou fazer. Eu vou importar de dentro de Ignite UI tokens, todas as minhas cores, e aqui eu vou exportar uma função chamada callers grid, e aqui eu vou fazer o seguinte, eu vou retornar object.entries, ou seja, eu vou percorrer todas as cores, que são no caso um objeto, elas são um objeto, onde a chave é o nome da cor e o valor é o hexadecimal daquela cor, e aqui eu vou usar um map para percorrer essa cor, e como o object.entries retorna um array, com vários arrays dentro, onde a primeira posição do array, o índice 0 é a chave e o índice 1 é o valor, a gente pode fazer o seguinte, aqui eu vou desestruturar o array que o object.entries retorna, e eu vou ter basicamente o nome da cor, que vai ser a chave, e o valor, o hexadecimal da cor, que é o resultado, que é o valor. E aqui eu vou retornar, simplesmente, uma div, como eu fiz um map, eu preciso passar uma key, o key pode ser o nome da cor mesmo, a nossa key, porque é o único, e aqui, olha só, eu vou passar um style, e aqui eu vou passar background color, como sendo o hexadecimal da cor, que está aqui em cima, e eu vou botar um padding de 2rem, e aqui dentro dessa div, eu vou colocar uma outra div, poderia ser um parágrafo também, tanto faz, e aqui o style dela vai ser display flex, justify content não é center, é space between, vou passar aqui um font-family monospace, e aqui color fff. E aqui dentro dessa div, a gente vai botar um strong, usando esse sinal de dólar na frente, para indicar que isso aqui é um token, para a pessoa saber como utilizar. Aqui está dando um erro, Ah tá, a gente já vai arrumar isso aqui. Span, eu vou botar a nossa cor em si. Vamos salvar isso aqui agora, mesmo com esse erro, para ver se ele vai funcionar, senão a gente já arruma o erro e depois volta aqui. Agora aqui dentro do meu mdx, eu vou importar o meu colors grid, de dentro de ./......................................................................................................................................................................................................................... A gente quase que não consegue enxergar direito, né? Então, o que que a gente vai fazer aqui dentro? Eu vou... Deixa eu abrir um terminal novo aqui. Eu vou dentro do projeto PackagesDocs. Eu vou instalar uma lib chamada Pollist, como uma dependência. Essa Pollist, ela permite a gente fazer vários cálculos, digamos, com cores, né? Pegar nível de contraste, dá pra fazer muita coisa legal. E aqui dentro, eu vou importar, de dentro do Pollist, uma função chamada GetContrast. E aqui, eu vou fazer o seguinte. Criar uma função. GetContrast... Contrasting... Ou melhor, nem preciso criar essa função, posso fazer direto aqui dentro do Color. Eu vou fazer o seguinte. Vou executar o GetContrast na nossa cor. O contraste que ela tem em relação à cor branca, que é a cor que eu quero colocar no texto. Se o contraste for menos do que 3.5, que fica um contraste muito baixo, eu vou trocar a cor do texto pra preto. Se não, eu posso deixar a cor branca mesmo. Salvo isso aqui agora, volto e olha só. Essas cores aqui que não tinham contrastado muito bem, né? Esses tons de cinza mais claros, eles já trocaram aqui pra cor preta, sem problemas nenhum. E agora sim, a nossa documentação já tá pronta. Pra gente arrumar esse erro aqui, eu preciso criar uma configuração do TypeScript. Como esse arquivo é um arquivo .tsx, ele não encontrou uma configuração do TypeScript, ele acaba reclamando aqui, porque ele pede que eu tenha declarado o React Global e tudo mais. Então, o que a gente vai fazer? Aqui no package.json, eu vou importar também a nossa .tsconfig aqui dentro do .docs. Vou rodar um npm install. Perfeito, já rodou. E agora, eu vou copiar a mesma configuração que a gente tem no pacote React. Vou copiar ela. Posso copiar o arquivo inteiro, na verdade. E jogo aqui dentro de .docs, dou um pass no arquivo aqui dentro. E agora, teoricamente, o meu ColorsGrid aqui, ele tem que parar de dar esse erro. Vou restartar o servidor do .ts aqui, pra ver se ele para. Beleza, com o servidor do TypeScript restartado, já parou de dar o erro. E agora sim, a gente já tem a nossa primeira documentação de tokens aqui, que são as cores. Mas a gente precisa documentar todos os tokens aqui dentro do nosso projeto."
  },
  {
    "id": "f02e668e-83c5-43b2-8005-0abdbc68c5a6",
    "title": "Configuração do Stitches",
    "transcription": "O que a gente vai fazer nessa aula é configurar o Stitches aqui dentro, que é a ferramenta de estilização que a gente vai estar utilizando durante toda a construção do nosso design system. Pra mim, hoje é uma das ferramentas mais legais que a gente tem pra trabalhar com CSS em JS, e ela vai funcionar super bem, principalmente porque a gente separou aqui os nossos tokens. Na verdade, criou os nossos tokens aqui de cores, font-sizes. Então, isso aqui integra muito bem com o Stitches em si. Olha só que legal. Dentro aqui do pacote de React, eu vou começar instalando o Stitches React. E agora, esse sim é uma dependência de produção, porque não necessariamente a aplicação que vai estar usando o nosso design system precisa estar construída também com Stitches. Então, nesse caso, mesmo que a aplicação hospedeira do nosso design system, que instalou o nosso design system, use styled components ou nem qualquer biblioteca CSS em JS, mesmo assim, a gente precisa ter o Stitches instalado, então não é uma dependência externa agora, porque não é uma dependência obrigatória, digamos assim. E agora, com o Stitches instalado aqui dentro do nosso pacote React, eu vou começar dentro da pasta search, criando uma pasta chamada styles. Essa pasta styles aqui agora, eu vou criar dentro dela um arquivo index.ts, que vai ter a nossa configuração do Stitches em si. E aqui, agora, olha só que legal. A gente vai usar a função createStitches, que ela não foi importada automaticamente, então, deixa eu importar de dentro de Stitches React, o nosso createStitches. E aqui, a gente vai usar a função createStitches, passando uma série de opções aqui pra ela. Essa função createStitches, aqui até se eu dar um Ctrl espaço dentro dela, ela aceita algumas opções aqui dentro. A primeira opção é theme, que é basicamente as variáveis que a gente vai usar dentro do tema da nossa aplicação. E se eu dou um Ctrl espaço aqui dentro desse theme, olha só que legal. Aqui ele traz, basicamente, que eu posso informar variáveis pra grande maioria dos tipos de tokens que a gente tem na web. Então, os índices, transitions, space, sizes, shadows, border-radios, line-height, letter-spacing, font-weight, font-sizes, font-colors e border-width e border-style. A gente tem vários desses tokens aqui dentro do nosso pacote de tokens. Então, olha só que legal. Dentro do pacote de tokens, a gente já criou aqui o nome das nossas variáveis, exatamente como que o Stitches usa. Então, é basicamente a gente só sair colocando essas variáveis aqui dentro. Olha só que legal, vou escrever aqui, colors, é igual a colors. Ele vai importar lá do in.ui.tokens. Depois eu tiro aqui, ficou igual, o nome, quando eu salvo, ele faz automaticamente. Então, font-sizes é igual a font-sizes que vem lá de dentro do in.ui.tokens. Font-weights é igual a font-weights que vem de dentro do in.ui.tokens. E a gente vai fazer isso aqui pras demais tokens que a gente tem lá dentro do nosso pacote. Então aqui, line-heights, temos aqui também o radi, que é o border-radials, que eu vou usar aqui radi. Tenho aqui também space, que eu vou usar space. E agora que a gente configurou isso aqui tudo certinho, o que eu vou fazer? Eu vou escrever aqui, simplesmente, export const. Crio aqui um objeto, porque eu quero fazer uma desestruturação do retorno aqui desse createStitches. E aqui eu vou basicamente retornar styled, que é a função que a gente vai usar pra fazer a estilização de novos componentes. CSS, global CSS, keyframes, getCSS, text, theme, create, theme e config. São basicamente todas as exportações aqui do createStitches, porém separadas cada uma na sua variável. Agora eu salvo aqui agora, e olha que interessante. Quando eu vou pra um componente, e agora eu quero fazer a estilização dele, basta eu importar de dentro de ./.styles a nossa função styled. E aqui eu vou criar, por exemplo, const button é igual a styled button. E agora, quando eu passo alguma opção que a gente pode usar um token, por exemplo, .family, dois pontos, e aqui eu dou um control espaço, veja que essas variáveis com sinal de dólar aqui na frente, são exatamente as variáveis que a gente tem no nosso pacote de tokens. Então, por exemplo, posso colocar aqui default. Se eu coloco, por exemplo, background-color, novamente, olha só, todos os meus tokens aqui, os tons de cinza e os tons de verde aqui do Ignite, também já aparecem aqui, já consigo utilizar eles sem problema. Isso vale também pra border-radials. Eu dou aqui um control espaço, e já traz aqui todas as opções de border-radials que eu tenho. Então, eu consigo ter essa integração direta do nosso pacote de tokens, diretamente aqui dentro, por causa do Stitches. O Stitches é muito legal e funciona muito bem com essa parte de tokens aqui dentro. E agora que a gente configurou isso, uma última configuração que eu vou fazer aqui dentro do Stitches, que eu particularmente gosto bastante e a gente usa aqui dentro da Rocket, é que o Stitches oferece uma outra opção aqui que se chama Theme Map. Essa Theme Map aqui, ela é basicamente uma forma de eu conseguir mapear propriedades do CSS pra algum tipo de token. Então, por exemplo, aqui dentro dos tokens, eu tenho esse token aqui que é space, que ele é um token mais genérico pra espaçamento, que por padrão, o Stitches vai entender que esse token aqui de space que a gente usou aqui, que a gente até botou ele aqui, ele é pra padding e pra margin. Então, se eu venho aqui, por exemplo, e escrevo padding, ele vai retornar aqui todos os spaces que eu tenho disponível. 1, 4, se eu quero 16, eu boto 4, por exemplo, como a gente já falou anteriormente. Porém, eu gosto de utilizar esses tokens de space aqui também pra width e height. Então, se eu escrever aqui, por exemplo, height, eu gostaria que ele trouxesse aqui os nossos tokens de space dentro de height também. E a gente consegue fazer isso simplesmente vindo aqui e falando, olha, eu quero que você use pro height o token de space. Pro width também, eu quero que você use os tokens aqui de space. Só que isso aqui, ele vai acabar substituindo os tokens que já existem no Stitches, se eu não me engano. Então, eu dou um ctrl espaço aqui, ele perde a referência dos outros aqui, por exemplo, do BorderRadius. Então, a gente precisa importar, opa, aqui ó, de dentro do StitchesReact, o defaultThemeMap, que é o padrão, e aí aqui dentro a gente faz . . . defaultThemeMap, que a gente entra aqui, a gente até pode ver um pouquinho como é que ele é, é basicamente isso aqui, certo? A gente vai importar ele aqui dentro e vamos apenas adicionar dois novos maps aqui dentro. Se eu salvo aqui agora, tudo tá funcionando. E agora quando eu escrevo height e boto o dólar, ele já traz aqui os nossos tokens. Então, se eu quero, por exemplo, se eu boto 10, ele vai ficar com 40 de altura, e aí a gente pode ir ajustando o melhor. 10 vai ficar com 4, 16, a gente sempre tem que apertar. Isso aqui vai ficar com 40, tá? Tudo bem, é só multiplicar por 4. Às vezes eu sou um pouco burro. Mas, tudo bem, agora a gente já configurou o Stitches aqui dentro da nossa aplicação e a gente já pode sair utilizando. O único ponto é que a gente ainda não consegue visualizar a nossa aplicação React, o nosso pacote React ainda, visualmente a gente não consegue entender se está funcionando ou não está funcionando essas aplicações de estilos aqui, que é o que a gente vai começar a fazer a partir de agora."
  },
  {
    "id": "f24da06a-7e78-4199-8946-22c3d2ac14b1",
    "title": "Configurando pacote do React",
    "transcription": "O que a gente vai fazer nessa aula é começar a dar vida agora para esse pacote React, aqui que vai ter os componentes do nosso design system utilizando os tokens que a gente tem nesse outro pacote. E aqui agora, então, dentro do pacote React, eu vou começar instalando como uma dependência de desenvolvimento o pacote React em si. E também vou instalar types barra React e types barra React DOM. E aí, por que eu estou instalando o React como uma dependência de desenvolvimento? Porque quando a gente cria um pacote, por exemplo, para React, uma biblioteca para React, a gente espera que, na verdade, o React seja instalado no pacote, na aplicação, de quem está usando a nossa biblioteca. Então, a gente não coloca o React junto com a nossa biblioteca, porque isso ia aumentar o tamanho da biblioteca consideravelmente, porque o React acaba sendo um pouquinho maior, e ia acabar criando, digamos, uma duplicação do React em si, dentro da aplicação do usuário que estiver instalando a nossa biblioteca. Então, se eu estou criando um design system que é para React, que só dá para usar no React, a pessoa que estiver usando o meu design system já vai ter o React instalado na aplicação dela, eu não preciso duplicar isso. E aí, desculpa que eu buguei aqui, mas e aí, aqui dentro do package.json, outra coisa que eu vou fazer é, aqui no script de build e no script de dev, a gente vai colocar também uma opção aqui no final, chamada \"-external react\". Isso aqui eu estou, basicamente, dizendo para o tsup que, quando ele for fazer o processo de build, eu não preciso me preocupar com a importação do React, porque ela é uma importação externa. É como se a minha biblioteca fosse importar o React da aplicação... Como não, né? É realmente isso. A minha biblioteca vai importar o React da aplicação hospedeira, a aplicação que está usando a biblioteca, e não pegar o React interno aqui dela. É uma dependência externa que a gente chama. E você pode ter outras dependências externas. Isso, como a gente está criando uma biblioteca aqui para o React, é a única dependência externa que a gente tem. Show de bola. Agora, o que a gente vai fazer? Eu já instalei o React, já instalei o types React, o types React DOM, e agora a gente pode criar o nosso primeiro componente para ver se está tudo certinho aqui dentro. Então, aqui dentro, do index.ts, eu vou fazer o seguinte. Vamos lá. Eu vou tentar criar o nosso primeiro componente. Eu vou deixar essa importação aqui dentro. E agora eu vou fazer o seguinte. Function.app. Return. H1. Isso aqui precisa ser tsx, o arquivo. H1. Hello world. E aí, eu vou tentar usar aqui no H1, passando o style, a cor dele, como sendo colors.ignite300. Salvo isso aqui agora. Vou rodar o processo de build para ver se está funcionando normalmente. Lifecycle build failed with error. Command failed. Vamos dar uma olhadinha. Tá, aqui no package.json é index.tsx que a gente vai usar aqui no nosso comando de build. Vamos rodar de novo. Beleza, já rodou a build normalmente aqui. Eu posso ver aqui no mjs que ele já conseguiu usar o jsx-runtime, que é a forma de escrever JSX mais moderna. Ele já criou o nosso componente aqui, já conseguiu passar o style, importou as cores. Então, tá tudo certinho. A gente já conseguiu configurar isso aqui perfeitamente bem. Agora, o que a gente precisa, na verdade, é começar a conseguir visualizar esses componentes que a gente está codando em React em algum lugar. Então, vai ser bem legal. Eu vou criar uma configuração base de estilização para a gente usar aqui na nossa aplicação. Porque usar os tokens dessa forma aqui não é tão legal. Porque a gente preferencialmente não escreve os CSS inline aqui dessa forma. Então, a gente vai fazer uma configuração de estilização aqui para o nosso projeto. E aí depois a gente vai configurar o storybook para a gente começar a visualizar os componentes que a gente cria aqui dentro da nossa aplicação React. Através de uma interface gráfica e conseguir manipular eles."
  },
  {
    "id": "5a14de3b-80ba-428b-8017-33b1be01ccd2",
    "title": "Do Figma ao código",
    "transcription": "E aí, como eu falei, a gente vai partir do total zero aqui, entendendo os elementos que a gente vai acoplar ao Design System, olhando a partir de um layout. O que é muito comum acontecer dentro das empresas? Geralmente, a concepção de um Design System nasce da seguinte forma. A gente começa a construir várias aplicações, a gente começa a perceber que existem elementos que são repetidos entre essas várias aplicações, e o pior, o terceiro passo, é quando a gente percebe que entre essas várias aplicações a gente tem pequenas diferenças entre esses componentes. A gente tem, às vezes, ali um botão que está seguindo uma cor um pouquinho diferente, um Border Radius, que às vezes em um está 6 e em outro está 8. Às vezes, a fonte dentro do botão, a gente utiliza um padrão em negrito, e a outra, a gente está usando um semi-bold. Então, o que acontece, que a gente geralmente parte para criar um Design System, é que a gente começa a perceber que nem toda aplicação, apesar de a gente querer que ela siga um padrão de design, está conseguindo seguir esse padrão de design. E aí nasce o Design System para a gente realmente conseguir seguir esse padrão entre todas as aplicações. E aí o que eu fiz aqui foi basicamente criar um layout de uma aplicação que a gente ainda vai codar no Ignite mais para frente, e a partir desse layout dessa aplicação, a gente vai identificar elementos que facilmente poderiam ser compartilhados entre várias outras aplicações. E eu não fiz a criação do Design System aqui dentro do Figma, mas é muito comum a gente ter também por parte, claro, de designers, a criação do Design System dentro do Figma. Inclusive aqui, por exemplo, eu posso mostrar um pouquinho o Andromeda, que é o Design System da própria Rocket, e a gente vai ver um pouquinho como ele é documentado aqui dentro do Figma, ou melhor, como a gente documenta aqui dentro do Figma, para eu mostrar para você. Então, aqui dentro da Rocket, a gente tem aqui um time de Design System and Ops, que fica toda a parte da concepção do Design System em si. Meu Deus, hoje o Figma está super lento, o que está acontecendo? Deixa eu botar... Eu não sei por que o Figma está tão lento aqui agora, vamos aguardar um pouquinho ele carregar. Mas dentro do Figma, a gente basicamente detalha aqui todos os tokens e componentes que a gente vai utilizar. Então, aqui dentro da linha de tokens, por exemplo, a gente pode ver que dentro da Andromeda da Rocket, a gente detalha todas as cores que a gente utiliza, todos os tons de cinza, nossos layouts são muito baseados em tons de cinza, todos os tamanhos de fontes, o peso das fontes, o Line Height, todos os font sizes, os tamanhos de fontes, Border Radius, Border Width, Box Shadow, Opacity. A gente detalha também toda a parte de espaçamento, então, os Margin Padding, a duração das animações. Então, você vai ver que o Design System vai muito além de simplesmente componentes. A gente pega até padrões de animação. A gente não pode ter, por exemplo, um hover de um botão, por exemplo, executando fora desses intervalos de animação que a gente tem aqui. E aí, claro, a gente detalha também os componentes em si, aqui dentro de Core Components. Então, a gente detalha todos os elementos de tipografia. Então, a gente tem um componente só para cabeçalho, um componente para texto, a gente tem componentes para botões de todos os tipos, componentes de ícones, labels, aqui toda a parte de Inputs, todos os estados do Input. Então, Input Complace Holder, Input Preenchido, Input de Senha, Input Desabilitado, Input Com Erro. Então, tem todos os estados aqui, Selects. Tem muita, muita coisa detalhada aqui dentro. É claro que a gente não vai construir um Design System tão completo quanto é o próprio Design System da Rocket aqui dentro, mas eu estou te mostrando isso aqui exatamente para você ter um pouco de dimensão do quanto que um Design System pode escalar dentro da sua empresa e o quanto que o Design System pode acelerar no desenvolvimento da sua própria aplicação. Mas olhando aqui para dentro do projeto Ignite Call, a gente vai dar uma olhadinha aqui e detalhar quais são os componentes que a gente vai colocar dentro do nosso Design System. Então, aqui dentro do VSCode, eu vou criar aqui um Markdown para a gente falar um pouquinho sobre, então, os componentes que a gente vai colocar dentro do nosso Design System. Primeiro, é comum todos os Design Systems incluírem um componente que se chama Text. Esse aqui geralmente é o primeiro componente que vem até antes do botão. Que são os componentes mais comuns. O componente de Text, apesar de ele não ter muito comportamento, porque no final das contas ele é apenas um texto, ele serve para a gente padronizar qual é a família de fonte que a gente está utilizando. Ele serve para a gente padronizar também o tamanho da fonte, a coloração da fonte. Isso é muito legal, porque a partir do momento que a gente tem um elemento Text, a gente vai usar esse elemento Text para qualquer lugar que a gente tenha um texto na nossa aplicação. Então, apesar de eu estar vendo esse elemento Text aqui dentro, esse mesmo componente Text pode ser utilizado, por exemplo, para esse carinha aqui, o passo 1 de 4. Ele pode ser utilizado, inclusive, para Label aqui dentro. Ou seja, qualquer lugar que eu tenha um texto na aplicação, eu posso estar utilizando um componente de Text. Aliado ao componente de Text, é muito comum a gente ter um componente de Heading, que são os cabeçalhos da nossa aplicação, que ele também padroniza a fonte, porque muitas vezes dentro de aplicações a gente tem a fonte de cabeçalhos diferente da fonte que a gente vai utilizar nos textos de corpo. Nesse caso aqui, a gente usa a mesma, que é a Roboto, mas é muito comum serem fontes diferentes. E também, nos componentes de Heading, a gente acaba tendo a utilização de um peso de fonte diferente. Então, a gente geralmente cria dois componentes diferentes para essa parte. E aí, outra coisa que geralmente a gente acaba criando também, caso seja comum utilizar dentro da sua aplicação, é um componente de Box, por exemplo, ou Card, independente de como você queira chamar. Nesse caso aqui, eu vou chamar de Box. O Box, geralmente, é aquele componente que é facilmente reutilizável e que muitos lugares da aplicação utilizam. Então, está vendo que, por exemplo, quando a gente acessa a própria aplicação da Rocketseat, a gente tem essa caixinha cinza aqui, que a gente usa em vários locais da Rocket. Até se eu entrar aqui no meu perfil, por exemplo, eu vou ver que em vários locais eu tenho essa caixinha cinza muito semelhante, pelo jeito a minha internet está muito lenta aqui hoje. Então, olha só, essa caixinha cinza aqui, que ela tem um Padding padrão, um arredondamento de borda, ela é utilizada em vários e vários locais aqui dentro. A gente vê que ela é reaproveitada em vários locais. E aqui a gente também tem essa caixinha cinza aqui, que tem uma bordinha, um Padding, um Border Radius, e a gente pode ver que ela é reaproveitada em vários e vários locais. E aí, eu vou também criar aqui um componente para a gente codar essa caixinha aí. E aí, não poderia faltar o botão. O botão, com certeza, é um dos componentes mais comuns que a gente tem em Design Systems aí dentro. O próximo é o nosso próprio input de texto, que eu vou chamar de Text Input. E veja que eu estou colocando aqui somente componentes que eu sei que eu posso compartilhar entre várias aplicações. O próximo componente aqui que a gente pode dar uma olhadinha... Bom, a gente pode ver que a gente tem um checkbox aqui dentro, que ele segue uma estilização diferente da estilização padrão do próprio HTML nativo. Então, a gente vai criar um componente para esse checkbox também. A gente tem aqui uma Text Area. Então, a gente vai criar também uma Text Area. Vou até mover aqui para cima para ficar junto com o Text Input. Aqui, a gente tem um avatar, que ele também pode ser facilmente reaproveitado entre várias aplicações. E, por último, um componente aqui que também pode ser reaproveitado entre várias aplicações é esse componente aqui, onde a gente tem o passo 3 de 4, onde a gente tem basicamente um Multistep Form. Isso aqui é muito comum quando a gente tem um formulário que tem várias etapas, a gente tem um indicador mostrando qual é a etapa que o usuário está. Então, eu vou chamar ele de Multistep. Eu acredito que não tenha mais nenhum outro componente. Deixa eu dar uma olhada aqui na minha colinha, mas eu acredito que são esses componentes que a gente vai estar criando aí dentro do nosso Design System. E aí, lembrando, por último, o que a gente não vai colocar no nosso Design System. Se a gente for olhar aqui, por exemplo, pô, Diego, esse calendário aqui, será que ele faz sentido estar dentro do nosso Design System? E aí a gente pensa, esse calendário aqui, será que facilmente eu poderia utilizar esse calendário em outro local da nossa aplicação, ou melhor, em uma outra aplicação que não fosse do mesmo gênero de uma aplicação de calendário, de agendamento, especificamente? Não, o calendário é específico de uma aplicação de agendamento, de uma aplicação voltada para essa parte de datas. Então, não faz muito sentido ele estar no Design System, porque ele é um componente que não vai agregar outros tipos de aplicação. E aqui você pode ver que já tem um spoiler, que é um elemento de Toast, um elemento de Toast Tip, que a gente não vai colar nesse Design System, e mais para frente você vai ver porquê. Mas existem elementos aqui dentro que são específicos dessa aplicação. E por mais que a gente possa pensar que esse calendário pode ser compartilhado entre outras aplicações, não necessariamente ele pode ser compartilhado com todas as aplicações. Ou seja, ele não faz parte do nosso Design System, e sim faria parte de um possível UI Kit que poderia ter esse calendário, um componente compartilhado entre essas duas ou mais aplicações que utilizariam esse calendário. Então, lembrando, a gente coloca no Design System somente elementos que podem ser compartilhados entre qualquer aplicação do nosso escopo, da nossa empresa."
  },
  {
    "id": "d00f127a-e1bb-4320-b4e9-afb479ed536d",
    "title": "Configurando tokens",
    "transcription": "O que a gente vai fazer nessa aula é configurar aqui os demais tokens que a gente vai utilizar dentro do nosso design system e passar um pouquinho por eles explicando o que eles fazem. Então como eu falei na última aula e nessa aula também, eu vou deixar um link aqui para um projeto no GitHub que contém todos esses tokens, um link aqui que você vai conseguir baixar todos esses tokens e colocar aí dentro. Então você pode acessar isso. Eu vou copiar todos esses arquivos de tokens, vou jogar aqui dentro da pasta e depois a gente sai comentando sobre eles. Então aqui eu já copiei todos eles, venho aqui na pasta, vou dar um paste. Ele vai substituir aqui alguns na verdade que vão ficar com copy porque eu já tinha esse arquivo antes. Então vou deletar eles e a gente vai passar um pouquinho sobre cada um desses arquivos. Então tokens de cores na verdade não mudou muito comparado com o que a gente já tinha antes. Não mudou nada na verdade, são os tons de cinza aqui e os tons de verde que a gente já tinha antes. Os font sizes aqui da nossa aplicação a gente pode customizar e variar bastante. E lembrando sempre usar medidas relativas quando a gente for trabalhar na web. Isso é super importante porque unidades de medida em pixels elas são absolutas, elas não podem ser alteradas de acordo com as preferências do sistema do usuário. Se ele aumenta ou diminui a fonte ali no iPhone ou no Android, ela não vai refletir caso a gente esteja utilizando em pixels. Por isso sempre unidades de medida relativas. E aí a gente pode pensar como padrão da web, cada um RAM equivale a 16 pixels. Então aqui a gente pode ver que a minha fonte median, que é geralmente o padrão que eu uso para todos os textos da web, e aí depois a gente pode variar. Então o tamanho median é o que eu vou usar por padrão nos textos. E aí depois a gente pode customizar para tamanhos menores ou maiores. Esse tamanho ele usa um RAM que equivale a 16 pixels. E aí a gente vai diminuindo, por exemplo, 0.875 aqui. São 14 pixels, 12 pixels e até 10 pixels de tamanho. E a gente pode ter tamanhos maiores também. Então aqui 1.125, são tamanhos 18, tamanho 20, a gente pode ter tamanho aqui 24, 32 e aí a gente vai aumentando também, não peça aqui muito da minha matemática. E aí a gente tem tamanhos aqui também, o peso da fonte, então regular 400, tamanho median e bold. Se a gente tivesse outros padrões aqui, black também, o tamanho é 900, o semi-bold, que é o 600, ou até o light, que é o 300, a gente poderia adicionar aqui também, como as minhas aplicações aqui do Ignite nenhuma usa outros padrões fora isso aqui, a gente vai manter esses padrões aqui. Fontes, a gente pode ver que eu tenho uma fonte default, que é o Roboto ou Sans Serif, caso o Roboto não seja carregado, e a fonte de code é Monospace. A gente poderia, como eu falei antes, é muito comum em aplicações a gente ter fontes diferentes para textos corridos e para cabeçalhos, então a gente poderia ter, por exemplo, uma configuração aqui, Heading, e usar uma fonte diferente, como por exemplo uma Montserrat. Então no nosso caso, a gente usa a mesma fonte Roboto, tanto para Heading quanto para textos corridos, por isso que a gente vai usar apenas a Roboto aqui nesse caso. Aí aqui a gente tem o nosso Line Height, que ele tem basicamente os tamanhos de texto, e aí, para você ter noção, é muito comum para textos corridos, parágrafos, que a gente tem várias linhas, a gente usar um Line Height de 160%, ou 1.6, tanto faz, que é o Line Height perfeito para web, mas para cabeçalhos a gente acaba usando um Line Height menor, geralmente 125. Isso aqui são padrões de design, não é necessariamente que você precisa seguir isso dentro da sua aplicação, mas é o que a gente acaba utilizando muito aqui dentro da Rocket. Mas a gente pode ter variações também, 140, 180, e pode até ter outras variações caso você queira utilizar na sua aplicação. A gente também define aqui alguns padrões de Border Radius, então aqui a gente tem, por exemplo, o Border Radius de 1 pixel 4, 6, 8, 16, ou o Full, que é 9, 9, 9, 9, 9, que ele vai basicamente determinar um arredondamento total da borda daquele elemento. Então isso aqui são só alguns exemplos que a gente usa aqui dentro da Rocket, e lembrando o Border Radius nunca usando medidas relativas, nesse caso aqui a gente acaba usando sim medidas absolutas para o Border Radius, porque a gente não quer que esse Border Radius mude de acordo com o tamanho da fonte do usuário. E também a gente tem padrões de espaçamento, isso aqui são Margin, Padding, Top, Left, Right, Bottom, que a gente parte aí usando um padrão muito comum entre vários Design System e bibliotecas front-end, então se você já usou o Tailwind, o Chakra UI, ou qualquer outro tipo de, não dá para chamar necessariamente de Design System, ou qualquer biblioteca que traga algum padrão para espaçamento, fontes, você vai ver que a gente segue um padrão muito semelhante. Qual que é esse padrão? Imagina que eu queira atingir, por exemplo, um Margin de 16 pixels, 16 pixels equivale a 1 rem dentro da nossa aplicação. Então eu sempre tenho que pensar, se eu quero 16 pixels, 16 pixels dividido por 4 dá quanto? Dá 4. Então eu vou colocar um Space de 4, que isso vai resultar exatamente em 16 pixels. Então a gente sempre pensa que esse número aqui da esquerda, multiplicado por 4, é o valor que vai dar em pixels do nosso Padding, ou do nosso Margin, ou qualquer outro tipo de espaçamento que a gente esteja colocando ali dentro. Então isso aqui é um padrão utilizado por várias bibliotecas front-end, como eu falei, tanto o Chakra UI, quanto o próprio Tailwind, como várias outras bibliotecas aí dentro. E aí a gente tem esse índex que ele precisa re-exportar tudo o que está aqui nos outros arquivos. Então, basicamente, vou jogar aqui as exportações, ele exporta tudo o que a gente tem de cores, de espaçamento, o Border Radius, Fonts, Font Sizes, Font Weights e Line Heights aqui dentro da nossa aplicação. E agora com todos os tokens criados aqui do nosso Design System, claro, você pode customizar, criar até mais tokens. A gente não criou token aqui, por exemplo, para Opacidade, para Box Shadow, a gente não criou token aqui para parte de animações, o Timing ali, qual que é a duração das animações. Você pode ter tokens para tudo isso. A gente não está criando porque nesse Design System a gente vai manter as coisas mais simples, como eu falei, mas no futuro você pode ir customizando e colocando mais informações no seu Design System."
  },
  {
    "id": "bc836215-53e9-470f-89bf-eef4dbf32c2e",
    "title": "Build do pacote com TSUP",
    "transcription": "O que a gente vai fazer nessa aula aqui é usar a primeira ferramenta, digamos assim, instalar o primeiro pacote, aqui talvez que você não conheça, que é o TS-UP. A gente vai instalar aqui dentro do pacote de tokens como uma dependência de desenvolvimento. O TS-UP é uma ferramenta que serve para a gente fazer o processo de conversão do nosso código num arquivo JavaScript, num pacote JavaScript que vai poder ser carregado por outras aplicações. E aí, novamente, por que a gente não faz com a própria biblioteca do TypeScript, como a gente mostrou antes, rodando o npxtsc, que ela também faz o build aqui do nosso pacote e também converte o código para JavaScript? O que difere é que o TS-UP consegue converter o nosso código para vários formatos diferentes. Então, por exemplo, a gente consegue converter o nosso mesmo código TypeScript para dois formatos, como um JS, por exemplo, e ECMAScriptModules, para que ele possa ser utilizado tanto em aplicações que têm suporte a ECMAScriptModules, aplicações mais recentes, que usam, por exemplo, essa sintaxe de import e export, e também possa ser utilizado em aplicações mais antigas que usam aquele padrão de require na hora de fazer a importação. Se a gente simplesmente converte o nosso código usando o TSC, o próprio TypeScript, faz o processo de build tradicional, a gente vai limitar quem pode consumir o nosso pacote em si. E a gente também consegue criar, junto com o TS-UP, toda a parte dos arquivos de definição de tipagem, a gente consegue também fazer um watch, e fora isso, o TS-UP é muito mais performático que o próprio pacote do TypeScript na hora de fazer o nosso processo. Então, esse aqui simplesmente é o projetinho do TS-UP, e ele é muito rápido porque ele usa por baixo dos panos o ESBuild, que é a mesma tecnologia que está por trás do Vite e várias outras ferramentas de desenvolvimento web. Então, ele é muito rapidinho, a gente já vai ver como a gente utiliza esse pacote em si. Então, agora com o TS-UP instalado, a gente vem aqui no nosso package.json, e a gente vai criar dois scripts aqui dentro. Primeiro, o script build, ele vai executar TS-UP src-index, que é o nosso arquivo principal aqui, e a gente vai passar aqui dois traço-traço format. Eu quero exportar o nosso pacote em ECMAScriptModules, ESM, e também CommonJS, CJS. E eu quero que ele também exporte os arquivos de definição de tipagem, que são aqueles arquivos que auxiliam os outros pacotes que importarem o nosso projeto de tokens a saberem qual que é a tipagem desse pacote e ter uma IntelliSense melhor. E aí, a gente vai criar aqui também um script chamado dev, que é para quando eu estou trabalhando nesse pacote, ele ficar monitorando qualquer alteração aqui nos arquivos e fazendo o processo de gerar aqui o build da nossa aplicação automaticamente, toda vez que eu altero um arquivo. A única flag que eu vou passar aqui é o traço-traço watch, no final o resto se mantém tudo igual. Eu vou salvar aqui agora, e olha que interessante, quando eu venho aqui no meu pacote e rodo npm run build, aguardo um pouquinho, e pronto, ele já gerou a build aqui dentro do nosso dist. E aqui a gente pode ver que diferente do padrão do próprio TypeScript, ele não gerou um arquivo JS para cada arquivo, ele minificou todos esses arquivos dentro de um único arquivo. Olha só, o meu index.mjs, que é do ECMAScriptModules, do ESM, ele já criou aqui todas as definições e exportou tudo aqui no final, e também o index.js, que ele usa o padrão do common.js, e aí aquela questão do require e tudo mais, a gente pode ver que também ele já unificou tudo isso dentro de um único arquivo. E ele criou para a gente também o arquivo de definição de tipagem, que é um arquivo que basicamente aqui declara para a gente quais são todas as cores, qual que é o formato, a gente usa strings, quais são as chaves que a gente tem nas cores, isso aqui vai trazer uma inteligência bem legal na hora que a gente estiver utilizando esse pacote. E aí o scriptdev, ele também é muito semelhante, porém ele fica observando as alterações nos arquivos. Então olha só, ele ficou rodando aqui agora, se eu venho aqui em cores, por exemplo, e adiciono uma outra cor, teste, aqui cor 000, e salvo, veja que no momento que eu salvar, ele já rodou a build de novo, e lá dentro do meu index já apareceu a nossa nova cor test aqui dentro. Então a gente vai usar esse scriptdev depois, enquanto a gente estiver codando o nosso design system, para a gente manter tudo muito reativo conforme a gente faz as alterações nos nossos pacotes."
  },
  {
    "id": "a0ba27fc-05f9-486e-8350-7985d33957ca",
    "title": "Carregando dados do produto",
    "transcription": "O que a gente vai fazer nessa aula é carregar os dados do produto aqui através do ID que está vindo aqui na nossa URL para mostrar em tela. E, novamente, eu, dentro do Next, eu posso, como eu já mostrei, tendo acesso a esse Query aqui do UseRouter, eu posso fazer a Query para buscar os dados do produto através do UseEffect aqui dentro e, perfeito, vai funcionar 100%. Porém, a gente já viu isso antes, que se eu fizer a requisição para obter os dados do produto aqui dentro do componente, esses dados não vão ser carregados quando um indexador, um bot ou qualquer coisa parecida for visualizar a nossa página. Então, se a gente vir aqui e desabilitar o JavaScript, a gente sabe que o conteúdo aqui do produto, a requisição, qualquer código que a gente coloque aqui dentro do componente, ele não vai ser executado. Pensando nisso, a melhor forma de eu carregar os dados aqui do produto, com certeza, é com alguma função que execute esse código via server-side. E aí eu posso executar isso utilizando SSR e utilizando SSD. Porém, eu tenho que sempre me fazer a pergunta, os dados que eu vou carregar aqui dentro, eles são atemporais? Ou seja, são dados que eu posso manter em cache por um tempo que dificilmente eles mudam? Sim, os dados de um produto, eles geralmente, dificilmente eles vão mudar, acho que mais o preço pode mudar, mas isso, sei lá, vai mudar uma vez a cada hora e olha lá. Outra pergunta que eu tenho que fazer é, os dados que eu vou carregar, eles dependem de alguma informação do contexto de execução ali da página? Por exemplo, algum cookie, o usuário logado, alguma informação em tempo real, digamos assim? O nosso caso, não. Então, se a nossa página não depende de dados do contexto atual, cookies, usuário autenticado ou qualquer coisa semelhante, e não tem problema essa página ficar salva em cache por um tempo, o melhor é a gente ir de geração estática. Caso contrário, se alguma dessas condições não fosse satisfeita, a gente faria então o carregamento utilizando SSR, que a gente ainda vai fazer mais pra frente e eu vou te mostrar isso. Mas aqui então, a gente vai começar exportando uma função, getStaticProps, a gente vai fazer a tipagem dela aqui dentro, e aqui eu vou só, a função sempre assíncrona, e no final ela precisa devolver um tanto de propriedade. E aí, quando a gente faz isso, a gente pode ver até que já para de dar erro. E aqui, vou passar aquele revalidate, que é basicamente eu falar quanto tempo eu quero manter essa página em cache, então aqui eu vou botar 60 segundos, vezes 60, vai produzir 1 hora, vezes 1, mesmo que não mude nada, eu vou falar que eu vou salvar essa página 1 hora no cache. E aí esse 1 aqui, ele não muda nada na conta, porém fica mais claro que isso aqui significa o 1 hora, um dia se alguém quiser vir trocar, só vem aqui e troca pra 2 horas. E agora aqui dentro, eu preciso buscar os dados do meu produto. E vamos lá? O que eu vou fazer aqui dentro? Eu vou, primeiramente, é super importante entender que aqui agora a gente vai ter um funcionamento um pouquinho diferente que a gente tinha lá na ROM. Por quê? A ROM era uma página que a gente girou de forma estática, porém você concorda comigo que a ROM não recebia nenhum tipo de parâmetro, ou seja, a ROM era sempre igual. No caso do produto, ela vai ser também uma página estática, mas ela tem que mudar de acordo com o produto. Não adianta eu gerar uma única página estática, porque eu preciso, na verdade, gerar uma página estática por produto. Concorda comigo? Então isso aqui muda um pouquinho. O que acontece? Aqui no getStaticProps, aqui dentro dos parâmetros, se eu fizer uma desestruturação aqui dentro, eu vou ver que uma das informações que eu posso pegar aqui dentro é parms. E aqui dentro desse parms, eu posso acessar o parâmetro id que vem aqui através do nome do arquivo. Então, se eu quero pegar o id do produto, basta eu escrever parms.id e eu já vou ter acesso a esse id. Esse id que vem aqui através da nossa URL. Perfeito? Vamos continuar aqui. Agora, o que eu vou fazer? Eu preciso buscar o produto de dentro do Stripe. Então eu vou dar um await stripe.products.retrieve, agora passando o nosso product id. E aqui eu vou fazer um expand, da mesma forma que eu fiz lá na nossa ROM, para buscar o preço. Só que agora, como não é uma lista, eu não preciso usar o data na frente. Eu escrevo diretamente defaultPrice. Aqui a gente pode ver que o product id deu erro. Por quê? Porque o método retrieve espera que o id seja uma string. Só que aqui, quando eu pego parms.id, ele está falando que isso aqui pode ser ou uma string ou um array de string. Por quê? Porque a gente pode receber dois parâmetros com o mesmo nome na URL. E aí ele vai ficar salvo dentro de um array. Então, a melhor forma de eu lidar com isso, tem duas formas. Eu posso forçar isso aqui, converter para uma string. Então, dessa forma, eu já conseguiria forçar. Ou eu posso aproveitar que o getStaticProps recebe alguns generics do JavaScript, que são como se fossem parâmetros da tipagem. E falar o seguinte, olha, getStaticProps passa um sinal de menor e maior. E aí o primeiro generic que a gente pode passar aqui dentro, é qual que é o retorno que a gente vai ter de dentro do método getStaticProps. Qual é o tipo das props que a gente vai passar. Só que eu não vou querer tipar isso, não é uma necessidade. Então, eu vou colocar aqui como simplesmente N. E o segundo é qual vai ser o formato desse objeto de parms. Então, a gente pode ver que eu passei um objeto vazio aqui, ele já fala que parms é um objeto vazio. Se eu passo aqui id é uma string, o parms agora já vira id string. E aí ele já entende que o productId aqui é uma string, porque eu estou pegando o id e o id aqui é uma string. Se eu trocasse aqui para number, ele já ia falar que o productId é number. Então, existem várias formas de resolver. Você pode resolver da maneira que achar melhor. E agora que a gente já tem os dados do produto, a gente vai fazer mais ou menos o que a gente fez na home. Então, eu posso até copiar mais ou menos o código que eu tenho aqui dentro do nosso map. E eu vou colocar aqui dentro. A única diferença é, preciso importar esse stripe aqui, addImportFromStripe. E esse retorno, esse objeto aqui, ele vai direto aqui nas props. Porém, eu vou criar aqui dentro um product e aí sim vou colocar esse retorno aqui dentro. E aqui agora a gente tem o id, tem o nome, tem a imagem que vai ser importante para a gente, o preço. Só que está faltando também a descrição que a gente precisa do produto, que lá na home não tinha. Então, vou botar aqui o product.description. E mais para frente a gente vai até precisar mais uma informação, mas por enquanto está ótimo assim. E agora, para a gente pegar os dados desse produto, como eu já falei, a gente pega através das props do componente. Então, a gente vai criar aqui uma interface, productProps. Eu vou falar que ele recebe um produto. E como ele é muito parecido com as informações que tem aqui na home, eu vou copiar mais ou menos esse objeto de tipagem. Vou colocar aqui dentro. A única coisa que tem a mais é uma description, que é uma string. Já aproveitando, percebi aqui que antes a gente estava enviando o preço como número, mas agora está como string. Então, aqui eu preciso voltar para string. Aqui também vai ser string, porque a gente está formatando esse preço aqui. E daí no final ele é convertido para uma string. Aqui nas props agora eu vou botar productProps. E aqui eu vou colocar simplesmente product. E aí posso mostrar os dados desse produto aqui em tela. Então, aqui no lugar do título eu vou botar product.name. No lugar do preço posso colocar product.price. No lugar da descrição podemos colocar product.description. E aí a gente tem a imagem também, que a gente pode colocar aqui dentro. Então eu vou pegar o image, que vem do NextFutureImage. Vamos colocar product.image.url. E aqui a gente vai colocar uma largura de 520, uma altura de 480 e um texto alternativo em branco. E é isso. Esse useHalter a gente não está utilizando. Podemos voltar aqui. E agora a gente vai salvar. E quando a gente volta para a nossa página de produto e eu dou um F5. Deu erro. E é normal, esse erro já era esperado. E vamos dar uma olhada aqui no erro. GetStaticPath. A gente não viu o que é isso ainda. Está falando que isso é obrigatório para DynamicSSDPages. E está faltando dentro da nossa página PrivateID. Então o que esse erro está falando? Ele está falando basicamente que a nossa página, essa product barra cochetes ID. E quando eu tenho cochetes ID, quer dizer que eu tenho um parâmetro, o ID do produto. Ou seja, isso aqui é uma página dinâmica. Ela muda de acordo com o parâmetro que ela recebe. Isso quer dizer uma página dinâmica aqui dentro do Next. E aí ele está falando, olha, para páginas que são StaticSiteGenerated, que são geradas de forma estática e são dinâmicas, ou seja, recebem parâmetros. A gente precisa, obrigatoriamente, um método retornado de dentro delas chamado GetStaticPath. Mas o que é esse método? Bom, a gente vai falar sobre esse método aí na próxima aula."
  },
  {
    "id": "0884ad4a-6e8f-49e2-a33e-b100ba03a0bd",
    "title": "Buscando produtos do Stripe",
    "transcription": "O que a gente vai fazer nessa aula é buscar os produtos do Stripe. Uma das coisas importantes do que a gente vem falando é que é importante que você entenda que quando a gente usa o método getServerSideProps e que a gente não faz a chamada usando o useEffect, isso aqui está rodando dentro de um server side em node, de um back-end em node, que é isso aqui. Ou seja, todo código que roda aqui dentro, ele não é disponível, ele não é visível para o usuário final. Então, um dos benefícios também de a gente utilizar o getServerSideProps e um dos casos de uso de a gente utilizar essa função e rodar algum código no server side é quando a gente precisa fazer alguma chamada API, por exemplo, que ela precisa estar escondida do usuário final, ela não pode estar visível. E o caso que a gente vai estar rodando aqui é um deles. Por quê? Aqui no Stripe, a gente tem duas chaves de API, a pública e a secreta. A pública, apesar de ela ser pública, ela não ser, digamos, uma chave que você precisa se preocupar em estar disponível para algum usuário, porque ela não dá acesso a nada, é uma chave que também não permite a gente buscar informações aqui dentro do Stripe. Então, ela é uma chave que é usada somente para criar checkout, depois a gente vai usar ela, mas ela é usada para casos muito específicos. Enquanto a chave secreta, sim, é a que dá acesso a gente listar produtos, por exemplo, acesso a todas as funcionalidades aqui do Stripe. Então, como a gente vai ter que usar a chave secreta para buscar a lista de produtos, porque é ela que dá acesso à lista de produtos, o getServerSideProps é o melhor lugar para a gente colocar isso, porque o código que a gente colocar aqui dentro não vai estar visível para o usuário final, então ele vai estar executando em uma camada que o usuário não tem acesso. Assim, aqui dentro a gente pode colocar código sensível, código de autenticação, código de banco de dados, tudo isso pode ir aqui dentro do getServerSideProps, sem problemas nenhum, porque o usuário não tem acesso. Então, bora lá, o que a gente vai fazer? Eu vou começar instalando uma biblioteca chamada Stripe, que é a SDK JavaScript do Stripe. Crio uma pasta lib, opa, escrevi errado, lib, aqui dentro, stripe.ts, import stripe from stripe, const stripe, vou exportar já daqui de dentro, export, é igual a new stripe, o primeiro parâmetro é a nossa API key, ela vai vir aqui do env.local, então o nome dela é stripe-secret-key, a gente precisa fazer aqui um practices.env.stripe-secret-key, e aqui como segundo parâmetro eu preciso passar API version, eu passo aqui 2022-08-01, se pra ti aqui tiver aparecendo outra versão, não tem problema nenhum, provavelmente eles devem liberar uma versão por mês, então talvez o número aqui, a data não fique exatamente igual a minha, mas pega qual está sugerindo aqui, e aqui a gente vai passar também, app-info name ignite-shop, eu passo esse app-info porque assim todas as chamadas que a gente fizer no Stripe, elas vão ficar um log lá dentro do nosso dashboard do Stripe, e lá vai aparecer o nome da aplicação que fez a requisição, ignite-shop. Com isso agora a gente volta aqui no get-server-set-props, e eu vou fazer o seguinte, const response é igual a wait, stripe.products.list, e o bom de usar uma SDK é que ele traz todo o autocomplete, então stripe. olha só, ele traz tudo o que a gente pode buscá-la de dentro, eu digito products, ele traz todos os métodos que eu posso fazer com produtos, então está aqui, list, e aqui para a gente visualizar eu posso dar um console.log, response.data, e quando a gente usa get-server-set-props, uma boa também, é a gente botar aqui um dois pontos, fazer uma tipagem nessa função, e dois pontos, get, com G maiúsculo, server-side-props, que vem aqui de dentro do next, dá um enter, ele já importa de dentro do próprio next, deixa eu só arrumar as importações aqui, isso aqui também eu vou mover aqui para cima, dessa forma, tá bom. E aí, aqui embaixo, como eu dei o console.log, meu VS Code deu uma travadinha, a gente aguarda um pouquinho, às vezes o VS Code, ele, não sei, ele infarta um pouquinho, logo ele volta a respirar, ó, voltou. Agora eu vou aqui no meu front-end, vou dar um F5, beleza, a gente pode ver que já trouxe aqui, ó, uma porrada de dados dos produtos que eu tenho cadastrados lá dentro do Stripe. E esse response.data, como eu posso ver, ele é um array, e dentro tem vários objetos, cada um desses objetos aqui é um dos produtos que eu quero mostrar ali na minha ROM. Como eu não vou crer todos os dados, tá, uma boa dica aqui é você fazer uma transformação dos dados, ou seja, o que é uma transformação dos dados, no fim das contas? É você criar uma nova lista de produtos, porém somente com os dados que você quer. Então eu vou pegar aqui, ó, para cada produto, e aqui eu retorno, e aí eu crio um novo objeto somente com os dados que eu quero. Então, por exemplo, aí eu vou crer o id do produto, eu vou crer o nome do produto, eu vou crer a imagem do produto, vou chamar de imageURL, isso aqui eu sei que está dentro de product.images, e o produto pode ter várias imagens, tá? Aqui, ó, como a gente pode ver que a gente só colocou uma, só tem um endereço dentro do array de imagens, então eu pego só o primeiro aqui, ó. Quero a URL do produto, product.url, que é esse carinha aqui, ó, que na verdade eu nem preciso disso aqui, né? Sei lá, nem preciso disso aqui não. E eu quero o preço do produto. Ele não vem diretamente aqui quando eu faço a listagem. Mas o Stripe, até se a gente for na documentação, Stripe, API Reference, o Stripe tem um conceito que ele chama de Expanding Responses, que é basicamente eu expandir um relacionamento dentro de uma resposta. Então, por exemplo, quando eu venho aqui na listagem de produtos, que foi o que eu fiz, que é produtos, e eu venho aqui em List All Products, a gente vai ver que aqui, ó, deixa eu ver se está aqui dentro, Retrieve the Product Object, onde é que era mesmo que estava esse negócio? Expand... Ah, será que não está aqui dentro? Aqui! Achei! A gente pode ver aqui, ó, que quando eu pego um produto, né, está vendo que tem essa tagzinha Expandable aqui, ó, do lado de Default Price. Esse Default Price, ele retorna o relacionamento, o preço na verdade, ele é um relacionamento com o produto, tá? Então, ele retorna o relacionamento, o ID na verdade do relacionamento, do preço com o produto. Porém, eu posso fazer um Expand nisso aqui, e aí ele retorna o objeto inteiro do preço, e não só o ID. Então, isso vale para vários relacionamentos aqui dentro do Stripe, tá? E aí, como é que eu faço com isso? Aqui no List, eu passo um objeto de configuração, e aqui eu tenho uma opção chamada Expand, tá? E aí, um ponto, como eu estou retornando uma lista de produtos, eu preciso fazer Data.DefaultPrice, porque aqui, ó, ele vem, quando é uma lista, ele vem dentro de Data. Quando não é uma lista, eu posso fazer direto, quando é um único produto, se eu fizesse um Retrieve aqui, né, para pegar um único produto, eu poderia expandir diretamente o Default Price, mas quando é uma lista, sempre Data antes. E aí sim, com o Default Price, agora eu consigo acessar as propriedades do preço. E aí o preço, para eu pegar essas informações dele, ele vai estar dentro de Product.DefaultPrice, e aí dentro, eu vou ter o Price, tá? Porém, novamente, se eu passo o mouse aqui em DefaultPrice, olha só, ele fala que o DefaultPrice, ele é o ID do preço, como eu falei antes. Por quê? Porque ele não entende que eu fiz um Expand aqui no DefaultPrice, então ele não entende que isso aqui é o objeto que contém todos os dados do preço, ele acha que isso aqui é só um ID. Inclusive, ele está aqui, ó, ele acha que isso aqui pode ser um ID ou um objeto com o preço. E aí, quando eu vou utilizar isso aqui, ele acaba não me dando o autocomplete aqui, porque ele entende que isso aqui pode ser um ID, pode ser só uma String, e não o objeto todo. Então, uma das coisas que eu faço nesses casos, é fazer o seguinte, eu dou um Const Price, Product.DefaultPrice, ou melhor, Response, não, na verdade, isso aqui tem que estar dentro, aqui, Price, Product.DefaultPrice, e aqui eu dou um Ask, e aí eu importo o Stripe aqui dentro, .Price, que é a tipagem que a gente tinha lá antes. Aqui, ó, lembra que eu passo o mouse por cima do DefaultPrice, ele pode ser String ou Stripe.Price, e aqui meio que eu estou forçando, isso aqui é um Stripe.Price, porque eu fiz um Expand, então com certeza vai vir o preço e não só o ID. Então, Price.UnitAmount, isso aqui vai vir o preço, isso aqui vai vir em centavos. Isso aqui é até uma dica boa, sempre que você for salvar preços, lidar com preços, é sempre bom salvar em centavos, porque daí não tem problema com vírgula, com problema de float que a gente tem nas linguagens, então você pode sempre, na hora de salvar no banco de dados, o Stripe faz isso, quando você trabalhar com o preço, divide ele por 100, é sempre algo que a gente costuma fazer nas aplicações. E agora eu vou retornar essa lista de produtos aqui, nas nossas props, tá vendo? E aí agora eu vou pegar aqui das minhas props, eu posso pegar a minha lista de produtos, como eu estou usando TypeScript, é legal eu criar aqui uma tipagem, então eu vou falar que ele recebe Products, tem um ID que é uma String, que mais? Um nome, ImageURL, um nome, ImageURL, e também o Price, que aqui no caso é um número. Isso aqui é um Array de produtos, então bota um coxetinho aqui no final, e coloca aqui Home Props, e agora que eu tenho os products, eu posso mostrar aqui dentro do JSON String File, por exemplo, só pra gente ver que está chegando ali, ó, dá um F5, dá todos os dados dos produtos, mas como eu não quero mostrar isso com o JSON String File, eu vou fazer o seguinte, eu vou deletar todos os produtos que eu tenho aqui, pegar e deixar só o primeiro, e aí aqui dentro eu vou fazer um Map, então Products.Map, pra cada produto, eu vou retornar isso aqui, vou colocar uma Key, que é obrigatório, né? Quando a gente trabalha com Maps dentro do React, vou usar o ID, a imagem aqui não vou colocar ainda, vou colocar aqui no nome do produto, coloco Product.Name, e aqui Product.Price, e é isso, só falta a imagem, né? Se eu salvo isso aqui agora, vejo aqui, dando um F5 aqui na página, tá aqui, ó, Camiseta Maratona Explorer 2, ó, o preço, R$74,90, R$69,90, R$89,90, R$79,90, ou seja, a gente tá carregando todos, né? Só não tá vindo as imagens ainda, se eu vir aqui simplesmente no Source da imagem, e colocar Product.ImageURL, vai dar erro, tá? Por quê? Porque por padrão, o Next, ele não faz aquele processo de otimização de imagens, que eu te falei, né, de converter a imagem pra um formato mais leve e tudo mais, pra qualquer endereço, pra qualquer imagem, a gente tem que especificar quais domínios a gente quer que isso aconteça. Então, o que a gente vai fazer? Até eu posso vir aqui na própria documentação, a gente precisa, aqui no Next Config, aqui dentro, a gente vai criar uma opção chamada Images, dentro a gente vai colocar Domains, e dentro a gente coloca os domínios. No nosso caso, o domínio é esse aqui, Files.stripe.com. Perfeito? Salvamos isso aqui agora, a gente reseta o servidor, reinicia, F5, e... Pimba! Tá ali, todas as nossas imagens carregadas, e você pode ver que demorou um tempinho, né, pra ele criar essa versão das imagens, tá? Mas agora, se eu dou F5 de novo, elas já estão criadas, elas ficam salvas em cache, tá? Inclusive, caso você perceba que isso é algo que tá te atrapalhando, né, tá demorando muito pra gerar essa versão da imagem, que duvido muito que aconteça no seu caso, mas dentro do componente do NextFutureImage, a gente tem uma propriedade que a gente consegue passar pra ele, deixa eu ver aqui, eu acho que não vai estar aqui especificamente, aqui ó, a gente tem uma propriedade chamada Loader, e esse Loader é basicamente um... a gente pode retornar... não, não é isso aqui não, não é o Loader não, é... Placeholder. A gente pode criar uma... uma imagem, digamos, de prévia, enquanto ele tá gerando, enquanto ele tá carregando ali aquela imagem, tá? E, inclusive, posso recomendar pra você uma das coisas muito legais, é que existe esse conceito de Blur, né, eu não sei se você já ouviu falar, mas tem uma biblioteca chamada BlurToHash, ou HashToBlur, não, BlurToHash, não é? BlurHash, deixa eu ver se eu consigo encontrar essa aqui, BlurHash? Deve ser, talvez. Mas ela gera... uma versão desfocada da imagem pra um carregamento mais rápido, enquanto a imagem não carregou, e aí quando ela carrega, mostra a imagem completa. Isso aqui é bem legal, tá? E ensina até aqui dentro da própria documentação do Next como que tu pode montar, tem aqui um exemplo, né, vou dar um Ctrl Shift F5, tá vendo? Que ele mostra uma imagem em Blur, e quando carrega ele mostra a imagem original. Isso é bem legal, eu não vou entrar muito a fundo nisso, mas é um conceito bem legal que você pode estar utilizando aí nas suas aplicações, dá um efeito bem legal pros seus apps."
  },
  {
    "id": "00859de6-3014-4e4a-84a2-341a6d7108b2",
    "title": "Botão de comprar",
    "transcription": "O que a gente precisa fazer aqui agora é obter esse Price ID aqui de forma dinâmica. Na verdade, isso aqui precisa ser um parâmetro enviado quando o usuário clica lá no botão Comprar. Então, vamos fazer isso. Aqui na nossa página do produto, a gente vai melhorar um pouquinho essa função do HandleByProduct. Primeiro eu vou transformar ela numa função assíncrona. E o que a gente vai fazer aqui? Eu vou começar usando um TryCatch, que é o aconselhável quando a gente vai lidar com requisições para APIs externas, principalmente para operações que vêm através de ação do usuário. É importante a gente trabalhar com o TryCatch para a gente conseguir mostrar para o usuário se deu algum erro, se está tudo certo. Então, aqui no Catch, eu vou simplesmente retornar algo como falha ao redirecionar ao Checkout. Mas aqui o melhor seria, vou até deixar aqui em comentário, conectar isso aqui com alguma ferramenta de observabilidade, um Datadog, um Sentry, para a gente conseguir obter essas informações do erro que possa ter acontecido aqui. Mas aqui dentro do Try, o que eu vou fazer é o seguinte. Eu vou começar instalando aqui uma biblioteca dentro do nosso projeto, que é o Axios. Por quê? Porque eu vou comunicar essa camada, o cliente, o componente do nosso projeto, do nosso app, com essa rota API aqui do Next, da mesma forma que eu conecto com qualquer outra API Node, utilizando um Axios da vida. Então, instalando aqui o Axios, o que a gente vai fazer aqui agora? Eu vou simplesmente fazer const response igual await Axios. Aqui eu posso importar o Axios e dar um POST diretamente. Como eu quero criar uma Checkout Session, o melhor método aqui é o POST. E agora, você pode ver que eu não criei aqui, como a gente já tinha criado para o Axios anteriormente, dentro de Lib, um arquivo API, que seta base URL, ou qualquer coisa assim. Por quê? Como a API aqui está rodando no mesmo endereço que o nosso front-end, ou seja, tanto a API quanto o front-end estão rodando em localhost 3000, basta eu colocar aqui o path, o caminho da rota ali do Next, por exemplo, barra API, barra Checkout, só tirando o localhost 3000, a parte do domínio, que ele vai conseguir se comunicar, porque ele usa da mesma base de endereço, a mesma base da URL do front-end. E aqui eu passo os parâmetros que eu quero enviar. Então, eu envio aqui, por exemplo, o PriceID, que vem de Product.DefaultPriceID. E aqui, agora, a resposta, como eu posso ver, ele devolve para a gente uma resposta chamada CheckoutUrl. Então, eu vou pegar essa CheckoutUrl de dentro de Response.Data e vou redirecionar o usuário para ela. Para a gente redirecionar o usuário aqui, por dentro de uma função, existe duas formas. Se for para uma rota externa, como é o nosso caso aqui, a gente está redirecionando ele para o Stripe. O Stripe não é a aplicação nossa, é uma rota externa. Eu uso o window.location.path, assim como a gente faz no JavaScript tradicional. E aqui eu uso o nosso CheckoutUrl. Se eu for redirecionar o usuário para uma rota interna, ou seja, a partir que ele clicou no handleByProduct, imagina que eu queira enviar ele para o Checkout, mas o Checkout é uma página interna aqui da nossa aplicação, do nosso próprio app. Aí eu faço o seguinte, eu pego, dou um useRouter do next, salvo isso, por exemplo, numa variável router, e aí eu dou um router.push e aí eu envio o usuário, por exemplo, para a rota Checkout. No nosso caso, não é, o nosso caso é uma aplicação externa, então eu uso esse modelo aqui de baixo. Então, tiramos aqui o router, tiramos aqui também a importação do router. E agora a gente vai testar isso aqui. Vamos salvar. Vamos ver, o servidor está rodando. Show. Localhost 3000. A gente clica aqui em qualquer produto. Deixa eu ver se está conectado no Wi-Fi correto. Está conectado no Wi-Fi errado. Por isso que está devagar. Vamos conectar aqui. Show. E agora, clicando em comprar agora, ele vai demorar um pouquinho, mas ele redireciona a gente para o Stripe tudo certinho. Como ele demora um pouquinho, como a gente pode ver, eu clico e demora aqui pelo menos um segundo, dois segundos. Uma ideia legal é você criar um estado, por exemplo, isCreatingCheckoutSession. Salva um booleano aqui dentro. Importa aqui o useState. E aí, aqui no começo de tudo, coloca isso aqui como true. E aqui, cria um finally. Ou melhor, nem precisa do finally. Só no catch aqui, a gente seta isso como falso. E aí você vai me perguntar. Tá, Diego, pera aí. Pera, pera, pera, pera. Já mete um João Kleber. Olha só, se der tudo certo, ou seja, se conseguiu criar a checkout session, eu não vou transformar isso aqui de volta para falso? Ou seja, o meu botão vai ficar mostrando um loading eterno? Não, né? A gente vai redirecionar o usuário para outra página. Por isso eu não preciso tirar esse createCheckoutSession, não preciso botar ele de volta para falso se deu tudo certo. Porque, na verdade, a gente vai redirecionar o usuário para outra tela. Ele nem vai mais ver a nossa aplicação. Beleza? Então, aqui agora, a gente vai pegar esse isCreatingCheckoutSession e aqui no nosso botão a gente vai passar um disabled. Ou seja, eu quero que esse botão seja desabilitado quando essa opção aqui estiver como true. E aí, só para o nosso CSS ficar legalzinho, lá nos styles, dentro de pages e product, aqui no nosso botão, eu vou fazer o seguinte. Se ele estiver disabled, eu vou colocar aqui um opacity 0.6 e um cursor not allowed. E aqui nesse hover, eu vou botar o hover somente se ele não estiver disabled. Show, né? Agora eu vou salvar isso e beleza. Agora a gente volta aqui para o nosso checkout. Agora aqui a gente não vai mais usar esse price aqui. Eu até tinha testado, mas esqueci de trocar esse price. Então, ele ia pegar sempre o mesmo produto. Para pegar o produto ali, a gente vai pegar de dentro do nosso Hack.body, que é o corpo da requisição. Vamos pegar o nosso, como é que a gente está enviando o parâmetro? PriceId. Então, aqui a gente também pega PriceId. E aí pronto, já estamos com o nosso PriceId aqui dentro. E aí uma das coisas que eu posso fazer aqui para evitar possíveis erros é o seguinte. Se essa rota aqui for chamada sem o PriceId, é legal a gente retornar um erro. Então, eu dou um res.status400.json e mando uma mensagem de erro aqui, por exemplo, PriceNotFound. E outra coisa que eu poderia fazer aqui, que é legal, é que o Next não faz divergência de método HTTP nessas rotas API. Ou seja, eu posso chamar essa rota aqui com GET, POST, PUT, DELETE, e ela vai funcionar em todos os casos. Então, para evitar que essa rota aqui possa ser chamada por GET, ou seja, o usuário pode acessar ela diretamente aqui pelo navegador, o que eu vou fazer é o seguinte. Se o Hack.method for diferente de POST, ou seja, se isso aqui não tiver sendo chamado com POST, eu vou retornar um erro. 405, né? METHOD NOT ALLOWED. Isso, 405. E aqui, só retorno um METHOD NOT ALLOWED. Nem precisaria de mensagem, na verdade, porque o próprio 405 já é autodescritivo, mas tá show de bola. É isso. A gente já fez tudo aqui, já deu tudo certo. Nossa rota de checkout está criada. Aqui está tudo certo. Vamos só testar o botão se está funcional. Então, vamos lá, vamos pegar uma camiseta aqui. Essa aqui, Ignite Abort. Quando eu clicar aqui, o botão tem que ficar com opacidade baixa, e lá no checkout tem que aparecer essa camisa aqui. Então, vamos lá. Já deu certo aqui. E aqui, beleza, já apareceu Ignite Abort, inclusive com o preço dessa camiseta."
  },
  {
    "id": "de4022bc-8ae9-4724-9261-5223e1d1d94f",
    "title": "Rota de agendamento",
    "transcription": "Nessa aula, a gente vai começar criando aqui a nossa rota dentro da API do Next para marcar um novo agendamento para um usuário específico. Com isso, eu também posso criar essa rota dentro aqui da pasta que recebe o parâmetro username, porque ela é uma rota que é totalmente dependente da informação do usuário. Eu sempre vou estar marcando um agendamento com algum usuário, então depende dessa informação, então eu posso criar, por exemplo, uma rota schedule. Eu vou copiar uma outra rota qualquer, como por exemplo, essa availability aqui, porque vão ter algumas informações que vão ser semelhantes, porém eu vou remover toda a parte aqui até a verificação se o usuário existe. Aqui dentro posso tirar, por enquanto, o DateAS, e aqui o retorno do JSON também vou deixar um objeto vazio. E aí aqui dentro, a primeira coisa que a gente vai mudar é que essa rota, obrigatoriamente, eu preciso que ela seja uma rota do tipo post, porque eu vou estar criando um usuário. Outra coisa que eu vou mudar, criando um agendamento, desculpa, outra coisa que eu vou mudar é que eu não vou pegar nada aqui do Hack.query, e sim de dentro do Hack.body, que é os dados do nosso formulário. Então lá do formulário eu vou ter o nome, o email, as observações, e eu também vou ter uma informação que não está no formulário, mas que eu preciso dela, que é a data do agendamento, que é aquela schedulingDate lá que a gente passou para dentro do formulário de confirmação. Esse date aqui vai ser utilizado, então. E aqui eu posso remover o date aqui de dentro. E aí uma das coisas que eu gosto muito de fazer quando eu estou aqui no back-end e eu vou receber mais dados, por exemplo, dentro do Hack.body, é usar o Zod para fazer o mínimo de parse nesses dados. Então eu gosto, por exemplo, ao invés de fazer já direto aqui Hack.body, eu gosto de criar aqui, pode ser aqui dentro mesmo, não tem tanta necessidade de fazer aqui fora, mais const, aqui a gente pode chamar de createSchedulingBody, esquema, ou só body, tanto faz, o esquema não precisa, z.object. E eu falo aqui que a gente vai ter o nome, z.string. Lembrando que aqui não é muito para validação, porque a validação a gente já fez lá no front-end, então aqui é mais uma dupla verificação e um parse, de certa forma. Então aqui, no date, a gente vai receber ele como uma string, e o Zod, em sua última versão, ele tem um novo z.string.dateTime, que ele faz automaticamente a conversão de strings que vêm num formato de data, por exemplo, 2022, 12, 21, t, 18, 00, 00, ele faz a conversão, basicamente, desses formatos de data, e aí pode ser is, o string, o tc, ele consegue converter automaticamente para a gente no objeto date, javascript. Então até quando eu fazer, por exemplo, aqui embaixo, ao invés de chamar o hack.body, fazer o createSchedulingBody.parse, mandando o hack.body, a gente vai ver que o date, passando o mouse aqui por cima, ele mostra como uma string, só que eu acho que a gente consegue converter ele para date aqui, de alguma forma, aqui ele faz o parse, ponto, deixa eu lembrar aqui certinho, tá? Zod, releases, deixa eu ver aqui a última versão que o Zod foi lançado, essa aqui, dateTime aqui, parse, offset, precision, beleza, eu acho que ele faz, ele não converte, só, a new method has been added to validate, tá, ele faz a validação, só que ele não converte, eu acho que a gente pode usar aqui um outro método também, que é esse curse, não sei exatamente como é que se pronuncia, mas, string email, tá, bom, eu acho que a gente pode usar aqui também um próprio, é que a gente vai ter que lidar com o date.js, então não necessariamente eu acho que faz sentido a gente converter aqui, eu acho que só a validação já tá bom pra gente, é, tá tranquilo, por enquanto. Beleza, então aqui eu tenho o nome e tal, eu acho que isso aqui eu posso mover até para baixo dessa parte de checagem se o usuário existe, porque se é só depois eu vou lidar com esses campos, e aqui o Zod já vai fazer essa verificação pra gente, e agora, o que a gente vai fazer, né, eu vou começar então a criar uma variável chamada schedulingDate, e aqui eu vou usar o date.js, tá, por volta desse nosso objeto date, até por isso que eu não me preocupei em ele e o Zod não fazer a transformação, aqui seria fácil, né, eu poderia fazer simplesmente um transform e passar o objeto date aqui dentro, ó, ele já ia converter. O que que eu tô errando aqui? Tá, não vou me preocupar com isso agora. Mas, é, o que que a gente vai fazer aqui basicamente é pegar o nosso date.js, e eu vou pegar a nossa data usando o construtor do date.js, e a primeira coisa que eu vou fazer é dar um startOfHour, eu vou novamente forçar pelo lado do back-end, eu não vou depender que o front-end envie a informação nesse formato, mas eu vou forçar no back-end que toda hora ela nunca esteja quebrada, ela sempre esteja no começo da hora, porque é mais fácil eu validar se já existe um outro horário salvo no banco de dados, um outro agendamento naquele mesmo horário. E aí a primeira coisa, a gente tem que fazer algumas verificações, mesmo que a gente já tenha feito anteriormente, tá, a primeira coisa, verificar se a data já não passou, tá. Isso é a primeira coisa e a gente vai ter que fazer essas verificações. Não é porque a gente já validou uma vez anteriormente que a gente não tem que validar de novo, tá. Então, aqui, dateIsInThePast, por exemplo. A gente vai fazer mensagens mais simples aqui, porque o foco agora não é a tratativa de erros em si, não é o nome da tratativa de erros, mas você pode customizar e colocar mensagens aqui, vai ser muito difícil a pessoa chegar nessa mensagem de erro, né, só se ela abriu a tela, clicou ali e aí esperou o tempo passar e aí depois tentou fazer o scheduling, né, daí já passou, mas é difícil. E outra coisa, a gente vai ver se já não tem algum outro scheduling marcado no mesmo horário. Então, a gente vai fazer um PrismaScheduling.findFirst, né, pra ver se encontra pelo menos um, onde o UserId seja User.id e o Date seja o meu SchedulingDate.toDate. Beleza. E aqui, o que a gente vai fazer também, tá. Então, nós vamos, se eu encontrar, vou copiar até o if aqui de cima, né, se eu encontrar um conflicting scheduling, a gente retorna também uma mensagem, por exemplo, there is another scheduling at the same time, alguma coisa assim. E aí, se deu tudo certo, a gente pode inserir o scheduling, então prisma.scheduling.createData e aqui a gente vai preencher os campos. Então, o Date, eu vou mandar o nosso SchedulingDate.toDate pra converter no objeto JavaScript, que é o que o Prisma aceita. Nome, email, observações e o UserId, que a gente vai mandar como User.id. E no final, como é uma criação, eu mando o status 201 e ponto end, porque eu não preciso retornar qualquer tipo de retorno de criações, né. Salvo, tá feito aqui o nosso Scheduling, nossa rota de Schedule. E agora a gente precisa chamar essa rota lá dentro do nosso Confirm Step. Então, aqui dentro do Submit, a gente vai transformar isso aqui em uma função assíncrona e nós vamos fazer um await api.post barra users, barra, aqui eu preciso colocar o ID do usuário, que vem de dentro, o username do usuário, que vem de dentro lá dos parâmetros da rota, então aqui a gente vai chamar o next, o halter const username é igual a string halter.query.username, vamos pegar esse username aqui dentro, barra schedule, que é a nossa rota de agendamento, e vamos enviar como parâmetros os dados que vêm aqui de dentro de data, então eu vou desestruturar eles pra ficar mais descritivo quais são os dados que vêm dali, que é nome, email e observações, e eu vou mandar tudo aqui, então nome, email, observações, e a nossa data que tá aqui em cima como um parâmetro que a gente recebe o nosso SchedulingDate. E aí, eu acho que se eu mandar aqui ele já vai fazer um toString e vai converter isso aqui pra um formato ideal pra enviar aqui dentro, mas se ele não converter, depois a gente mexe. E show de bola, vamos testar agora se tá funcionando. Apenas a única coisa que eu vou fazer aqui no final é depois que ele cadastrar o Scheduling, eu vou redirecionar ele de volta lá pro calendário daquele usuário, então apenas barra username, que vai cair lá na primeira página lá do calendário. Vamos lá, barra schedule, barra username. Bora lá, a gente vai selecionar o dia 21, vou pegar aqui um horário disponível, 14 horas por exemplo, DiegoTeste, teste, arroba, teste.com, botar qualquer observação, vou dar um confirmar. Eu acho que talvez tenha dado certo, só que como eu tô na mesma rota, ele não mostrou. Vamos dar uma olhada no Prisma Studio, se ele criou, ó lá, criou, DiegoTeste, teste, arroba, teste. Vamos ver a data, 17, tem que botar sempre menos 3, porque tá em UTC, então UTC menos 3, que eu tô no Brasil no caso, então fica 17 menos 3, 14 horas, que foi o horário que a gente selecionou. A única coisa é que ele não redirecionou, digamos, de volta, porque eu já tô nessa própria rota. Então, ao invés de redirecionar, o que eu vou fazer aqui é apenas chamar aquela onCancelConfirmation, e aí talvez teria que trocar o nome desse método depois, porque agora não é que eu tô cancelando, é porque já deu tudo certo. Então aqui eu vou criar um outro, vamos lá, dia 21, veja que o horário das 14 já não fica mais disponível agora, horário das 16, botar qualquer coisa aqui, e agora quando eu der um confirmar, ele tem que me redirecionar de volta lá pro calendário, show, e o horário das 16 não tá mais disponível, e ele já foi cadastrado aqui dentro do Prisma Studio. Então, a gente finalizou a parte do cadastro, do novo scheduling, porém a gente ainda não tá integrando com o calendário do usuário pra criar esse evento lá na agenda dele, então bora fazer isso."
  },
  {
    "id": "1dc1fc74-a089-4a9a-8fdf-4b2023663e0b",
    "title": "Criação do evento no Google",
    "transcription": "Bora então para a nossa última aula nesse processo de se comunicar com a API do Google aqui dentro de Pages, API, ou melhor, a gente já está com o arquivo aqui em cima, na rota de Schedule. Aqui dentro a gente vai fazer a nossa comunicação com a API do Google. E eu vou fazer essa conexão, essa comunicação com a API do Google logo depois de eu criar o evento, o Scheduling dentro do nosso banco de dados. Para isso, o que a gente vai fazer aqui dentro é basicamente o seguinte. Eu vou começar criando uma constante chamada Calendar, que é igual a Google. Ele vai importar isso de Google APIs.calendar, que é a API de calendário do Google. Aqui a gente precisa passar uma versão que a gente vai estar utilizando, no caso a v3, que é a única possível. E aqui nós precisamos passar o nosso Auth. O nosso Auth é basicamente aquele método que a gente criou, que é o getGoogleAuthToken e passando o nosso user.id. Show de bola! Agora a gente já tem acesso à API de calendário e para isso a gente já pode fazer um await calendar.events.insert para a gente inserir um novo evento aqui dentro da agenda. E agora a gente vai ter várias informações que a gente vai ter que colocar aqui dentro. A primeira delas é o CalendarId. O que acontece? Quando a gente faz a integração com o calendário do Google, o usuário tem duas opções. Ele pode informar para a gente qual calendário ele quer utilizar, então ele poderia criar um calendário personalizado dentro da agenda dele, só para os eventos do Ignite Call, por exemplo. Só que aqui, como a gente não criou esse Select, para o usuário poder selecionar, a gente pode usar a opção Primary. A opção Primary vai pegar qual é o calendário principal, o calendário default de criação de eventos dentro para o usuário. Fora disso, a gente vai enviar um RequestBody aqui dentro. Esse RequestBody precisa ter todas as informações relacionadas ao evento em si. Então, primeiro é o Summary, que vai ser o título do evento. E aqui a gente vai colocar com aspas, até para eu colocar uma interpolação. Eu vou chamar de Ignite Call. Todos os eventos vão começar com Ignite Call para ser mais fácil identificar. E aqui, a gente vai botar o nome do usuário que pediu uma agenda com esse outro usuário. Então, nesse formato. A gente vai ter uma Description, que vão ser as nossas observações. Então, se o usuário colocar qualquer observação, vai ficar aqui na Description. E nós vamos ter o horário de Start e o horário de Termo. O horário de Start, ele precisa ter aqui dentro dele, o DateTime, pode ter TimeZone também. Só que aqui no DateTime, a gente vai pegar simplesmente o nosso SchedulingDate, que está aqui em cima, nosso objeto SchedulingDate.format. Simplesmente assim, ele já vai formatar no formato ISO. Então, olha só, ele já traz ela no formato ISO 8601, que é aquele formato que tem o TimeStamp, tudo certinho aqui, ó. Menos 5, por exemplo, para o Google conhecer. E o horário de Termo, como ele vai ser sempre uma hora após o horário de início, a gente pode pegar o nosso SchedulingDate, AddOneHour.format. Então, a gente adiciona uma hora. A gente sempre precisa informar, no caso do Google, o horário de início e término. A gente não informa o horário de início e a duração. Aí, a gente vai colocar aqui, Atendees, que é basicamente quem vai estar convidado para o evento. É claro que o usuário que a gente está criando o evento na agenda dele, ele não precisa ser convidado, ele vai ser automaticamente convidado. Então, aqui a gente bota somente os outros usuários. E aqui eu posso botar, basicamente, o e-mail do usuário, que a gente está recebendo até como parâmetro aqui, no body. E eu posso botar também aqui o DisplayName, que é o nome do usuário que está sendo convidado. E aqui tem várias outras informações, tá? Se mais para frente tu quiser dar uma olhada, né? Então, tem mais algumas outras informações que a gente pode colocar aqui dentro, mas, por enquanto, a gente não vai colocar. E aí aqui, olha que legal, a gente consegue passar um ConferenceData, que é basicamente para ele conseguir criar o evento já com uma chamada do Google Meet. Isso é legal porque já está pronto aí a chamada, é só o usuário utilizar. E aqui a gente vai passar a opção chamada CreateRequest, para que ele crie a chamada no Google Meet no momento que eu criar esse evento na agenda do usuário. Aqui eu vou botar uma RequestID, que precisa ser qualquer coisa, só que ser único, tá? Então, aqui eu vou usar o Random, o UID. Ou melhor, ao invés de usar o Random, o UID, eu vou usar o UID que a gente cria do próprio Scheduling. Então, a gente já tem o UID gerado, né? Então, eu vou botar aqui o Scheduling.id, como o RequestID aqui dentro. E aí, a gente vai passar uma outra carinha aqui, chamada ConferenceSolutionKey, que precisa ser esse formato aqui, tá? Até se você quiser procurar no Google, aqui ó, ConferenceSolutionKey na Calendar API. Aqui ó, a gente pode botar Hangouts Meet. Aqui ó, ela tem algumas opções, tá? A gente pode botar EventHangout, pra quem usava o antigo, Google Hangouts, né? EventNamedHangout pra classe... Cara, assim, vou resumir pra ti. Usa o Hangouts Meet. A Google, ela adora deixar um monte de coisa depreciada, ficar mudando o nome de produto, e aí dá nisso, né? E aí a gente tem que ficar se virando aqui, mas hoje a API recomendada é o Hangouts Meet. E aí tem uma outra coisa que a gente tem que colocar aqui, que é o ConferenceDataVersion, tá? Esse ConferenceDataVersion aqui ó, até vamos ler aqui ó, VersionNumberOfConferenceDataSupportedByTheAPIClient Version 0, assume que eu não vou enviar nenhuma informação de conferência. Version 1, habilita o suporte pra enviar a ConferenceData, as well, né? Pra criar uma nova conferência usando o CreateRequestField, que é o que a gente tá utilizando. Então, por isso que a gente precisa enviar o 1 aqui, pra que isso aqui ó, seja válido. E agora a gente vai testar, olha que legal. Vamos salvar, vamos voltar aqui na nossa aplicação. E agora a gente vai criar um evento lá pra sexta-feira, dia 23, aqui ó, 14 horas. Vou pensar num horário que eu não tenho nada, vou botar aqui, 16 horas. E aqui quem tá criando um evento comigo é o John Doe, johndoe.example.com E... fala Dev... E aí eu vou dar um confirmar e agora... Eu acho que deu certo. E agora a gente vai abrir o Calendar.google aqui. Deixa eu ver se eu tô logado com a minha conta. Vai aparecer um monte de evento aqui. E agora, se a gente for aqui no dia 23... Ai meu Deus, sumiu tudo. Que? Foi pra janeiro já? Não, não, não, não, não, não, não. Volta aqui. Dia 23, olha lá. Ignite Call John Doe, aqui ó. Já na direita, 4 horas, que foi o que eu marquei. E olha lá, já tá o fala Dev lá, e já tá o John Doe convidado. Se tiver alguém com esse e-mail, já foi convidado. E tá lá o link pra conferência já. Então, ele já automaticamente cria isso aqui, tudo pra gente. Cara, massa demais. Finalizamos um processo bem importante aqui na nossa aplicação. E bora continuar porque ainda tem mais algumas coisinhas aí pra gente fazer."
  },
  {
    "id": "7b24b5fe-885d-4ad2-8509-8bc55b8a17f4",
    "title": "Otimizações de SEO",
    "transcription": "Nessa aula, a gente vai configurar algo na nossa aplicação que não deixa de ser importante, que é a parte de SEO, a parte de MetaTags. Principalmente porque a nossa aplicação é uma aplicação que vai ser pública. Qualquer pessoa pode acessar, qualquer pessoa pode criar uma conta, marcar. Então, eu gosto muito de utilizar esse pacote chamado Next SEO, porque ele é um pacote que traz uma integração muito mais fácil para a gente definir defaults, imagens, padrões, títulos, descrições. Então, tem bastante coisa legal que a gente consegue definir. Eu vou começar instalando esse pacote e a primeira coisa que ele pede para a gente, caso eu queira definir um padrão, é a gente colocar esse default SEO dentro do nosso app. Então, eu vou lá dentro do nosso app aqui. Ele tem aqui o nosso container next-app. Acho que isso aqui não é necessário. Mas eu tenho que colocar esse default SEO aqui em algum lugar. Então, a gente vai basicamente colocar esse componente aqui dentro. Eu vou importar do Next SEO o default SEO. E aqui ele vem com algumas opções, do Open Graph, Twitter e por aí vai. Aqui, por exemplo, posso deixar ptbr, o URL. Colocaria o URL da nossa aplicação. Aqui eu não tenho uma URL, então eu botaria ignite-call.rocketseat.chrome.br. Só um exemplo. E o site name aqui, ignite-call. E aqui o Twitter também, ignite-call. Aqui tem todas as opções que a gente pode configurar. São muitas e muitas e muitas opções. Imagem, tudo que tu pode configurar aqui dentro. Então, eu não vou entrar em todas elas. Até vou tirar aqui o Twitter, vou deixar por exemplo só um exemplo de Open Graph. E o mais importante aqui é a gente customizar por página algumas opções. Então, por exemplo, aqui dentro da home da nossa aplicação, a gente pode colocar, e isso pode ficar em qualquer lugar. Eu particularmente gosto de colocar aqui um fragment por volta de tudo. Para deixar isso separado, digamos, da parte visual da nossa aplicação. E aqui eu jogo um Next SEO, dessa forma mesmo. Importo aqui, e aí boto aqui o título da nossa. Deixa eu dar uma olhadinha até como que eu tinha colocado aqui. Então, aqui eu tinha botado no título, descomplique sua agenda. Ignite call, dessa forma. E aqui eu posso botar uma descrição. Posso aproveitar e copiar a descrição que eu tinha jogado lá na home. Conecte seu calendário e permita que as pessoas marquem agendamentos no seu tempo livre. E aí a gente vai fazer isso aqui também para outros componentes. Então, para a página de cadastro, aqui. Então, para a parte de Register, nós vamos jogar aqui o Next SEO aqui dentro. Joga lá embaixo. Salva para ele arrumar já a identificação. Importa, Next SEO. Crie uma conta. E aqui a gente não necessariamente precisa ter descrição em todas as páginas. E a gente vai seguindo aqui para o restante das páginas. O mais importante aqui nesse caso é o título. Essas páginas aqui de Update Profile, Connect Calendar. Essas coisas aqui. Vamos, por exemplo, para Connect Calendar. A gente vai colocar o Next SEO aqui dentro. Só que aqui vai ter um Q a mais. Porque além de a gente colocar o Next SEO. Colocar aqui, por exemplo, no título. Connect na sua agenda do Google. Aqui a gente também vai botar uma opção chamada No Index. Para o Google não indexar essa página especificamente. Porque lá é uma página acessível somente a partir do fluxo de cadastro. Então, a gente vai copiar isso aqui. Vamos para o Time Intervals aqui. Vamos jogar aqui dentro. Aqui embaixo, fechar o nosso Fragment. Importar o Next SEO. Selecione sua disponibilidade. Também No Index aqui, porque eu não quero que indexe. Update Profile aqui. A gente vai botar também. Atualize seu perfil. E por último, aqui a gente vem na nossa página Schedule. E vamos botar um Fragment aqui por volta de tudo. Importar o Next SEO. Vamos botar aqui Agendar Com. E vamos colocar isso aqui dentro de uma variável. Agendar Com User.Name Vamos salvar isso aqui agora e vamos dar uma olhada. E aqui, Index. Eu não quero No Index não, senão eu estou louco. Pronto, olha só. Agendar Com Diego Fernandes. A gente já tem todo o fluxo. Descomplica sua agenda. A pessoa vem aqui e bota algum usuário. Criar uma conta. Então, todo o fluxo já está com os títulos certinhos. E aqui, claro, o mais correto seria também a gente criar aquelas Open Graph Images. Uma imagem de 1200x630. Caso você queira se aventurar, uma das coisas que daria para fazer bem legal é aqui, por exemplo, nessa página de Schedule, a gente gerar uma Open Graph Image, que é aquela imagem de compartilhamento, de maneira dinâmica, quem sabe até usando o Satori, que é uma biblioteca criada pela própria Verso, para criar especificamente, converter HTML, CSS para SVG ou PNG, para exatamente criar essas imagens. Até tem aqui o Verso Open Graph Image Generation. Então, ele tem aqui uns exemplos de como a gente consegue criar essas imagens aqui de uma maneira dinâmica. E aí, daria para colocar o avatar do usuário, o nome dele. Eu não vou fazer aqui porque iria muito além do escopo dessa aplicação, do que a gente se propôs para desenvolver aqui, mas a parte de SEO, pelo menos, está finalizada."
  },
  {
    "id": "b5be1bfb-34c0-4b65-ac5e-02caa1af174e",
    "title": "Deploy no Planetscale",
    "transcription": "Nessa aula, a gente vai dar start ao nosso processo de deploy da nossa aplicação. E, para isso, a primeira coisa que a gente precisa fazer deploy é do banco de dados. Hoje, a gente está utilizando um banco de dados MySQL. Para isso, eu vou utilizar o serviço do PlanetScale. O PlanetScale nada mais é do que um serviço de banco de dados as-a-service, mas você poderia hospedar esse banco de dados em outros serviços, como o próprio AWS Aurora, tem várias outras opções. O único ponto que a gente tem que cuidar aqui é que, como o deploy da nossa aplicação, do código da aplicação, vai ser feito dentro da Versal, a gente precisa entender que a Versal funciona com o modelo de computação serverless, que é um modelo de computação onde a nossa aplicação vai ser executada em containers isolados conforme os usuários forem acessando. A nossa aplicação nunca fica rodando 24 horas por dia, digamos assim, num servidor que está ali direto ligado. Ela vai ligando e desligando o servidor conforme as pessoas vão acessando. Ou seja, existem bancos de dados específicos para trabalhar em contextos de aplicação como essa, porque são aplicações que têm um custo maior para o banco de dados em questão de conexões. Porque, imagina, cada vez que alguém chama a nossa aplicação, qualquer rota, a nossa aplicação precisa criar uma nova conexão com o banco de dados. Então, a gente tem várias problemáticas nisso, connection pooling, eu não vou entrar em todos os pontos aqui, mas o ponto é que você precisa saber que hoje existem bancos de dados especializados em ambientes serverless, e é algo que está crescendo muito, como o PlanetScale. Nós temos o Neon.tech, que está quase saindo também, que é um PlanetScale, porém para Postgres, digamos assim. Nós temos a FaunaDB, nós temos a SupaBase, nós temos a AWS Aurora Serverless também, que é da própria Amazon. Então, a gente tem vários bancos de dados hoje que são especializados nesses ambientes serverless. E, por isso, quando você for hospedar a sua aplicação na Vercel e ela for uma aplicação FuseTech nesse modelo que a gente tem o back-end próximo ao código front-end, sempre lembre de utilizar algum desses bancos de dados e não um banco tradicional hospedado num RDS da vida da Amazon que não tenha qualquer tratativa para lidar com esse número de conexões. E aí, aqui dentro do PlanetScale, a gente vai logar na nossa conta. Aqui eu tenho algumas outras coisas. E aqui eu tenho um... O certo seria a gente criar do zero. Eu vou nesse Rocketseat Examples Serverless aqui, que é uma outra organização. Você pode criar a sua própria organização. E aqui eu estava testando, então eu vou apagar esse banco daqui para a gente começar do zero juntos. Então, eu vou apagar aqui esse banco. Show de bola. E agora, basicamente, você vai, depois que criar a sua conta, não precisa colocar cartão de crédito nem nada. O PlanetScale tem um plano gratuito bem legal. Você vai criar aqui embaixo, clicar em Create, para criar a sua base de dados. Aqui a gente dá um nome para ela. Eu vou chamar de IgniteCall. Aqui a gente pode selecionar a localização. Como a Vercel vai hospedar o nosso código na US East, provavelmente a gente pode deixar o banco de dados mais próximo também, então US East também. Pronto. Aqui o banco já vai estar sendo criado. Vamos aguardar um pouquinho. Show. Banco criado. Uma das primeiras coisas que a gente precisa entender é que o PlanetScale funciona com um mecanismo bem interessante de branches. Assim como o GitHub, a gente tem branches no nosso código. Então, imagina que várias pessoas podem trabalhar em versões diferentes do nosso código dentro do GitHub e depois elas sincronizam essas diferentes versões numa branch principal, que lá no GitHub é a main ou a master, por exemplo. O PlanetScale tem esse mesmo funcionamento, só que para bancos de dados. A gente pode ter várias versões do nosso banco de dados diferentes rodando simultaneamente, digamos assim. Geralmente, ela é usada não para desenvolvimento, mas usada, por exemplo, para ambientes de staging, ambientes de preview, alguma coisa parecida. E a gente pode depois, em algum momento que a gente entende que alguma dessas branches está apta para ir para a produção, a gente faz uma, eles chamam aqui de deploy request, mas seria como se fosse a pull request lá dentro do nosso GitHub. E aí ele faz essa integração direta de todos os campos que foram criados, as tabelas que foram criadas, modificadas, direto com produção. Então, a primeira coisa que eu vou fazer, clicando aqui em branches, a gente vai ver que a gente começa já com a branch main. A branch main é aquela principal. E aí a primeira coisa que eu vou fazer é vir aqui nessa branch main e fazer um promote a branch to production. E a gente vai selecionar a main e dar um promote branch. Isso aqui vai fazer com que a nossa branch main seja a branch de produção, especificamente. E show, a gente não vai mexer em nada aqui. O que eu vou fazer agora é clicar aqui na direita, create new branch, e a gente vai dar um nome para essa branch. Como o plano gratuito só pode ter uma branch, eu vou criar uma branch aqui dentro chamada de migrations, só para a gente visualizar como as branches funcionam. A base branch pode ser a main, para ela herdar as configurações da main, sempre. E aqui a gente pode até trocar a região. Então, se em desenvolvimento e tudo mais, eu quero às vezes usar uma outra região, sem problemas. Vou dar um create branch aqui agora. A gente aguarda aqui um pouquinho. Enquanto ele vai criando a branch, outra coisa que eu vou fazer aqui dentro do projeto IgniteCall, dentro dos settings, é, aqui dentro, clicar nessa opção Automatically Copy Migration Data, e Migration Framework, eu vou selecionar o Prisma. E vou dar um Save Database Settings. Isso aqui vai fazer com que, automaticamente, o PlanetScale olhe para a tabela de Prisma Migrations, que é onde ficam os registros de quais migrations já foram executadas dentro do nosso código, e quais não foram executadas, para ele saber o que ele precisa mudar, o que ele precisa mudar, o que ele não precisa mudar, e por aí vai. Show de bola. Vamos voltar aqui em Branches. Show. Vamos ver se ele já criou a branch Migrations. Já criou. Está tudo certo. E agora, o que a gente vai fazer? A primeira coisa que eu preciso fazer, antes de colocar o meu código em produção, lá na Vercel, eu preciso que o nosso banco de dados esteja atualizado. E hoje, infelizmente, o PlanetScale, que é algo que eles têm vontade de fazer, mas ele ainda não tem uma integração direta, por exemplo, com o GitHub, para que toda vez que eu suba o código, ele rode as migrations sozinho, e ele não tem nem action no GitHub, no GitHub Actions, para a gente conseguir... Ele até tem aqui uma documentação, using PlanetScale com GitHub Actions, só que é muito ruimzinho. É muito código que você tem que colocar para fazer coisas simples. E é algo que eles estão trabalhando nisso, por isso o PlanetScale ainda tem muito a melhorar. Mas aqui, então, a gente vai atualizar o nosso banco de uma maneira mais como os aztecas e incas faziam, que é simplesmente de forma manual. Então, a gente vai jogar essas alterações do banco, as migrations para dentro do banco, de uma maneira mais manual. E aí você pode criar, claro, um fluxo do GitHub Actions conforme você vai avançando com o seu app. Mas aqui na direita, dentro do branch migrations, a gente vai ter um botão Connect. Clicando nesse botão Connect, a gente recebe uma URL de conexão. Eu posso simplesmente copiar ela por completo. Viemos aqui no .env e a gente substitui essa URL de conexão aqui em cima no nosso database URL. Outra coisa que a gente precisa fazer é dentro do schema.prisma, a gente precisa botar esse relationMode prisma aqui dentro de datasourceDB. Então, aqui vamos no nosso prisma, schema, datasourceDB, e a gente vai jogar o relationMode prisma. Isso aqui é basicamente, pode ver que ele já vai ficar com esse símbolo aqui amarelo, e aí a gente pode vir aqui, selecionar, add an index for the relation field, e a gente vai, em cada um deles, adicionando. O que acontece? O PlanetScale não suporta foreign keys, nativas do banco de dados. Então, os relacionamentos, eu quero buscar o usuário dessa conta, é feito por parte do prisma. Então, é o prisma que lida com os relacionamentos. Então, aqui a gente tem duas opções, foreign keys, que é nativo, ou o prisma lidar com esses relacionamentos por baixo dos panos. Como a gente não tem foreign keys dentro do PlanetScale, automaticamente, as colunas, que são relacionamentos dentro do banco de dados, não são criados índices. E aí acaba que o relacionamento, na hora de fazer uma busca por essa coluna, fica mais lento dentro do banco de dados. E por isso que ele pede para a gente criar um índice para cada uma dessas colunas que têm relacionamentos dentro das nossas tabelas. Com isso pronto, a gente já criou. Eu vou rodar, antes de mais nada, eu vou fazer o seguinte. Eu vou voltar, aqui é o URL de conexão do nosso .env para o URL anterior, só para a gente rodar as migrations. npx prisma migrate dev. E aqui eu vou botar add database indexes. Vamos aguardar um pouquinho. Show, perfeito. Ele falou que teve uma atualização no prisma. Não tem problema, eu já li essa atualização, não mudou muita coisa, só diminuiu um pouquinho o tamanho da engine do prisma. Mas agora sim, a gente vai voltar, aqui, a nossa conexão com o banco de dados para o URL lá do PlanetSKU, e a gente vai executar um comando aqui chamado npx prisma db push. O db push nada mais vai fazer do que simplesmente pegar todas as nossas migrations e executar nessa URL de banco de dados que a gente apontou aqui em cima. Diferente do comando migrate, que ele faz muito mais uma comparação. O comando migrate que a gente estava executando ali antes, ele é um comando que faz uma comparação. E aí, se você quiser estudar um pouquinho mais, aqui dentro de prisma planet scale, você pode cair nesse tutorial aqui. Aqui embaixo, ele fala basicamente... Aqui, watch the guide. Não queria pegar no vídeo não. Talvez no site do PlanetSKU. Deixa eu ver certinho. Db push. Aqui, the recommended workflow with using prisma alongside PlanetSKU is to use the prisma db push instead of prisma migrate, como eu estava falando para você. E tem aqui, dentro do site do prisma, tem uma diferenciação entre os dois. O db push, ele não interage ou depende das migrations. A migration table não vai ser atualizada e nenhum arquivo novo de migration vai ser criado. Isso é super importante, porque o PlanetSKU não suporta esse tipo de comparação entre as migrations. Isso precisa ser feito por nós. E aí, quando trabalhando com o PlanetSKU, é recomendado usar o db push instead. E aí, ele tem várias explicações aqui dentro, mas a gente não precisa se preocupar com isso agora. Feito isso, voltando aqui dentro do PlanetSKU, a gente pode ver, clicando aqui em esquema, dentro do nosso branch de migrations, que ele já trouxe todos os SQLs para a gente criar as tabelas aqui no banco de dados. E aí, o que a gente vai fazer aqui agora é criar uma deploy request. Aqui, a gente pode ver que eu não tenho nenhuma deploy request. O que eu tenho que fazer? Clico aqui no branch migrations, que é onde a gente criou, que a gente botou aqui nossas migrations, e a gente vai vir aqui em create deploy request. E veja que ele vai criar algo parecido com o que a gente tem no GitHub, uma sessão com comentários e também tudo o que precisa ser feito, que é criar as tabelas. Ele traz tudo o que vai ser feito quando a gente executar esse deploy, digamos assim. Aqui tem os schema changes, caso a gente queira ver. Ele faz como se fosse um diff do Git. E aqui agora é só a gente vir em deploy changes e ele já vai fazer o deploy automático das nossas migrations. Então, ele vai validar também, se não tem qualquer tipo de erro, e aí vai aplicar aqui as mudanças. E é muito legal porque o PlanetSKU usa um sistema de shadow database por baixo dos panos, que todas as migrations nunca são executadas direto no nosso banco em produção. Elas são executadas numa cópia do nosso banco em produção e se tudo deu certo, aí sim é executado no banco em produção. Beleza, deployment completed successfully. E agora, se a gente vem aqui no nosso branch main, que é o branch de produção e vem em schema, a gente vai ver que todo o nosso schema das migrations já está aqui. Então, agora o nosso banco de dados já está no ar, já está atualizado e a gente pode fazer o deploy da aplicação em si dentro da versão."
  },
  {
    "id": "b8d5165d-0b86-4f5c-9365-1f1293518c81",
    "title": "Deploy na Vercel",
    "transcription": "Agora, a gente vai fazer o deploy do código dentro aqui da Version. Pra isso eu vou acessar... Aqui eu tô na conta da Rocketseat. Ah, vamos jogar aqui mesmo. Mas primeiro, eu preciso subir esse... Eu não vou subir o projeto no GitHub, porque toda vez que eu subo o projeto no GitHub vem um monte de gente lá já... olhar o projeto e ficar mandando comentário. Então, eu vou direto usando a CLI da própria Version. Caso você não tenha ela, só vai aqui na ProcuraVersion, CLI, faz a instalação e depois de instalar ela, tu tem que rodar um Version login. E aí ele vai fazer o login aqui com a sua conta da Version, pra você tá utilizando. Bora lá! Eu vou rodar então aqui, simplesmente dentro da pasta do projeto. Só rodar a Version. Setup and deploy? Yes. O correto seria você configurar isso com uma... integração com o GitHub, né? Então toda vez que faz commit, lá push, ele já faz o deploy. Aqui eu não vou por causa de motivos que eu já expliquei. Ah, mas eu podia criar um repositório privado, né? Verdade, faz muito mais sentido. Então, vamos lá. Deixa eu ver se tem alguma coisa no git status. Dá um git add aqui. Eu tô dando commit com mensagem troll aqui por enquanto nesse repositório. gh-repo create, pra criar um repositório. Push an existing local repository. E aqui eu vou dar o nome de IgniteCall mesmo. E aqui, privado. Aguardar um pouquinho. Add remote? Yes. Yes. Yes. E pronto. Agora, gh-repo view, menos W. Tá lá. Nosso repositório já tá privado aqui dentro. Agora vem o add new project. Aqui, Diego3G. IgniteCall, que já tá aqui. Import. Pronto. Já trouxe todas as opções aqui dentro. E aí, aqui agora, a gente vai fazer algumas configurações. Dentro de environment variables, nós precisamos colocar as nossas variáveis ambiente. O GoogleClientId vai ser o mesmo. O nosso GoogleClientSecret vai ser o mesmo, que a gente tá usando em desenvolvimento. O NextAuthSecret podemos usar o mesmo também. Não tem uma necessidade de mudar. Aqui, a gente vai botar também o nosso database URL, que não vai ser essa aqui. No caso da database URL, a gente precisa botar agora a URL da nossa branch main, que é a branch de produção. Ou, voltando aqui em IgniteCall, clicando aqui em connect, ele vai trazer a URL de conexão pra gente. E nós vamos copiar apenas o texto dela. Cuidado pra não copiar as aspas juntos, senão vai dar bug. E cola aqui dentro. Uma vez que não tem aspas nem no começo nem no final, não precisa começar com MySQL e terminar com Strict ou com o que termina lá dentro do PlanScale, porque pode mudar. Vou dar um add aqui agora e pronto. Todas as nossas variáveis ambiente já foram adicionadas e agora a gente vai fazer deploy da nossa aplicação. Uma das coisas é que eu ainda não configurei domínio pra essa aplicação. Então, uma das coisas que a gente vai ter que lembrar é que eu vou ter que voltar lá no console do Google pra configurar as URLs de redirecionamento lá e tudo mais que a gente tinha configurado anteriormente. Lembra que hoje eu só botei localhost e tinha botado aqui 127 só pra testar. Mas como eu não tenho URL ou não sei a URL ainda, a gente vai ter que configurar depois. Então, vou dar um deploy aqui agora e rezar pra que dê tudo certo. Vamos aguardar aqui o processo finalizar. Se der algum erro também, a gente volta aqui e arruma o que pode acontecer. Show! Finalizou o deploy aqui dentro da Verso. O tab tá mostrando já a nossa home aqui. Eu posso até clicar aqui e ele já abre. IgniteCall.Verso. Não tinha nenhum app criado com esse nome. E agora eu vou copiar esse endereço aqui e eu vou voltar lá dentro do Google e a gente vai cadastrar aqui o RI. Vamos botar a nossa aplicação. E aqui no URL de direcionamento também vou colocar a nossa aplicação. Não vou tirar o localhost porque eu quero continuar usando esse app aqui em Dev, mas vou colocar aqui o nosso IgniteCall.Verso.app.ipa.alpha.callback.google. E vou salvar. Vamos aguardar aqui. Quê? Tá, pelo menos salvou. Deixa o F5 aqui pra eu garantir que salvou. A tela simplesmente fechou. Tá, vou dar um salvar aqui. Nossa, cara! Já sei o que acontece. A Google tem um... Eles usam o Windows... Fazer um ponto back no history pra voltar pra tela anterior. E aí se eu cheguei por essa tela, eu volto pra tela... Nossa, cara! Que coisa, hein, Google? Que coisa! Olha só, cara! Tá, coisa feia, né? Mas tudo bem. Então a gente confurou aqui as credenciais. Eu acho que era isso, tá? Tela de permissão ou alta. Eu acho que aqui dentro eu não tinha que confurar nada. Deixa eu dar um editar app aqui pra garantir. Domínio autorizado já tá aqui. Ignite app.Verso.app. Acho que ele colocou automaticamente. Se o seu não tiver, então já coloca aqui. E agora eu acho que é só testar, realmente. Será? Mas eu tô com medo. Vamos lá. DiegoSF. Reservar. Beleza. Diego Fernandes. Próximo passo. E agora que pode dar bug. Se a conexão com o banco não funcionou. Deu boa. Conexão com o banco. Então conectar agora. Que é o segundo passo onde pode dar bug. Acesso bloqueado. A solicitação desse app é enviada. Não foi possível fazer login porque esse app enviou uma solicitação inválida. Tente novamente ou entre em contato com o desenvolvedor pra falar sobre o problema. Redirect URI mismatch. Se eu não me engano. Isso é porque no NextAuth. Quando a gente vai colocar em produção. Posso até pegar isso aqui. NextAuth. Redirect URI mismatch. Se eu não me engano. É porque a gente tem que informar a nossa variável ambiente. NextAuth. URL. Senão ele não funciona. Tá em produção. Então vou fazer o seguinte. Continue to dashboard. Vamos em settings. Environment variables. Criar uma nova variável. NextAuth. URL. E ela precisa ser exatamente o domínio da nossa aplicação. Que é. Deixa eu voltar aqui. Até o app. Beleza. Agora ela vai estar em production. Preview. Development. A barra aqui no final não precisa. Vou dar um save. Já adicionou. Só que quando eu atualizo as variáveis ambiente. Ele não faz um novo deploy da nossa aplicação. A gente pode ver até que o deployment está aqui. Então eu tenho que vir aqui no deployment. E dar um redeploy. Pode dar um redeploy with existing build cache. Não tem problema. E vou clicar em redeploy aqui dentro. Pra ele fazer o deploy de novo. Porém lendo as novas variáveis ambiente. Vamos aguardar um pouquinho aqui. Show. Deploy finalizado. Já que ele não mostra o confeti de novo. Deixa eu mostrar aqui. Uou. Vamos lá. Agora a gente vai acessar de novo aqui. Eu já estava com o usuário pré-criado. Então eu posso dar só um F5 aqui nessa página. De conectar a agenda. Pra gente testar se agora a conexão vai funcionar. Eu espero que sim. Então clique em conectar. Não funcionou. Por que? Deixa eu verificar por que está dando esse erro aqui. Bom, eu estava dando uma olhada no Google. E tem várias pessoas com o mesmo problema. E tem várias causas. E uma delas que eu tinha visto aqui. A alteração que a gente faz lá dentro do Google. Às vezes para os domínios autorizados. Eles demoram para propagar. E aí peguei e fui almoçar. Só que voltei e não tinha dado certo. E aí? O que eu fiz? Eu vi que outra pessoa lá no Stack Overflow. Postou que ela só conseguiu fazer funcionar. Criando uma nova credencial. E foi isso que eu fiz. Eu vim aqui em credenciais. Criei uma nova credencial. Novo ID de cliente OAuth. Aplicativo da web. Botei aqui Next Production. E adicionei as URLs aqui. Que ficaram exatamente como eu estou te mostrando aqui em tela. Não mudei nada comparado com o que eu já tinha lá no outro. Salvei, copiei o Client ID e o Secret aqui. E coloquei dentro das variáveis ambientes aqui do Ignite Call. Então vim aqui em Settings. Environment Variables. E coloquei aqui dentro do Client Secret e Client ID. Vim aqui em Deploy. Fiz o redeploy. Então cliquei e dei um redeploy. E funcionou. Normalmente. Então... Vim aqui em conectar. Vamos testar o restante da aplicação agora. diego.shell.f Já apareceu. Vê que a tela é diferente. Vamos acessar o Ignite Call. Sim, permissões do calendário. Show. Próximo passo. Podemos selecionar as datas aqui. Eu vou tirar só sexta e quinta. Vou deixar segunda, terça e quarta. Aguardamos um pouquinho. Perfeito. E aqui. Sit Show. Profit Sit. Finalizar. Pronto. Já está aqui dentro. Já consigo ver as datas aqui dentro disponíveis. Os horários também disponíveis. Pode ver aqui como a gente não colocou alguns estados de loading. Algumas telas aqui as vezes ficam sem aparecer nada. Então seria legal depois a gente trabalhar com essa parte de estados de loading e tudo mais. Mas tá. Dia 28. 8 horas. Vamos botar aqui. John Doe. johndoe.example.com johndoe.example.com Testando app em produção. E aí ele tem que criar dia 28. 8 horas da manhã. Não confirmar. Show. Calendar.google Dia 28. 8 horas da manhã. Ignite Call. John Doe. Já testando app em produção. Então agora sim a gente finalizou toda a nossa aplicação. Inclusive o deploy dela."
  },
  {
    "id": "f0516277-fe56-4296-8bb0-b12280c7cba8",
    "title": "Criando Adapter do Prisma",
    "transcription": "Nessa aula, então, a gente vai criar o nosso próprio adapter. Então, vamos até aproveitar aqui o exemplo que o NextAuth traz pra gente. Então, vou copiar o exemplo inteiro aqui na documentação. Vamos abrir o VastCode aqui. E aqui no VastCode... Eu vou aqui na esquerda... Dentro de lib... Dentro de lib, geralmente, eu coloco os arquivos específicos de uma biblioteca que eu instalei. Então, por exemplo, eu vou criar uma pasta que pode ser NextAuth ou Auth, só pra ficar mais fácil. E aqui dentro eu vou criar prisma-adapter.txt E aqui eu vou pular aquele código. A única coisa que eu vou arrumar é que aqui é um código JavaScript, não é um código TypeScript. Então, esse return aqui é pra quem usa JavaScript usar o JSDocs, que é uma forma da gente ter tipagem com o JavaScript. Só que como a gente tá usando TypeScript, isso aqui é um pouco meio desnecessário. A gente pode escrever isso aqui de uma forma diferente. Primeiro, eu não gosto de usar o default, então eu vou trocar o nome pra prisma-adapter. Aqui, client-options, isso aqui não é obrigatório, vou até tirar. E aqui no retorno eu coloco adapter, que tem que vir de dentro de NextAuthAdapters. Salvei também, ele já deu uma reduzida aqui nos métodos. E só de tipar aqui adapter, a gente vai ver que ele já traz muita coisa. Então, tipo assim, createUser, que recebe um parâmetro user. Se eu passo o mouse por cima de user, a gente já sabe que é adapterUser, tá vendo? Então, é muito bom, ele já traz pra gente muito pronto aqui. E aí, o que eu vou fazer aqui dentro? Eu vou começar codando os métodos aqui dentro. Mas, porém, entretanto, eu vou começar com os métodos desses métodos aqui pra baixo. O método createUser eu vou deixar pro final, e eu explico o porquê. Na verdade, o método createUser, lembra que a gente vai ter que fazer ele de uma maneira diferente. Por quê? Porque não é criar o usuário. Porque o usuário já foi criado lá no momento que ele criou na primeira tela do formulário de cadastro, que ele botou usuário e nome. Então, aqui nesse método createUser, a gente não vai fazer a criação do usuário. Eu tenho que buscar nos cookies o ID do usuário salvo, pra saber qual que é o usuário que tá usando a aplicação. E, com base nessa informação, eu tenho que atualizar o registro do Isabelo de usuário. Então, ele vai ficar um pouquinho mais complexo se a gente faz depois. Vamos lá. Método getUser. Vamos começar aqui com o primeiro método. Bem simples. Recebe o ID e precisa retornar o usuário. A gente vai fazer um const user. Preciso ter acesso ao prisma aqui dentro, então eu dou await. Acho que só descrever prisma ele já vai importar. Tem que ser o . . . prisma, não o arroba prisma client. Prisma.user.findUniqueWhereId igual o ID. Aqui eu posso fazer uma short syntax, não preciso fazer isso aqui. Dessa forma já tá ok. E aqui uma coisa importante, eu não posso retornar o user aqui dentro. Olha, vai até dar erro. Porque o user que vem do prisma não é o mesmo formato que o user do nextAuth, digamos assim. Então, aqui eu preciso retornar um adapter user, que é só algumas informações específicas. Então, até se eu retornar um objeto aqui e der um ctrl espaço, ele já fala, essas informações que eu preciso retornar. id, email, emailVerified, image e name. Só que, aqui novamente, lembra que na tabela do banco de dados a gente trocou, né? Image, não era image, a gente mudou por avatar URL. EmailVerified nem tinha, né? Então, a gente mudou algumas coisas aqui. Então, a gente precisa, antes, configurar pra que o nextAuth saiba que a gente modificou isso lá dentro do nosso banco de dados. E aí, pra gente fazer isso, a gente vai ter que fazer o seguinte, tá? Acompanha o raciocínio. A gente vai ter que criar, dentro de source, uma pastinha arroba types, tanto faz o nome dela, na verdade. E aqui dentro, eu vou criar um arquivo chamado nextAuth.d.ts, que é um arquivo específico de definição de tipos. Ele serve pra eu sobrescrever tipagens de bibliotecas. Porque esse adapter user, ele é uma interface que existe dentro do nextAuth, aqui no adapters. Eu não tenho como modificar essa interface, eu não posso modificar um código que está dentro da pasta NodeModules. Então, eu tenho que sobrescrever esse user aqui. Então, aqui no arroba types em nextAuth, a gente vai fazer isso, tá? Como é que vai funcionar? Eu vou importar nextAuth de dentro de nextAuth. Eu sou obrigado a importar, porque se eu não importar, ele vai achar que eu estou criando a tipagem do zero e não sobrescrevendo. Não sobrescrevendo algumas interfaces específicas. E aqui eu vou dar um declare module nextAuth. E aqui eu vou criar uma interface chamada user. Por que user e não adapter user? Porque se a gente for ver aqui o adapter user, na verdade ele estende outra chamada user. E essa user aqui é a que a gente pode modificar. Inclusive já caiu aqui no meu próprio arquivo de tipagem. Aqui eu vou botar, o usuário tem um id, um nome, email, username e avatar url. Aqui ele está dando um errinho, acho que eu posso botar só um export. Aqui o slint está me incomodando. O slint, você sabe demais. Eu vou criar um arquivo aqui, .slintignore. E eu vou falar pra ele ignorar todo o arquivo que termina com d.ts. Pra ele não ficar fazendo linting nesses arquivos aqui. Show. Agora, quando eu vou retornar o usuário, veja que ainda está o image aqui, mas agora tem o avatar url também. Deixa eu ver se eu consigo remover esse image daí. Eu estava dando uma olhada aqui na própria documentação do NextAlpha. E eles falam aqui sobre o user, o account e o profile. Provavelmente deve ser possível eu sobrescrever especificamente ali o adapter user. Só que eu não encontrei aqui uma forma muito simples. E também, bom, não vou investir tanto tempo nisso porque não vai ser um problema pra gente, sendo bem sincero. Porque só da gente sobrescrever o user aqui, essas outras propriedades ali, tipo o image, ela não é obrigatória. E o email overfired aqui a gente pode retornar como nulo, não vai ser um problema. Então aqui dentro, a gente pode, deixa eu só pegar aqui minha colinha pra gente não perder, retornar cada um dos campos. Então id, user.id. Name, user.name. A gente vai ter que fazer isso pra todos. Username, user.username. Por que ele tá dando erro aqui? Object is possibly nule. Ah tá, porque o find unique ele pode retornar nulo aqui dentro. Então vamos pelo menos prefixar aqui com o ponto de interrogação. Email, user.email. Avatar URL, user.avatar.url. E aqui ele tá dando erro só porque a gente não colocou uma propriedade obrigatória, que é o email overfired ali. Vamos mandar como nulo, só pra ele não ficar reclamando. Promise, id, string, name, undefined. Types of id. Ah tá, porque ele não pode retornar undefined. Então eu vou fazer o seguinte. Caso, ou melhor eu acho que eu tenho um método aqui, o find unique or throw. Acho que esse aqui pode ser o melhor método pra gente utilizar aqui dentro. E aí o user aqui, ele é obrigatório, então a gente pode tirar esse ponto de interrogação. Ainda tá dando erro, deixa eu dar uma olhadinha. Type null is not assignable to string. Email are incompatible. Ah, porque o email ele pode ser nulo. Nesse caso aqui, faz sentido porque lá dentro do Prisma a gente definiu que o email dele é nulo. Porém, o adapter não aceita o email como nulo. É porque esse método getUser aqui, ele só vai ser chamado realmente quando o usuário já foi criado. Só que o Typescript não sabe disso. Então uma das coisas que a gente pode fazer, por exemplo, é botar um pontinho de exclamação aqui no final. Pra dizer pro Typescript que isso aqui vai ser informado, assim como o avatar, o url também. E aí já para de dar erro aqui. Porque faz sentido, o Typescript não sabe ainda que esse método vai ser chamado só depois que o usuário já foi criado. Pronto, a gente já tem o nosso primeiro método. Só que agora a gente tem que fazer os próximos também. Eu vou reaproveitar esse para fazer o getUserByEmail. A única coisa que muda é que eu preciso buscar o usuário por email. Pronto, o método está pronto. E assim a gente vai fazendo para todos os demais métodos. Então vamos lá, getUserByAccount. Aqui muda um pouquinho a forma que a gente vai fazer. E aí a gente vai escrevendo cada um desses métodos separadamente. Para não ficar muito longo aqui, vamos fazer um corte e a gente termina de criar esses métodos aí na próxima aula."
  },
  {
    "id": "e895ed9c-d26e-4a14-ae35-5ead0c21b73d",
    "title": "Tabela de agendamentos",
    "transcription": "Agora que a gente está se aproximando aqui do final da aplicação, que a gente vai construir a parte de finalização aqui do agendamento, a gente precisa, claro, dentro do Prisma, criar a nossa tabela que vai armazenar os agendamentos que até agora a gente não criou. Então, a gente vai começar criando aqui um model chamado scheduling, e aqui a gente vai seguir a mesma estrutura que a gente estava seguindo para as outras tabelas, ID, String, com default UUID, aqui a gente vai ter um campo Date, e esse campo, o nome dele por si só já diz, ele vai ser a data do agendamento em si. Lembrando que essa data aqui a gente tem que cuidar só para na hora que a gente salvar ela no banco de dados não salvar quebrada, porque como a gente vai permitir agendamentos de uma em uma hora, é importante que no banco de dados também, vai facilitar, não necessariamente precisa ser, mas vai facilitar no banco de dados a gente salvar 14 horas fechadinho, e cuidar para não salvar minutos e segundos quebrados, a não ser que no futuro você mude um pouco a estratégia, o usuário possa escolher, por exemplo, qual que é o intervalo de agendamento, se ele quer aceitar agendamentos de 15, 15 minutos, 30, 30 minutos, então isso é algo que dá para aperfeiçoar depois na aplicação, e não vai envolver muito mais lógica do que a gente vai criar daqui para frente. E aqui eu vou colocar alguns campos que a pessoa preenche aqui no formulário de confirmação, então quando ela vai agendar com alguém, ela precisa botar o nome, o e-mail e as observações, que daí é um campo nullable, então por isso que eu boto o ponto de enrogação para dizer que ele é opcional, e aí aqui a gente vai ter também o createdAt para anotar quando que esse agendamento foi criado. E aí por último, todo agendamento é um agendamento com algum usuário da aplicação, então aqui a gente precisa criar o relacionamento, é só escrever user, user, dois pontos e pronto, o resto ele cria sozinho, e aí eu mudo somente o nome de userId para userUnderlineId para seguir o restante dos padrões da nossa tabela. E aí também eu vou mudar o nome da tabela com o max para schedulings no plural, porque é o padrão que a gente está seguindo em todas as tabelas aqui dentro. Feito isso, a gente roda um prisma migrateDev, createSchedulings, que é o nome da nossa tabela, e pronto, a gente já está com a tabela criada aqui dentro. Uma outra coisa que a gente pode fazer, aproveitando aqui o tempo da nossa aula, é aqui no Google Chrome, quando a gente seleciona uma data, por exemplo, o 20 de dezembro, a gente pode já aproveitar e mostrar a data correta aqui em cima. Para isso a gente também pode usar o Date.js, mas lembrando que essa data que é retornada aqui, ela traz um date para a gente, caso você queira utilizar o INTL DateTimeFormat para formatar e mostrar o dia da semana e o dia do mês, beleza, mas como a gente já tem instalado o Date.js e a API dele é muito mais simples do que a API de internacionalização do próprio JavaScript, eu prefiro então a gente utilizar direto o Date.js. Então aqui eu quero pegar basicamente o dia da semana, só que o dia da semana ele vai ser totalmente dependente dessa informação SelectedDate aqui ela existir, então a gente vai pegar o WeekDay, somente caso o SelectedDate exista. Então se o SelectedDate existe, eu vou pegar o Date.js, vou passar para ele como parâmetro o próprio SelectedDate.format, e aqui a gente pode passar dddd em minúsculo que vai retornar o dia da semana. Caso o SelectedDate não exista, a gente pode retornar nulo daqui de dentro, e aí aqui dentro, no lugar de terça-feira, eu consigo mostrar o WeekDay, e agora o dia e o mês a gente pode fazer uma nova formatação. Caso você tenha qualquer dúvida sobre a parte de formatação, você pode dar uma olhadinha aqui dentro do próprio site do Date.js, que aqui ele tem todas as regrinhas para formatação. O que a gente quer mostrar aqui é 20 de setembro, então a gente precisa de duas informações que é o dia e o mês. Então a gente vai colocar aqui DateDescribedDate, talvez, não sei, alguma coisa que identifique a data, e aí a gente vai fazer o mesmo processo, só que aqui no format, para botar o dia, aqui ó, a gente pode até dar uma olhada, é o dd maiúsculo, inclusive o zero na frente, caso o dia seja menor que 10. E aí aqui no meio a gente tem esse espaço de espaço, isso a gente pode botar entre cochetes, que ele vai escapar, digamos assim, não vai entender que isso aqui é algo que eu queira fazer uma formatação com o Date.js. E aí a gente precisa do mês, por extenso, que é mmmm, então a gente bota aqui, perfeito. E aí agora a gente joga também o nosso DescribedDate aqui dentro, voltamos na aplicação, e tá lá, agora, terça-feira, 20 de dezembro, se eu seleciono outra data, ele já troca automaticamente lá em cima, conforme eu vou selecionando. É claro que os horários ainda não estão carregando aqui, porque a gente ainda precisa fazer uma validação pelo back-end, porque eu preciso retornar aqui somente horários que realmente estejam disponíveis, e não qualquer horário, por isso que a gente ainda deixou aqui tudo meio estático nessa página, mas vamos começar então a pensar como que a gente vai trabalhar com os horários que já estão ocupados aqui dentro do nosso app."
  },
  {
    "id": "53b0568a-8dbc-4d41-abc2-d17d229f2436",
    "title": "Estilos globais",
    "transcription": "Nessa aula a gente vai configurar alguns estilos globais aqui pra nossa aplicação. Então, com o Stitches, o que a gente pode fazer é criar na pasta styles um arquivo global.ts e dentro desse arquivo a gente vai simplesmente exportar global.css e aqui a gente vai exportar, na verdade vai usar uma função chamada global, ou melhor, global.css não, global.styles eu vou chamar, porque global.css já é o nome da função que eu vou importar de dentro do arquivo index que a gente criou, que é essa função aqui. E aqui dentro eu posso colocar estilos globais, por exemplo, eu posso colocar aqui o asterisco falando que todos os elementos da página vão ter margin 0 e padding 0. Lembrando só que eu tenho que escrever essas instruções do CSS como objetos do javascript. Aqui eu vou pegar o body, vou colocar aqui, por exemplo, posso colocar aqui trasto, webkit, font, smoothing, antialiased. Se colocar várias, por exemplo, posso pegar aqui body, input, textarea, button, font-family roboto, font-weight 400. Então eu posso basicamente configurar aqui da maneira que eu preferir. Salvando isso aqui agora, antes da gente continuar aqui e colocar mais estilos no CSS global, aonde que eu vou jogar esse global.styles aqui? Primeiramente, uma das coisas que eu já falei anteriormente, mas vou falar de novo, o document, apesar de ele ser um arquivo que ele vai carregar uma única vez na nossa aplicação, ele é o documento HTML, não é recomendado que a gente coloque nenhum CSS aqui dentro do document. Para isso, aonde que a gente vai colocar esse global CSS? A gente vai colocar dentro desse app. O que é o app? O app funciona como um wrapper, um container para as páginas da nossa aplicação. O app é como se fosse um componente que é carregado junto com qualquer página da nossa aplicação. Então não interessa se eu estiver acessando a home, se eu estiver acessando a página de produto, se eu estiver acessando a página de sucesso, todas essas páginas, elas na verdade estão carregando o componente app e esse componente app específico está carregando a página através desse componente que ele tem aqui dentro. Inclusive a gente pode adicionar TypeScript, vindo aqui dando dois pontos, escrevendo aqui, props, que importa de dentro de next barra app e agora isso aqui já vem a tipagem certinha do next. Então aqui dentro dele, a gente vai simplesmente, antes desse return, escrever global styles e isso aqui é uma função, a gente só chama a função. Pronto, não precisa fazer mais nada. Eu vou também tirar esse export default aqui de baixo e vou colocar export default aqui e trocar o nome ao invés de myapp para app mesmo, já resolve. Salvo aqui agora, volto no Chrome e dou um F5. A gente pode ver que ele já aplicou os estilos globais, já tirou o margin e o padding e o mais interessante disso tudo é que mesmo com o JavaScript desabilitado, todo o CSS continua funcionando sem problemas nenhum. E agora, para a gente finalizar os estilos globais, eu vou criar mais algumas variáveis do nosso tema de cores e tudo mais, então vamos lá. Eu vou criar uma cor chamada white, que ela é FFF e aqui eu vou criar alguns tons de cinza. Então grey 900, que ele vai ser 12, 12, 14. O grey 800, que ele vai ser 20, 20, 24. O grey 300, que ele vai ser C4, C4, CC. Opa, faltou a hashtag aqui. O grey 100, E1, E1, E6. Vamos criar também dois tons de verde. O green 500, que ele vai ser 00, 87, 5F. E o green 300, que ele vai ser 00, B3, 7E. E essas cores aqui, elas estão na verdade todas no Figma, aqui do Ignite Shop, aqui em cima, por isso que eu só fui colocando elas aqui dentro diretamente, mas você pode copiar dali de dentro. E aqui, salvo isso aqui agora, a gente vai voltar aqui no nosso estilo global e aqui no meu body eu vou escrever background color e aqui a gente pode ver que já aparece todas as cores. Eu vou colocar o grey 900 e color do texto eu vou colocar o grey 100, que também já aparece aqui automaticamente. Eu salvo isso aqui agora, volto no Chrome, dou um F5 e a gente pode ver que ele já aplicou automaticamente aqui a cor de fundo pra gente. Eu posso ver que ele já perdeu a cor roxa aqui do botão, porque o nosso botão ele tava usando aquela color rocket heat que não existe mais, então aqui a gente pode usar uma outra cor só pra ver como é que fica, por exemplo, o green 500 aqui, ou green 300, salvo ele e a gente já pode ver que ele aplica a cor verde de fundo aqui no nosso botão, que foi a cor que a gente definiu aqui no nosso tema. Aqui é o Diego do futuro, na verdade, depois que eu já gravei a aula, e agora eu já tô vários dias depois de ter gravado essa aula, e eu percebi que na verdade eu coloquei esse global styles aqui dentro do MyApp, mas o melhor pra ele aqui no caso é ficar fora desse componente, porque se eu coloco esse global styles dentro da função, o que vai acontecer é toda página que eu acessar na aplicação, toda vez que eu trocar de página na aplicação, tudo que tá dentro do MyApp executa de novo, mas os meus estilos globais eles não mudam, na verdade, entre cada página, e por isso o melhor local pra colocar esse global styles é fora do MyApp. Lembrando que como eu sou o Diego do futuro, talvez as aulas que você assistir daqui pra frente, elas estejam mostrando o global styles dentro do MyApp, então só cuidado pra não se confundir, porque na verdade o global styles aqui precisa ficar fora do MyApp em si. Valeu!"
  },
  {
    "id": "2d5b77c7-d019-4e63-bf07-ff35b912bb2b",
    "title": "Checkbox com Controller",
    "transcription": "Pra gente fazer nosso checkbox funcionar aqui, é importante entender que esse checkbox não é um checkbox nativo do HTML, por isso eu não posso simplesmente vir aqui e usar o register. Ele não vai funcionar, porque o register só funciona para elementos nativos do HTML. Então, como o checkbox é algo totalmente criado por fora, ele é quase praticamente só uma div com um botão dentro, eu tenho que usar uma outra técnica do React Hook Form, que é usar um Controlled Input, um Controlled Component. E como é que funciona? Basicamente, eu vou dar um CTRL X aqui no checkbox, e eu vou botar aqui um novo componente chamado Controller, e ele vem de dentro do React Hook Form. O Controller a gente vai usar quando a gente tem algum elemento em tela, visual, que vai inserir uma informação no formulário e não é um elemento nativo do HTML. E aí a gente vai usar o Controller. O Controller é bem simples de ser utilizado. A gente vai passar pra ele, primeiro, o nome, que é o nome do campo. Então aqui eu vou passar mais ou menos o que eu passo nos outros nomes dentro do register. Então eu vou usar aqui a chave, e vou botar intervals.width.enabled, que é o nome do campo que esse checkbox vai alterar, que é esse carinha aqui. E aí a gente vai passar pra ele também a opção Control. Lembra que é a mesma opção que a gente utilizou aqui no useFieldArray, que é basicamente uma API do React Hook Form, esse Control é uma API do React Hook Form que permite a gente alterar valor de campo, pegar valor de campo, registrar, é uma API que permite a gente fazer qualquer coisa com todos os campos que tem no formulário. Então esse Controller usa essa API pra conseguir criar esse campo, manipular o valor e por aí vai. E aqui a última propriedade, que é a mais importante, ela se chama Render. Essa propriedade nada mais é do que a propriedade que vai criar o checkbox, que vai renderizar o checkbox. Então ela é basicamente uma função, eu posso simplesmente criar uma função aqui e retornar o nosso checkbox. Só que a diferença é que esse Render, ele recebe uma série de propriedades. Se eu faço uma desestruturação aqui e dou um Control espaço, eu posso acessar algumas delas. O Field, FieldState, FormState, a propriedade que a gente quer aqui é o Field. Dentro desse Field eu tenho algumas opções também, como por exemplo, OnChange, Name, OnBlur, Path, Value, ou seja, eu consigo obter informações sobre esse campo especificamente dentro do React Hook Form. Eu não vou desestruturar de novo aqui, senão vai ficar um código meio sujo. Eu vou diretamente aqui no nosso checkbox usar a propriedade, primeiro, OnCheckedChange. Essa propriedade é chamada automaticamente toda vez que o usuário clicar pra trocar o valor do checkbox. E aqui dentro ela recebe Checked. E aqui dentro eu vou fazer, basicamente, Field.OnChange, lembra? Que é o que a gente recebeu daqui, o OnChange eu vou chamar quando eu quero alterar o valor do campo. Passando Checked == true. Por que eu não simplesmente peguei o Checked e passei aqui dentro? Porque se a gente for investigar o que esse Checked pode ser, ele é um CheckedState. Ele pode ser um booleano ou ele pode ser indeterminate. Esse indeterminate aqui é um pouco chatinho na questão de TypeScript, mas ele é importante porque... Pensa que eu tenho um checkbox em tela, e esse checkbox apareceu em tela, só que o usuário nunca manipulou o valor dele. O valor dele é true ou é falso? O valor dele é falso. Você pode pensar que ele é falso, mas existe um terceiro estado que é o que o Radix, que a gente usa pra esse componente e implementa, que é o indeterminate. Eu não consigo determinar porque o usuário nem mexeu no checkbox. Ou seja, não é true nem falso, ele é indeterminado. Então aqui a gente tá fazendo basicamente uma regra. Se o Checked for true, ou seja, o usuário foi lá e realmente deu o check nele, então ele vai aplicar o valor como true. Se não, ele é falso. Aqui eu vou passar pro checkbox também a propriedade Checked, pra gente conseguir recuperar o valor inicial desse checkbox como sendo fio do ponto value. Isso aqui vai ajudar a gente a recuperar o valor inicial que a gente tá dando aqui pro Enable pra cada um dos campos aqui do nosso formulário. Então vamos salvar aqui agora, volto aqui pra dentro do Google Chrome e olha lá. Todos os checkboxes aqui já estão selecionados, os do dia da semana, e o no caso aqui do domingo e sábado não estão selecionados. E aí uma outra coisa que eu vou fazer pra ficar bem legal aqui é o seguinte, tá? Eu quero desabilitar os Text Inputs quando aquele intervalo tá desabilitado. Ou seja, se o domingo aqui tá desabilitado, eu não quero permitir o usuário vir aqui e mudar a hora de início e a hora de término. Então a gente vai fazer o seguinte. Eu vou utilizar aqui de dentro do UseForm uma função que ele retorna chamada Watch. A função Watch me permite basicamente assistir, saber em tempo real as mudanças que houveram em algum campo. Então eu vou fazer o seguinte, const intervals é igual a watch intervals. Agora esse intervals aqui, ele vai retornar o array de intervalos com todos os intervalos que a gente tem dentro do nosso formulário, só que ele vai retornar em tempo real. Toda vez que houver uma alteração nesses valores, ele vai retornar pra gente. E aí é legal porque aqui embaixo, no Text Input, eu posso fazer algo como o seguinte. Eu quero desabilitar esse Text Input caso intervals no índice index, que é o índice do campo aqui em cima, esteja desabilitado. Ou seja, enabled seja igual a false. E aí a gente pode replicar a mesma coisa pro input de baixo, salvo isso aqui, volto no Chrome e olha lá. Agora, se eu desabilito algum dia, ele desabilita juntos os campos e eu não consigo mexer. Quando eu habilito, ele já habilita os campos também. Esse aqui é um formulário um pouquinho mais complexo, envolve um pouco mais de lógica, um pouco mais de regra. Então tem que tomar cuidado pra não se perder aqui no meio de tudo isso. Mas é legal porque a gente está utilizando basicamente todas as features do React Hook Form. A gente usou Field Array, usou Watch. Então usou bastante funcionalidades aqui que com certeza se você for criar formulários mais complexos, você vai ter que lidar com esse tipo de coisa. Mas a gente ainda não criou nada de validação, nada de transformação. A gente vai ver o poder que a gente consegue ter com o Zod, agora nas próximas aulas, de conseguir validar esse formulário. Porque tem bastante validação que a gente pode fazer aqui pra não permitir o usuário inserir alguns valores de uma maneira errada. E também a gente vai precisar fazer tratativa, porque hoje o horário está sendo inserido dessa forma, 0800. Só que salvar o horário dessa forma aqui no banco de dados eu não gosto muito. Eu acho ruim de trabalhar com ele. Então a gente vai melhorar um pouquinho as coisas aqui nas próximas aulas."
  },
  {
    "id": "ef884eee-807c-4a17-be92-71c2f8e0113c",
    "title": "Rotas autenticadas no Next",
    "transcription": "Nessa aula, o que a gente vai fazer é persistir os dados que a gente está fazendo de input nesse formulário, então toda a disponibilidade do usuário dentro do banco de dados. Para isso, a primeira coisa que a gente tem que fazer é moldar o nosso banco de dados para aceitar essas informações, porque hoje o nosso banco de dados não tem nenhuma tabela, nenhum lugar para a gente salvar informações da disponibilidade do usuário. A gente só tem, por enquanto, as tabelas relacionadas à autenticação, criação, conta, login social. Então, o que eu vou fazer aqui é basicamente minimizar todos os models, todas as tabelas, para ser mais fácil, e eu vou criar um novo model aqui chamado UserTimeInterval. E esse UserTimeInterval, cada entrada que a gente tiver aqui dentro, vai ser relacionado a um intervalo de tempo disponível para aquele usuário. Então, se aqui, por exemplo, dentro da nossa aplicação, o usuário preencher que ele tem disponibilidade em três dias da semana, a gente vai criar três registros dentro do UserTimeInterval. A gente não vai colocar todos os intervalos do usuário dentro do mesmo registro, porque ficaria muito difícil trabalhar. Eu teria que criar, talvez, uma coluna só para domingo, uma para segunda-feira, eu acho que ficaria um pouco ruim, então é melhor a gente separar em mais dias aqui, nem mais entradas aqui dentro. Eu vou começar criando o id, que é myString, id, default, uid, igual a gente fez nas outras tabelas. E aqui dentro eu vou começar com o weekDay, que vai ser um inteiro, que vai de 0 a 6, representando domingo, segunda, terça, por aí vai. Eu vou criar aqui um time, startInMinutes, e aqui ele vai ser um inteiro também. E aqui, basicamente, a gente vai criar as duas colunas, de começo e fim, que o usuário selecionou. Como a gente está convertendo para minutos aqui no momento que a gente faz o envio do form, tanto o startTime quanto o endTime, a gente salva isso em minutos também no banco de dados para ser mais fácil. E agora a gente precisa da referência para o usuário, então cada timeInterval pertence a um usuário. Um usuário pode ter vários timeIntervals aqui dentro. Então nesse caso, com o Prisma, basta a gente falar, olha, esse userTimeInterval está relacionado a um usuário. Basta eu fazer isso aqui, quando eu salvo, ele já cria automaticamente todo o relacionamento. E aí ele cria nesse padrão camelCase, então a gente vai colocar um if aqui no meio, que é o padrão que a gente está seguindo aqui dentro da aplicação, e ele cria o relacionamento nos dois lados. Então um userTimeInterval pertence a um usuário, e lá nos usuários ele cria também o relacionamento inverso. Então um usuário possui vários userTimeIntervals. Aqui o nome não fica tão legal, então a gente vai trocar para timeIntervals. E aqui eu vou colocar ele em camelCase mesmo. E por que camelCase? Esses relacionamentos aqui, que eles não têm, por exemplo, o tipo do campo da coluna, esses campos aqui dentro da tabela do Prisma, que eles não têm o tipo da coluna, string ou qualquer coisa assim, que aqui por exemplo é um array, isso aqui não vai criar nenhuma coluna no banco de dados. Isso aqui é só interno para o Prisma, na hora que a gente for trabalhar com o modelo de user, para a gente poder fazer, por exemplo, user.timeIntervals. Se eu colocasse camelCase, no JavaScript eu teria que fazer timeUnderlineInterval, só que camelCase não, né? O underline, só que aqui ficaria um pouco estranho, então eu prefiro nos relacionamentos especificamente trabalhar com o padrão de camelCase. Só que aqui embaixo, o userId, tá vendo que ele tem o tipo da coluna? Porque isso aqui vai criar uma coluna chamada userId dentro dessa tabela, então nesse caso eu prefiro trabalhar com o underline. Feito isso, eu vou só fazer um arroba arroba map para a gente renomear o nome dessa tabela para userUnderlineTimeUnderlineIntervals, porque senão ele vai criar o nome da tabela no banco com esse nome aqui, e fica um pouco esquisito. Vou salvar aqui agora, e a gente vai rodar um npx prisma migrateDef para ele criar essa createUserTimeIntervals, o nome da minha migration, e pronto, ele já criou a migration e também já criou a tabela no banco de dados. E agora a gente vai começar criando uma rota na API dentro de users, e aqui eu vou criar uma nova rota chamada timeIntervals.API.ts. E essa timeIntervals aqui, ela basicamente vai ser responsável por receber o nosso formulário aqui da página de timeIntervals e processar, salvar essas informações dentro do registro do usuário. E a partir do momento que o usuário já passou por aquele passo de conectar com a agenda do Google, esse usuário já está logado dentro da nossa aplicação. Então para a gente obter informações do usuário logado, já que a gente está utilizando o NextAuth, é muito simples. Então a gente não precisa se preocupar em ter uma referência, por exemplo, para o ID do usuário aqui na rota, porque esse ID já está dentro dos cookies da aplicação. Então para a gente vai ser super tranquilo. Aqui dentro eu vou começar exportando uma função, como default, o nome dela pode ser Handler, tanto faz, Hack e REST. E aqui vai ser do tipo NextAPIRequest e essa aqui NextAPIResponse. Show de bola, e agora a gente vai começar a processar. Primeira coisa, isso aqui é um método, uma rota que vai ser chamada para cadastrar os intervalos de tempo que o usuário tem disponibilidade. Por isso, eu vou começar com o primeiro if aqui dentro, que se o método não for post, eu já vou dar um erro aqui dentro, porque essa rota não vai ser feita para atualizar os dados de intervalo, ela vai ser chamada uma vez só, por enquanto, para o usuário poder apenas cadastrar essas informações. Show de bola, e agora uma das coisas que a gente vai fazer, como eu falei, é que eu quero obter informações do usuário logado aqui dentro. E lá no NextAuth, existem várias formas de a gente obter informações do usuário logado. E aqui embaixo, a gente pode ver, por exemplo, dentro de ClientAPI, aqui na direita, deixa eu ver se eu consigo encontrar aqui, a gente tem o getSession, porém o getSession é um método que a gente usa apenas no client-side, ou seja, somente lá dentro dos componentes, no React, para obter informações do usuário logado. Aqui ele fala, no server-side, a gente não usa o método getSession, porque esse getSession vai buscar as informações dos cookies de uma maneira, sendo que só funciona no lado do browser. Quando eu quero obter informações da sessão no lado do server-side, a gente tem esse método aqui chamado unstableGetServerSession. A gente vai pegar esse método, e aqui, por mais que ele fale que essa feature é experimental, a gente vai utilizar porque, por enquanto, é a única forma performática de a gente obter a sessão do usuário dentro do server-side. Mas cuidado, porque talvez quando você entrar nessa documentação, pode ser que ela esteja de uma maneira diferente, então vale a pena dar uma lida aqui na documentação para ver como é que faz. No nosso caso, a gente vai copiar esse método aqui dentro, vamos colocar aqui, vou importar ele de dentro de NextAuth, e aqui a gente pode ver que ele recebe algumas informações. Primeiro, o REC, que a gente tem aqui em cima, então REC, o REST, que a gente tem aqui em cima, REST, e aqui, AuthOptions. Esse AuthOptions, ele vem aqui de dentro do NextAuth API, que é esse nosso arquivo. Para obter esse AuthOptions, a gente precisa basicamente chamar esse método aqui, BuildNextAuthOptions. Então a gente vai chamar essa função aqui, BuildNextAuthOptions, importando lá de AuthNextAPI, passando para ele o REC e o REST, e ele vai devolver para a gente as nossas AuthOptions, que são as nossas opções de autenticação. Lembrando que a gente precisa passar o REC e o REST para esse método, para que ele consiga basicamente obter informações da sessão lá dentro do adapter do Prisma. A gente fez toda essa funcionalidade aqui, que ficou bem massa. E agora, dentro dessa sessão, até para a gente testar se isso aqui está funcionando, eu vou retornar daqui de dentro, simplesmente, a nossa session, para a gente ver se está funcionando. Aqui está dando um erro de linting, então a gente pode ver, identifier unstable getServerSession is not in camelCase. Isso aqui é um erro de linting, porque ele pede para que a gente mantenha todo o nome de variável e função aqui dentro do código como camelCase, mas por enquanto eu vou desabilitar esse erro aqui. Então a gente vem aqui no nosso linting, Rules, camelCase, off. Então desabilito a regrinha para ele não ficar dando erro nessa informação. E agora vamos lá. Eu vou rodar o nosso projeto de novo. Eu tinha parado de rodar aqui, até porque eu já estou gravando em outro dia. Vamos abrir aqui a nossa aplicação. Teoricamente eu já devo estar conectado, então a gente vai abrir direto aqui a página registered barra timeIntervals, para eu garantir que eu estou logado aqui na aplicação. Deixa eu só vir aqui em Application, Cookies, beleza, NextAuthSessionToken, está aqui a informação que a gente precisa. E agora eu vou, simplesmente, abrir a nossa aba Network, que na verdade a gente ainda não fez a chamada. Então aqui no index, aqui onde a gente tem o console.log, a gente vai trocar isso aqui por await api.post barra users barra timeIntervals, enviando aqui os nossos dados, que é o nosso formData aqui, por enquanto. Vou enviar ele completo, depois eu faço uma desestruturação aqui e envio ele por parts. A gente pode até, para ficar um pouquinho mais organizado, pegar assim, intervals, e aqui a gente envia dessa forma, e envia assim, pode ser. Vamos voltar agora no Chrome, aqui em Network, deixa eu limpar aqui, e vamos dar um próximo passo. Tá, espera aí, experimental, ele rodou, só que ficou impending, ele tentou selecionar nas sessions, API result, ah tá, claro né, aqui a gente não pode ter um return nesse formato aqui. A gente precisa retornar hash.json, e aí sim, enviar a nossa sessão. Então vamos voltar, dar um F5 aqui, para garantir, limpar a aba Network novamente, dar um próximo passo, e tá lá, o timeIntervals, e a gente pode ver que ele trouxe aqui da sessão, que a gente retornou, todos os dados do usuário logado, então nome, email, e o que importa para a gente, o id. Com esse id aqui, a gente consegue fazer uma inserção dentro da nossa tabela de timeIntervals, porque lá ela tem referência para o id do usuário, e aí a gente consegue inserir o restante das informações aqui dentro, que a gente vai fazer na próxima aula."
  },
  {
    "id": "de041db7-a87a-4033-9343-e5cf3238e31c",
    "title": "Persistindo perfil",
    "transcription": "Para a gente finalizar com chave de ouro aqui, a gente vai carregar o avatar do usuário. Então, aqui embaixo de text, eu vou começar colocando aqui o nosso avatar, que vem de ignite.ui.react. E aqui eu vou colocar o nosso source, que ele vem de session.data.user.avatar.url. Vamos salvar aqui agora. Eu volto lá e já posso ver o meu avatar sendo exibido em tela. E eu vou colocar também no avatar, que eu perdi aqui, um texto alternativo como sendo session.data.user.name, que é o nome do F5. Pronto, já está carregando ali. Aqui é um ponto super interessante de dizer, porque quando eu fui construir essa aplicação aqui a primeira vez, o avatar estava dando bug, ele não mostrava. E aí eu fui descobrir na internet que o Google tem uma política de cores para carregamento do avatar, o que faz sentido, porque eles querem evitar que a gente carregue o avatar diretamente, o URL do avatar dentro dos sites, porque isso consome muita banda deles. Então, eles têm uma política de cores para a gente não conseguir carregar diretamente o avatar de dentro de qualquer endereço. A gente tem que informar ali. Tem um monte de regrinha para a gente seguir, de certa forma. Mas o que eu quero dizer no final das contas e por que eu estou falando isso? Porque como a gente fez o carregamento da sessão do usuário aqui pelo server-side, quando o Next foi montar a nossa página, o nosso HTML, ele conseguiu montar todo o HTML da nossa página pelo server-side. Ah, Diego, o que isso quer dizer? Quer dizer que mesmo com o JavaScript desabilitado aqui, eu posso desabilitar, posso dar um F5 aqui na página, e a gente vai ver que a página é carregada normalmente. Aqui ele não conseguiu carregar o avatar especificamente, porque, na verdade, não é nem que ele não conseguiu carregar o avatar, é porque o componente de avatar no meu design system tem uma regrinha para depois que o avatar foi carregado, ele troca o componente, porque senão ele fica mostrando um fallback, digamos assim, mas não é o ponto agora. Mas o que eu quero dizer é que como o Next conseguiu montar essa página toda aqui pelo server-side, ou seja, pelo Node, antes de chegar no client-side e antes de chegar no JavaScript do browser, ele consegue carregar o avatar independente desse problema de CORS, porque o CORS não se aplica a requisições feitas a partir de um back-end, somente requisições feitas a partir do browser. Ou seja, a gente não vai ter erro aqui de carregamento do avatar por CORS no Google, porque o avatar foi carregado via server-side já, a requisição foi feita via server-side. E aí só porque eu falei isso, ele não conseguiu carregar aqui o nosso avatar. Ah, ele tá com um cache aqui, deixa eu ver. Ai meu Deus, só porque eu falei isso, o nosso avatar não carregou? Network, deixa eu ver se ele tá dando erro aqui de carregamento da imagem. Image. Ah, ele tá dando erro de carregamento da imagem. Ah, ele tá dando erro de carregamento da imagem. Deixa eu dar um console.log na nossa imagem de avatar aqui, pra ver se essa imagem tá sendo trazida desde o primeiro momento. E tá. Aqui então, deixa eu fazer um teste bem rápido. Se eu colocasse um image com isso aqui. Aqui no avatar, deixa eu tentar passar uma outra opção, que é o heffer policy, como no heffer. Vamos testar dessa forma aqui, salvando, dou um F5. Ctrl Shift F5 pra tirar o cache. Cara, o avatar do Google, eu não sei porquê, eu fiz a explicação toda, só que ele tem um bugzinho muito, muito, muito chato. Que ele fica bloqueando as requisições, e isso acontece principalmente quando eu tô em ambiente de desenvolvimento, em produção não vai acontecer. Mas em ambiente de desenvolvimento ele fica limitando o número de requisições que eu posso fazer, e aí por eu estar usando localhost, é que ele entende, e ele fica bugando, ele fica dando o erro 403. Só que isso não vai ser um problema tão sério mais pra frente. Só que em desenvolvimento ele vai ficar dando esse bug. Já tentei fazer mil coisas, e o mais correto seria a gente não depender da URL do Google. O que seria o mais correto? No momento que o usuário fez login na nossa aplicação, eu copiar, digamos assim, o avatar dele pra dentro do nosso site, ou até criar uma URL que intercepta, digamos assim, o avatar. Mas eu não vou ficar me prendendo nesse erro aqui, é um erro que se você for procurar no Google, vai ter um monte, milhares de pessoas com esse problema, e várias delas resolvendo de uma forma, outras resolvendo de outra forma, e é bem chatinho de lidar com esse erro. Mas eu não vou me preocupar com isso, porque não vai prejudicar nem um pouco os aprendizados que a gente quer ter nesse conteúdo, uma imagem aqui do Google. Mas vamos continuar. Agora o que eu vou fazer é a parte de atualização do perfil. Então eu vou criar uma rota na nossa API aqui, dentro de users. Eu vou criar uma rota chamada profile.api.ts, e essa rota aqui vai ser muito parecida com a rota de atualização ali do timeIntervals, então a gente vai copiar ela aqui e jogar aqui dentro. Só que a única diferença é que aqui no meu body, eu vou receber apenas a biografia do usuário, que vai ser uma string. Aqui não vai ser timeIntervals, body esquema, aqui vai ser updateProfile, body esquema. Show. O resto aqui não vai ser post, vai ser... Vou botar put, faz mais sentido eu acho. Aqui eu vou pegar a biografia, e aqui eu quero atualizar o usuário logado. Então eu vou só dar um await prisma.user.update, where id é igual a session.user.id. Aqui o user pode estar vazio talvez, acho que não. Ah não, porque a gente fez um if aqui em cima, então tá ok. Data, eu vou atualizar a opção... Eu não criei o campo ainda pra biografia, então vamos lá. Schema dentro de user. Vou criar aqui um campo chamado bio.string, e eu vou botar ele como um campo opcional, porque até o usuário terminar o cadastro dele, ele ainda não vai estar preenchido. npx prisma migrate-dev add bio to users. Pronto, tá adicionado, voltamos aqui e já aparece aqui, viu? Feito, simples assim. Rastatus aqui não, vou botar 200, vou botar 204, 204 pra quem não sabe é sucesso, porém uma resposta sem conteúdo, então a gente usa 204. Eu evito usar 200, 200 eu deixo mais pra listagem mesmo, ou quando eu quero retornar alguma coisa do back-end. Perfeito, agora aqui dentro do nosso handle update profile, eu vou fazer o await api.put users barra update profile, enviando a biografia que vem de data.bio. Salvo, dou F5, agora a imagem carregou. Por isso que eu tô falando, isso aqui geralmente vai dar porque eu tô fazendo requisições demais. A outra coisa que eu percebi aqui, passo 1 de 4, tá errado. Então current step 4, show. E a imagem aqui, às vezes ela vai aparecer, é porque quando eu tô no local host ele fica limitando o número de requisições que eu posso fazer, então às vezes aparece, às vezes não aparece. Sobre você, cto.at.rocketseat, vou mandar qualquer coisa aqui. Deixa eu só abrir um especial elemento, network, não finalizar. Show, ele já chamou, update profile, só que deu 404. Já sei, eu botei só profile, não update profile. F5 de novo aqui, cto.at.rocketseat, finalizar. Acho que agora deu certo, né? Show profile, response, 404. Se eu for no Prisma Studio, in user, aqui ele não carregou ainda porque o Prisma tá... Quando eu boto campo novo na tabela eu tenho que cancelar o Prisma Studio e rodar de novo, senão ele não carrega os campos novos. BIO, tá aqui, cto.at.rocketseat, ele já cadastrou. Cadastrou no usuário certo. Antes eu tinha feito alguns testes, eu criei outros usuários, vou até deletar aqui pra não ficar incomodando. Show. Feito isso, nós terminamos essa página. Só que agora, o finalizar, ele não tá... Depois de finalizar aqui, ele não tá mandando o usuário pra lugar nenhum. O que eu vou fazer aqui, tá? Depois dele terminar, eu vou encaminhar ele pra uma nova rota que eu vou criar na minha aplicação. Então deixa eu importar aqui o halter, use router. Aqui eu vou dar um router.push, vou enviar o usuário, vou mandar pra uma rota chamada schedule-session.data.user.username. Ou seja, eu vou basicamente mandar o usuário pra uma rota schedule-jusf, que é o username dele. Por quê? Porque essa rota aqui é a rota que vai mostrar este calendário aqui embaixo. Então depois que o usuário se cadastrar, eu vou mandar ele pra rota do calendário dele. Ou seja, é a rota que o usuário pode simplesmente copiar o endereço na URL e mandar pros amigos, mandar pra quem ele quiser, botar no Instagram, Twitter, sei lá onde que ele quiser colocar, pra que as pessoas possam marcar agendas com ele. Save. Aqui tá dando só um errinho porque novamente session.data pode ser nulo. A gente sabe que não pode, porque de certa forma a gente carregou o session no primeiro momento aqui. Mas mesmo assim o TypeScript não consegue inferir tudo automaticamente. Isso seria utopia. E aí, só pra gente terminar aqui com chave de ouro, se a gente for ver aqui na rota, por exemplo, o timeIntervals, depois que o usuário faz a conexão dos intervalos, a gente também não tá redirecionando ele pra próxima rota. Então vamos fazer aqui um const router é igual a useRouter. E aqui embaixo também, depois de ele cadastrar, eu vou dar um await router.push barra register, barra update profile. Vou até copiar isso aqui, porque eu acho que na rota de connectCalendar a gente também não faz nada. Aqui ó, no handle connectCalendar, depois que ele termina o login com o Google, aqui eu tenho um console.log, eu não vou redirecionar ele aqui, porque quando ele termina o login com o Google não quer dizer que ele clicou no botão de próximo passo. O que eu vou fazer aqui então? Eu vou trocar esse botão aqui, porque esse botão está como disabled, o usuário só consegue clicar nele quando o usuário já autenticou. Então aqui eu vou criar uma função handleNavigateToNextStep. Eu não botei o nome, tipo timeIntervals, porque o next step pode mudar no futuro, então assim fica um pouquinho mais... handleNavigateToNextStep. Deixa eu ver se já parou o erro aqui. E aqui dentro eu vou fazer o awaitHolder.push, registerTimeIntervals. Acho que é isso. Agora eu vou testar o fluxo todo do zero. Então a gente vai voltar na página inicial da aplicação, vem o Applications, vou deletar os cookies de autenticação aqui, apaga tudo, porque eu quero testar o fluxo de cadastro inteiro da aplicação. Então o usuário aqui eu vou botar Diego ou qualquer coisa, só pra gente não usar o mesmo usuário. Reservar, beleza, já veio pra cá. Diego Fernandes, vou dar um Enter. Foi. Google Calendar, conectar. Conecto o meu usuário aqui. Como eu já tinha conectado antes, vai ser o processo mais rápido. Clicando em próximo passo, show, já foi pro timeIntervals. Tiro aqui algumas informações. 10, boto aqui 14 só pra gente testar. Próximo passo, show, já traz a pauta de perfil. SitShowAtRocketSeat, 2 só pra gente identificar lá, finalizar. E pronto, ele mandou pra Schedule, DiegoSF, que ainda não foi criado, porém, se eu volto lá no Prisma Studio, vou carregar aqui, tá lá o Diego, tal, tal, tal. A bio acabou botando no Diego errado. Session.userId. Peraí. Session, rec, res. Peraí. Tá, eu já sei o que que é. A gente logou com a mesma conta do Google. Tá, isso aqui é um ponto super importante. E não é um bug. Esse que é o ponto benéfico, digamos. Não é um bug. O que que acontece, né? Quando a gente cadastrou com o primeiro usuário, lá em Account, que ficam as associações de usuários com contas do Google, ele falou que pra conta do Google, com esse id aqui, que é a minha conta lá no Google, o usuário relacionado com essa conta é esse aqui. Que se a gente for ver aqui na direita, em User, é o usuário com o DiegoSF. Quando eu criei o novo usuário e loguei com a mesma conta do Google, ele entendeu que eu tava logado com o usuário anterior. E aí tudo dali pra frente valeu como se eu estivesse com o usuário anterior, né? Então, tá aí, não é um bug, mas cabe talvez a gente pensar num comportamento diferente, talvez? Não sei. A gente teria que pensar em alguma forma que a aplicação talvez informar o usuário, alguma coisa assim. Legal, não é um bug, mas é interessante o funcionamento que teve aqui e deu tudo certo. Mas é isso, nosso fluxo tá totalmente funcional. Agora a gente vai começar a partir pra página de calendário e daqui pra frente vai ser bastante código massa que a gente vai criar."
  },
  {
    "id": "d7b1b03e-0241-4e50-a03a-7b30ac632540",
    "title": "Estilização do calendário",
    "transcription": "Bora lá! O que a gente vai fazer agora, então, é a parte de CSS aqui do calendário, pra ele ficar estilosão. Ah, tem um erro aqui. TimeIntervals.getWeekDays. Ah, hum, é, hum, tá. Lá no... eu buguei a nossa função getWeekDays, falando que o parâmetro aqui é obrigatório. Só que não é, né? Hum, será que eu posso... será que nos outros lugares eu vou lá e altero? Ou eu venho aqui e faço que isso aqui não é obrigatório? Hum, qual que é o erro daí? Abiding pattern cannot be optional in an implementation signature. Tá, talvez eu possa fazer isso aqui. Hum, e aí funciona. Tá, tá show. Ah, vamos lá. CalendarIndexTiles, vamos começar a fazer os estilos aqui e a gente vai vendo em tela já como é que vai ficando. Vamos começar pelo CalendarContainer, a gente vai começar dando um display flex, porque flex é vida. Cara, às vezes eu clico em umas teclas do Mac e eu fico três anos só tentando entender o que aconteceu. FlexDirectionColumnGap 6 e vamos botar um padding 6 também, porque a gente tinha tirado o padding lá como eu falei antes e agora a gente precisa botar de volta. O header aqui vai ser display flex também, alignItemsCenter, justifySpaceBetween. Salva, vamos dar uma olhadinha como é que tá ficando aqui. Beleza, agora já ficou bem diferente. A tela tá um pouquinho maior aqui que o calendário original e logo eu explico o porquê, mas não vamos entrar nesse mérito ainda agora, tá? Tá, vamos pro CalendarTitle aqui, a gente vai botar um font-weight medium e aí o span que tem ali dentro, que eu tinha colocado só pra botar um estilo diferente, eu vou botar um color-gray 200 nele. Show, já ficou legal. Agora os nossos actions aqui, a gente vai colocar um display flex gap 2, color-gray 200 também. Só que agora a gente tem que modificar um pouquinho os botões que estão ali dentro, que são esses dois botões aqui de passar e voltar. Existe uma propriedade no CSS que muita gente acaba não usando que é o all, que a gente consegue botar all unset, ele pega todas as propriedades do CSS e tira o valor delas padrão. Olha só, daí já tira tudo do botão, borda, background, e aí a gente começa a colocar tudo do zero aqui. Cursor pointer, line-height zero. Por que line-height zero? Porque quando a gente tem um botão que ele é só um ícone dentro dele, é só um elemento visual que não é um texto, geralmente a gente tem que resetar o line-height ou font-size, porque o tamanho do botão é definido com base no line-height e no font-size. Ou seja, o tamanho pode ficar discrepante ao tamanho do ícone que está ali dentro. Border-radius, aqui a gente vai botar small, e aí o SVG, que é o ícone ali dentro, a gente vai colocar aqui nele um width 5, height 5. E agora a gente vai fazer o seguinte, no hover do botão eu vou colocar um color gray 100, e no focus do botão eu vou colocar um box-shadow 0, 0, 0, que é x, y e blur, 2 pixels que é o tamanho. E aqui, o que acontece? No stitches, ele não vai conseguir, se eu botar aqui, por exemplo, a gray 100, ele não vai conseguir identificar que isso aqui é um token de cor. Eu teria que botar box-shadow-color para ele conseguir identificar, só que nem tem como. Então, para ele conseguir saber que isso aqui é um token de cor, o stitches, porque box-shadow não é uma propriedade especificamente de cor, diferente do color, onde é uma propriedade de cor. Então ele consegue identificar que isso aqui é um token de cor, automaticamente. Só que aqui ele não consegue, então eu tenho que botar dollar, colors, dollar, tudo junto, gray 100. Então ele vai entender, ah beleza, é um token de cores, e aí esse aqui é o token. Então eu salvo aqui agora, deixa eu dar o focus aqui, não deu certo, deixa eu dar um inspect aqui, dar uma olhadinha. Botão, hover, focus, tá, o hover deu certo, o focus, ah, botei dollar aqui, tem que botar o A commercial. Agora sim, já ficou a bordinha de foco, ali ó, legal. E agora vamos para o restante do calendário aqui. Calendar by, width 100%, por padrão as tabelas não tem width 100%, mas como a gente já colocou flex-direction, não tem tanta necessidade, mas tudo bem. Font-family, aqui eu vou botar default, isso aqui vai botar font-roboto na tabela, que por padrão tabelas do HTML não herda a font padrão do documento. Border spacing 4 pixels, ou eu posso botar em rem, isso aqui dá 0.25 rem, posso colocar o table layout fixed. Esse table layout aqui, ele é o algoritmo que vai ser utilizado para calcular o tamanho das colunas, e esse fixed, ele basicamente determina que todas as células da tabela têm o mesmo tamanho. E isso é fixed, ou seja, se o container aumenta ou diminui, os tamanhos vão aumentar e diminuir. Isso é legal porque para o efeito que a gente quer dar, e principalmente para trabalhar com responsivo, fica muito mais fácil. E aqui eu vou pegar o th, que está dentro do thead da nossa tabela, e eu vou definir que a cor dele é um pouquinho mais escura, grade 200, o font-weight vou botar medium, uma fonte um pouquinho mais grossa, e o font-size small. E aí eu vou pegar também o thebody, before, para eu conseguir colocar um distanciamento. Isso aqui é legal porque, entre esse primeiro carinha aqui e o thehead, tem um espaço aqui no meio entre eles. Se eu pegar os elementos aqui, olha só, calendar, weekdays e frame. O weekdays e o... pronto, 12, tá vendo? Eles têm 12 pixels de distância do head, do cabeçalho, para o corpo. E não existe como eu botar uma margem, não tem como botar margem na tr, não tem como botar margem no thebody, não tem como botar margem no thehead, eles não aceitam. No display table não tem como eu botar margem nesses elementos por volta. E aí um hackzinho que eu encontrei na internet é eu colocar um elemento a mais no before do thebody, e colocar nele um content com um ponto, por exemplo, olha só que maluquice. Um line height, 0.75 rem, que daria os 12 pixels, botar aqui um display block, e colocar a cor dele com a mesma cor de fundo. Não me julguem, por favor, por esta gambiarra. Mas foi a única forma que eu encontrei de botar um espaçamento, e aí o ponto está perdido aqui em algum lugar, a gente só nunca vai achar ele. E aqui agora eu vou pegar o thebody td, que é cada célula, e a gente vai botar nela um box sizing border box, só isso. O que vai definir o tamanho da célula é o botão aqui dentro, por isso que aqui eu nem vou adicionar muita estilização, a gente vai direto para o calendar date, e esse sim é o cara que vai ter todas as informações. Então eu vou começar com all unset de novo, tira todas as estilizações, eu acho mais fácil. E aqui a gente já começa, width 100% para ele ocupar toda a largura, e aqui vem o pulo do gato. A gente vai definir nele a propriedade aspect ratio como sendo 1 barra 1. Isso aqui é muito massa, porque se a gente for ver aqui no Figma, cada uma dessas células aqui, eu quero que elas tenham a mesma largura e a mesma altura. Por mais que aqui no Figma elas não estejam com a mesma altura e largura, eu quero que elas tenham a mesma altura e largura. Não tem como eu definir a largura e a altura aqui diretamente, porque se o usuário diminuir o tamanho da tela, a largura da tabela vai diminuir, e com isso a altura ficaria fixa. Então quando eu boto a largura 100% e o aspect ratio 1 barra 1, ele vai obrigar esse botão a ter exatamente a mesma altura e a mesma largura. E aí como a largura está sendo definida com base no tamanho do componente pi, a altura também vai ser definida com base nesse valor. Então aspect ratio é uma propriedade bem legal do CSS quando a gente precisa forçar esse tipo de comportamento. Aqui eu vou definir um background grey 600, um text-align center cursor. Vamos botar aqui um pointer. Aqui a gente vai botar um border-radius small. Vamos ver como é que está ficando. Feio pra caramba, porque a nossa tabela está muito grande. Deixa eu já resolver isso aqui. Aqui dentro, deixa eu ver qual era o componente que eu resolvi isso aqui, deixa eu só dar uma olhadinha. Aqui dentro a gente vai colocar display-grid nesse container. Eu vou colocar aqui um width 540 e grid-template-columns 1fr, ou seja, só tem uma coluna no grid. Por enquanto, porque a gente ainda não criou isso com o calendário aberto. Mais pra frente a gente vai ter uma variação aqui, calendário aberto ou fechado. Isso aqui é com o calendário fechado, com a lista de horários fechada. O calendário precisa ser um pouquinho menor e por isso que eu fixo a width do calendário aqui em 540, aqui no calendar-step. Mais pra frente a gente vai ter um width aqui, então por enquanto a gente não precisa se preocupar. Mas é legal pra ver como o aspect-ratio já funcionou. A largura diminuiu, automaticamente a altura diminuiu também. Vamos voltar aqui. Aqui eu vou botar um estilo também pra focus, mais ou menos como a gente fez lá no botão. Aqui eu vou até copiar o que a gente fez no botão, box-shadow. Então aqui quando eu passo o mouse ele já faz esse foco aqui. E agora o que a gente vai fazer? Eu vou criar mais um estilo pra quando isso aqui estiver desabilitado, eu já explico o porquê. Então vai ser background-none, cursor-default e opacity 0.4. E eu vou criar um estilo de hover. Só que o hover eu vou aplicar somente se ele não estiver desabilitado. Então se não estiver desabilitado, aí no hover eu quero botar um background-grey-500, que é um pouquinho mais claro que o background padrão que é grey-600. Agora o que acontece? Eu vou desabilitar um dia aqui, só pra gente ver a diferença. Então no dia desabilitado ele não fica clicável, porque o botão com disable não fica clicável. E o dia fica mais opaco, e o resto dos dias aqui fica legal. E aqui se a gente copiasse essa linha inteira aqui e duplicasse, e colocasse dias também nos outros dias aqui, só pra estimular, o calendário ia se preenchendo. Mas por enquanto tá tranquilo aqui. É isso. Agora a gente já terminou a parte visual do calendário em si. É claro que ainda falta bastante coisa pra isso aqui ser funcional. Por enquanto clicando aqui não acontece nada. Mas vamos terminar mais essa parte estrutural aqui da direita, da lista de horários, que vai ser muito mais simples. E terminando isso aqui, a gente vai pra parte de funcionamento do calendário, que tem bastante coisa aí. Até o próximo vídeo."
  },
  {
    "id": "9f97ce28-54fa-4193-a953-40ab5657896d",
    "title": "Estrutura visual da lista de horários",
    "transcription": "Nessa aula, então, a gente vai criar essa estrutura aqui da direita de lista de horários. E para isso, o que eu vou fazer aqui no... Deixa eu fechar aqui o máximo de coisas possível. Então, Collapse, Close. Aqui dentro de Pages, Schedule, Schedule Form, Calendar, Step. Aqui dentro a gente vai ter logo um estado, uma variável que ela vai determinar se o usuário já selecionou algum dia ou não. Se ele já clicou aqui no calendário em algum dia ou não. Para determinar se a gente tem que abrir essa lista aqui da direita ou não. Mas como, por enquanto, a gente ainda não... Entendeu? A gente ainda não tem essa funcionalidade, esse botão. Tem um botão, mas ainda não tem nada por trás do calendário. Tudo fake, por enquanto, os dados. A gente vai criar aqui uma outra informação. Por exemplo, HasSelectedDate. Ou IsDateSelected. Alguma coisa assim. E aí, aqui, só para simular, eu vou botar um True. Só que a gente pode depois trocar o True para False para ver o Time Picker fechando ou abrindo. E aí, o que a gente vai fazer? Se o IsDateSelected, a gente vai mostrar um outro carinha aqui. Eu vou criar ele para aproveitar aqui dentro mesmo, dos estilos. Porque esse aqui não faria sentido ser um componente global. Eu acho que dificilmente ele é reaproveitável. Então eu vou criar ele mesmo aqui nos estilos, porque são só um conjunto de divs e botões. Vou chamar ele de Time Picker mesmo. Criar aqui como uma div. Logo a gente vai adicionar os estilos já. Mas aqui dentro eu vou fazer o seguinte. Vou mostrar o nosso Time Picker aqui, caso o IsDateSelected. É claro que aqui ele vai mostrar, só que a div é em branco. Então não vai aparecer nada visualmente aqui no Chrome. Só que o que eu quero mudar também é o seguinte. Aqui nesse nosso container, lembra que a gente colocou o width 540 e o grid-template-columns 1fr. Aqui dentro, como eu estou lidando com o Stitches, uma das coisas que a gente pode fazer no Stitches é criar variantes. Variantes são basicamente propriedades que esse componente pode receber para mostrar um formato ou outro. Trocar a estilização baseada em uma propriedade que ele recebe. E aí eu vou criar uma variante aqui chamada IsTimePickerOpen. E aqui essa variante vai ter o true, a sua versão true, e a sua versão falsa, se o Time Picker está aberto ou não. Se ele não estiver aberto, que é a versão do calendário, somente o calendário aparecendo em tela, eu vou botar isso aqui, o width 540, que é o que a gente já tinha colocado, e grid-template-columns 1fr. No caso do valor como sendo true, eu vou botar o grid-template-columns 1fr 280px, que é a da direita do Time Picker. Porém, também vou colocar aqui um media-max-width de 900px, e vou botar o grid-template-columns 1fr de novo. Ou seja, se a tela reduzir muito, eu vou fazer com que o calendário e o Time Picker fiquem um abaixo do outro, para ficar visualmente mais interessante. Então olha só, quando eu volto no Chrome agora, a nossa tela aqui já está maior, só que a gente ainda não passou aqui para ele o nosso IsTimePickerOpen como sendo o IsDateSelected aqui em cima. Então agora olha só, ele já reservou um espaço aqui na direita para o nosso Time Picker, e agora quando eu troco isso aqui para false, ele já volta para o tamanho original do calendário. Então a gente já tem um comportamento bem legal. Só que agora o nosso Time Picker aqui, por enquanto a gente não colocou nada dentro dele, mas a gente vai ter várias coisas. Posso começar até pelos estilos aqui para ser mais rápido. A gente vai ter o nosso Time PickerHeader, que ele vai ser um text que vem lá do IgniteUI React. A gente vai ter também, além do header, nós vamos ter a lista em si, que é a lista de horários, e aqui eu vou trabalhar com uma div. Nós vamos ter aqui cada um dos itens, então eu vou chamar de TimePickerItem, que vai ser um button. E é isso, basicamente são esses itens aqui que a gente vai ter. E aí aqui no nosso componente, já vamos deixar até pronto. A gente vai ter o Time Picker, como eu falei. Dentro nós teremos o nosso Time PickerHeader, que está importando, já importou automaticamente lá em cima. E aqui dentro vai estar escrito, por exemplo, terça-feira 20 de setembro. Qualquer coisa assim, eu não sei exatamente se isso é uma terça-feira, eu só estou mostrando. E aí o spun aqui é só para trocar cor, como a gente tinha feito lá no calendário também. Aqui a gente vai ter o Time PickerList, e aí dentro da lista a gente vai ter cada item. Item aqui dentro, já importou todos lá. E o item aqui é um botão, então ele vai ter basicamente o horário escrito dentro dele. Então, por exemplo, 0800H, e aí a gente vai ter vários aqui. Eu vou botar bastante para ele também, porque a gente vai ter que lidar com barra de rolagem aqui dentro. Salvo, volto aqui no Google Chrome e está lá todos os horários. E é claro, a gente precisa trabalhar na estilização desses itens aqui. Então, vamos lá rapidinho para a gente finalizar essa parte visual e poder ir para a parte funcional, que é a parte mais massa. Vou começar colocando aqui um BorderLeft de um pixelSolidGray600 e um Padding de 660. E aqui, 6 em cima, 6 nas laterais e 0 embaixo, porque como vai ter barra de rolagem, eu quero lidar com esse Padding embaixo de uma outra forma. E aqui eu vou botar um OverflowY no eixo YScroll, porque... Bom, acho que não precisa nem explicar. E aqui, para a gente conseguir... Isso é uma coisa interessante, né? É muito difícil a gente conseguir, por exemplo, essa div que está por volta. Ela é uma div com altura condicional, né? Ela é flexível, digamos assim. A altura desse container aqui é totalmente definida por base no calendário. Então, é muito difícil eu fazer um scroll, né? Se eu boto aqui Height 100%, se o conteúdo desse TimePicker aqui for maior, ele vai esticar essa div aqui. Vai jogar ela lá para baixo e aí o calendário vai ficar pequeno e tudo mais. Então, um hack que a gente tem para isso é o seguinte. Nós vamos colocar aqui nela um PositionAbsolute. Até por isso que a gente botou um PositionRelative aqui no container, que é o que está por volta do calendário e da lista. E com o PositionAbsolute, tem um hackzinho bem legal para a gente fazer com que o tamanho da nossa TimePicker, seja a altura dela, seja exatamente igual ao conteúdo que tem aqui. Que é botar PositionAbsolute e botar tanto o Top quanto o Bottom como o Zero. E ele vai definir a altura totalmente com base no restante do conteúdo dessa div aqui. Isso é bem legal. Eu vou botar o Right zero também, porque ele está totalmente alinhado para a direita. E vou botar o Width aqui 280, porque é a largura realmente que a gente vai trabalhar com esse TimePicker. E olha só, já deu certinho. A altura ficou certinha, tá vendo? Aqui a borda. E já criou a barra de rolagem aqui do lado. Eu posso deixar ela ali, não preciso nem me preocupar, porque vai ter barra de rolagem. Porque geralmente vai ter muito mais horários do que vai caber ali dentro. Aqui no Header, font-weight Medium, e a gente vai só no Span botar aquele ColorGray 200. E aí no TimePickerList, a gente vai dar um MarginTop 3, DisplayGrid. Já te explico o porquê do Grid, tá? GridTemplateColumns, por padrão, vai ter uma coluna só. E aí por que eu botei Grid? Por que eu botei Grid? Porque quando a tela for reduzida... Acho que a gente tinha botado 900 pixels lá no outro. Eu vou botar em duas colunas aqui, os horários. Então olha só, conforme eu diminuo aqui a tela... E aqui a gente vai ter que organizar, ficou meio ruim. Mas... MaxWidth... Por que ele não dividiu aqui em duas colunas? Medium, MaxWidth, 900 pixels. Tá, eu vou logo ver isso, tá? Mas a gente arruma isso daqui a pouco. TimePickerItem, vamos lá no button aqui só pra gente finalizar. Border, vou botar 0. Aqui não precisa dar um AllUnset, porque a gente já vai modificar aqui a BackgroundColor. Gray, 600. Padding, 2, 0. Cursor, Pointer. Color, Gray, 100. Border, Radius, Small. FontSize, Small. LineHeight, Base. Show, tá ficando bem legal. E aqui a gente vai ter o seguinte, eu vou pegar o LastChild. E vou botar uma MarginBottom 6. Por que? Porque lá no final eu quero que sobre um espacinho. E aqui o Padding, aqui em cima a gente tinha criado sem o Padding embaixo. Porque não funciona, tá? Eu não consigo botar o Padding aqui quando tem o OverflowScroll. E ele ficar o Padding lá embaixo, ele não fica. Então tem que botar no último elemento. E aqui a gente vai ter algumas versões também desse componente, que é... Ele desabilitado. E aí é Background, basicamente, None. Cursor, Default. Mais ou menos o que a gente tinha feito lá no calendário, né? Então eu passo de 0.4. E aqui tem a versão... Quando ele não estiver desabilitado e eu fazer um Hover. Que eu vou mudar basicamente só o Background dele pra Gray, 500. Que é um pouquinho mais claro. E aqui a gente tem também a versão Focus. Que é o nosso Box. Shadow, 0, 0, 0. 2 Pixels. Colors, Gray, 100. E aqui como eu não dei o All Unset... Ah não, já ficou legal, tá show. Perfeito. Aqui ainda ficou um pouco esquisito, comparado ao layout do Figma. Porque a gente não criou todos os dias aqui no calendário. E aí acabou não empurrando o tamanho do container. E aí ficou um pouquinho menor aqui. E também por causa do responsivo que logo a gente tem que dar uma arrumada. Mas por enquanto tá massa, a gente finalizou. Finalizou então a nossa lista aqui do Time Picker. Falta pra finalizar, digamos, de visual. Terminal responsivo e falta também a parte aqui da confirmação. Com isso a gente tem toda a parte visual pronta. E a gente tá livre pra entrar na parte funcional. Que, cara, tem bastante coisa massa. A gente vai escrever umas Queries SQL bem cablosas. Pra calcular a disponibilidade também. O próprio código front-end pra calcular quais dias aqui tem disponibilidade. Quais não tem. Qual dia começa o mês. Se é uma quinta-feira e tal. Tem bastante cálculo legal pra gente fazer. Mas no final vai ficar bem supimpo."
  },
  {
    "id": "c947da17-e8c4-471b-af5d-982abf5bca10",
    "title": "Formulário de confirmação",
    "transcription": "Nessa aula eu já vou deixar a parte do React Hook Form aqui instalada no nosso formulário de confirmação. Então eu vou chamar de Confirm Form Schema z.object. E aqui dentro a gente vai ter o nome z.string. Eu vou criar algo bem simples por enquanto. Email z.string.email e a gente vai ter as nossas Observations. É um pouco estranho, mas vai ter que ser isso mesmo. A parte de observações ela não é obrigatória, então eu vou botar aqui que ela é nullable. O Zod já entende que ela não é obrigatória. E aqui eu vou criar const useForm.resolver.zod.resolver.confirmFormSchema. E aqui register.handle.submit.formState.isSubmitting.errors. E agora eu vou pegar o register aqui e vamos jogar aqui o nome, email e aqui embaixo observations. Além disso, vamos botar o isSubmitting lá embaixo no botão do submit. Então disabled isSubmitting. O handle.submit aqui por volta do nosso método de confirmação. Vou criar aqui o type.confirmFormData que é igual a z.inform.typeof.confirmFormSchema. E aqui os erros. A gente não vai ter em todos os campos, a gente vai ter só no nome e email. O nome e email eu vou jogar aqui embaixo mesmo, depois do texto input. E agora aqui em cima, questão de validação. No nome eu vou validar só tomando 3 caracteres, no caso do email eu vou configurar a mensagem, então digite um email válido. E é isso, de resto está tranquilo. Deixa eu ver como é que eu estava fazendo o registerIndex. Estava fazendo assim também, e lá não estava dando erro. Eu tenho quase certeza que eu sei o que é, mas deixa eu restartar o servidor só para garantir. Bom, pelo jeito minha quase certeza estava errada. Está aqui, a única coisa é que nos erros, no formError, eu vou botar um sizeSmall. Está muito grande, o nome precisa de no mínimo 3 caracteres e digite um email válido. Então show, a gente finalizou aqui o nosso form, a integração com o React Hook Form. Uma coisa a menos para a gente continuar aqui a nossa aplicação."
  },
  {
    "id": "9e3fd5f9-cd2d-42d5-922b-56f97ae3aea3",
    "title": "Calculando dias do mês",
    "transcription": "Nessa aula, a gente vai começar a estruturar, escrever o código que vai criar basicamente o array de dias daqui do nosso mês. E esse código vai ser bem, não complexo necessariamente, mas ele vai ser bem interessante, porque ele envolve bastante coisa. E vamos lá, não tem muito o que a gente ficar falando aqui. Eu vou começar criando aqui uma variável, vou chamar ela de calendarWeeks. E aí por que vai ser calendarWeeks o nome? Porque vai ser um array com cada uma das semanas do mês. Perfeito? Porque vai ser mais fácil mostrar porque aqui embaixo eu preciso, acompanha comigo, cada semana ela vai ter um TR e cada dia vai ser um TD. Então basicamente o que eu quero formar aqui no fim das contas é um array, cada posição do array é uma semana com vários dias. Por exemplo, a primeira semana vai ter o dia 1, 2 e 3. A segunda semana vai ter o dia 4, 5, 6, 7, 8, 9 e 10, até completar 7 dias. 1, 2, 3, 4, 5, 6, 7, por exemplo. Porque a primeira semana não tem 7 dias completos do mês, como a gente pode ver no layout, onde o mês já começa direto na quinta-feira, então a primeira semana só tem 3 dias. Então a gente vai criar basicamente um array nesse formato aqui. Como aqui eu vou ter que fazer bastante operações de cálculo, pega o primeiro dia, calcula, vê o quanto que falou, bastante coisa, uma das coisas boas de eu fazer nesse caso aqui é usar um useMemo, porque a gente memoiza o retorno dessa função aqui e faz o cálculo dos dias do mês somente quando for realmente necessário e não toda vez que esse componente renderizar, porque vão ser cálculos não lentos, mas são custosos se a gente for pensar que pode atualizar por alguma coisa boba, que as vezes o componente pai renderizar ou qualquer coisa assim, então é legal a gente evitar. Show! Primeira coisa que a gente precisa fazer. Quantos dias existem no mês? Isso é a primeira coisa que a gente precisa fazer no mês atual, no mês que está selecionado aqui do CurrentState. Então vamos lá, a gente vai começar a fazer aqui. Days... opa, aqui eu fiz errado, tem que ser assim. Const daysInMonthArray, eu quero criar um array com todos os dias do mês. E aqui eu vou fazer o seguinte, array.from, mais ou menos como a gente já tinha feito lá em outro código, aqui no getWeekDays, array.from e tal. Então a gente vai fazer um array.from, length, e aqui a gente vai passar um tamanho do array, então eu vou pegar a data atual, currentDate, que ele é um objeto do Date.js, dentro do Date.js eu tenho vários métodos para trabalhar e tem um método muito legal aqui que é o daysInMonth, ele retorna exatamente quantos dias eu tenho no mês atual desta data aqui. No caso, dezembro de 2022, que é o meu caso aqui, no seu pode ser que seja diferente. E aí a gente vai vendo os diferentes formatos já, se está funcionando. E aí aqui agora, eu quero percorrer isso aqui, então eu vou dar um ponto map, e esse map, o que me importa aqui de dentro dele nem é o valor, porque o valor aqui, quando eu crio um array, usando o array.from, length, todos os valores eles estão com um undefined. Então não é isso que me importa, o que me importa é o i, porque o i simboliza o índice, e o índice vai de 0 até o tamanho de tantos dias que eu tenho no mês. Então, sei lá, eu não faço a menor ideia, mas vamos supor, dezembro tem 31, ele vai de 0 até 30, nesse caso. E aí aqui dentro, eu vou retornar a data atual, porém, eu vou substituir nessa data que eu estou retornando aqui de dentro, o dia. E o dia, quando a gente trata de datas no JavaScript, sempre é date, cuidado, não usa day, porque day quer dizer dia da semana. Sim, isso aí é um negócio que me dá uma agonia desgracenta, mas sim, é date, o date quer dizer o dia. E eu vou substituir isso aqui por i mais 1. Por que i mais 1? Porque como o i começa em 0, não faz sentido ter o dia 0, não existe. Então, i mais 1 porque começa em 1. Então se o mês tiver 31 dias, aqui eu estou criando um array com vários objetos de date, do date.js ali dentro, cada dia representando, cada dia sendo um objeto date, tendo o dia, então i mais 1 por aí vai. Aqui a gente pode até dar um console.log daqui a pouco, já pra gente ir visualizando como é que fica isso. E aqui, como a gente está usando essa variável currentDate aqui dentro, ela tem que ser uma dependência do nosso useMemo. Toda vez que a currentDate mudar, porque o usuário, por exemplo, mudou o mês, foi para o próximo, foi para o anterior, a gente quer recalcular esse valor daqui de dentro, então eu vou retornar esse daysInMonth array, só pra gente ver como é que fica. Cara, eu sempre faço isso, não sei porque. Inspect, console, e está lá, um array 31, porque são 31 dias que tem em dezembro, e aqui está eles, todos os dias. Então a gente pode ver, ele vai do dia 1, quinta, feira, sexta, ele já sabe certinho até dia 31, que é sábado. Perfeito, e agora a partir disso, a gente não vai conseguir já direto usar isso aqui dentro do nosso calendário, porque eu preciso saber o dia 1, ele parte na quinta-feira, certo? Então eu preciso saber quantos dias eu preciso pular, eu preciso fazer esse cálculo, digamos assim, de certa forma. E aí se eu for ver no Figma, aqui ele começa, deixa eu pensar qual é a melhor forma da gente fazer isso. Aqui eu estava pensando, porque existe uma maneira mais fácil de resolver, e eu não vou por ela. Por que? Aqui no Figma, está vendo que assim, quando os dias aqui, por exemplo, quarta-feira seria dia 31, dia 30 do mês passado. Então ao invés de deixar em branco, eu vou mostrar os dias do mês anterior aqui. Acompanhe comigo, vai ser massa. Mostrar os dias do mês anterior, só que sem possível a pessoa clicar. E aqui também, no final, eu quero mostrar já dia 1, que é o próximo, só que sem permitir a pessoa clicar, ao invés de deixar em branco. Eu acho que vai dar um visual mais bonito aqui para o nosso calendário, e deixar ele até mais reaproveitável. Mas depois você pode pensar se você quer manter isso ou não. Mas olha só que legal. O que eu vou fazer aqui? Eu quero pegar qual é o dia da semana, no caso a gente sabe que é quinta-feira, do mês de dezembro, do que eu estou gravando essa aula. Mas o dia da semana do primeiro dia do mês. Lembra que lá quando eu criei a data, que é o Current Date, eu já acertei o dia do mês como sendo 1? Ou seja, basta eu pegar o Current Date e pegar o dia da semana. Então, ponto, Get Day. Lembra que Day é dia da semana, Date é o dia. Então, se eu quisesse pegar dia 1, é Date. Dia da semana, que é o Day, aqui vai me retornar quinta-feira. Não vai retornar quinta-feira, não vai retornar zero. Eu acho que domingo é zero. Então, vamos botar First Week Day aqui para ver quinta-feira. Ele vai retornar 4. Então, quinta-feira é 4. A gente já sabe disso. E agora, o que eu vou fazer? Eu vou criar aqui um outro Array chamado Previous Month Fill Array. O que eu quero aqui? Eu quero criar um Array com os 4 itens do mês anterior. Nesse caso, que eu estou em dezembro. Deu para entender, né? Os 4 dias do mês anterior que vão preencher o nosso Array. Ou seja, que sobraram aqui, que faltaram para formar a linha inteira de dias do mês. Como que a gente vai fazer isso? Array.from Length First Week Day. Porque, olha só, quantos dias faltaram aqui? 4. O nosso First Week Day, que eu dei um console.log, ele deu 4. O First Week Day, ou seja, o dia da semana, sempre vai me retornar quantos dias faltaram para preencher a linha. Isso não é coincidência, é muito louco. E aqui agora, o que eu vou fazer? Eu vou percorrer. Isso, novamente, eu não tenho interesse no valor. Isso aqui é só no índice, porque o valor vai estar com uma Defined. E aqui de dentro eu vou retornar CurrentDate.subtract i mais um Day. Ou seja, eu estou pegando a data, que já está no dia 1, e eu estou subtraindo, ou seja, estou voltando. Está vendo? Então agora, olha só, se eu retorno esse PreviousMonthFillArray daqui de dentro para o console.log, olha só o que vem dentro dele agora. Vem os dias do mês anterior, ou seja, se a gente está em dezembro, vem novembro. Olha lá, novembro 30, 29, 28 e 27. Massa, né? Só que, para eu mostrar isso aqui em tela, no meu calendário, concorda comigo que eu não posso mostrar dia 30, 29, 28 e 27. Ao contrário, eu quero 27, 28, 29 e 30. É o reverso. E aí existe um método no Array, que pouca gente acaba usando, que é o Reverse. Simples assim. E ele faz um Reverse do Array e pronto. Está lá, 27, 28, 29 e 30. E com isso a gente já consegue, então, retornar um Array. E agora, pensa comigo, se eu retornar um Array daqui de dentro com todas as datas do mês anterior e todas as datas do mês atual, eu já começo a perceber, olha só, que eu tenho uma informação aqui que eu mais consegui aproveitar. Olha, 27, 28, 29 e 30, que são os 4 que ficariam aqui no começo. E aí, 1, 2, 3, só que ele ainda não está dividido por semanas em si. Então, daqui a pouco a gente vai repartir um Array maior em Arrays menores, mas a gente ainda não terminou. Porque, da mesma forma que eu fiz o PreviousMonthArray, eu tenho o NextMonthFillArray, que é o que está faltando aqui no final. Pode ser que eu termine, por exemplo, o último dia do mês, termine numa quarta-feira. Então, falta eu mostrar aqui 3 dias, por exemplo, do próximo mês. Então, faltam mais algumas coisas. Bora terminar, porém, numa próxima aula pra gente dar tempo de tomar uma água e ir no banheiro."
  },
  {
    "id": "839b726f-93a1-436b-b20b-18ab6b479c02",
    "title": "Rota de horários disponíveis",
    "transcription": "Nessa aula a gente vai começar a construir as nossas rotas de disponibilidade de cada usuário da nossa aplicação. E isso eu digo começar a construir porque vão ser várias rotas e elas não vão ser tão simples. Então, eu tenho duas rotas de disponibilidade, duas operações que eu posso fazer na API de disponibilidade. Uma delas que é para retornar quais datas estão disponíveis ou não estão disponíveis. A gente vai ver qual que é a estratégia aqui certinho. Dentro do mês que a pessoa selecionou. Então aqui, por exemplo, se o dia 21 está totalmente ocupado já de agendamentos, a gente deveria retornar ele como disabled para a pessoa não poder marcar. Mas também quando a pessoa clica em um dos dias, a gente tem que retornar aqui na direita somente os horários disponíveis para ela poder marcar. Ou seja, horários que ainda não tem outros agendamentos nesse mesmo horário. Então, agora a gente vai começar primeiro com essa rota que lista os horários disponíveis de um dia ou os não disponíveis de um dia, tanto faz. Porque ela é um pouco mais simples. E aí depois a gente vai para essa parte de rota que lista os dias não disponíveis no calendário como um todo. E aí, tudo isso é filtrado por usuário. O que eu quero dizer? A disponibilidade de um usuário é específica de um usuário. Por isso essas rotas eu vou criar aqui dentro de uma pasta que recebe um parâmetro username. Beleza? Então o que eu vou fazer? Aqui poderia ser o id do usuário também, mas tanto o username quanto o id são únicos, eles são índices para a gente poder buscar. Então eu acho que o username acaba ficando mais legível ali a rota, então eu vou preferir usar o username nesse caso. E aí dentro eu vou criar aqui um availability.api.ts. Essa rota aqui vai ser assim como as demais rotas que a gente tem aqui no Next. Então ela recebe o hex, o rest, vou tipar aqui certinho, então nextAPIRequest e nextAPIResponse. E aqui dentro, a primeira coisa que eu vou fazer, se o método aqui dentro for diferente de get, eu já vou dar um status 405.end, porque essa é uma rota que eu busco uma informação, uma informação de disponibilidade, então se não for feito o método get, nem faz sentido. Depois disso, eu vou buscar o username de dentro de hack.query.username. Aqui eu não consigo, não existe parms dentro do Next, então a gente busca direto de hack.query. O query retorna tanto os dados que são enviados aqui via parâmetro na rota, quanto também os dados enviados em query parms mesmo, por exemplo, localhost, 33, por exemplo, se eu mandasse uma informação dessa forma, com ponto de interrogação, ele também retornaria aqui dentro, que é de onde a gente vai obter a data. Então, aqui eu quero pegar o date de dentro de hack.query, o date vai vir através aqui também dos nossos query parms, então a gente vai chamar essa rota dessa seguinte forma, api-users-diegosf-availability, mandando a data, então vai mandar, por exemplo, 2022, 12, e o dia tanto faz, porque ele vai pegar, ah não, é o dia específico também. E aí, recebendo isso aqui, eu preciso retornar dessa rota aqui todos os horários que estão disponíveis para a pessoa marcar o horário nesse dia específico. Então essa rota tem esse intuito, que são basicamente todos os horários disponíveis que não estão ocupados. Então aqui, se a data não for informada, que isso aqui é uma possibilidade, a gente vai retornar uma mensagem de erro, então date not provided, por exemplo, algo mais simples, porque dificilmente o usuário vai cair nesse erro, porque isso é só se o front-end realmente não enviar a informação, é difícil o usuário manipular alguma coisa, um usuário que não tem conhecimento de tecnologia manipular alguma coisa para não enviar a data, então não precisa ser uma mensagem de erro muito legal. E aqui, a gente vai começar buscando o usuário do banco de dados, para ver também se o usuário com esse username aqui existe, então deixa eu importar o Prisma aqui, find unique where username, e aí podemos também checar se o usuário não existe, retornar uma mensagem de erro, então user does not exist, show de bola, e agora se tudo isso existe, a gente vai começar a buscar a disponibilidade do usuário. Primeira coisa que eu vou fazer, eu vou criar um objeto aqui chamado reference date, tanto faz o nome do objeto, porque é só para a gente transformar, usar o djs, digamos assim, dentro da data que a gente está recebendo aqui em cima do hack.query, e aqui veja que eu coloquei string, porque quando a gente recebe algo dentro do hack.query, a gente pode receber um array de string também, porque parâmetros get aqui nos query params, eles podem ser enviados múltiplas vezes, a gente pode ter isso aqui, o date1 e date2, só que isso aqui provavelmente não é o que vai acontecer, porque é o front-end que envia, a gente que determina como isso vai ser enviado, então eu só faço um string aqui para ele converter, para ele entender que esse date aqui vai ser uma string, e se for um array, vai dar bug, não tem problema, mas no front-end a gente não vai enviar essa informação como um array. E aí, primeira coisa que eu vou fazer é uma validação aqui, é caso a data que a pessoa esteja passando aqui, seja uma data que já passou, uma data que está no passado, eu não tenho nenhum horário disponível nesse dia, então isso é a primeira coisa que eu vou fazer. Ah Diego, mas mais para frente a gente não vai permitir que a pessoa clique num dia que já passou? Sim, a gente já não permite hoje, mas mesmo assim, a minha API não pode depender de validações que foram feitas somente no client-side, então a gente tem que cuidar com isso, então é bom que eu faça esse tipo de validação em todas as pontas da minha aplicação. Então, isPassedDate, eu vou começar pegando a nossa data, vou pegar o final do dia dela, então endOfDay, mais ou menos a mesma lógica que a gente tinha feito lá no client-side para não mostrar a data disponível aqui, e eu vou verificar se isso aqui é antes de hoje, se isso aqui está no passado. Se isPassedDate, ou seja, a data já foi passada, eu vou simplesmente retornar um JSON com uma propriedade availability como sendo um array vazio, ou seja, não existe disponibilidade nenhuma nesse dia. Então, isso aqui é a primeira regra que a gente vai checar. Depois disso, o que eu vou fazer? Agora, daqui pra frente, eu preciso fazer basicamente um cross, um cruzamento de dados entre o timeInterval, que é o intervalo de tempo que o usuário selecionou que ele tem disponibilidade, com os schedulings, ou seja, eu tenho que passar por esse timeInterval aqui validando se existem schedulings suficientes para cobrir todos os intervalos que o usuário tem. Se não, quais são os horários que eu não tenho schedulings ativos. E aqui começa assim, a gente vai ter que escrever um pouquinho mais de lógica, vai ter que envolver um pouco mais de regrinhas aqui dentro, mas no final vai ficar bem legal. Então, eu vou começar selecionando a disponibilidade do usuário. Então, eu vou dar um userAvailability await prisma.userTimeInterval.findFirst where userId seja igual a user.id e weekDay seja igual a referenceDate.getDay, que retorna o dia da semana. O que eu estou fazendo aqui? Eu estou buscando no banco de dados o userTimeInterval, ou seja, o intervalo de tempo que o usuário simbolizou que ele vai estar disponível, onde o dia da semana bate exatamente com a data que eu estou chamando essa rota de disponibilidade. Ou seja, eu tenho a data de referência, que é a data específica, o dia que o usuário selecionou aqui. Se ele selecionou dia 22, é uma quinta-feira, eu estou buscando lá no userTimeInterval onde for aquele usuário quinta-feira, qual que é o startTimeInMinutes e o timeEndInMinutes. Beleza? Com isso aqui em mãos, primeiro eu posso fazer o seguinte, se o usuário não tem disponibilidade nesse dia, ou seja, não foi encontrado um userAvailability, porque lembra que lá na hora que ele seleciona os horários dele, ele pode não selecionar quinta-feira, e aí aquilo não vai ter horário disponível. Ou seja, eu posso dar novamente o return res.jsonAvailabilityVazio, ou seja, ele não selecionou nenhum horário naquele dia. Se não, eu posso, ou seja, se ele tem um horário, pelo menos algum horário disponível, nesse dia, eu vou pegar as informações timeStartInMinutes, timeEndInMinutes, e agora eu preciso converter isso aqui em horas. Lembra que a gente salvou isso aqui com minutos? Então, startHour é igual a startTimeInMinutes dividido por 60, e endHour é timeEndInMinutes dividido por 60. Aqui um leve adendo, tá? A gente está fazendo aqui na nossa aplicação que a pessoa possa marcar agendamentos de hora em hora. Se não fosse de hora em hora, eu jamais poderia fazer essa divisão aqui por inteiro, porque isso aqui poderia dar um número quebrado. Porque se timeStartInMinutes, se a pessoa coloca lá que ela começa 9h15, já vai bugar aqui, já não vai dar certo. Então, a gente vai botar de hora em hora. Por isso que é super importante a gente cuidar com isso. E agora, o que eu vou fazer? Eu vou retornar, imagine que, isso aqui vai retornar, por exemplo, startHour como sendo 10 da manhã, vai retornar um inteiro, no caso, 10, e esse aqui, o end, seria 18. O que eu quero criar agora é um array com todas as horas disponíveis nesse intervalo. Então, por exemplo, 10, 11, 12, 13, 14, 15, 16, 17 e 18. Mais ou menos dessa forma. Eu quero criar um array nesse formato aqui. Pra criar um array nesse formato aqui, que são todas as horas possivelmente disponíveis, pra depois eu bater no banco pra ver se elas realmente estão disponíveis, pra ver se não tem nenhum agendamento marcado nesses horários, eu vou começar criando um array. Então, possibly times, ou possible times, possibly, possible, possible, possible times, tempos possíveis, possibly, possivelmente vezes, não, é possible times. Igual. Então, a gente vai usar aquela técnica do array.from, que a gente já usou várias vezes. Então aqui, nós vamos criar um array. O tamanho dele sempre vai ser, se a gente ver aqui, 1, 2, 3, 4, 5, 6, 7, 8, 9. Então, 9, a gente quer que, o 18, na verdade, não vai estar disponível, porque se 18 horas é quando ele acaba, o expediente, digamos assim, o último horário disponível tem que ser o 17. Concorda comigo? Porque vai dar 17 até 18. Então, 18 não é um horário disponível. Então, aqui a gente pode ver que ele tem 8 de tamanho. 1, 2, 3, 4, 5, 6, 7, 8. 18 menos 10, 8. Ou seja, o tamanho do array sempre vai ser o endHour menos o startHour. Que, na verdade, são quantos horários cabem aqui dentro. Se a gente tivesse feito quebrado, 30 em 30 minutos, o cálculo aqui seria diferente. A gente tem que pensar nisso também. 15 em 15 minutos, beleza. Pega, divide por 4 ou multiplica isso aqui vezes 4. Então, assim, tem regrinhas que a gente vai ter que cuidar. E aqui eu faço um map, igual a gente tinha feito antes. Porque o valor é sempre undefined. E eu retorno startHour mais i. Porque o i começa em 0. Então, o startHour é 10. O primeiro valor vai ser 10. E depois o i vai aumentando. Então, 11, 12, 13, até chegar em 17. Perfeito. Agora que a gente já tem o nosso array de possíveis horários, a gente tem que ir batendo no banco de dados, vendo se em algum desses horários aqui já está ocupado por algum outro agendamento. Mas vamos continuar isso aqui a partir da próxima aula. Então, por enquanto, o que eu vou fazer aqui para a gente testar se até agora está funcionando é eu vou retornar o possibleTimes aqui dentro. E aí a gente vai fazer um teste na nossa API aqui para ver se está tudo retornando certinho. Então, vamos lá. Eu vou pegar aqui localhost 3000 barra API barra Users, barra DiegoSF, barra Availability. Veja que eu já tinha acessado aqui, porque eu estava construindo essa aplicação em outro momento. Vou botar aqui dezembro e dia 20. Ele tem que retornar todos os horários disponíveis que eu tenho naquele dia. Eu não posso retornar o possibleTimes dessa forma aqui. Eu sempre esqueço. No next tem que sempre botar um JSON. E aí possibleTimes dessa forma. Então, deixa eu mandar de novo aqui. Olha lá, 8 às 17. Então, vamos validar isso aqui. Porque o dia que eu informei, 20 de dezembro, ele é uma terça-feira. Se a gente for lá no Prisma Studio, UserTimeInterval, a gente vai ver que o meu usuário aqui, que é esse carinha aqui, aqui ele até criou mais, porque a gente tentou fazer o cadastro aqui. Mas deixa eu fazer o seguinte, deixa eu deletar, vou botar para ele. Zero era domingo, então segunda e terça. Eu vou deletar todo o resto. Vou deixar aqui somente segunda e terça-feira. Terça ele trabalha das 8 até 1080, que deve ser 18. Vamos trocar aqui de 480 para 600, que deveria ser às 10 horas da manhã. Agora eu dou um F5 aqui. Veja, ele já começa às 10 horas da manhã. E aí se eu boto aqui que ele termina às 5, então 1020, volto e pronto. 16 horas é o último horário. Então a gente já está conseguindo chegar até aqui. O que eu preciso agora? Para cada um desses horários aqui, eu preciso ver se já não existe um scheduling, ou seja, e aqui ele não mostra a tabela porque a gente acabou de criar, ele não rodou o Prisma Studio de novo, mas não tem problema, se existe algum agendamento já marcado nessa hora. Se sim, eu não posso retornar isso aqui também. Mas vamos continuar que vai dar boa."
  },
  {
    "id": "342bcdeb-129d-4693-af28-045607f759d9",
    "title": "Exibindo horários disponíveis",
    "transcription": "O que a gente vai fazer nessa aula agora então é mostrar aqui na tela os horários, os disponíveis e os não disponíveis também. Mas antes disso eu vou criar aqui uma interface chamada Availability, que ela vai simplesmente marcar a tipagem aqui do meu objeto de disponibilidade, que eu vou salvar no estado. E aqui é muito simples, eu vou ter o possible times, que ele é um array numérico, e eu vou ter o available, que é um array numérico, um deles são todos os horários possíveis e aqui são só os disponíveis. Então o que acontece, eu vou listar todos os possíveis, mas deixar habilitados somente os disponíveis. Então aqui agora no useState eu falo que ele pode ser um objeto nesse formato ou nulo caso ainda não esteja carregado. E aí lá embaixo, ao invés de fazer o console.log, eu vou dar um set availabilityResponse.data e aqui embaixo no timePickerList eu vou fazer um availability.possibleTimes, tem que cuidar com o ponto de erogação aqui, ele precisa existir né, porque pode ser nulo no primeiro momento. E aqui eu vou pegar a hora, e aí aqui dentro eu vou retornar um timePickerItem, vou remover os outros aqui dentro, e aí é o seguinte, aqui agora no lugar de 8 eu vou botar string hour.padStart 2 e 0, porque se o horário for abaixo de 10, por exemplo 9 e 8, ele vai ter um caractere só, então eu preencho com 0 no começo pra ficar 2 caracteres sempre. E aí aqui a gente precisa botar a nossa key, que eu vou botar a hora né, porque nunca vai ser repetida. O nosso timePickerItem, a gente tem uma estilização dele pra disabled, então ele vai estar disabled caso exista esse hour aqui dentro do nosso, ou melhor, se não existe o hour dentro de availableTimes né. Então ele vai estar disabled caso não exista dentro de availability.availableTimes o nosso hour. Show! E agora a gente pode ver como é que ficou, então olha lá, já deu certo, 10 horas tá disabilitado, 11 e o resto tá tudo habilitado, se eu troco de dia aqui, por exemplo dia 21, aqui ele deu erro, provavelmente porque, vamos dar uma validada aqui, deixa eu dar uma olhada no console, deixa eu retornar aqui, clicando dia 21 ele dá erro, vamos dar uma olhada porque, cannot read properties of undefined reading map, deixa eu validar isso aqui. Tem algum outro console.log aqui que a gente esqueceu no código, que tá me atrapalhando um pouco, então deixa eu procurar aqui, calendarWeeks, esse carinha aqui, show, clico no dia 20, aparece, possibleTimes e availableTimes, quando eu clico no dia 21, ele mostra availability array 0, já lembrei, lá na nossa API, tá legal que a gente chegou nesse ponto, em alguns momentos a gente retorna availability como um array vazio, só que é importante que a gente retorne no mesmo formato, então eu vou pegar isso aqui, selecionar os dois lugares onde pode retornar vazio e retornar pelo menos no mesmo formato, possibleTimes vazio, availableTimes vazio. E aí agora teoricamente, se a gente clica dia 21, pronto, ele não mostra nada, isso não é um problema, porque mais pra frente, nas próximas aulas, a gente quer desabilitar o dia 21 por completo aqui, então a pessoa não vai conseguir nem clicar, mas tudo bem não retornar nada, então dia 20, 22, 23, 24, a gente tinha só segunda e terça, então segunda aqui vai aparecer, todos os horários disponíveis, tá vendo, aqui até quebrou um pouquinho, certo seria a gente dar uma reduzida aqui um pouco no texto, aumentar o container aqui, mas não tem problema por enquanto, show de bola, agora a gente já conseguiu seguir bastante, falta, claro, a gente ainda bloquear alguns dias aqui e terminar o processo de scheduling lá com o formulário pra agendar um novo compromisso e conectar isso com a API do Google pra criar também o evento lá dentro do calendário da pessoa, então a gente tá perto do fim, mas ainda tem bastante coisa, bora lá."
  },
  {
    "id": "e4204328-b35f-40a1-94e9-8e77ce72f2f7",
    "title": "Bloqueando dias da semana",
    "transcription": "Nessa aula a gente vai começar a criar a nossa rota que vai retornar as datas bloqueadas aqui dentro do calendário. Então a gente precisa retornar, por exemplo, em dias como dia 22, que não tem nenhum horário disponível, e até dias, por exemplo, dia 20, onde a gente até tem horário disponível mas que a gente tem schedules cobrando todos os horários disponíveis, a gente tem que retornar aqui no calendário que essas datas não estão disponíveis, elas ficarem desabilitadas assim como essas outras datas aqui que a gente colocou que não estão disponíveis porque já passaram. Então, vamos lá, vou começar criando aqui dentro de API Users também, dentro de Username, porque as datas são relativas a um usuário específico, e aqui eu vou chamar de BlockedDates.API.ts e aqui eu vou até copiar o Availability porque vai ser semelhante a estrutura da rota aqui, eu vou retornar aqui um JSON vazio, o Prisma eu vou utilizar daqui a pouco, o Date.js também vou utilizar, mas a gente começa validando que o método é GET, porque novamente é uma rota que eu vou estar buscando uma informação, e aqui a gente vai fazer algumas coisas semelhantes com o que a gente fez lá no Availability, então posso até copiar aqui até a checagem se o user existe, porque a gente também vai pegar Username, porém aqui de dentro do Hack.query a gente não vai buscar apenas o Date, a gente vai pegar Year e Month, por quê? E aqui dentro do Chrome, dentro da nossa aplicação, a gente quer retornar os dias disponíveis em um mês específico dentro de um ano específico, e aí ao invés de eu mandar para o back-end algo como, por exemplo, 2022-12, que seria o mês, eu acho que vai ser ruim, a gente vai ter que fazer um split, vai ter que tratar isso aqui porque não dá para converter diretamente para uma data, então a gente manda o ano e o mês separado para ficar mais fácil do back-end conseguir entender isso, e aí se eu não tiver o mês informado ou não tiver o ano informado, um dos dois, a gente bota Year or Month Not Specified ou qualquer coisa parecida com isso. Show, e aí a gente valida se o user existe e pronto, acabou as validações e agora a gente vai para começar a calcular as datas. Primeira coisa que a gente tem que fazer, eu vou procurar quais são os dias que o usuário tem disponibilidade, os dias da semana, porque a primeira coisa que a gente quer bloquear aqui que está ruim, por exemplo, é dia 21, dia 21 o usuário não tem disponibilidade, esse usuário aqui, se a gente for até no banco de dados, o meu usuário, ele tem disponibilidade somente segunda e terça, então quarta, quinta, sexta, sábado, domingo, são dias que eu já tenho que retornar que eles não estão disponíveis desde o começo, então a primeira coisa que eu vou fazer é procurar os dias da semana que eu tenho disponibilidade, então por exemplo, Prisma UserTimeInterval.FindMany, SelectWeekDayTrue, porque eu quero pegar apenas o dia da semana, não preciso pegar os outros campos, Where, UserID é igual a UserID, pronto, depois isso aqui já me retorna uma lista, um array com vários weekdays, de 0 até 6, representando o dia da semana, que o usuário tem disponibilidade, se o dia da semana não está aqui nessa lista, o dia da semana aqui do nosso calendário, ele já não, opa, eu fechei aqui, ah não, estava aqui, o dia da semana não está aqui, ele já não tem que nem aparecer disponível aqui no calendário, beleza, isso aqui pronto, a gente ainda vai trabalhar com essa informação, então o que eu vou fazer aqui agora, eu vou fazer um const blockItWeekDays, quais são os dias da semana que eu quero bloquear, que são todos os dias da semana, tirando o que ele tem disponibilidade, então aqui eu poderia fazer array.from que a gente fez, mas como o dia da semana é pouquinha coisa, eu vou fazer aqui, 0, 2, 3, 4, 5, 6, mais rapidinho, e aqui eu já faço um filter weekdays, e eu preciso verificar, eu quero manter aqui apenas os bloqueados, ou seja, os que o usuário não tem disponibilidade, então os que não, eu vou retornar os que não tem, e aqui some available weekdays, .weekday igual a weekday, então eu estou retornando os que não estão nessa lista aqui, eu vou retornar daqui de dentro, e aí eu já vou pegar e vou retornar daqui de dentro mesmo, então show de bola, e bora começar a testar isso aqui, o DJS eu vou comentar por enquanto, porque a gente não está utilizando, API users DiegoSF, e agora é blockItDays, year 2022, month 12, show, olha só, domingo, quarta, quinta, sexta e sábado, ele não tem disponibilidade, então são alguns dias que a gente já pode começar a trabalhar para não mostrar lá dentro do nosso calendário, então já vamos começar fazendo isso, eu vou lá para dentro do nosso calendário, então vamos copiar aqui do CalendarStep, essa nossa chamada API aqui para a gente aproveitar ela, e aí aqui dentro do Calendar nós temos este carregamento aqui do CalendarWeek, e aí eu posso ou manter esse componente aqui desconexo, digamos, de qualquer chamada API para ser um componente aproveitável entre várias aplicações, ou eu posso fazer a chamada API aqui dentro dele mesmo, eu acho que é melhor a gente manter ele desconexo, então o que eu vou fazer tá, lá dentro do CalendarStep, aqui que é onde a gente chama o calendar, aqui no calendar eu vou receber uma propriedade chamada blockItDates, que é igual a um array com várias datas, e agora aqui dentro eu vou, se bem que não vai rolar botar aqui, porque a parte de controle do mês atual tá aqui dentro do calendário, então ficaria ruim, vou fazer dentro do calendário mesmo, não tem problema tá, aqui então a gente vai pegar e vai fazer a requisição aqui dentro, vamos lá, vamos importar o useQuery, e aí vou criar uma interface aqui em cima, é blockItDates, ela tem uma propriedade que é o blockItWeekDates, que é um array numérico, e aqui então esse nosso caninho aqui vai retornar blockItDates, aqui eu vou chamar também de blockItDates, aqui blockItDates, e aqui eu preciso retornar, aqui eu tenho o ano e o mês, porém eu vou trabalhar com essas informações num formato diferente, deixa eu só pegar aqui a minha cola só pra eu lembrar como é que eu fiz esse formato aqui, então aqui a gente vai fazer o seguinte, eu vou chamar a nossa API, o username precisa vir da rota, então const router é igual a useRouter, const username é igual a string router.query.username, aí eu tenho o username ali dentro, esse enabled aqui não precisa, ele vai executar porque já vem o mês pré-selecionado aqui no currentDate, e aqui a gente vai enviar year currentDate.getYear e month currentDate.getMonth, e aqui na chave a gente precisa também passar o ano e o mês pra ele saber como fazer o cache por ano e por mês, e pronto, são as variáveis que a gente usa aqui, e aqui no availability é blockedDates, show, salvo isso aqui agora, e agora, aqui dentro do calendarWeeks, que é aquela função que a gente usa pra calcular os dias do calendário disponíveis, a gente vai passar o blockedDates aqui também dentro da rede de dependências, porque quando o blockedDates mudar, seja por qual motivo, eu quero recalcular isso aqui, e aqui dentro onde os dias do mês que podem estar apenas hoje desabilitados, caso eles já passaram, eu vou colocar uma regra a mais aqui dentro, então, os dias do mês podem estar desabilitados caso aquilo já passou, ou o blockedDates.blockedWeekDays inclui o date.getDay, que é o dia da semana, eu acho que é isso, né? Deixa eu até validar aqui na minha cola, seria isso, exatamente, exatamente, salvo aqui agora, voltamos ao Chrome, vamos lá no calendário, e olha só, prontinho, todos os dias da semana, quarta, quinta, sexta, sábado, eles não estão disponíveis porque aqui no Prisma eu só tenho segunda e terça, então se eu vou pro próximo mês, olha só, só segunda e terça fica disponível, se eu volto, como eu tô usando o React Query, ele já tá isso instantâneo, não precisa nem carregar, então é um carregamento muito rápido. Show de bola, então a gente já tem aqui os dias da semana disponíveis, os horários disponíveis, já tá ficando bem legal, só que ainda tem um problema, se a gente tem algum dia da semana que tem todos os horários ocupados, e aí pra facilitar isso, o que eu vou fazer? Eu vou pegar, por exemplo, terça-feira, que é aqui o WeekDay2, e eu vou falar que ele só tem dois horários disponíveis, então 600 até 720, pra dar duas horas, então a gente volta aqui na aplicação só 10 horas e 11 horas, com o horário disponível, vou lá em Scheduling, vou criar um novo Scheduling, vou copiar a data aqui do de baixo, vou botar em cima, 14, 14 menos 3 daria 11, que é o único horário que eu tenho ali disponível, aqui novamente posso botar qualquer coisa, só pra ele marcar, e aqui no User seleciono o DiegoSF, que é o usuário, que é o usuário, tem que clicar fora aqui, que eu tô querendo marcar, aqui ele perdeu o horário aqui, deixa eu botar de novo, 14 horas, show, save. Aqui na aplicação, não tá mais disponível, ou seja, se eu der um F5 agora, o dia 20 aqui não deveria estar mostrando, porque todos os horários aqui estão ocupados, então a gente tem que fazer uma query agora pra validar esse tipo de situação."
  },
  {
    "id": "195d523e-d39f-4837-8be9-fea13ea0ec4c",
    "title": "Bloqueando horários no passado",
    "transcription": "Antes da gente continuar aqui e terminar nossa rota de agendamento, bora aqui na nossa rota de availability aqui. Inclusive eu finalizei o projeto todo, então vou ter que rodar tudo de novo, porque é um novo dia de gravações e com isso eu sempre encerro tudo. Mas basicamente... Ah tá, eu esqueci de rodar o banco de dados. Tá, mas tudo bem. Enquanto vai rodando ali, o que a gente precisa fazer, que eu tinha falado que ficou faltando na última aula, é aqui na rota que retorna os horários disponíveis, hoje a gente está retornando inclusive horas que já passaram. Então aqui em available times, além da gente verificar, eu poderia pra ficar um pouquinho o código mais legível aqui. Eu vou separar em constantes, em variáveis diferentes, pra gente ficar mais fácil de entender o que é cada verificação que a gente está fazendo. Então, por exemplo, isTimeBlocked vai basicamente retornar essa condição que a gente estava fazendo de procurar dentro do blocked times se aquela data está lá. E eu vou pegar uma outra aqui, isTimeInPassed. E aí, essa aqui o que eu vou fazer? Eu vou pegar o referenceDate, que é basicamente a data de referência que a gente estava criando aqui em cima. A gente utiliza ela pra... Bom, é a data de referência, o dia que a pessoa selecionou. Ponto. setHour como sendo o time que a gente tem aqui em cima, que é o horário. Ponto. E aqui, isBeforeNewDate. Basicamente, eu estou validando se a hora que a gente está percorrendo aqui está no passado. E aí, ela só vai estar disponível caso ela não esteja blocked e também caso ela não esteja no passado. Acredito que seja isso. Vou inicializar minha aplicação agora, já com o banco de dados de pé. E agora, se eu volto lá na aplicação, o problema é que agora, como já passou um dia aqui, eu estou no dia 21 e no dia 21 a gente tinha selecionado que o usuário não tinha nenhuma data disponível. Então, vamos pegar aqui. Abrir o Prisma Studio. Sem pressa. Vamos no UserTimeInterval. E vamos pegar aqui, por exemplo, do dia da semana que estava pra... Isso aqui começa domingo, segunda, terça. Então, a gente troca isso aqui pra três, que seria quarta-feira. Volta e pronto. Já está ali. O dia 21 agora já está disponível porque é quarta-feira. Se eu clico aqui agora, o horário das oito e das nove não está mais disponível porque todos os horários disponíveis ali já tinham passado. E aí, claro, a gente teria que talvez pensar em retirar isso aqui do calendário. Mas eu não vou ficar também fazendo todas as regras do mundo aqui. Eu acho que não é o ponto. Pra gente validar que realmente só está funcionando, que está funcionando, eu vou colocar aqui pra finalizar o horário também um pouco mais tarde. E pronto. Olha só. Agora são dez e quarenta e sete. O único horário disponível próximo é das onze horas. Porque é o próximo horário disponível validando que eu não posso selecionar horários que já passaram. Legal, né? Então, a gente finalizou essa parte de disponibilidade de horários. E agora a gente vai começar a pegar esses dados da data selecionada, o horário selecionado, pra conseguir fazer o cadastro do Scheduling lá dentro da API. Então, bora lá."
  },
  {
    "id": "be15738d-a56d-493e-9824-0ba3dfde0012",
    "title": "Configurando API do Google",
    "transcription": "Nessa aula, a gente vai criar a configuração para a gente trabalhar com a API do Google. E para isso, a primeira coisa que eu vou fazer já é instalar a Google APIs aqui dentro. E aqui eu não vou forçar a versão nenhuma, vou instalar a versão que vier. A última vez que eu tinha instalado era 105. Dificilmente deve ter mudado muita coisa. Deixa eu ver. 109, mas não deve ter muita coisa, espero, na mudança na sintaxe. A gente vai começar aqui dentro de lib, criando um arquivo chamado google.ts. E aqui eu vou começar criando uma função, assíncrona mesmo. E ela vai se chamar... deixa eu ver aqui qual seria o melhor formato. getGoogleOauthToken E aqui ela vai receber o userId como uma string. O que eu quero fazer nessa função? Para a gente acessar a API do Google, a gente precisa do token de autenticação, que é basicamente essa informação aqui, o accessToken. Só que esse token pode ser que ele já esteja expirado, já tenha passado essa data aqui. E aí a gente precisa atualizar o token usando o refreshToken e retornar o novo token válido. Então essa função aqui vai ser basicamente a função que sempre vai ser chamada quando a gente for se comunicar com a API do Google. E essa função vai automatizar esse processo. Ela vai bater no banco de dados, vai ver se o token já expirou ou não expirou, e vai atualizar ou não as informações. Então, olha só o que eu vou fazer aqui dentro. Eu vou começar buscando account where, ou melhor, prisma account, find first, where. E aqui a gente vai receber provider Google, userId igual a userId. O que eu estou fazendo aqui? Eu estou procurando o registro na tabela account, onde o userId for o que estou recebendo em parâmetro, e o provider for Google. Deixa eu até importar o prisma aqui, de ponto barra prisma, que é o arquivo que a gente tinha criado antes aqui da conexão. Ou seja, aqui agora eu tenho basicamente a informação que eu preciso para eu conseguir operar, para obter informações se o token já está expirado, para saber o accessToken e tudo mais. E aqui a primeira coisa que eu vou fazer, seeAccount. Ou melhor, nem preciso, eu posso trocar aqui o método até para findFirstOrThrow. Daí eu nem preciso validar se o account existe. Mas o account com certeza tem que existir aqui na nossa aplicação, porque a gente só tem login com Google. E aqui eu vou começar criando um objeto auth, que ele vem de new Google. Deixa eu ver se ele traz o autoimport. Olha, ele já importa Google de dentro de GoogleAPIs.auth.oauth2. E aqui eu preciso passar para esse auth2 basicamente o nosso clientId e o nosso clientSecret. Então nós vamos passar basicamente process.env.googleclientId e process.env.googleclientSecret. E aí agora a gente vai dar um auth.setCredentials, que são as nossas credenciais de autenticação, e nós vamos passar para ele basicamente o accessToken, que vem de account.accessToken, o nosso refreshToken, que vem de account.refreshToken, e o nosso expiryDate, que vem de account.expiresAt. Perfeito, com isso a gente já está autenticado na API do Google. Porém lembra que eu falei que o nosso accessToken pode estar expirado. Se ele estiver expirado, a gente não consegue usar ele. Eu não consigo fazer operação nenhuma aqui que não seja a operação de atualizar o token. Primeira coisa que eu vou fazer então é verificar se eu preciso atualizar o token, ou seja, se o token já está expirado. Então eu posso até fazer o seguinte, if token expires, para ficar um pouco mais semântico. O que eu vou fazer aqui agora? Eu vou utilizar o Date.js novamente, e eu vou pegar o nosso account.expiresAt vezes 1000. Então o expiresAt é salvo em epoch.timestamp. Então o que acontece? Quando a gente salva isso aqui no banco de dados, deixa eu até jogar ele aqui dentro, olha só, a timestamp to human date. Isso aqui representa quarta-feira, dia 21, 15 horas e 21. Ou seja, a gente até pode ver, só que na minha timezone é 12 horas e 21. Então ele tem uma hora de expiração, está vendo? Isso aqui é o Unix timestamp. Só que isso aqui é em segundos. Quando o Date.js vai ler, ele precisa disso aqui em milissegundos. Por isso que aqui eu passo para ele em milissegundos. Isso por quê? Porque lá dentro do nosso esquema, a gente falou que no account o expiresAt é um número que pode ser nulo. Então aqui, dificilmente ele vai ser nulo, mas eu vou fazer o seguinte, se account.expiresAt, vou fazer um if aqui embaixo, talvez se eu não tiver um account.expiresAt, que provavelmente quer dizer que não expira, eu vou retornar daqui de dentro o nosso objeto Auth mesmo e não vou executar o restante do código. Que é o que eu vou retornar depois, só que com o token atualizado. Então eu estou meio que entendendo que se não tiver uma data de expiração, o token não expira nunca. E aí o retorno Auth mesmo dificilmente vai cair dentro desse código aqui, porque o token do Google eu sei que expira. E aqui embaixo, então, a gente vai validar se essa data aqui é before agora. Misturar inglês com português. Então eu estou validando se a data de expiração do token é anterior à data atual. Se for anterior à data atual, eu preciso atualizar esse token. E aí como que eu vou fazer? Eu vou basicamente fazer o seguinte, const, não vou desinstruturar nada por enquanto, mas eu vou simplesmente executar o método auth.refreshAccessToken, simples assim. E ele retorna pra gente aqui dentro, se eu dou um CTRL espaço, esse credentials. E dentro do nosso credentials, vou até fazer a desinstruturação separada aqui, olha só, a gente tem acesso a todas as informações desse token de novo. Que pra gente, o que importa pra gente aqui, posso pegar o accessToken, o expireDate, tem que cuidar só o nome que ele dá aqui, o idToken, várias informações, o refreshToken, a gente tem o scope e tem o token type. São todas as informações retornadas aqui no credentials. E por que eu peguei cada uma delas aqui? Porque agora, o que a gente vai fazer é salvar isso aqui dentro do Prisma. Pra que a gente tenha, a próxima vez que a gente for trabalhar com os dados desse usuário, a gente já tenha esse token atualizado. Então aqui, updateWhereId, account.id, eu já tinha buscado o account aqui antes, então eu posso reaproveitar o mesmo id aqui pra atualizar. E o data, aqui a gente vai enviar cada uma das informações que a gente tem aqui dentro. A única coisa é que o expireDate, aqui a gente tem que cuidar, porque no banco, como eu falei, ele precisa ser salvo em segundos e não milissegundos. E aí meu interfone começou a tocar, meu cachorro não vai berrar? Estranho. A gente precisa salvar ele em segundos, então eu preciso dividir ele por mil. Então, aqui eu vou usar o math.floor, só pra ele fazer um leve arredondamento ali. Então eu vou pegar um expireDate, dividido por mil, pra gente salvar isso em segundos. E a gente salva isso em segundos no banco, porque assim a gente ocupa menos espaço, digamos assim. Então a gente consegue salvar dentro do inteiro, ao invés de ter que criar um BigInt, alguma coisa assim. E aqui o nome não é expireDate, é expireAt. E aqui expireDate is possibly null or undefined. Ah, ele pode retornar como null ou undefined também. Então, aqui eu vou fazer o seguinte, se eu tiver um expireAt, se não eu salvo nulo. Dessa forma aqui eu acho que já resolve tranquilamente. Talvez quebrando linha aqui, não deixa. Então tá bom. Show. Agora que a gente já fez a atualização dentro do Prisma, o que a gente vai fazer aqui no final, depois de atualizar a account, é auth.setCredentials, executar esse mesmo método aqui em cima que seta as credenciais de trabalho com a API. Só que agora a gente vai usar as informações que vieram aqui do refresh. Então, o accessToken que veio dali de cima, o refreshToken que veio dali de cima e o expireDate que veio daqui de cima também. Que veio do processo de refresh. Eu só tô olhando aqui porque aqui, quando eu dou setCredentials, expireDate, aqui também tem que estar multiplicado por mil. Porque isso aqui vem do banco. E aí eu vou fazer só uma verificação simples aqui. Se não, nulo. Show. E agora, no final de tudo, aqui eu preciso retornar auth, que é o nosso objeto de autenticação. E com isso, pronto. Sempre que a gente chamar essa função, passando um userId, ela vai fazer todo o processo de se autenticar com o Google. E caso a autenticação não tenha conseguido ser feita por causa do token expirado, ela vai já também fazer o refresh do token. E agora a gente já consegue criar o evento lá no Google dentro da API. Então, bora fazer isso."
  },
  {
    "id": "04b1f799-c3fe-4ff7-aeac-5b7de45d580b",
    "title": "Configuração do ESLint",
    "transcription": "Nessa aula a gente vai configurar uma das coisas mais importantes aí no desenvolvimento da aplicação que é o SLint, para ele facilitar a gente a manter padrões de código. O SLint já vem instalado aqui dentro do Next, a gente optou por instalar ele. E ele vem, o SLint e o preset do SLintConfigNext com algumas configurações, até se a gente acessar aqui o SLintRCJSON, ele traz apenas o extends aqui no NextCoreWebVitals, mas a gente poderia estender caso a gente quisesse a toda a parte de configurações do Next. Mas como aqui na Rocket a gente tem uma configuração de SLint própria, o que eu vou fazer aqui é instalar a nossa configuração, então rocketsheet barra SLintConfig, menos D, aguardar um pouquinho, show. E agora aqui dentro de extends eu vou colocar um array, eu vou continuar estendendo o NextCoreWebVitals, porque ele vai trazer algumas opções de linting específicas para a Next, para a gente manter a nossa aplicação mais performática, que não são cobertas nessa config padrão de SLint da Rocket, até porque ela não é feita especificamente para a Next, mas sim para a React no geral, então a gente geralmente estende as duas. Aqui eu vou estender então rocketsheet barra SLintConfig barra React, e também o NextCoreWebVitals. Aqui outra coisa que eu gosto já de fazer, deixa eu ver se ele já tem aqui, isso, ele já tem um script de lint, então isso é uma das coisas importantes, porque assim a gente já pode, agora que a gente instalou, rodar aqui o lint para ver, ele já traz vários errinhos aqui. Vou tentar fazer o fix automático, na maioria deles né, e alguns aqui ele não conseguiu, não sei se ele, eu acho que ele não passou o fix aqui para o comando, porque isso aqui é até uma dica legal, quando você cria um script no npm, se você tenta rodar e passar um comando, assim, por exemplo fix, o npm não sabe que esse traço traço fix aqui é um parâmetro, uma flag, para o comando do lint, ele acha que é uma flag para o npm, então quando eu quero passar parâmetros, ou flags, ou qualquer tipo de informação, para dentro deste comando aqui, eu preciso usar o traço traço, e aí sim eu boto os comandos, então tudo que eu boto depois do traço traço, vai ser repassado para o comando next lint, e não para o npm, vamos ver se assim ele vai, fiz uma explicação toda, show, resolveu, então a gente pode ver que agora sim, ele fez todos os ajustes de lint, de preview, em todos os componentes aqui, em todas as pastas e arquivos que a gente tinha aqui dentro da nossa aplicação, aqui ele traz inclusive uma hello world aqui na rota, a gente vai customizar isso depois, mas show, a gente já configurou o lint e vamos continuar com o desenvolvimento do nosso echo"
  },
  {
    "id": "3d9e924e-1301-4ed4-a9ae-dc6b10f33731",
    "title": "Estrutura visual da home",
    "transcription": "Nessa aula, o que a gente vai fazer é a estrutura da nossa página home. Então, lá no Figma, que você tem acesso aí embaixo pela aula, é só acessar o Figma, a gente vai criar basicamente essa página aqui. Então, o que eu vou fazer? Eu preciso exportar essa imagem aqui da direita. É a única imagem que a gente vai utilizar ali dentro. Ele até tem uma imagem de fundo aqui, tipo uma gradinha ali, mas não necessariamente isso a gente vai fazer. Não é o foco aqui da gente no desenvolvimento dessa aplicação, a parte visual, digamos assim. E aqui a gente vai, inclusive, criar um componente a mais. Porque aqui eu tinha colocado uma opção de criar conta com o Google, mas eu vi que a maioria dessas ferramentas seguem um fluxo um pouco diferente. Aqui na Home, já pede para a pessoa colocar o usuário que ela quer utilizar na ferramenta. Então, para criar um fluxo sem muitas barreiras de entrada, já pedia com o uso do Google da pessoa aqui no começo. Então, a gente vai deixar para pedir a conta do Google somente lá na hora que ela for conectar a agenda. Então, fica uma barreira de entrada menor. Então, o que eu vou fazer? Eu vou clicar aqui, eu vou exportar a imagem. Copy as png? Não, quero export image png. E a gente vai www.ignite. Aulas, Ignite Call. Dentro de Source, vamos criar uma postinha aqui dentro. Assets. E eu vou chamar esta imagem de App Preview. PNG mesmo, né? E aqui a gente vai começar, então, a criar a nossa Home. Como a nossa Home vai ter alguns estilos, eu não gosto de deixar a Home aqui no index.page.txt porque a gente teria que colocar os estilos aqui dentro também. Então, styles.ts não fica tão legal. O que eu gosto de fazer no Next para criar a página Home? Eu gosto de criar uma pasta chamada Home. Aí eu crio aqui dentro um index.page.txt, que vai ser a mesma coisa que isso aqui. Posso até reaproveitar e jogar aqui dentro. E aqui eu crio styles.ts. E aí o que eu faço? Nesse index aqui, que vai ser a Home em si, na verdade, nesse Home aqui, eu não coloco o page.txt. Para ele não criar uma rota localhost 3000 barra Home. Isso aqui não é legal de existir, porque a Home não vai ter nada. Então, eu não coloco o page.txt. Eu deixo o page.txt somente nesse aqui, para eu entender que somente isso aqui é a rota Home. E dentro desse aqui, eu faço basicamente uma re-exportação. Então, eu faço o seguinte. Eu export. E aqui eu posso usar a sintaxe from Home. E aqui eu posso simplesmente exportar o default. Dessa forma aqui. Aí ele vai basicamente abrir o arquivo index, pegar o export default que tem aqui dentro e re-exportar ele. Então, esse arquivo index é obrigatório existir, mas a gente trabalha com a nossa Home num arquivo separado. Esse styles não tem nada aqui dentro. Agora a gente vai começar a criar a estrutura aqui da nossa página Home em si. Então, deixa eu tirar isso aqui. A gente vai começar com parênteses aqui dentro. E eu vou começar fazendo o seguinte. A gente vai ter... Precisa de uma div, primeiramente, para centralizar isso aqui. Então, eu vou criar aqui dentro dos styles. Para criar as estilizações, a gente vai importar de dentro do ignite-ui-react. Um carinha chamado styled, que é do Stitches. E aqui dentro eu vou começar exportando container, que vai ser um styled div. E a gente vai exportar daqui de dentro também, outros dois carinhas. Que é esse da esquerda e o container aqui da direita. Então, esse da esquerda aqui, eu vou chamar ele de hero, styled div. E o da direita eu vou chamar de preview, styled div também. Então, basicamente, três containers. O que engloba tudo aqui para centralizar a aplicação. Um da esquerda e um da direita que vai a nossa imagem. Então, aqui eu vou começar jogando esses elementos em tela. Então, container, vamos ter o hero. Hero é um nome muito utilizado em landing pages. Por isso que eu botei hero. Hero, geralmente, é o call to action. Quando você tem uma landing page que tem algum call to action, o slogan, digamos assim, da aplicação, com algum call to action rápido, alguma ação para o usuário fazer ali, a gente chama isso de hero. Mas você pode dar um nome que você preferir no fim das contas. Aqui dentro, então, a gente vai ter o hero e vai ter o preview. Dentro do hero aqui, que é aquela parte da esquerda, a gente vai ter um heading, que vai ser do ignite.ui.react, que é o texto ali, agendamento descomplicado. A gente pode até copiar isso aqui já e colar aqui dentro. E a gente vai ter um texto, que ele vem de dentro do ignite.ui.react, que ele já vai fazer a importação automatizada, que é esse texto que tem aqui embaixo. Posso copiar ele também e colar aqui embaixo. A única diferença é que o nosso heading aqui, no nosso design system, a gente tem alguns tamanhos. Então, se eu passo a propriedade size para ele, a gente pode ver que aqui ele tem vários tamanhos. O tamanho que a gente vai utilizar aqui é o 4XL. E o texto também tem alguns tamanhos, está vendo? Vários tamanhos aqui dentro. A gente vai estar utilizando aqui o tamanho large, que é um pouquinho maior que o padrão de 16 pixels, que é o median. E aqui embaixo depois a gente vai ter um formulário, não vai ser esse botão do criar conta com o Google, acabei não colocando no Figma, mas sem problemas nenhum. E aqui no preview a gente vai ter a nossa imagem, mas eu preciso importar essa imagem aqui dentro, então eu vou fazer aqui um import preview-image-from . . . . .assets-app-preview.png se não me engano foi o nome que a gente deu para a nossa imagem. E aí agora a gente vai utilizar o componente do next-image para botar a nossa imagem em tela. Sempre que a gente for colocar uma imagem dentro da nossa aplicação, principalmente imagens que são estruturais, imagens que não são inputs do usuário, como imagens de avatar, que nesse caso também pode utilizar, mas principalmente essas imagens que são assets da nossa aplicação, que são arquivos locais da aplicação, é importante que a gente use o componente do next-image porque ele faz uma otimização automatizada nas imagens. Então ele converte a nossa imagem para vários tamanhos, carrega o tamanho exato para a resolução que a pessoa está carregando. Por exemplo, essa imagem aqui tem, sei lá, 800 de largura, então se a pessoa carrega isso aqui no celular, não necessariamente eu preciso carregar 800 pixels de largura, eu posso carregar uma imagem menor, com uma qualidade menor, por exemplo, e ela também converte em vários formatos diferentes. Pô, a gente usou PNG, mas existem formatos hoje que são mais performáticos que PNG. Eu nem estou falando de SVG, que trata com vetores, eu estou falando de WebP, por exemplo, que é um formato para a gente conseguir trabalhar com imagens, tanto com transparência e tudo mais, só que de uma maneira muito mais leve. Então o next-image faz isso de forma totalmente automatizada para a gente. E aí eu vou usar esse componente de image aqui dentro, e aí a primeira coisa que a gente precisa passar é o source da imagem, que eu vou passar o preview-image. E aí uma das exigências que o next-image traz para a gente é a gente definir, pelo menos, ou a altura ou largura da imagem para ele carregar proporcional a ela. Então eu vou definir a altura de 400, que seria a maior altura possível dessa imagem. Então a gente sempre trabalha com essa ideia, eu não carrego a altura que eu desejo mostrar em tela. É a maior altura possível que eu posso mostrar essa imagem em tela, para ele entender qual é a maior resolução. E aqui, por padrão, o next-image derruba a qualidade, ele abaixa a qualidade das nossas imagens para 80%. Nesse caso, como é uma imagem na home, na parte principal da página, eu preciso que ela tenha uma qualidade boa, então eu vou voltar aqui a qualidade dela para 100, que é diferente de 80, que é o padrão. E, por padrão, o next-image coloca que todas as imagens não tenham uma prioridade no carregamento da página. Então o que ele vai fazer é que a nossa aplicação vai carregar por completo e depois vai carregar as imagens. Só que se a gente for ver, nessa página especificamente, a imagem está na viewport do usuário assim que ele abre. Então essa imagem tem prioridade de carregamento, porque ela é altamente importante para a nossa aplicação, para o usuário conseguir entender o que a nossa aplicação faz, como é que a nossa aplicação funciona. Então é importante passar aqui um carinha chamado priority. Simplesmente ele já vai carregar isso aqui com prioridade. E aqui é legal, até com regra de acessibilidade, a gente colocar algum texto alternativo. Então vou colocar aqui, por exemplo, calendário, simbolizando a aplicação em funcionamento. Aqui eu acho que a gente poderia até ser melhor, mas por enquanto eu acho que está ok. Feito isso, vamos salvar a aplicação rodando, a gente pode voltar no Chrome e é isso que a gente vai ver. Ainda de uma maneira um pouco estranha. Meu Deus, meu gato está berrando. Bom, deve ser apenas carência, mas vamos lá. O que a gente vai fazer aqui agora é adicionar alguns estilos aqui na nossa aplicação. Eu vou começar com container, então aqui no container a gente vai precisar fazer uma regra bem interessante, porque isso aqui foi algo que a gente fez em um outro módulo do Ignite, porque a aplicação está centralizada, de certa forma. Isso aqui precisa ficar centralizado. Conforme eu aumento a tela, esses componentes aqui precisam ficar centralizados. Porém, concorda comigo que essa imagem aqui não tem uma margem na direita, enquanto esse carinha aqui tem uma margem na direita. Então a gente precisa, de certa forma, centralizar a aplicação. Porém, se o tamanho da tela for menor que a soma desses dois elementos aqui, eu quero que a imagem vá perdendo espaço. A tela vá subindo para dentro da imagem, e não que esse componente aqui na esquerda acabe perdendo espaço. Então a gente vai ter que fazer um cálculo aqui para entender qual vai ser a largura exata da nossa aplicação. Então aqui, o que eu vou fazer? Eu vou definir, olha que interessante, eu vou começar colocando aqui um background red para a gente visualizar o nosso container. Então vamos lá. Olha só, eu vou setar, primeira coisa, um display flex, display flex, para que os nossos elementos fiquem um ao lado do outro. Vou dar um align item center e vou dar um gap. E aqui ele traz todos os nossos tokens do design system. Aqui a gente vai botar um gap de 20. Beleza. Aqui, caso você queira dar uma olhada, lembra, tem toda a documentação aqui, o gap de 20. Nesse caso, ele simboliza 5rem, que simboliza 80 pixels no final das contas. Por isso é importante olhar a documentação ali, caso algum desses tokens aqui fique confuso para você. E agora, o que a gente quer? Vamos lá. Primeira coisa, a gente quer calcular qual que é a largura máxima desse elemento, porque conforme eu tiro o zoom aqui, a gente pode ver que ele está ficando para a esquerda. Eu quero que ele fique totalmente para a direita. Então, eu vou começar colocando aqui um margin-left alto. Isso aqui vai fazer, basicamente, ele jogar o nosso elemento totalmente para a direita, porém, apenas quando ele tiver uma width menor. Então, se eu venho aqui e jogo uma width, por exemplo, de 1.200 nele, olha só, ele ficou, o fundo vermelho ali, porém, totalmente alinhado para a direita. Se eu não tenho esse margin-left alto, ele vai ficar para a esquerda, que é o padrão do CSS. Porém, agora, quando eu volto para o tamanho original, o que acontece? Essa width de 1.200 que eu coloquei aqui, ela está menor do que o tamanho da minha tela. A minha tela aqui é 1920. Eu quero que ela ocupe mais espaço. Eu tenho mais espaço disponível. Por isso, para calcular, aqui a gente vai usar até max-width ao invés de width, porque se eu tiver em telas menores, ele vai continuar respeitando o 100%. Então, o max-width vai aplicar somente se a minha tela permitir, se ela não for menor. E aqui a gente vai usar um cálculo. Então, o que a gente vai fazer? Eu vou usar o 100% do viewport-width, que ele basicamente retorna o tamanho da minha janela, menos, e aqui, o que a gente vai fazer? Eu vou, qual que é o tamanho desejado que eu quero que tenha o meu container? Geralmente, a gente trabalha com o tamanho máximo, que é o do container da tela, de 1.200, 1.160. A gente não trabalha com tamanhos muito maiores para o conteúdo da nossa página. É de largura que eu digo isso. Então, o que a gente vai fazer? 100% viewport-width, que seria o tamanho todo, menos, novamente, o tamanho todo, menos 1.160, que seria o tamanho do nosso container. Ou seja, se eu estou pegando o tamanho da tela todo, menos o tamanho do container, eu tenho só o que sobra. Ou seja, aqui basicamente eu estou calculando, cara, qual que é o tamanho das sobras, que seria a minha tela menos o conteúdo. Concorda comigo? Então, eu estou pegando a minha tela, menos a diferença do conteúdo. E aqui eu vou dividir por 2. Por que dividir por 2? Porque concorda que aqui eu quero a margem apenas na esquerda e não na direita. Por isso, eu estou dividido por 2 aqui, porque na direita eu não preciso dessa margem. Se não, se eu precisasse, eu nem precisaria desse cálculo todo, mas isso aqui é só para a gente exemplificar isso aqui. Eu salvo, volto aqui no Chrome, e olha só, já está funcionando. Ele só não está centralizado verticalmente ainda, que é algo que a gente vai arrumar. A gente pode simplesmente colocar aqui um height, sem vh, e pronto. A gente já pode ver, deixa eu tirar esse fundo vermelho que está horrível, e pronto, a gente já pode ver que agora a imagem ficou cortadinha, como que a gente queria. Se eu vou diminuindo, ele vai cortando a imagem. Ele acabou criando uma barra de rolagem, porque o certo aqui seria a gente criar um layout responsivo, porque por mais, eu não coloquei nenhum overflow, hidden, nem nada disso. Se a gente quisesse aqui, overflow, hidden, só que não é a melhor estratégia, porque em algum momento a gente vai ter que lidar com o que acontece quando a pessoa chega aqui. Essa imagem nem faz mais sentido. O certo seria já colocar o texto para cima, a imagem para baixo talvez, mas não é algo que a gente vai dar tanta atenção, porque o foco dessa aplicação, especificamente do Ignite.Cal, é a gente aprender muito como utilizar o Next na questão de construir uma aplicação full stack, tanto back-end quanto front-end, dentro de uma única codebase, de uma maneira legal, por isso que a gente não vai dar tanto foco nisso. Beleza. A gente vai fazer o nosso hero aqui, então vou dar um maxwidth nele de 480 pixels, um padding de 0 a 10, então a gente pode ver como é que ele fica aqui, se eu diminuir um pouquinho a tela agora, ele já não fica mais colado ali na lateral. E aqui a gente vai fazer o seguinte também. Eu quero estilizar, para botar margem entre esses carinhas e mudar um pouquinho aqui o heading, quando ele estiver em telas menores, a gente pode fazer da seguinte forma. Ao invés de eu estilizar aqui, por exemplo, um H1, que está aqui dentro do hero, quando eu coloquei esse heading aqui dentro, ele não está como um H1. Então eu teria que botar SH1 para ele funcionar como um H1, porque por padrão o heading é um H2. Só que mesmo assim eu não gosto de estilizar o H1, porque se em algum momento eu trocar de H1 para H2, vai parar de funcionar. O que eu gosto de fazer? Eu gosto de importar de dentro do Ignite UI React, por exemplo, o heading e o text. E eu consigo aqui dentro do Stitches fazer da seguinte forma. Eu posso botar deste lado aqui uma interpolação e boto o heading, dessa forma. E assim eu consigo estilizar o heading aqui dentro. Só que eu preciso botar cochetes por volta, senão ele não funciona. Tem que ser dessa forma aqui. E agora eu consigo estilizar o heading ali dentro. Por exemplo, se eu colocar aqui uma cor vermelha, ele já estilizou. E agora não interessa se eu troco o heading para H1 ou H2, vai funcionar. E a mesma coisa a gente pode fazer aqui com o nosso text. E aqui no text eu vou dar um margin-top 2, color-gray 200. A gente vai dar um font-size nele XL, então aumentar um pouquinho o tamanho dele. E pronto. Aqui na verdade, font-size XL, a gente poderia, aqui no tamanho, já definir o XL, se a gente quiser. Então a gente não precisaria definir isso por dentro do CSS. Show de bola. Agora, o que a gente quer fazer aqui... Peraí que deu algum bugzinho. Alguma coisa a gente errou aqui. Hero, overflow-hidden. Aqui a gente não quer esse overflow-hidden, mas mesmo assim... Ah, é porque a gente definiu... Ah, tá, beleza. O que aconteceu aqui? A imagem cortou. Porque lá no Figma, quando a gente exportou a imagem, ele exportou a imagem já cortada. Quando a gente veio aqui no export e exportou esta imagem aqui. Tá vendo? Ele exportou a imagem cortada. Então, o certo é... Bom, eu vou deixar o URL aí para você conseguir mexer no arquivo, mas o certo seria a gente conseguir exportar essa imagem sem estar cortada. Peraí um minutinho. Pronto, já peguei o mesmo arquivo que você teve acesso aqui. Então, você duplicou. Eu vou só arrastar a imagem aqui para fora, em algum lugar, e eu vou exportar ela de novo. Salvar aqui em app.preview. Sobrepor aquela que a gente já tinha. Dar um ctrl-z só para voltar o layout aqui. E pronto, já está a nossa imagem ali certinha. Mais para frente a gente vai ter algumas configurações aqui, mas só para a gente não deixar o responsivo aqui tão errado, o que eu vou fazer aqui? Dentro do preview aqui eu vou dar primeiramente um padding-right 8, um overflow-hidden aqui, para a imagem poder cortar. Então, eu tiro o overflow-hidden lá de cima e deixo ele aqui embaixo. Então, a gente consegue diminuir a tela e não cria barra de rolagem. Mas nem era isso que eu queria fazer. Aqui embaixo eu vou botar um arroba-media max-width 600 pixels e eu vou simplesmente tirar a imagem da tela. E agora, quando a gente reduzir a tela, chega um momento aqui que ele tira a imagem e fica só o texto. E aí o heading acabou ficando um pouco grande aqui. Então, aqui dentro a gente vai botar também um media max-width 600 pixels e a gente vai diminuir o font-size aqui para 6x0. Salvo e pronto. Já diminuiu ali um pouquinho o tamanho do nosso texto. E agora a gente vai continuar estilizando aqui a nossa aplicação porque tem mais um componente aqui na ROM que vai ficar bem legal."
  },
  {
    "id": "9c4ae234-bfd1-4503-897b-3f8f8e508145",
    "title": "Componente ClaimUsernameForm",
    "transcription": "Nessa aula, a gente vai criar um componente aqui dentro da página Home. E quando um componente é específico de uma página, eu gosto de criar uma pasta Components dentro da página. E ali dentro eu vou criar o componente. Então aqui, eu vou criar o nome dele, vai ser Claim UsernameForm. E dentro vai ter um arquivo index.tsx e um arquivo styles.ts. No Claim UsernameForm, ele vai ser um componente, como qualquer outro. E aqui dentro ele vai ter a estrutura. A estrutura aqui em si, aqui nos styles, eu vou começar criando um caninho chamado Form. Aqui ele vai pegar o styledForm. E aí isso aqui vai estar por volta de tudo. Simplesmente Form. E aqui dentro eu vou ter um TextInput, que vem dentro do IgniteUI React. E eu vou ter um botão, que também vem de dentro do IgniteUI React. O TextInput eu vou passar pra ele size=\"small\", então tamanho menor. Aqui a gente tem uma opção no TextInput que a gente pode passar aqui ao prefixo. A gente vai passar aqui o nome do nosso domínio, então eu vou pensar ignite.com. E daí o usuário da pessoa vem depois aqui da barra, eu já mostro como é que isso fica. Placeholder, eu vou botar seu usuário, a gente está criando em português, aqui a interface é melhor assim. E pronto. No caso do button, a gente vai colocar um size=\"small\". O type=\"submit\", porque ele está dentro de um formulário. E é basicamente isso. Dentro do botão aqui a gente esqueceu de botar o texto, então dentro dele vai estar escrito reservar usuário. E eu vou botar um ícone também. Pra botar o ícone, a gente vai instalar aqui o Phosphor React, que é o pacote que a gente vai estar utilizando de ícones. E aqui dentro eu vou usar o arrowRight, que vem de dentro do Phosphor React. Show, já fez a importação. Perfeito. Salvo isso aqui agora, eu vou voltar lá na home e a gente vai colocar aqui abaixo do meu text em si, a gente vai colocar o nosso Claim UsernameForm. Salvo aqui agora. E aqui, uma das coisas que eu quero evitar é que dentro desse Claim UsernameForm eu posso ter aqui dentro, cabeçalhos, posso ter textos também. Então a gente tem que cuidar, porque aquele estilo que a gente colocou lá na home, ele vai aplicar pra todos os headings e todos os texts dentro dessa área aqui. Ou seja, se tiver algum text ou heading aqui dentro do Claim UsernameForm, também vai aplicar. Então nesse caso aqui, o que eu prefiro é botar assim, no sinal de maior aqui na frente, pra ele aplicar somente no heading e no text que estão dentro especificamente do componente hero, que é o primeiro nível, não dentro de outros componentes que estejam também dentro desse componente hero. Isso tem formas de fazer, mas essa é a forma que eu vou usar aqui dentro. E agora, aqui nos meus estilos, o que a gente vai fazer? Ao invés de simplesmente usar um form aqui dentro, eu vou importar aqui o box que vem de dentro do Ignite UI React. E a gente vai ver que ele já vai trazer uma estilização bem legal pra esse nosso formulário. E aqui agora eu vou dar um display grid. Eu vou botar aqui um grid-template-columns como sendo 1fr e alto. Então ele vai botar como que o input tenha um tamanho flexível e o botão seja alto, o tamanho dele seja definido baseado no conteúdo. Um gap, dois entre eles, e a gente vai colocar aqui um margin-top 4 pra distanciar um pouquinho do texto. Um padding de 4 pra diminuir um pouquinho, porque ele tem um padding um pouquinho maior. E aqui, quando a tela diminuir, botando um media, max-width, vamos botar aqui de 600 também, porque foram os outros medias que eu tinha colocado, então pra manter o mesmo breakpoint, eu vou botar um grid-template-columns 1fr. Isso aqui vai fazer com que quando eu diminuo a tela, o formulário ocupe tanto o botão quanto o input, enquanto ele ocupa em largura total no nosso grid. O formulário era basicamente isso. Então o usuário vem aqui e vai colocar o... Eu vou até trocar aqui o texto, vou deixar apenas reservar pra não ocupar tanto o botão. O usuário vai colocar, eu quero que meu usuário seja Diego3G ou DiegoSF. Clique em reservar e aí ele vai ser redirecionado pro restante das páginas do Ignite Call, onde ele vai continuar o fluxo todo aqui de cadastro do usuário e tudo mais. Por enquanto é isso. A única coisa é que esse nosso form aqui, como a gente usou o box agora aqui dentro, acontece que se eu der um especial elemento, ele não é mais um formulário. Ele é uma adívia, tá vendo? Se eu quero que ele se comporte como uma tag form, eu preciso vir aqui no form e passar pra ele uma propriedade SForm. Todos os componentes que a gente... E agora ele é um formulário. Todos os componentes que a gente está exportando aqui de dentro do Design System, eles aceitam essa propriedade S pra gente conseguir trocar qual que é o elemento sendo exibido em tela. Então, aqui na própria Home, esse texto que eu coloquei aqui dentro, ele é um P, um parágrafo. Mas se eu quisesse que ele fosse outra coisa, bastava eu vir aqui e passar pro texto, por exemplo, S span. E agora ele é um span, ele não é mais um parágrafo. Mas aqui não tem necessidade, né? É só pra exemplificar um pouquinho do que a gente pode fazer. Show! Visualmente o nosso formulário aqui de claim, de resgate, digamos assim, de reservar, sei lá, ele tá pronto, mas ainda falta a parte funcional dele, né? Então a gente vai criar isso a partir das próximas aulas."
  },
  {
    "id": "b77aa8a6-980c-483b-8400-21276c5299bb",
    "title": "Estrutura visual do cadastro",
    "transcription": "Nessa aula, a gente vai começar a estruturar visualmente as outras páginas da nossa aplicação. Então, a gente vai começar pela página de cadastro, que é essa primeira página aqui. E como a gente já tem os componentes do Design System prontos, isso aqui vai ser muito rápido, muito mais rápido do que a gente fazer os CSS na mão. Para isso, eu vou começar criando aqui dentro de pages, register e dentro index.page.tsx. E aqui, eu vou criar também um styles.ts. Eu vou até começar pelo styles aqui porque é rapidinho, na verdade, o que a gente vai fazer aqui dentro. Eu vou importar de dentro de ignite-ui-react o nosso componente, o box, e aqui eu vou exportar um container. Geralmente eu gosto de chamar de container, a div, digamos, o main, div, sei lá, o que vier por volta de tudo. E aqui, o box não vai ser utilizado nesse carinha ainda aqui. Ele vai ser utilizado mais pra baixo. Mas esse carinha aqui, basicamente eu vou definir nele o max-width de 572. Por que 572? Porque se a gente for pegar aqui, é 40. Só que como eu quero botar um padzinho aqui nas laterais, de 16 pixels em cada lado, que daria 32, eu aumento pra 572 pra quando o usuário diminuir a tela, ele mesmo assim ficar legal. Então aqui eu vou dar um margin também de 20 em cima, esse aqui dá 80 pixels. Alto nas laterais pra centralizar e 4 abaixo. E padding, como eu falei, de 0 e 4 nas laterais que dá 16 pixels. Então a gente sempre multiplica isso aqui por 4 pra saber exatamente qual é o valor que está sendo retornado. E aqui eu vou ter também um header, que aqui eu vou botar o styled como uma div mesmo. E eu vou ter também onde eu vou usar a box, que é o meu formulário. Então aqui mais ou menos como a gente fez lá no claim username form. Então aqui eu vou usar a box, só que depois vai ser uma tag form. Então a gente vai usar o as lá depois pra... E aqui o styled que eu também preciso importar de dentro do ignite-ui-react. E por enquanto é isso. Mais pra frente a gente pode ter mais coisas, mas a estrutura base é isso aqui. O meu header, já pra deixar aqui o CSS pronto, a gente vai usar um padding 06 nele. O header o que que é? Ele é basicamente o cara que fica aqui. Que contém essas três informações, o título, a descrição e o multistep aqui. Qual que é o passo aqui do formulário. E aqui a gente vai fazer algo como a gente fez lá na home. Então aqui eu vou fazer... Eu quero estilizar o heading que está dentro do header. Então aqui nele eu vou botar um line-height base. E aqui eu quero estilizar também o text. Deixa eu importar de ignite-ui-react. Tem que cuidar da importação do text, porque existe uma classe text nativa do JavaScript. Então olha só, quando eu tiro aqui, continua existindo um text. Que é uma interface aqui, eu sei lá de onde, do React. Então tem que cuidar porque quando eu uso o text aqui, tem que importar do ignite-ui-react. Senão é capaz de você ficar aí uma hora procurando um bug. E aqui a gente vai definir um color. Gray 200, margin-bottom 6. E aí antes de partir para o formulário, bora botar isso aqui em tela para ver como é que está ficando. Então aqui na página de registro. Como é uma página, precisa ser um export default. Vou chamar ela de register, aqui dentro. Return, e aqui a gente vai colocar os nossos elementos. Vou começar colocando o nosso container, que vem aqui dos styles. Cuidar para importar dos estilos certos, dos estilos que estão aqui na mesma pasta. Aqui header, também a mesma coisa. E aqui dentro do header eu vou ter o meu heading. E aqui o meu heading, por padrão, ele é um h2. Só que nessa página, se a gente for pensar nos elementos HTML, a gente tem que entender que o correto é a gente pensar sempre em semântica, e não necessariamente no estilo que aquele elemento traz visualmente. Então não é porque é um título que necessariamente precisa ser um heading. Então aqui eu vou colocar ele como um strong, por ser um texto que tem um pouco mais de peso, mas não necessariamente ele é um cabeçalho. Mas, assim, depende muito da página. E aqui eu vou botar basicamente o texto que a gente tem ali no Figma. Então copio aqui, bem-vindo a Ignite Call. E aqui embaixo a gente vai ter um text, que vem do Ignite UI React. E aqui eu vou botar também o texto que tem aqui dentro do Figma. Então copio e colo aqui dentro. Show de bola. E aqui embaixo do text a gente vai importar o nosso multistep, que vem de dentro de Ignite UI React também. E aqui eu vou botar basicamente que o tamanho dele é 4, eu tenho 4 passos ao total. E o currentstep é 1. Eu estou no primeiro passo, que é o cadastro. Vou salvar isso aqui agora. Aqui no Chrome a gente vai acessar a página barra register. E pronto. É isso aqui que a gente tem até agora. E, cara, já está ficando muito massa. E agora aqui embaixo do header a gente vai colocar o nosso form, que vem também aqui dos estilos. Form, lembra que eu falei, por enquanto ele seria uma div, mas eu quero converter ele em uma tag form. E aqui dentro a gente vai ter os nossos campos aqui do input. Os campos aqui eu vou botar eles por volta de label. A label não precisa de for, porque o input vai estar dentro dela. Então aqui eu vou botar um text, size=\"small\", nome=\"usuário\", e abaixo o text-input. Então todos os elementos de input vão ser dessa forma. Esse text-input aqui vai ser o mesmo lá da home, lá do usuário. Então eu vou botar nele um prefixo, ignite.com, placeholder=\"seu usuário\", mais ou menos como a gente tinha feito lá. E a gente vai ter um outro campo aqui embaixo, que é o nome completo. Deixa eu lembrar aqui no Figma. Isso, nome completo. Ele vai ser um text-input, ele só não vai ter o prefixo aqui, mas ele vai ter o placeholder. Eu vou botar seu nome. Show. E aqui embaixo, no final de tudo, a gente vai ter um button, que também vem de ignite-ui-react, tipo submit. E dentro dele eu vou escrever próximo passo, e vou colocar o ícone arrow-right, que vem de dentro do Fosfor React. Se eu salvo aqui agora e volto aqui no Chrome, tá assim. A gente vai, claro, dar uma estilizada melhor aqui dentro dos estilos, mas já tá visualmente agradável. Aqui no Form, a gente vai começar dando um margin-top=\"6\", pra distanciar ele aqui do header. E agora eu vou dar um display-flex com flex-direction=\"column\", porque o input tá um abaixo do outro. E um gap de 4 pra ele distanciar o input, cada input um do outro, em 16 pixels. E a gente vai pegar o label agora, que é aquele container que tá por volta tanto do texto quanto do input, e a gente vai fazer um trabalho parecido. Eu vou ter o display-flex, flex-direction e o gap, só que o gap é menor, é 2 agora. Pra eu distanciar um pouquinho o input... Tá, distanciar um pouquinho aqui a label em si do input. Mas tá funcionando, eu aplico na label e ele já seleciona o input em si. E é isso. Como a gente colocou o flex aqui no formulário, o input também já tá ocupando a largura toda, porque o padrão do align-items é stretch, então ele estica todos os elementos pra caber aqui dentro. E assim a gente terminou visualmente a nossa página de cadastro. Já ficou bem legal, a gente pode ver que com pouquíssimos estilos a gente já tem a página de cadastro, e as outras vão ser mais fáceis ainda. Então a gente vai investir pouquíssimo tempo durante a construção dessa aplicação, em CSS, estrutura, a gente vai investir muito mais tempo em código, mas claro, a gente precisa passar por essa etapa de estilização, de visual, você vai ter que passar isso inúmeras vezes durante o seu dia-a-dia trabalhando com front-end."
  },
  {
    "id": "f052f491-158f-475e-8e4b-09ff3c06f71b",
    "title": "Valor inicial do nome de usuário",
    "transcription": "O que a gente vai fazer nessa aula, então, é esse fluxo de redirecionamento. Aqui dentro do Claim UsernameForm, eu vou fazer o seguinte, né? Eu quero que, aqui dentro, ao invés de a gente fazer um console.log desse data, eu vou pegar o nosso username, que está dentro de data, e eu quero redirecionar o usuário. Para redirecionar o usuário, eu vou acessar router, que vem de useRouter, do next barra router. E aqui, para fazer o redirecionamento, eu uso o router.push. Esse redirecionamento pode levar um tempo. Uma coisa interessante para se dizer aqui é que o router.push retorna uma promise, porque ele demora um tempinho para redirecionar o usuário de uma página para outra. Então, a gente pode usar o await aqui dentro. Qual é a vantagem de a gente usar o await e usar essa função de submit como sendo uma função assíncrona, dentro do React Hook Farm? Aqui no React Hook Farm, quando a gente pega aqui do farm state, por exemplo, o isSubmitting, e faz, por exemplo, eu quero desabilitar o botão de reservar, quando o isSubmitting estiver como true. Se eu não faço essa função de submit, que eu mando aqui para o handleSubmit, uma função assíncrona, e dentro dela uso await nas ações que podem demorar, o meu isSubmitting nem vai aparecer, ele vai ser instantâneo, porque essa função não é assíncrona, então ele vai entender que essa função já executou. Então é importante que as operações que demoram para executar no processo de submit do formulário, como por exemplo o router.push, eu coloco um await. Assim, o estado do submit vai durar até que o redirecionamento seja finalizado. Isso aqui é bem legal, uma sacada bem interessante que eles tiveram aqui no React Hook Farm, que faz toda a diferença na interface. E aqui agora, então, eu vou botar barra register, que é a nossa rota, e eu vou enviar para ela um parâmetro, um queryParam, username, igual, enviando o nosso username. Vamos salvar aqui agora e vamos testar esse fluxo. Então eu vou voltar lá para a home da nossa aplicação, vou botar aqui, DiegoSF, clico em reservar, ele ficou cinza, quase não deu para ver, porque foi muito rápido, só que agora ele me redirecionou para a página register, com o queryParam, username, sendo DiegoSF. E agora eu preciso pegar essa informação e preencher aqui dentro desse campo do formulário. Então a gente vai lá, tem um erro aqui em cima? Ah, ele fez uma importação desnecessária. A gente vai lá para a página register aqui dentro, deixa eu pegar minha cola aqui também, e agora, o que a gente vai fazer aqui? Para setar o valor default, uma das estratégias que a gente tem, por exemplo, aqui no useForm, eu tenho uma opção chamada defaultValues. Então eu poderia, por exemplo, aqui, username, se eu informo aqui que o defaultValue de username é DiegoSF, quando eu volto aqui do F5 nessa página, ele já preenche com DiegoSF. Porém, qual que é o ponto? Quando eu informo esse defaultValue aqui dentro do useForm, ele é apenas o valor no primeiro carregamento da página. Ou seja, se a pessoa vir aqui por algum motivo, e isso eu estou pensando num possível segundo momento, algo que possa existir, mas se algo mudar no parâmetro, aqui na URL, ele não vai refletir dentro do formulário. Então, eu quero te mostrar uma outra estratégia, que é, eu posso pegar aqui dentro do useForm, do retorno dele, uma função chamada setValue, que ela serve exatamente para a gente setar o valor de algum campo do formulário de uma maneira manual, de uma maneira programática. E aí, o que eu vou fazer aqui dentro? Olha só que interessante. A gente vai usar o router aqui do Next, então eu vou dar um useRouter, e aqui eu vou fazer um useEffect do React, e aí eu vou depender, a nossa dependência vai ser o router.query.username. Veja que eu coloquei o ponto de interrogação, porque isso aqui pode não existir necessariamente. E aí, dentro aqui do useEffect, eu vou até fazer uma verificação, se existir router.query.username, porque se não, nem faz sentido, porque não tem usuário nenhum em cima, não tem porque preencher esse campo. Se isso aqui existir, eu vou dar um setValue, o nome do campo, que é username, com o valor router.query.username. Só que, aqui ele tem um missIndependency, então setValue, que estava faltando nas dependências, que é uma função, então precisa ser utilizado. Só que aqui está vendo que ele está dando um erro, por quê? Porque o Next, não o Next na verdade, uma das coisas que poucas pessoas sabem, é que o queryParam, ele não é o único. Eu poderia enviar o username duas vezes, isso era até comum a gente fazer antigamente, para enviar arrays dentro dos parâmetros na URL. E isso aqui ele faria, basicamente, o que ele vai fazer é converter em um array. Então, username vai ser um array com dois valores, jQSF e 123. Então, como eu quero permitir, na verdade, apenas uma posição, eu vou tentar converter, vou forçar a conversão do router.query.username em uma string. Então, mesmo que seja um array, ele vai fazer um toString no array. Isso não vai acontecer, porque a gente sabe que só se o usuário for lá e digitar na rota, mas é muito improvável de acontecer. A gente salva isso aqui agora, e olha que interessante, vou dar um F5 na aplicação, preencher o jQSF, e agora eu posso modificar o valor aqui dentro. Se eu dou um F5, volta para o valor original, mas o ponto é, se eu vier aqui na URL e trocar, por exemplo, para teste, olha só, no momento que eu dou um Enter, ele já reflete aqui dentro. Então, é claro que aqui houve um recarregamento da tela, mas se eu tivesse em algum momento aqui um link, que eu redirecionasse o usuário trocando o valor desse parâmetro, se esse valor aqui trocar por qualquer motivo, esse useEffect vai executar de novo, alterando o valor do nosso campo. Então, eu criei esse código, mesmo que improvável de acontecer, de isso aqui trocar na URL, mas eu criei isso aqui para te mostrar realmente que existe essa funcionalidade do setValue dentro do React Hook Farm. E não só setValue, a gente tem várias, como por exemplo o próprio getValue, e a gente tem também o watch para observar. Bom, tem bastante coisa que dá para fazer aqui dentro. Show de bola, a gente já está então com o fluxo aqui da nossa aplicação pronto, bora continuar."
  },
  {
    "id": "e023f19f-d7d2-4e6c-ae3b-5ca8af0d389d",
    "title": "Persistindo usuário no Prisma",
    "transcription": "Nessa aula a gente vai fazer o cadastro do usuário, então aqui na página de Register, aqui no índex desta página, quando o usuário envia o formulário que o handle register aqui, que ele faz o submit para o próximo passo, a gente quer chamar aquela nossa API root que a gente tem aqui dentro, que hoje o nome dela está como hello, mas eu vou mudar o nome dela aqui para ser, bom, eu vou criar uma pasta chamada users e dentro eu vou criar um index.api.ts, porque mais pra frente eu vou ter várias rotas de API específicas para usuários, então eu posso ter atualização, criação e tudo mais, e aqui dentro o index ele vai servir então para quando o usuário acessar localhost 3000 barra api barra users, ele vai chamar a rota index, que é a rota raiz aqui dentro dessa pasta, eu vou copiar o conteúdo de hello, vou jogar pra dentro de index, tiro esse data que não tem necessidade, aqui o next API response também posso deixar dessa forma mais simples, e aqui dentro eu vou deletar nossa rota hello, e a única coisa que eu vou fazer aqui dentro, no nosso json aqui, só para não dar erro, eu vou retornar dessa rota exatamente o que ela recebe, então eu vou retornar hack.body, que é o corpo da requisição, então tudo que a gente enviar para essa rota, o next vai devolver pra gente na resposta, então basicamente não faz muita coisa, e eu gosto de colocar o return aqui na frente, para evitar que qualquer código a partir daqui seja executado. Show, então lá no nosso index a primeira coisa que a gente precisa fazer é essa requisição, e para isso eu vou utilizar o axios, que é uma biblioteca muito legal, que a gente já ouviu falar sobre ela, já usou ela em outros projetos, para fazer requisições entre front-end e back-end, porque é isso que a gente vai fazer agora, esse código aqui que está dentro da página register, ele é um código front-end, essa rota que a gente criou aqui é um código back-end, a gente precisa comunicar as duas pontas, então aqui dentro de lib, eu vou criar um arquivo chamado axios.ts, e aqui eu basicamente vou exportar uma constante api, é igual a axios, ele já importou aqui, ponto create, vou criar uma instância do axios, e aqui base url, ao invés da gente informar a url completa, http localhost 3000 barra api, por exemplo, é onde vai estar as nossas rotas de api, como o front e o back eles estão no mesmo projeto, eles já vão estar na mesma url, então o axios na verdade, isso aqui ele já vai conhecer, porque ele vai estar executando na mesma url do back-end, o back e o front vão estar na mesma url, então eu posso colocar, por exemplo, só barra api, ou seja, ele vai reaproveitar o host do front-end, o endereço do front-end, vai apenas colocar um barra api no final, e aí tudo que vier depois, ele vai entender como as rotas back-end da nossa aplicação. Aqui dentro do handle register, agora, pra gente testar, o que eu vou fazer, eu vou colocar um try catch, pra gente também lidar com possíveis erros, aqui dentro, por enquanto, eu vou dar apenas um console.log no erro, mais pra frente a gente coloca um aviso, e aqui dentro eu vou fazer um await api, então eu vou importar aqui o api que a gente acabou de criar, lá de dentro de lib, barra axios, ponto post, porque como a gente está fazendo a criação de um usuário, eu vou usar o método post, aqui, barra users, e aqui dentro eu posso enviar o corpo da nossa requisição, então pra criar o usuário, eu vou mandar apenas o nome, que vem de data.name, e o username, que vem de data.username, e aqui, eu poderia, como o nome e o username é igual, eu poderia, se você concorda, enviar diretamente data, só que eu acho ruim, na hora que alguém vem dar manutenção nisso, a pessoa passa o olho aqui por cima de data, e não sabe exatamente o que é data, então eu gosto de deixar mais explícito, assim, possível, pra que quando a pessoa veja, tá, eu tô chamando a API, eu tô enviando o nome e username, beleza, agora fica muito mais claro o que está sendo enviado, e mais pra frente, se a gente quiser receber mais dados no data, porém, não enviá-los aqui pra API, usar eles pra fazer algum outro tipo de tratativa, tranquilo, a nossa API fica intacta em relação a isso. Salvo isso aqui agora, e a gente vai testar, então eu venho aqui no Chrome, vou abrir a aba de inspecionar elementos, vem aqui em Network, vou abrir aqui um pouquinho mais, e agora eu vou preencher aqui, por exemplo, Diego SF, Diego Fernandes, se eu dou um próximo passo, veja que ele já chamou aqui a rota users, usando o método post, recebeu status 200, API é que o endereço ficou certinho, e se eu for ver a resposta em preview, olha só, é exatamente os mesmos dados que eu enviei, o nome e o username, porque foi isso que a gente retornou aqui de dentro da nossa rota da API. Só que agora eu quero cadastrar o usuário no banco de dados, né, e aí, antes da gente cadastrar diretamente o usuário no banco de dados, existem algumas coisinhas que a gente precisa cuidar quando a gente trabalha com essas rotas back-end dentro do Next, que a primeira coisa, essas rotas, elas não são, é, eu não consigo falar para elas de uma maneira mais explícita qual é o método que ela precisa aceitar, por isso ela aceita todos os métodos, post, put, delete, get, e isso é ruim, porque como eu quero simbolizar apenas a criação de um usuário, e não chamar essa rota aqui na listagem, por exemplo, fica ruim, então uma das coisas, primeiras coisas que a gente precisa fazer aqui é fazer um if, se o hack method for diferente de post, eu quero dar um erro, porque eu não quero que essa rota aqui seja chamada no método diferente de post, então eu vou dar um return, res, que é a nossa response, ponto status, 405, caso você não conheça o 405, ele é de method not allowed, né, então ele basicamente retorna semanticamente que esse método não é suportado, não é permitido por essa rota, e eu dou um ponto end, que basicamente o end, diferente do send ou do json, ele termina a resposta, ele envia a resposta, porém sem nenhum corpo, sem precisar ter enviado nenhum texto, mensagem de erro ou qualquer coisa assim, porque o 405 já é autodescritivo, e aí, o que eu vou fazer aqui dentro, de dentro do meu body, eu vou pegar o nome e o username que eu estou recebendo, que é exatamente o que está sendo enviado, e agora eu vou utilizar o prisma aqui dentro para cadastrar esse usuário no banco de dados, então const user é igual a await, prisma, e aqui veja que ele já vai dar a importação aqui de dentro da nossa pasta lib, aqui ele deu erro porque eu usei await, então tem que trocar essa função por uma função assíncrona, pronto, prisma ponto, e aqui veja que o prisma já identifica que existe uma tabela de usuário, o model user, e quando eu dou um ponto, ele já traz todos os métodos que eu posso executar, o método que a gente quer é o create, então aqui no create, se eu dou um ctrl espaço aqui dentro, a gente pode enviar data e select, o select basicamente é quais dados eu quero retornar do usuário após a sua criação, e o data é quais dados a gente quer utilizar para criar o usuário em si, os dados das colunas do banco de dados, e aqui dentro de data, se eu dou um ctrl espaço novamente, olha só, ele traz todos os campos, só que os campos id e o campo created at, veja que ele tem um ponto de interrogação no final, porque como esses valores eu setei lá no prisma que eles possuem valores default, o prisma entende automaticamente que eles não são obrigatórios, porque eles possuem um valor default, um valor que vai ser preenchido automaticamente, então eu só preciso preencher aqui dentro o name e o username, que é exatamente os campos que eu recebo aqui em cima, então eu passo o name, username, e pronto, dessa forma o prisma vai criar o usuário, para a gente validar que isso aqui está realmente funcionando, eu posso retornar o usuário criado aqui dentro do json, e eu vou trocar também o status aqui da resposta do prisma nessa rota, do prisma não, do next nessa rota, para 201, que é o status que a gente usa geralmente em, os códigos, o código HTTP que a gente usa geralmente, para simbolizar que algo foi criado, o recurso foi criado, então é só uma maneira de manter a nossa API um pouquinho mais semântica, não necessariamente isso aqui vai fazer uma diferença no resultado lá para o frontend, salvo isso aqui agora, projeto ainda está rodando, lembrando que eu deixei o projeto rodando, e agora eu vou clicar em próximo passo aqui de novo, ele chamou, a rota users, porém agora o retorno veja que agora já tem o created at, tem o id, que foi exatamente o recurso criado no prisma, se eu for lá no prisma studio e dar um refresh aqui na esquerda, veja que a nossa tabela de usuários agora, ela já tem o usuário aqui dentro, diego sf, diego fernandes, created at, o id já foi tudo criado certinho, porém, essa rota ela tem um bug na verdade, porque se eu tentar cadastrar um usuário aqui dentro, com um nome de usuário que já existe, clicando próximo passo, olha só, dá erro, só que dá erro de uma maneira ruim, dá um 500, internal server error, porque a gente não lidou com isso, a gente não criou algum tipo de verificação, se a gente está tentando inserir um usuário com o username que já foi usado antes, até porque o username ele é único, então a gente tem que cuidar, porque essas rotas backend a gente precisa fazer todo o processo que a gente faria no backend tradicional, fazer validação, tudo isso, a gente precisa tomar cuidado, mas a gente vai fazer isso com certeza para deixar o nosso projeto nos trinques."
  },
  {
    "id": "24d2e136-06d3-4de2-9d2e-44c8790480bd",
    "title": "Página de conexão do calendário",
    "transcription": "Já voltei da academia, já, e cafezinho pronto pra gente continuar. Vamos lá. O que a gente vai fazer agora? Agora que a gente já finalizou a parte de cadastro, aqui dentro da nossa aplicação, a gente vai pro próximo passo, pra próxima página. Então eu vou criar uma página pro usuário se conectar, conectar o calendário dele, que é essa página aqui, que seria o segundo passo do cadastro. E ela vai ser muito semelhante à página de cadastro em si, do Register. Então o que a gente vai fazer? Eu vou criar aqui o Connect Calendar, pra ficar com o nome mais descritivo possível. Dentro eu vou criar um index.page.tsx e eu vou copiar o conteúdo inteiro da página de cadastro. E a gente vai remover aqui tudo que tem a ver com a parte de conexão com o calendário. Tudo que tem a ver com a página de cadastro especificamente. Então essa parte aqui do EaseEffect, o router, vou remover, depois eu coloco alguma coisa. Formulário, a gente nem vai ter formulário, na verdade é só um botão ali. Então tudo que for de formulário, remove. Logo a gente arruma aqui as importações. Esse form aqui tira também. Podemos deixar farm por enquanto, mas daqui a pouco eu vou trocar. Aqui, o que a gente vai fazer? Eu vou tirar algumas importações. Vou criar um arquivo de estilos. E aqui no arquivo de estilos, a gente vai fazer o seguinte. Essa parte do container e do header, que ela é igual entre as duas páginas. Tanto a página de cadastro quanto a de conexão. Eu vou pegar esse container aqui do styles, desse styles aqui. Então a gente vai reaproveitar os estilos que estão nesse styles global, digamos assim, dentro da pasta register. Para todas as subpastas aqui do register. Então, por exemplo, container, a gente vai pegar de lá e header. O form e form error, eu nem vou usar. Então aqui é ponto, ponto, barra, styles. Beleza. Essa função aqui em cima, handleRegister, deixa comentada por enquanto. Depois eu posso reaproveitar para a parte de conexão. E aqui embaixo onde tem form, aqui, a gente vai remover por completo. E aí o texto aqui, a gente vai trocar. Então, connect sua agenda, deixa eu copiar. E copiar esse texto aqui de baixo. E o step aqui embaixo agora, o currentStep, vai ser 2. Porque são 4 passos ao total para a pessoa finalizar o cadastro. E aqui é o segundo passo. O botão que a gente removeu, eu poderia reaproveitar. Então deixa eu copiar esse botão aqui de volta. A gente vai botar ele aqui embaixo do header por enquanto. Mas logo ele vai dentro de um container. E agora aqui nos estilos, realmente, eu vou criar... Vou chamar de connectBox. E ele vai ser basicamente um styled, que vem lá do IgniteUI React. Usando o box, que também vem do IgniteUI React. E aqui, marginTop 6, display, flex e flexDirectionColumn. Aqui eu vou exportar também um carinha chamado connectItem. Que seria este carinha. Então o box é este carinha inteiro, o item é este carinha aqui do meio. Que está por volta do Google Agenda. Opa, este aqui. Então aqui pode ser uma div mesmo. E aqui a gente vai botar alguns estilos a mais. Então a primeira coisa é displayFlex. AlignItemsCenter. JustifySpaceBetween. E agora, border. 1pxSolidGray600. Vamos botar um padding também de 16 em cima e embaixo. E 24 nas laterais. Tem um mosquito chato aqui. BorderRadius. Vamos usar o tamanho median lá do Design System. E aqui, um marginBottom de 8 pixels. Para o botão não ficar... Tanto para distanciar o connectItem um do outro. Quanto também para distanciar do próprio botão que a gente vai ter. Por enquanto é isso. Então a gente volta aqui. Deixa eu tirar este disable por enquanto. E aí a gente vai colocar o nosso connectBox aqui dentro. Vamos botar o botão dentro deste connectBox. E o nosso connectItem. E dentro do connectItem aqui, é que a gente vai ter um texto que vem. Que eu preciso importar lá do IgniteUI React. Ah, já está, porque a gente usou aqui em cima. Google... Eu vou botar como Google Calendar. Porque acho que não se chama Google Agenda. E aqui, precisamos criar este botão conectar aqui. Então, botão... Conectar. E ele vai usar a variante... Secondary. Que é esta com apenas a bordinha. E o sizeSmall. Salvo, voltamos lá. Vamos acessar aqui. Register. Barra. Connect Calendar. Show. Já ficou bem legal. Cara, trabalhar com Design System assim é muito bom, né? Muito fácil. Ah, faltou a flechinha ali dentro. Que é a mesma flechinha que a gente usou aqui embaixo. Então a gente pode até reaproveitar ela, né? Ó, pronto. Cara... É muito rápido fazer interface desta forma. Beleza. Agora, o que eu quero fazer, né? Lembrando que... Da última aula, a gente tinha feito para o fluxo da pessoa começar aqui no Register. Depois que ela preencher aqui, a gente salva no cookie, então, o User ID. Este User ID é o que a gente vai usar para identificar o usuário até ele chegar no final do fluxo de cadastro. Esta estratégia, inclusive, é bem legal. Só que aqui, faltou a gente redirecionar o usuário de dentro desta tela do Register, lá para dentro do Connect Calendar, que seria o próximo passo, né? Ah, aqui tem um erro, deixa eu ver. Do Axios, que a gente ainda não está usando, mas eu posso deixar comentado porque a gente vai usar. E o Text Input a gente não está utilizando mais. Então, aqui no Register, depois de ele criar o usuário, aqui ó. Vamos fazer um await router.push barra Register barra Connect Calendar para ele conectar o calendário. Salva aqui agora. Voltamos lá dentro e agora a gente vai fazer um teste. Então, deixa eu abrir o Prisma Studio de novo. Eu não quero ficar criando mil usuários, tá? Então, eu vou deletar este usuário aqui e vou criar o mesmo. Então, DiegoSF. Nossa, tem um pouquinho de zoom demais aqui. Diego Fernandes. Próximo passo. Beleza. Então, ele já redirecionou a gente para o Connect Calendar e, teoricamente, dentro aqui de Application, Cookies, a gente já tem o ID. A gente pode validar. Começa com 2A e termina com 87. Está lá, 2A e termina com 87. Então, ele está atualizando o cookie certinho, da maneira que a gente espera. E agora, este User ID vai ser o suficiente para a gente depois, assim que o usuário clicar em Conectar, o que eu espero que aconteça? Abra a janela para ele logar com a conta do Google, pedindo, inclusive, permissão para acessar o calendário. E aqui para frente, a gente vai entrar em um fluxo bem... não diria complexo, mas é a parte core da aplicação agora. Então, toda essa parte de integração social daqui para frente vai ser muito legal. A gente vai criar muita coisa legal. Então, já se prepare aí a mente, esteja bem tranquilo, tranquila, porque vai ter bastante conteúdo. E quando abrir esse modal, assim que a pessoa entrar com a conta dela do Google, até também se ela não entrar, seria legal a gente mostrar uma mensagem de erro, a gente pode fazer isso. Mas, quando ela entrar, eu quero que ela volte para esta página aqui e o botão, ao invés de estar Conectar, esteja conectado, para mostrar que a pessoa já fez a conexão. E aí, ela pode ir para o próximo passo. Então, inclusive, para a gente já antecipar, uma das coisas que a gente vai ter que fazer aqui, deixa eu ver como é que eu, inclusive, fiz desta forma. Não, por enquanto eu deixo assim. Eu ia tentar já antecipar uma ação aqui, mas eu acho que ia mais confundir do que ajudar. Mas está ótimo assim desta forma. Vamos começar com a parte de login. Então, agora é só integrar com o login social do Google que as coisas vão tomando vida."
  },
  {
    "id": "52a6d5a8-3ca1-4036-afd0-08e52c2c2f6e",
    "title": "Fluxos de autenticação no Next",
    "transcription": "A partir desse momento na aplicação, até como eu falei na aula anterior, a gente vai entrar num fluxo bem, de certa forma, extenso de entendimento, caso você nunca tenha feito, mas não necessariamente muito código, que é entender como que vai funcionar todo o fluxo de autenticação. A gente vai estar utilizando aqui na nossa aplicação um protocolo de autenticação chamado OAuth, que é um protocolo muito utilizado, que basicamente ele consiste em uma pessoa conceder permissões de acesso a alguns recursos da conta dela em algum outro provider, em um provedor, em outra aplicação, para a nossa aplicação. No caso, por exemplo, a gente vai estar utilizando o Google aqui. Então, o usuário, quando ele clicar em conectar, o que eu quero fazer? Eu quero abrir a página do Google para ele se autenticar, dar permissões para a gente usar os recursos de calendário, porque eu vou precisar criar evento, vou precisar, basicamente, criar evento. E isso retornar para a minha aplicação, e a minha aplicação tem algum tipo de chave, de token, de access token, para ela conseguir comunicar com a API do Google como se fosse aquele usuário. Existe um termo para isso, eu ia errar aqui o termo em inglês, com certeza, mas a gente vai, basicamente, fazer chamadas para a API do Google, de criação de evento, simulando que a gente é o usuário, ou seja, com as permissões que o usuário nos concedeu. E no Next, especificamente, na verdade, se a gente não está falando de Next, existem várias bibliotecas que implementam esse protocolo de OAuth. Se a gente está no Express da vida, eu acho que a mais famosa é o Passport. Com certeza não é esse. O Passport do Express, que é uma biblioteca já antiga, mas ainda muito útil, porque ela, basicamente, faz essa parte de suporte à autenticação. Mas, no Next, a gente tem algumas outras bibliotecas para lidar com essa parte de autenticação. Por quê? Porque, dentro do Next, se a gente for parar para pensar, a gente tem o nosso código front-end e o nosso código back-end dentro da mesma codebase, dentro do mesmo projeto. E isso traz desafios, mas traz muitas vantagens. Uma das grandes vantagens e o motivo da gente utilizar uma biblioteca como essa é que o Next tem esse funcionamento de server-side rendering, ou seja, é muito fácil dentro do Next eu acessar alguma informação sensível, como, por exemplo, de autenticação, direto do meu front-end, direto do React. Então, obter o usuário logado, obter o link para o usuário fazer login, ou seja, existem bibliotecas específicas de autenticação no Next por o Next ter esse ambiente onde front e back rodam muito próximos um do outro, ou seja, a gente tem muitos benefícios com isso. E aí, na própria documentação do Next, se a gente for procurar aqui em Next Authentication, a gente vai cair aqui nessa documentação que ele fala sobre alguns patterns de autenticação dentro do Next. Ele explica tudo isso que eu falei e tudo mais. E ele traz alguns exemplos de bibliotecas que são as mais famosas, que é o ARIOS Iron Session, particularmente, nunca utilizei. O Iron Session, se eu não me engano, ele é... As duas têm um nível... Por exemplo, Iron Session é mais caso você queira construir uma autenticação estilo JWT tradicional, como a gente faz, geralmente, em back-end, o usuário loga com e-mail e senha, a gente retorna um JWT, e aí a gente usa esse JWT, esse token para fazer as requisições do front para o back. Mas, para mim, a biblioteca mais legal é o Next Auth, que ela automatiza quase que o processo de autenticação por completo. E acho que é importante a gente aproveitar esse tempo que a gente está conversando sobre autenticação e dizer que, para mim, a autenticação é uma das coisas que quase nunca vale a pena você implementar do zero. Hoje, existem inúmeras maneiras de você realizar autenticação sem gerar grandes custos e de uma maneira muito mais legal para o usuário final. Até você mesmo, eu acho que você prefere logar utilizando o GitHub ou alguma rede social sua do que ficar lembrando senha, do que ficar... Cara, mais um serviço com mais uma senha é chato. Então, existem inúmeras maneiras de a gente fazer autenticação hoje nas nossas aplicações, seja logando com uma rede social, como Google, GitHub, até Discord, por aí vai, usando esse protocolo de OAuth, ou até com outras soluções, como, por exemplo, SMS. Então, a pessoa loga com o celular, recebe um código, bota o código e ela está logada. Ou Magic Link, por exemplo, também, que é uma solução interessante que não necessariamente precisa ser esse que eu estou mostrando, mas, bom, pelo jeito eles pivotaram para ser algo para Web 3, mas eles têm aqui o Magic Auth, se não me engano. Bom, eles pivotaram bastante o negócio, mas isso aqui era uma startup bem focada em autenticação via Magic Link, que é aquele, a pessoa bota só o e-mail, e aí no e-mail dela recebe um link, quando ela clica, ela já está autenticada. E aí, assim, existem inúmeras estratégias, sabe? E o NextAuth, se você está implementando a autenticação num projeto, onde o projeto é Next, e você está criando o back-end dentro ali do Next, com certeza é a solução mais incrível para você utilizar. E eu vou te mostrar o porquê que ela é tão incrível e como que a gente pode... Ela suporta a gente autenticar com vários providers, de OAuth, por exemplo, se a gente vier aqui na documentação aqui na esquerda, olha só. Ela integra com Apple, Auth0, cara, Betonet, nossa, assim, cara, muitas, olha só, Discord, Dropbox, e-mail, Facebook, Foursquare, meu Deus, GitHub, GitLab, Google, Instagram, olha só o tanto de opções que a gente tem para integrar ela. Então, isso é muito legal. E uma pergunta que eu recebo muito é, Diego, eu tenho um back-end separado e eu quero construir a autenticação dentro do meu projeto front com o Next. Mesmo assim, dá para eu utilizar NextAuth? Dá, mas as vantagens, elas começam a ficar muito menores. Eu acho que existe uma complexidade muito grande para você fazer o setup, para rodar junto com o teu back-end, a não ser que o teu back-end esteja, já tenha implementado o protocolo OAuth, aí beleza, é mais fácil, mas se não, eu particularmente não recomendo. Se o teu back-end é só retorno JWT e tudo mais, eu acho que faz o modelo tradicional, guarda o JWT num cookie, utiliza ele, faz o refresh quando necessário. Então, não acho que vale a pena, nesse caso, utilizar o NextAuth, porque a configuração fica bem extensa. Então, a gente usa mais o NextAuth quando a gente tem o back-end junto, muito próximo do nosso front-end, que é o caso que a gente está desenvolvendo essa aplicação. Era basicamente isso, eu queria trazer uma aula para explicar um pouquinho sobre a autenticação, o que a gente vai estar utilizando, o que é o próprio OAuth, os providers aqui dentro, o que a gente vai construir e um pouco de tomada de decisão quando você estiver criando a autenticação dentro da sua aplicação. E agora, claro, bora começar a autenticar a nossa aplicação com o Google."
  },
  {
    "id": "84d9cd0b-7fa6-4d3a-8563-06a70d44c547",
    "title": "Mensagem de erro e ajustes",
    "transcription": "Nessa aula a gente vai mostrar então a mensagem de erro aqui da nossa aplicação, caso a pessoa não tenha dado as permissões ou tenha acontecido qualquer outro erro, porque pode acontecer, nunca se sabe. E também fazer alguns ajustes aqui na tela até pra gente já deixar ela fechadinha aqui. Primeira coisa que a gente vai fazer, eu vou pegar aqui const halter igual use halter, e aqui eu vou criar uma variável hasOfError, essa variável ela vai basicamente ser um true ou false, caso eu tenha o error aqui dentro da url. Por enquanto eu só vou ter o erro de permissions, então eu nem vou fazer tipo, ah se for erro de permissions é essa mensagem, se for outro é essa, eu só tenho esse, então se tiver esse eu mostro a mensagem, se não, não, então vai ser só um true ou false. Então aqui eu vou validar, router.query.error, que é o que a gente quer olhar. E aqui eu vou, como eu quero um booleano, posso só simplesmente fazer uma dupla negação aqui, e o hasOfError já vai ser um boolean, caso isso exista, vai ser true, se não, false. E aí eu vou aqui nos meus estilos, criar, eu vou chamar de alfError, styled, vai ser um texto, tem que cuidar pra importar aqui certinho, igniteuiReact, e aqui a gente vai dar um color, f75a68, e eu vou botar também um marginBottom de 16px pra ele jogar o botão um pouquinho pra baixo. Acho que é isso, agora, aqui embaixo, entre o connectItem e o button, a gente vai fazer o seguinte, eu vou botar seHasOfError, eu vou mostrar alfError, e aqui eu vou colocar uma mensagem, e eu até tenho preparado uma mensagem pronta aqui, deixa eu copiar ela pra você ver, vai ser dessa forma aqui, falha ao se conectar ao Google, verifique se você habilitou as permissões de acesso ao Google Calendar. E aqui também, como isso aqui é um texto, eu vou botar um sizeSmall aqui. Salva, volta ao Chrome, e olha lá como é que ficou. Aqui eu vou diminuir um pouquinho a margem, vou botar 2 mesmo. Então fica a mensagem de erro ali, no caso, quando esse erro estiver preenchido. E aí, o que eu vou fazer? Outra coisa que eu quero fazer agora é, se o login der certo, ou melhor, se a pessoa não logou ainda, eu quero que o botão de próximo passo fique cinza, se a pessoa já logou, eu quero que ele fique verde, e esse botão aqui de cima fique cinza, fica desabilitado pra pessoa não poder logar de novo. Então lembra que eu falei que a gente tem esse session aqui, se eu dou um console.log session aqui dentro da nossa página, eu consigo ter acesso às informações de login do usuário. Então o que eu vou fazer aqui? Aqui esse session está preenchido, mesmo que o login dê erro, porque eu tinha feito login antes, lembra, e dado certo, e aí eu não tirei as informações do cookie, mas a gente pode fazer o seguinte, inspecionar, tirar essas informações aqui do NextAlpha, e aí basicamente a gente já tira o login, porque antes eu tinha feito login, antes de testar essa parte de erro, eu tinha feito login e tinha dado certo, porque quando não está autenticado ele retorna assim, ah isso aí, vocês entenderam, cara, às vezes pega um trava-língua que é difícil, mas o que a gente vai fazer então? Eu vou fazer uma outra variável aqui, por exemplo, chamada hasSignedIn, ou isSignedIn, e aqui eu vou verificar que session.status=\"authenticated\", e aí aqui embaixo eu vou fazer o seguinte, o botão de próximo passo vai estar desabilitado caso o usuário ainda não está logado, e o botão de conectar, eu nem vou fazer a questão de desabilitar ele, eu vou criar um outro botão, porque eu vou ter que mudar o conteúdo, o ícone, aí ficaria muito if aqui dentro, então é melhor fazer o seguinte, eu faço o seguinte, se o usuário já está logado, eu vou mostrar um outro botão, se não, eu vou mostrar aquele botão que a gente já tinha, aí esse outro botão aqui, eu vou mostrar dentro dele escrito conectado, e vou mostrar um ícone chamado check, que vem de dentro do Phosphor React, e aqui nele eu vou passar size=\"small\", disabled, o S-Link já organiza aqui pra mim, beleza, vamos testar aqui agora, então a gente volta, deixa eu voltar aqui pro Connect Calendar sem o erro, perfeito, o próximo passo aqui está desabilitado, não consigo clicar, eu acho que aqui ele ficou até um pouquinho meio junto, deixa eu voltar nos estilos, aqui eu vou aumentar um pouquinho, e aqui também, só pra ele separar um pouquinho mais, então eu não consigo clicar no botão, vou clicar em... deixa eu ver se eu não... beleza, vou clicar agora em conectar, aqui, acessório Ignite Call, aqui ele já botou as permissões certinhas, então dá um continuar, não preciso nem selecionar porque eu já tinha logado antes, e pronto, olha só, agora ele já deu conectado, e o botão de próximo passo já está liberado. Só pra último ponto aqui, pra gente ajustar, eu vou separar essa função que faz login aqui, eu vou chamar ela de HandleSignIn, ou HandleConnectCalendar, vou criar essa função aqui em cima só pra separar, e vou chamar o SignIn aqui dentro, pronto, na verdade eu só queria separar pra não botar Error Function, eu prefiro botar funções separadas aqui dentro, mas você pode fazer da maneira que você preferir, eu gosto de separar as funções aqui em cima. Não tem mais muitos ajustes pra gente fazer aqui dentro, essa página está praticamente finalizada, é claro que em questões de back-end, digamos assim, ainda tem muita coisa pra fazer, porque se tu for parar pra pensar, o usuário até fez login aqui dentro, mas no nosso banco de dados, a gente não anotou nada do login do usuário, o que é ruim, porque todo login que a gente faz com alguma rede social, usando o OAuth, seja Google, GitHub, qualquer um, o login que a gente faz com essa rede social, ele tem um tempo de expiração, e geralmente é curto esse tempo, porque essas informações que a rede social nos traz, nome, e-mail, o token pra gente conseguir fazer chamadas, elas são limitadas, elas têm um tempo de expiração, porque geralmente elas são trazidas pra nossa aplicação, apenas pra nossa aplicação conseguir salvar essas informações no nosso banco, pra depois a gente ter essas informações do nosso banco, não precisar toda vez bater na API pra consultar nome, imagem de perfil e por aí vai. Então, quando a gente trabalha com login social, a gente tem que entender que por mais que o usuário tenha feito login pelo Google, eu não devo depender totalmente do Google pra que o usuário consiga trabalhar na nossa aplicação, por isso é importante que a gente tenha esses dados também do nosso lado, caso seja necessário. Então a gente vai ver um pouquinho como que a gente vai salvar esses dados no banco de informações, como que o NextAuth lida com isso, porque aqui a gente tá desenvolvendo uma aplicação que ela só tem login com o Google, por exemplo. Mas é comum a gente ter, por exemplo, aplicações que o usuário tem login com o Google, às vezes ele vai lá e cria uma senha, daqui a pouco ele pode logar tanto com o Google quanto com a senha, aí às vezes ele vai lá e loga com o GitHub, então ele pode logar na mesma conta com o GitHub, com o Google ou com o e-mail e senha, então não é tão simples a gente lidar com esse tipo de autenticação, mas o NextAuth consegue lidar com isso de uma maneira bem legal, eu vou mostrar aí nas próximas aulas."
  },
  {
    "id": "2b170361-5e1e-4e73-b1c6-c511c0c82e0f",
    "title": "Estrutura do banco de dados",
    "transcription": "O NextAuth tem duas maneiras comuns de lidar com autenticação. Uma delas é não salvando nada em banco de dados. A gente chama isso de stateless. Então, basicamente, o que ele faz? Ele vai lá, bate na API do Google, valida, que o usuário realmente se autenticou, e aí ele gera um JWT por parte do nosso back-end, aqui um token JWT, que garante que a gente está autenticado. E pronto, até esse token durar, a nossa autenticação vai funcionar aqui dentro e sem problemas nenhum. E existe uma outra forma, que é salvando as informações no banco. E aí a gente pode usar essa forma, salvando informações no banco, quando a gente quiser, por exemplo, obter detalhes do usuário que está se autenticando na nossa aplicação, e inclusive, possivelmente, fazer relacionamentos mais para frente, ter outros dados salvos no banco. Então, se a tua aplicação, você estiver botando o NextAuth ali dentro, meio que só para mostrar ou não uma informação em tela, alguma coisa assim, e a tua aplicação não vai ter um banco de dados próprio, beleza, segue assim, sem problemas nenhum. Agora, se a tua aplicação já vai ter um banco de dados, quando você estiver criando esse modelo de aplicação Full Stack, onde o back está dentro do Next, se a tua aplicação já vai ter um banco de dados, faz muito mais sentido tu salvar também essas informações de usuários que estão autenticados na tua aplicação, e-mail, imagem de perfil, no teu banco de dados, porque assim tu pode recuperar essas informações depois, pode trabalhar relatório e tudo mais. E o NextAuth, ele chama isso de Adapter. Então, aqui na esquerda, está vendo Adapters? Ele tem Adapter para a grande maioria dos, digamos, ORMs, não necessariamente ORMs, mas até bancos de dados que a gente usa na web. As ferramentas mais comuns da gente utilizar para trabalhar com bancos de dados dentro do JavaScript. Então, por exemplo, Prisma, a primeira delas aqui, a gente está usando Prisma, a gente vai usar esse Adapter, mas tem outros aqui, FaunaDB, que é um banco bem legal para trabalhar com aplicações serverless, Dynamo da AWS, Firebase, então você pode salvar as informações de autenticação lá dentro do Firebase, legal também. PouchDB, MongoDB, Neo4j, TypeORM, Sequelize, SupaBase, MicroORM, Dgraph e Upstash Redis. Então, salvar as informações lá no Redis dentro do Upstash em si. E aqui a gente está usando Prisma. E aqui dentro do Prisma, a gente pode ver todo o processo de setup desse Adapter. E aí, antes de a gente prosseguir aqui com a parte do Adapter em si, aqui embaixo, no Setup, ele tem essa seção Create the Prisma Schema, ou seja, ele mostra para a gente aqui quais são todas as tabelas que a gente vai precisar para armazenar as informações sobre autenticação. E aí, o que a gente vai fazer? Eu vou copiar isso aqui. Control-C nunca é um só, eu sempre dou uns oito, Control-C, para garantir que eu copiei. E a gente vai colocar aqui dentro do nosso Schema.prisma. Só que eu não vou manter as informações exatamente da maneira que elas estão aqui, a gente vai dar uma modificada, só que isso virá com algumas consequências, mas logo a gente fala sobre isso. O que acontece? Se eu não quiser modificar nenhuma informação aqui, tudo bem, vai funcionar 100%, é só a gente seguir aqui, configurar, botar o Prisma Adapter lá dentro da nossa configuração do NextAuth, e ele vai começar a salvar tudo dentro do Prisma, não tem problema nenhum. Porém, algumas coisas, alguns comportamentos a gente vai querer modificar. Por quê? Se a gente for ver nesse Control-V que a gente deu, a gente trouxe um Model User, uma tabela de usuários, que tem id, nome, e-mail, e-mail verified, image, accounts e sessions, relacionamentos aqui. Só que a gente já tinha um Model User, lembra? Então, está aí o primeiro comportamento que a gente vai ter que modificar. Quando a pessoa logar na nossa aplicação, o comportamento comum que o NextAuth tem, quando a gente bota, por exemplo, o Prisma Adapter, é no momento que a pessoa logou na aplicação a primeira vez, ele cria o usuário, cria a sessão, cria o account, que logo eu vou explicar o que é. Só que no nosso caso, o usuário já foi criado. Lembra? O usuário é criado no momento que ele bateu lá na primeira página, aqui no Register. Então, aqui a gente cria o usuário. Quando ele faz login, não é lá que eu vou criar o usuário. Eu já tenho o usuário criado. Lá, naquele momento que ele faz login, o que eu preciso fazer, na verdade, é associar o usuário que já tinha sido criado na primeira tela, que foi na tela Register, com os dados do usuário que está fazendo login. Então, salvar essas informações que eu tenho novas, e-mail, o avatar, essas coisas, no usuário que já existe. Por isso, a gente vai ter que modificar um pouco o comportamento do adapter do Prisma. E por isso, a gente vai criar o nosso próprio adapter do Total Zero. Isso é muito massa. Eu não vi nenhum conteúdo da internet mostrando como a gente faz isso. Mas se a gente for ver aqui em Adapter, deixa eu ver aqui, em Models, acho que ele explica... Aqui, create your own adapter. Ele explica um pouquinho o que a gente vai ter que fazer para criar o nosso próprio adapter. A gente vai criar um adapter aqui também para o Prisma, porém, com as nossas modificações. O que é o adapter, nada mais é? O adapter funciona como, no back-end, o repositório. Ele é um intermédio, um ponto de conexão entre o back-end da nossa aplicação e o banco de dados. O adapter provê vários métodos para manipular dados, criar dados no banco de dados para que a nossa aplicação possa chamar esses métodos. E o NextAuth precisa que a gente implemente todos esses métodos aqui, e cada um desses métodos aqui precisa fazer uma operação no banco de dados. Então, olha só, para criar um adapter nosso, um próprio adapter, a gente vai ter que criar um método que recebe o usuário e cria ele no banco. Então, aqui a gente vai ter que fazer a operação no banco, chamar o Prisma, criar e tudo mais. A gente vai fazer tudo isso aqui do zero, vai ficar bem legal. Um método que retorna o usuário, um método que retorna o usuário por e-mail. São tudo métodos que o NextAuth usa internamente para trabalhar com o banco de dados. Se a gente não quisesse modificar nada, se a gente não tivesse esse comportamento que a gente tem na nossa aplicação de a gente criar o usuário antes dele fazer o login, que é o que a gente está fazendo, se a gente não tivesse isso, a nossa vida seria muito mais fácil. A gente só usaria o Prisma adapter do NextAuth e acabou ele. O resto ele faria tudo sozinho. Mas, como a gente gosta de um desafio e eu queria te mostrar tudo, inclusive como criar o próprio adapter, caso o banco de dados que você esteja utilizando não esteja naquela lista do NextAuth, dos adapters suportados, a gente vai ver como criar isso aqui do total zero. Aproveitando que a gente está criando o nosso próprio adapter, eu posso também escolher quais campos eu quero salvar no banco de dados, quais eu não quero. Eu posso escolher o nome dos campos, eu vou poder configurar tudo isso. Diferente de caso eu estivesse utilizando o adapter padrão lá do Prisma, eu não conseguiria configurar isso do zero porque ele tem a sua própria definição de campos, que eu acho ruim. Por quê? Porque tem campo que está em CamelCase, tem campo que está com um underline. Para mim está um pouco esquisito, para ser bem sincero. E aí a gente vai configurar aqui para ficar da melhor maneira para a gente. Então vamos lá. Primeira coisa, todos os campos que estão em CamelCase a gente vai trocar para KebabCase. É isso? SnakeCase. SnakeCase. Kebab é com isso. Eu nunca decoro esses negócios de case, nem me pergunto. Vamos trocando, depois eu vou explicar o que são essas tabelas account e session, mas então aqui é o Provider, Account, ID. Cuidado para não errar o nome dos campos que eu já tinha errado aqui. ID token aqui embaixo, o resto está tudo igual. Esses arroba DB ponto aqui, podemos tirar todos. Isso aqui é específico para bancos MySQL. Como a gente não está usando MySQL ainda, a gente está usando o SQLite mais para frente. Na hora que a gente for fazer o deploy da aplicação, a gente até vai trocar, mas por enquanto a gente não precisa. Beleza, a tabela account está fechada, eu posso aqui. Tabela session, vamos trocar também. Então session, underline token. User, underline ID. Expires user, tudo certinho. Salvo aqui só para guardar. Esse user aqui, o que eu vou fazer? Eu vou copiar os campos dele. Esses campos aqui, tudo que não é o ID e o name, porque isso aqui eu já tenho na outra tabela, eu vou tirar daqui e a gente vai jogar lá para a tabela que a gente já tinha de usuário. E aí o que a gente vai mudar aqui é só a parte de email verified. Eu nem vou colocar aqui dentro, porque na minha aplicação eu nem vou ter essa parte de verificação de email, porque o NextAuth tem suporte a gente fazer aquele funcionamento tipo assim, a pessoa loga na nossa aplicação, a gente envia um email para ela, para ela ter que verificar que o email é válido. Só que aqui como a gente vai ter só login social nessa aplicação, essa funcionalidade de token de verificação não é útil. Essa funcionalidade só é útil quando a gente tem login email e senha, que a pessoa pode criar a conta informando o nome, email e senha e não com login social. Então essa parte, essa tabela de token de verificação eu vou tirar. Tudo que tem relacionado a essa parte de verificação eu vou tirar. O resto eu deixo. Os relacionamentos aqui do Prisma eu gosto de deixar como último campo. Então vamos ver aqui e deixo no final aqui de tudo. Então é isso, deixa eu confirmar. ID, username, name, email, image. Eu não gosto de image, eu prefiro avatar, URL, eu ia falar odeio, mas meu Deus, coisa muito pesada. Avatar URL, por enquanto é isso, eu acho. Account, deixa eu dar mais uma última checada. Aqui, user id também, user underline id. E aqui também, provider underline account, underline id, que ele cria um unique com dois campos. Logo a gente já fala sobre isso. Lá no session também, user id. Beleza, eu acho que a gente terminou tudo aqui. Faltou uma última coisa, lembra que eu falei que o Prisma ele não cria as tabelas em caixa abaixo no plural? E é por isso que eu criei esse map aqui. Eu vou fazer a mesma coisa para as outras tabelas. Então aqui account, vou botar um map aqui embaixo, onde accounts. E session, vou chamar de sessions. Feito isso, o que são essas tabelas? User é o usuário. Cada vez que tiver um usuário novo na nossa aplicação, autenticado ou não, vai existir um registro dentro da tabela user. Account é a integração de um usuário com algum provider. Sempre que o usuário loga na nossa aplicação, pensa assim, o mesmo usuário logou tanto com o Google quanto com o GitHub na nossa aplicação. Eu vou ter um account para o Google, que vai ser identificado através desse provider. Então aqui no provider vai estar Google, por exemplo, ou GitHub. E eu vou ter um account para o GitHub, ou seja, um para cada, um registro nessa tabela para cada. Porém, o usuário é o mesmo, beleza? E session, quer dizer, cada vez que o usuário fizer login numa máquina diferente, eu vou ter uma sessão. Eu vou ter uma sessão para cada... é isso mesmo, beleza. E agora a gente vai criar a nossa migration. Então, deixa eu parar o Prisma aqui do lado, vou dar um NPX, Prisma, Migrate Dev. E aqui o nome, Unique Constraint Covering the Columns E-mail on the Table... Beleza. Are you sure you want to create? Sim. Create Auth Tables, eu vou chamar, porque na verdade eu criei várias tabelas. E aí aqui pronto, ele já criou a nossa migration aqui, com todos os statements aqui para fazer as alterações no banco, criar as novas tabelas. E pronto, a gente já pode rodar um NPX Prisma Studio para validar que está tudo criado. Então, olha só, a gente pode dar um mais aqui do lado. E agora eu já tenho tabelas Account, Session e User. Clicando aqui em User, por exemplo, eu posso ver que a gente tem alguns campos novos agora no usuário, como E-mail e Avatar URL, que ainda não estão preenchidos, porque eu ainda não fiz essa implementação pelo lado do NextAuth, que é o que a gente vai fazer a partir da próxima aula, que é criar o nosso próprio adapter. O próprio adapter quer dizer que a gente vai criar a nossa própria forma do NextAuth persistir barra se comunicar com o banco de dados que a gente acabou de criar ali utilizando o Prisma."
  },
  {
    "id": "8ab3fb1b-8dc4-4c45-b0c0-ca4b53f782cf",
    "title": "Conteúdo da sessão do Next Auth",
    "transcription": "A última coisa que a gente vai mexer no NextAuth para deixar ele pronto para o que a gente vai fazer daqui para frente é que, se você lembrar, quando a gente usa esse hook e usa session para retornar os dados da sessão vou até dar um log aqui na sessão no frontend para ver os dados que são retornados ali de dentro se a gente vem aqui na página connect calendar, inspect vem aqui no console, a gente vai ver um objeto aqui dentro de data eu tenho expires, que é a data que expira o meu acesso e dentro de user eu só tenho email e nome eu não tenho mais nenhuma outra informação e isso é outra coisa que a gente consegue configurar no NextAuth inclusive a gente vai precisar, porque eu quero ter acesso ao avatar eu quero ter acesso a praticamente todas as informações do usuário e isso é um callback aqui dentro do NextAuth então aqui dentro de callbacks eu vou criar uma outra função assíncrona, aqui dentro, chamada session e tudo que eu retornar dessa função é o que é passado lá para o frontend no hook essa função session aqui, se eu desestruturar o que ela recebe daqui de dentro eu tenho acesso ao session e ao user e aí aqui eu vou fazer o seguinte, eu vou retornar tudo que eu tenho dentro de session, que é basicamente o nome e email, já como ele tem ali, digamos assim e o expires, só que eu vou substituir a informação do user ali dentro da session, passando todos os dados do usuário então eu vou mandar o user inteiro aqui, não vou nem selecionar os campos mando tudo, e agora olha só, só de fazer isso aqui voltando lá no frontend, dando o F5 aqui olha só, agora dentro de data vem todos os dados do usuário nome, username, id, avatar, email posso até pegar o avatar aqui, jogar ele no browser e tá lá o meu avatar dentro do gmail então agora a gente tem acesso a todas as informações do usuário ali na camada do frontend e isso vai ser super útil porque mais pra frente aqui no Figma a gente pode ver que mais pra frente aqui, eu vou querer acessar dados do usuário, como por exemplo o avatar posso querer mostrar dados do usuário logado então isso é importante e é por isso que a gente fez isso e agora, a gente particularmente aqui finalizou toda a configuração do NextAlpha e eu sei que foi bastante coisa e pode ter sido cansativo de certa forma, mas é super importante você entender que a gente extraiu o máximo do NextAlpha a gente fez, como eu falei eu nunca vi em nenhum tutorial, em qualquer conteúdo do mundo alguém explicar como a gente cria o adapter do zero com Prisma, faz essa questão do profile eu demorei muito pra encontrar todas essas configurações e por isso que eu queria te mostrar, e cara, ficou muito legal então esse adapter que a gente criou, você pode pensar nele como eu falei, o intermédio entre a nossa aplicação e o banco de dados e mais pra frente você pode criar um próprio adapter quem sabe pra salvar essas informações do NextAlpha em um outro banco de dados qualquer, ou não usar o Prisma usar alguma outra estratégia, então só nisso aqui você aprendeu muita coisa de como você pode personalizar o funcionamento do NextAlpha pra sincronizar com o seu fluxo de autenticação e mais pra frente a gente até vai fazer uma alteração pequenininha mas é pra uma coisa muito específica, mas basicamente a gente finalizou toda a parte do fluxo de autenticação da nossa aplicação que por, digamos, peculiaridades da nossa aplicação esse processo do usuário poder criar o usuário antes de logar gerou todo esse trabalho da gente criar o nosso adapter do zero porque se a gente fosse usar o adapter do próprio NextAlpha ele ia tentar criar o usuário aqui nesse momento e não é isso que a gente queria, criar o usuário nesse momento isso aqui daria muita dor de cabeça, a gente tentar fazer uma gambiarra pra sobrepor somente o método createUser e tal cara, não queria fazer isso, então aproveitei pra criar o adapter do zero assim também a gente já padronizou os nomes dos campos no banco de dados já ficou muito melhor, na minha opinião, e isso aqui tá muito massa um app com certeza pronto pra ir pra produção mas vamos continuar que tem bastante coisa pra gente fazer ainda bastante aprendizado envolvido, bora, bora, bora"
  },
  {
    "id": "390ff2cb-1c97-40ae-b5b7-935b2d15df99",
    "title": "Introdução",
    "transcription": "Fala DMK! Estamos para iniciar mais um módulo aqui dentro do Ignite, mais um projeto que a gente vai desenvolver juntos. E esse projeto aqui, que é o Ignite Call, provavelmente vai ser a aplicação mais completa que você já desenvolveu com o Next na sua vida. Ele é um projeto que a gente vai desenvolver ele do total zero até um projeto muito completo para se colocar em produção. E a diferença desse projeto, talvez para outros projetos que você já tenha desenvolvido utilizando esse framework incrível que é o Next, unido ao React, claro, é que esse projeto vai ser um projeto full stack. Então uma das coisas que você já pode se preparar aí é que esse código, esse projeto que a gente vai desenvolver, ele vai envolver tanto código front-end quanto código back-end também. E a gente não vai perder tanto tempo, investir tanto tempo na parte visual do nosso projeto, HTML, CSS, porque a gente vai utilizar um design system pronto de um outro projeto que a gente desenvolveu aqui do Ignite, que foi um projeto onde a gente desenvolve um design system para construir a interface da nossa aplicação. Então a parte de inputs, formulários, botões, tudo isso já vai vir pronto e a gente vai só sair criando nossa interface usando esses componentes prontos. Esse aqui é um projeto que eu preciso te avisar desde o início que vai ser um projeto extenso. São mais de 60 aulas, em algumas delas talvez você se sinta cansado ou cansada. E calma, respira, vai tomar uma água, tomar um café, quem sabe jogar alguma coisa, se divertir um pouco e depois volta e continue estudando. Não é um projeto para você pegar e assistir, quem sabe, 15, 20 aulas seguidas. Uma das outras é realmente um projeto para você pegar, assistir um conjunto de 5, 6 aulas, se concentrar muito bem nessas aulas para captar todos os conhecimentos e depois seguir, quem sabe, num próximo dia. Então não sai que nem um louco ou que nem uma louca querendo consumir esse projeto da maneira mais rápida possível. Tenta cuidar e abstrair, e abstrair não, melhor, obter o máximo de conteúdo possível dessas aulas. Cuidar muito com tudo o que eu explico, porque como eu falei, é um projeto muito complexo. A gente vai escrever desde queries em SQL puro, a gente vai criar várias rotas no back-end, fazer validação, trabalhar com formulário, conectar com a API do Google, trabalhar com Prisma, que é um ORM incrível para dentro do ecossistema JavaScript, para a gente conectar com o nosso banco de dados. Lá no final a gente vai fazer deploy do projeto, usando o Versa, usando o serviço chamado PlanetScale para botar o nosso banco de dados no ar. Então assim, é um projeto muito completo. E eu não poupei funcionalidades, como você bem pode ver. É um projeto muito grande, um projeto com mais de 60 aulas, provavelmente um dos maiores projetos que a gente já construiu aqui dentro do Ignite. Então aproveita, consome com calma, porque vai exigir. Tem aulas que são densas, tem aulas aqui que infelizmente tiveram que ficar com quase 20 minutos, porque não tinha como dividir simplesmente a aula, porque era um assunto mesmo dentro do mesmo conteúdo. Então assim, aproveita, consome com calma, vai na fé que vai dar tudo certo. E na primeira aula aqui eu já vou te mostrar como é que funciona o layout do projeto. Então nessa aula de introdução eu nem vou mostrar o layout do app que a gente vai desenvolver, mas você vai poder copiar aí no Figma e sair codando. Esse é um projeto que dá para evoluir muito, mas antes de mais nada é um projeto totalmente pronto para produção, um projeto com certeza que você pode incrementar ele, colocar mais coisas, adicionar algumas features, e com certeza é um projeto que pode render bons frutos para você no futuro, tanto em conhecimento, porque o que a gente usa aqui dá para replicar para vários outros tipos de projetos. Mas também, claro, caso você queira usar esse app aí na vida real, quem sabe até comercializar, é algo que também é totalmente possível. Eu vou me despedindo por aqui, mas a gente vai começar com tudo então agora. Bora codar e com calma, respira bem aí, que apesar das primeiras aulas serem mais instalação e setup, a gente vai começar logo ali a partir da sexta, sétima aula, muito, muito, muito código. Então respira e vem com calma, pega um cafezinho e bora codar."
  },
  {
    "id": "261e67bd-7c85-48d8-b3a8-dbaf7b5bdd4e",
    "title": "Alterando banco para MySQL",
    "transcription": "Nessa aula, a gente vai começar a calcular os dias que estão lotados aqui para retornar eles como dias não disponíveis também no nosso calendário. Mas, antes disso, eu percebi que ficou dando um errinho de TypeScript. Isso porque esse sinal aqui do ponto de interrogação, ele acaba podendo retornar undefined. Então, a gente tem duas alternativas aqui. Uma delas, que eu acho que é até melhor, por exemplo, validar aqui no começo desse useMemo aqui. Caso o blockedDates ainda não tenha nenhuma informação dentro dele, ou seja, ele ainda não foi carregado, a gente retorna um array em branco daqui de dentro do calendarWeeks. Porque assim a gente evita também, e aí a gente pode tirar esse ponto de interrogação, a gente evita também que o calendário apareça antes da gente terminar a chamada para a API que busca as datas bloqueadas. Podendo mostrar o calendário com falsos positivos, mostrando datas ali não bloqueadas, só porque a chamada API ainda não terminou. Então, dessa forma, a gente salva, volta para o calendário e tudo vai funcionar normal. Só que se a gente rodar em uma internet mais lenta, ou até em produção, e aí seria legal botar um load e tudo mais, mas o calendário agora a gente só carrega depois que a busca pelas datas bloqueadas finalizar. Mas o que a gente vai fazer aqui agora, é lá no nosso blockedDates, continuar aqui a nossa query, e agora a gente vai fazer uma query bem mais complexa. Porque a gente precisa agora retornar os dias que eles estão cheios, então agora vai ser uma query um pouco mais complexa. Porque, imagina, eu preciso pegar cada dia da semana, por exemplo, segunda-feira. Eu preciso ver quais horários eu tenho disponíveis na segunda-feira, 8, 9 e 10, vamos supor. Na mesma query, quais agendamentos eu tenho na segunda-feira? Ah, 8 e 9, então isso aqui ainda tem horário disponível. Aí não, eu pego terça-feira que tem 8, 9 e 10, e aí eu tenho 3 agendamentos, então falso. Só que eu quero fazer tudo isso aqui numa mesma operação no banco. Não quero ter que ficar fazendo múltiplas operações no banco, porque isso aqui tornaria o processo muito mais penoso. Imagina, para cada dia do mês eu faço uma query no banco. Não dá, eu tenho que fazer tudo na mesma. Uma query só no banco, um SQL só, tem que me retornar já informações de todos os dias que estão bloqueados, porque eles estão lotados. E aí a gente vai escrever um SQL bem grande aqui até. Então eu vou chamar aqui de blockedDatesRaw, talvez, porque vai ser um retorno do banco de dados mais bruto, para depois eu tratar. E aqui a gente vai utilizar um método do Prisma que se chama QueryRaw. Por quê? Porque não tem como a gente fazer essa query aqui, que vai ser bem mais complexa, usando o formato do Prisma de queries. Porque ele não vai ser suficiente, a gente vai ter que fazer muitas operações aqui. O Prisma não permite a gente fazer essas operações. Então é importante a gente entender que pode ser que tenha momentos que a gente vai ter que recorrer a fazer queries mais brutas. E aqui o QueryRaw, ele basicamente é um template literal. Então ele pode receber diretamente, sem parênteses, sem nada, os backchecks, as crazes, assentos graves, não sei exatamente, para a gente fazer a query. Aqui só para a gente exemplificar, select, por exemplo, tudo, from, scheduling, se eu salvo isso aqui agora e retorno isso aqui embaixo, só para a gente ver, salvo, volto no Chrome, venho aqui na minha API onde eu estava executando o F5, ele retorna todos os schedulings. Só que aqui outra coisa que a gente vai ter que fazer depois é formatar certinho isso aqui. Mas a gente vai começar a escrever a query aqui. Vamos lá, vamos começar do básico. A primeira coisa que eu preciso fazer aqui é buscar todos os schedulings possíveis naquele mês, daquele usuário. Concorda comigo? Então é isso que a gente vai fazer. Então vamos lá. Primeiro eu gosto de quebrar meu SQL, então eu vou quebrando por verbo, select, from, cada um eu vou quebrando aqui embaixo. E aí eu vou escrever meu WHERE aqui embaixo. Eu quero selecionar todos os schedulings. E aqui eu vou dar um apelido para o scheduling, está com um S, então é um alias, mais fácil da gente fazer as buscas aqui embaixo, não precisar escrever schedulings, ponto. Então s.userid é igual, e aqui a gente pode fazer uma interpolação mesmo, botando o nosso user.id. Pronto, vai trazer somente os schedulings daquele usuário. Que na verdade são todos, porque a gente não criou nem mais um usuário na aplicação, mas tudo bem. E aqui, AND, vou criar mais uma verificação. E eu quero buscar apenas os schedulings que a data, o mês e o ano da data, bate com o mês e o ano da data que eu estou buscando aqui em cima. Então AND, aqui como a data está sendo salva num formato completo, eu vou botar isso de uma forma diferente. Eu vou usar um método chamado DateFormat, que existe dentro do SQL, para fazer S, ou melhor, scheduling, ponto date. Então estou pegando a data do scheduling, essa data aqui, não é a createdAt, essa data aqui. E aí eu quero pegar aqui %y, traço %m. Isso aqui vai me retornar, então, ano mês, num formato, por exemplo, 2022-12, nesse formato aqui. E aí, agora, eu quero verificar se isso aqui é igual a, basicamente, este ano e este mês aqui. Então, aqui eu vou botar, por exemplo, posso colocar uma string aqui dentro, com um if, e aí eu boto a variável year e a variável month. A gente já tinha utilizado isso em outro momento? Acho que não, né? Salvo, voltamos aqui dentro, F5, e agora deu erro. No such function DateFormat. Por quê? Nós estamos utilizando SQLite na nossa aplicação. E o SQLite, agora, começa um problema da gente estar utilizando o SQLite na nossa aplicação, que é, se a gente quer publicar a nossa aplicação em MySQL, em algum momento, a gente vai precisar, em desenvolvimento também, fazer essa aplicação em MySQL. Principalmente quando a gente for começar a escrever raw queries, ou seja, queries que são SQLs direto para o banco. Porque, nesse momento, o Prisma não está mais trabalhando aqui em cima, convertendo as funções para um formato que funciona em todos os bancos de dados. Então, aqui a gente chegou num ponto que não dá mais pra gente continuar com o SQLite. A gente vai precisar rodar no MySQL. E aqui, de um ponto que a gente já tinha discutido antes, como você vai rodar MySQL na sua máquina, existem diversas formas. O que eu aconselho, Docker. Agora, se você estiver no Windows, eu sei que o Windows tem problemas de WSL com Docker, eu acho que hoje em dia até já está mais resolvido. Só que eu não vou conseguir saber todos os problemas que podem acontecer na sua máquina de utilizar o Docker. Mas, se você estiver em ambiente UNIX, seja Linux ou Mac, eu sei que isso vai ser transparente para você só instalar e sair utilizando. Eu vou te mostrar como que eu faço para subir um banco MySQL aqui na nossa máquina, usando o Docker. E aí, como você vai instalar o Docker, eu posso deixar um guia, eu vou deixar um guia também aqui nessa aula, caso você não tenha instalado, de como instalar o Docker na sua máquina e fazer ele funcionar. Então, vamos lá. A primeira coisa que eu preciso fazer é abrir o Docker. E, enquanto ele abre o Docker, eu já tenho um container do MySQL lá, mas eu vou te mostrar basicamente o comando que eu uso para rodar o MySQL, que é isso aqui. Então, docker run, eu dou um nome para o meu banco de dados, para o meu container, que vai se chamar MySQL. Seto uma variável ambiente, usando o \"-e\", chamada MySQL root password, ou seja, em desenvolvimento eu estou trocando a senha do usuário root do MySQL, que o nome do usuário inclusive é root, para docker. E aqui eu estou expondo a porta 3306, que é a porta padrão do MySQL, ou seja, expondo ela para a minha máquina, para a host, na verdade, que é a minha máquina, ou seja, quando eu acessar a porta 3306 do localhost, vai direcionar para a porta 3306 dentro desse container. Se você não sabe como o Docker funciona, talvez isso seja um pouquinho também de informação demais, mas basicamente a gente pode entender o Docker como um subsistema dentro do nosso sistema operacional, não é uma máquina virtual, na verdade, ele herda o kernel da máquina principal. Então, se você está no Mac, no Linux, ele herda o Unix da sua máquina e não precisa recriar tudo isso do zero, por isso que não é uma máquina virtual, ele é mais uma abstração no formato de container. E aqui eu estou utilizando a imagem do MySQL na sua versão latest, aqui como eu já tenho um container do MySQL, até se eu dar um docker ps aqui \"-a\", eu vou ver que eu tenho um container aqui embaixo do MySQL, eu vou criar um novo para a gente partir do total zero juntos, então eu vou dar um docker run novamente, só que eu tenho que trocar o nome, o meu aqui eu vou botar MySQLignite, só para eu não criar com o mesmo. Então, a gente aguarda um pouquinho, aqui eu devia ter rodado ele com a opção \"-d\", para ele ficar rodando em modo detached, mas não tem problema, a gente aguarda que ele terminar de subir o nosso SQL e pronto, quando ele dá esse ready for connections, está pronto. Posso dar um, acho que o ctrl-c não vai resolver aqui para parar ele, então a gente vai ter que, eu vou fazer o seguinte, aqui num outro terminal, deixa eu dividir esse terminal, docker ps, eu vou dar um docker stop MySQLignite, então enter, pronto, agora ele já fez o stop aqui embaixo. E agora, como eu já tenho o meu container, eu posso só simplesmente dar, deixa eu fechar esse terminal, um docker start MySQLignite, dou enter e pronto, ele já está rodando, se eu dou um docker ps, pronto, a gente pode ver que ele está rodando aqui na porta 3306. E aí, para a gente fazer o MySQL funcionar aqui na nossa aplicação, a gente vai ter que fazer dois ajustes bem rapidinhos. Primeiro deles, aqui no env, vou trocar a URL de conexão, que não vai mais ser um arquivo físico, o dev.db, que é o SQLite, nós vamos trocar para mysql://root, que é o meu usuário, docker, que é a minha senha, que eu botei aqui no comando, no docker run, essa aqui é a senha, e root sempre vai ser o usuário principal, arroba localhost, dois pontos, 3306, que é a porta, e aqui eu dou um nome para o meu banco, tanto faz, vou chamar de ignite call, que é o nome do banco de dados, salvo, aqui no prisma, eu vou deletar o banco de dados, dev.db, a gente vai precisar criar algumas informações do total zero, se cadastrar de novo na aplicação, então, infelizmente, aqui, provider, eu vou trocar para mysql, salvo, também preciso apagar a pasta migrations, porque ela foi gerada utilizando o SQLite, até aqui no migration lock, está aqui, provider SQLite, então, eu vou apagar, e agora, eu vou rodar tudo do zero, então, npx prisma migrate dev, aqui como são várias tabelas, o nome da migration vai ser apenas create db structure, que ele vai criar todas as tabelas de uma porrada só, deu certo, então, ele já criou aqui o nosso SQLite, que cria todo o banco de dados, sem problemas nenhum, e aí, agora, teoricamente, já está tudo funcionando, não vai ter problema nenhum, só que eu preciso fazer o processo todo de cadastro dentro da aplicação, inclusive, eu vou parar de rodar o Prisma Studio, parar de rodar a minha aplicação, rodar a aplicação de novo, rodar o Prisma Studio de novo, lá no Prisma Studio, eu vou ver que agora não tenho mais nenhum dado, porém, todas as tabelas estão criadas, sem problemas nenhum, volto aqui na minha aplicação, inspeciono, venho em application, cookies, aqui na minha aplicação, deleto todos os cookies, para a gente fazer todo o processo de cadastro na aplicação de novo, então, a gente vai para register, DiegoSF, deixa eu dar um pouquinho de zoom, Diego Fernandes, conectar o Google Calendar, vamos ver se está tudo funcionando, sem problemas nenhum, beleza, ele deu erro, provavelmente, já sei o que é, fechou, o que acontece, quando a gente trabalha com MySQL, aqui dentro do Prisma, os campos que são string, no MySQL, eles são convertidos para varchar, com um tamanho específico, dentro do MySQL, deixa eu até abrir a nossa migration aqui, eles são varchars com 191 caracteres, porém, alguns campos de texto aqui, eles precisariam ter mais do que 191 caracteres, nesse caso, no MySQL, especificamente, a gente precisa botar aqui no Prisma, por volta, depois desses campos que precisam ter um tamanho maior, arrobaDB ponto, e aqui a gente tem vários, e eu vou botar a opção texto, então, a gente vai botar isso somente nos campos que faz sentido ter mais de 191 caracteres, então, por exemplo, biografia faz sentido, porque pode ser grande, e aí, deixa eu ver, aqui dentro de account, a gente vai colocar isso tanto no refresh token, quanto no access token, porque são coisas bem grandes, e no id token também, aqui em session, deixa eu ver se eu boto em algum lugar, não, é isso, são só nesses campos mesmo, a gente salva aqui agora, vamos rodar npx prisma migrate dev também, e vamos colocar aqui, update text field types, pronto, show de bola, a gente pode, para garantir, só rodar o Prisma Studio de novo aqui, e rodar a nossa aplicação de novo, e a gente vai continuar fazendo o processo, então, deixa eu voltar aqui, aplicar em diego.shell.f de novo, ainda não deu certo, deixa eu ver só, check state, provavelmente é porque eu devia ter começado o processo do total zero, então, register, deixa eu fazer o processo do zero aqui, ele já, agora, acaba que já tinha um usuário, ele criou? criou, então, deixa, se bem que ele gravou na sessão usuário, então, eu posso ir direto para connect canada, porque o id do usuário já deve estar na sessão aqui nos cookies, e aí não preciso criar ele do zero, não, não tá, então, deixa eu fazer o processo do zero mesmo, apaga aqui, apaga aqui, cara, agora eu tô ficando confuso, deixa eu fechar tudo aqui, user, por que que eu não tô conseguindo desertar, vamos lá, diego.sf, diego.fernandes, enter, connect to google calendar, próximo passo, show, seleciona segunda e terça, na segunda-feira, lembro que eu queria deixar, na terça, né, vou deixar o horário bem, das 8 às 10 somente, algo bem menor, próximo, cto, rocketseat, finalizar, perfeito, a gente tem mais ou menos o que a gente já tinha antes, porém, usando o MySQL, só que a gente ainda não tem os horários ocupados aqui, que seriam úteis para a gente começar a trabalhar na nossa rota lá de horários bloqueados, né, então, eu vou criar dois schedulings aqui na mesma pegada que a gente tinha feito, só trocar aqui a data certinho, né, então, 2022, 12, hoje é dia 20, só que hoje é terça-feira, então, pode ser hoje, aqui, cuidado, né, para criar perto da sua data, né, que você tá trabalhando aí, e aqui os dois horários bloqueados, esses horários aqui, inclusive, já passaram, né, já deveriam estar bloqueados, então, isso aqui a gente faz uma checagem depois, mas, como a gente não checou ainda, eu vou criar nesses horários mesmo, não tem problema, às 8 horas, que aqui deveria ser 11, porque sempre vai ser UTC, então, fica mais 3, Diego Fernandes, Diego, arroba, test.com, e aqui o user seleciona DiegoSF, a data ficou errada? 11, 0, 0, faltou 0, 0, o que ficou errado aqui? 2022, 12, 20, aqui ficam dois pontos, 11, 2, 0, 0, agora sim, show. Se eu volto lá agora, 8 horas já tá ocupado, e a gente vai criar mais um aqui, copiando, porém, 12, que significa 9 horas, Diego, Diego, arroba, test.com, porra, perdeu de novo a referência aqui, 12 horas, às vezes ele dá uma perdida o Prisma Studio aqui, dá uma bugada, save, fechou, 9 horas ocupado. E agora sim, a gente pode, teoricamente, abrir nossa API, users, blockerDates, passando ano 2022, mês 12, se eu dar um enter, veja que agora deu tudo certo, não deu mais o erro lá na nossa rota, aqui em blockerDates, por causa do DateFormat, porque isso aqui agora é uma função válida no MySQL, e eu troquei pra MySQL, porque MySQL é o banco que eu vou utilizar em produção, mas você pode, talvez, trabalhar com outro banco, e aí tem que cuidar, porque as funções aqui vão ser outras, mas é isso, bora continuar, porque essa query aqui ainda vai longe."
  },
  {
    "id": "57cec1ee-3715-47fe-90fc-799f9760d0b5",
    "title": "Instalação do Design System",
    "transcription": "Durante o desenvolvimento desse projeto, o Ignite Core, a gente vai estar utilizando um Design System, uma biblioteca de componentes construída aqui pela Rockstech, inclusive dentro do Ignite, que é o Ignite UI. Então foi um Design System que a gente construiu em um dos módulos do Ignite. E aqui eu aconselho que mesmo que você tenha feito esse módulo e tenha desenvolvido o Design System, que não é obrigatório para seguir na construção dessa aplicação, utilize o meu pacote, o que eu desenvolvi, e não o seu, porque eu fiz alguns ajustes de tipagem, algumas coisas que não couberam serem apresentadas lá naquele momento. Então a gente vai utilizar sempre esse pacote aqui. E aí você pode ver que o Ignite UI aqui hoje tem três pacotes. O pacote que a gente vai estar utilizando no final das contas é o Ignite UI React, que são os componentes especificamente dessa biblioteca para trabalhar dentro do React. Então aqui no VS Code a gente vai começar abrindo o terminal e instalando Ignite UI barra React. Pode colocar um arroba latest, não tem necessidade na verdade, ele vai instalar a última versão de qualquer forma, até porque a tag latest por padrão no npm ela pega a última versão lançada. E aí pronto, com o Ignite UI instalado, a gente pode fazer algumas configurações aqui para estar utilizando esse pacote aqui dentro. Primeira coisa, aqui dentro de source, eu vou começar criando uma pasta styles. Dentro da pasta styles eu vou criar um arquivo chamado global.ts, que vai ter alguns estilos globais na minha aplicação. E aqui dentro eu vou importar, de dentro de Ignite UI React, eu posso simplesmente importar o global.css. O global.css vem do Ignite UI, por baixo dos panos ele está utilizando o Stitches. O Stitches que é uma ferramenta de CSS em JS, muito semelhante a Styled Components, muito semelhante a Emotion, muito semelhante a qualquer outra biblioteca de CSS em JS que a gente tem comumente utilizado dentro do React. Então, basicamente uma forma de a gente escrever estilização por dentro do JavaScript. Talvez se você usa o Styled Components, usa alguma outra biblioteca, você tem que aprender um pouquinho a diferença entre essas APIs, mas a gente vê junto aqui, não tem problema nenhum. Para criar os estilos globais dentro do Stitches, a gente basicamente vai criar uma variável chamada global.styles, por exemplo. Vamos chamar a função global.css, essa função recebe um objeto e aqui dentro a gente vai declarar as nossas estilizações. Por exemplo, eu quero que para todos os elementos, e isso eu vou declarar em formato de JavaScript, veja que é um objeto, eu não declaro isso com CSS especificamente. Aqui dentro eu vou falar que para todos os elementos do HTML, eu vou ter um box.sizing como border box, vou ter um padding como zero e vou ter um margin como zero aqui. E dentro do body, por exemplo, da minha aplicação, para a gente visualizar que o nosso design system está funcionando, até se a gente acessar aqui dentro, deixa eu pegar o ignite.ui, ele acabou não colocando aqui, mas vamos acessar 05.ignite.ui, eu coloquei, aqui está o repositório do projeto, e se a gente acessar o repositório deste projeto, a gente pode ver que aqui na direita tem um link para a documentação. Esse link para a documentação vai abrir um storybook com todos os componentes, cores, tudo o que a gente vai poder utilizar do ignite.ui. Caso você não tenha codado esse módulo, é bom você abrir essa documentação e dar uma olhadinha aqui. Por quê? Porque a gente já deixou algumas cores prontas, tamanhos de fonte, o peso da fonte, as famílias da fonte, line height, os radios, spacing para margem, padding, e alguns componentes como avatar, a box, button, checkbox, multistep, textarea, que não abriu aqui, textinput, o heading e o text. Então, vários componentes que a gente vai estar utilizando na nossa aplicação. Por que eu estou falando isso agora? Porque aqui nos tokens, se a gente clicar em tokens e colors, a gente vai ver que a gente tem várias tonalidades de cinza, que são as cores que a gente vai estar utilizando nessa aplicação, que são geralmente as cores que a gente usa em aplicações desenvolvidas aqui dentro do Ignite. A gente tem algumas tonalidades de verde, que são variações do verde da cor do logo do Ignite. E aqui tem um teste, que não era para ter subido, mas subiu ele, não tem problema nenhum. Mas todo o resto aqui está disponível. E aqui dentro do stitches, para a gente utilizar esses tokens, basta a gente prefixar a nossa cor, até dando background color. E já vendo aqui, ele já traz a sugestão de todas as cores de cinza do Ignite, inclusive do teste ali. Mas a gente vai colocar aqui um gray 900, por exemplo, como cor de fundo da aplicação. E vamos colocar aqui uma cor de texto como sendo o gray 100. Caso você queira ver os valores, é só dar uma olhadinha aqui na direita. Então o gray 100 é esse E1, E1, E6. E o 900 é o 12, 12, 14, que geralmente é o que a gente usa. E eu também gosto de adicionar aquela opção, traço WebKit font-smoothing anti-aliased, para que dentro dos browsers que estão baseados em WebKit, como Chrome, Microsoft Edge, Vivaldi, a fonte anti-aliased, elas fiquem mais detalhadas, então fica mais legal. E agora para a gente utilizar esse global styles, basta a gente acessar pages, a pasta app, e importar aqui dentro. Então a gente vai tirar essa importação que tem aqui dentro. E eu vou simplesmente só executar a função e ele já vai fazer a importação automática. Então é só global styles aqui, dar um Enter, e executa a função. Eu executo a função aqui mesmo, porque os estilos globais da nossa aplicação, a gente vai carregá-los uma única vez, então não necessariamente a gente precisa executá-los dentro do componente. Se eu acabo colocando dentro do componente, o app acaba recarregando. Toda vez que a gente acessa uma página nova, e assim gerando estilos globais do zero, toda vez que a gente acessa uma página nova, o que acaba sendo, muitas das vezes, um gasto de performance desnecessário. Feito isso, a gente pode rodar nossa aplicação, para testar se ela está funcionando da maneira que a gente espera. Então abre aqui, localhost 3000, e a gente tem que ver exatamente isso. Um fundo cinza escuro, e a fonte aqui mais clarinha. Uma das coisas que está faltando aqui, que já dá para perceber, é que a gente está sem a fonte que a gente vai estar utilizando nessa aplicação, que é a fonte Roboto. Então eu posso também já pré-configurar essa fonte aqui. Mas a gente tem aqui, então deixa eu remover as fontes que eu já tinha selecionado. Aqui a gente vai estar utilizando três tamanhos. A gente vai estar utilizando o regular, que é o 400, o median, que é o 500, e o bold, que é o 700. Com essas três fontes selecionadas, a gente pode copiar o código HTML de utilização, e a gente vai basicamente criar um arquivo chamado document.tsx, que é a maneira que o Next tem no momento atual para configurar o documento, digamos assim, o HTML da aplicação. Aqui a gente vai simplesmente exportar como default uma function chamada document. O nome aqui é irrelevante, porque a gente está exportando como default. E aqui a gente vai utilizar alguns elementos que vêm de next-document. Então HTML, o head, que também vem de next-document. Cuida para não importar o head aqui de next-head, que são duas coisas diferentes. Eu vou coloar aquele HTML que a gente importou, e aqui ele não veio com as linhas quebradas, então a gente arruma isso na mão. Aqui, como a gente está no projeto React, a gente tem que fechar cada tag com a barra no final, e também aqui o cross-origin precisa ser com o O maiúsculo, no formato de QML case, e aqui a gente pode ou deixar assim, ou colocar anonymous, porque ele obriga a gente a colocar um valor aqui para o cross-origin. Feito isso, é importante lembrar que essas duas linhas de pre-connect precisam ser as primeiras linhas aqui no topo do head, e os demais scripts que a gente for colocar, tudo aqui dentro, a gente pode colocar ou aqui, ou abaixo aqui do link da importação da fonte. Vou colocar aqui o body da nossa aplicação, e dentro do body a gente vai ter simplesmente o main, que vem de next-document também, e o next-script, que vem de next-document aqui. Feito isso, a gente pode salvar e restartar aqui a nossa aplicação. Voltamos lá, e agora a gente vai ver que a fonte roboto ainda não funcionou. Claro, ela não funcionou porque a gente não determinou que a fonte roboto é a fonte padrão na nossa aplicação. Isso até é algo que a gente fala bastante durante a construção do nosso design system, que todos os textos da nossa aplicação, inclusive esse próprio hello world que a gente colocou aqui dentro, dentro do h1, a gente vai utilizar componentes que vêm de dentro do próprio design system. Então, lá de dentro do ignite-ui-react, você vai ver que tem dois componentes, um deles chamado heading e outro text. Já dá pra entender a diferença deles. O heading a gente vai utilizar quando a gente vai utilizar algum texto que é um heading, então h1, h2, h3, h4, h5, h6, e o text a gente vai utilizar pra qualquer outro texto. O heading por padrão aqui, ele é um h2, mas a gente pode mudar isso, então basta eu simplesmente usar heading aqui dentro, ele vai ser um h2. Caso eu queira que ele funcione como um h1, basta eu passar a propriedade ast-h1 e ele vai funcionar agora como um h1. Assim pro text também, que por padrão, se não me engano, ele é um parágrafo ou um span, e aí a gente pode customizar ele. Tem que dar uma olhada lá, eu não lembro, mas a gente pode olhar. Show agora, a gente está vendo aqui que ele já pegou a fonte roboto, já aplicou, só que tem um problema aqui. Se eu inspecionar a minha aplicação, for aqui e desabilitar o JavaScript e dar um F5, a gente vai ver que o CSS não carrega. Isso porque, por padrão, o status não tem uma integração nativa com o server-side-rendering, a gente tem que adicionar um código a mais. Aqui dentro do document, a gente precisa, pra que o server-side-rendering funcione, criar uma tag style, a gente precisa colocar um id nela, chamada stitches, e aqui a gente vai colocar um conteúdo nela, só que é um conteúdo que vem através de uma variável JavaScript. Quando acontece isso no React, a gente precisa usar o dangerouslySetInnerHTML e aqui a gente vai passar um objeto, underline, underline, HTML, dois pontos, e aqui a gente vai chamar uma função chamada getCSSText, deixa eu até tirar meu rosto da frente, que vem de dentro aqui do IgniteUI React, exatamente. Então a gente chama essa função aqui dentro, salva, volta lá pro Google Chrome, deixa eu ver se eu preciso restartar a minha aplicação quando eu mexo no document, não tenho certeza, nessa nova versão do Next eu acho que não precisa mais, mas pra garantir. E agora se eu venho aqui, desabilito o JavaScript, restarto a nossa aplicação, a gente pode ver que tá tudo funcionando, a estilização funcionando 100%. Então a gente já tá com a parte de integração de estilos na nossa aplicação rodando 100% e agora é só sair estilizando, criando a estrutura aqui das páginas."
  },
  {
    "id": "b35b13c1-a04d-4a1a-91ce-360bf32a5a75",
    "title": "Manipulando cookies no Next",
    "transcription": "Para a gente criar um exemplo de validação aqui dentro da nossa rota, uma das coisas que a gente pode fazer antes de tentar criar já diretamente o usuário é buscar por um usuário com o mesmo username do que está tentando ser criado. Então eu posso fazer, por exemplo, const userExists é igual a waitPrisma.user. E aqui tem um método muito legal que se chama findUnique, que eu posso encontrar um registro por algum campo que seja único. Então até quando a gente fizer o WHERE aqui dentro, veja que dentro do WHERE ele só permite eu fazer uma busca por ID ou por username, que são os únicos campos que a gente tem, únicos, dentro da tabela de usuário. Aqui a gente vai procurar pelo username. E aqui, caso esse userExists aqui retorne alguma coisa, a gente vai dar um erro. Então vou retornar aqui, vou fazer um early return, ou seja, o resto do código não vai executar. Eu vou retornar um status 400, que seria um código mais genérico de erro, um bad request, aqui com uma mensagem de erro. Então json.message.username.alreadyTaken, por exemplo, ou alreadyExists, tanto faz. Show de bola, agora se eu volto no Chrome, a gente vai ver que se eu tentar registrar aqui, ele não vai mais dar erro na rota, ou melhor, ele deu um 400, bad request. E o preview aqui eu tenho username.alreadyTaken. Como a gente fez apenas o console.log do erro, é isso que aparece aqui embaixo, o axisError. Então, mais pra frente, correto, claro, seria a gente mostrar alguma mensagem de erro. Pra ficar, talvez, um pouco mais agradável, antes da gente ter uma estrutura de erro melhor aqui, eu vou fazer o seguinte. Caso, olha só, caso ele retorne um objeto de erro e dentro tenha, dentro do response, dentro do data eu tenha um message, eu vou mostrar um alerta. Então, só pra ficar mais legal, olha só. Caso o erro seja um objeto e dentro dele eu tenha um response, e dentro do response eu tenha data, e dentro de data eu tenha message, então a gente está fazendo bastante o NullishCollessingOperator aqui. Aqui a gente vai fazer um alerta com esse campo, erro.response.data.message. Response does not exist on type, porque o erro aqui é undefined. E aqui a gente poderia fazer talvez de outra forma, porque o axisError poderia fazer talvez o seguinte, if error instance of axisError, ou seja, se o erro é uma instância do axisError e eu tenho erro.response, porque como ele sabe que isso aqui é um axisError, ele já vai entender que tem response. Data acho que também, porque todo response tem data.message. Ah não, object is possibly undefined. Então vai ter que ser dessa forma aqui mesmo. Meu TypeScript está um pouco lento aqui, às vezes ele não retorna na velocidade mais rápida possível aqui. Deixa eu dar um restart no TypeScript pra ver se é erro mesmo, ou se eu estou escrevendo certo e ele só não está dando erro. Tá, dei um restart agora e parou de dar problema. TypeScript está rodando? Tá, então é isso. Então se for um erro do tipo do axis, ele vai tentar dar um alerta aqui na mensagem, se não eu vou só dar um consoleError mesmo, mostrando o nosso erro aqui. Google Chrome, vamos voltar. Agora vou dar o próximo passo. Não mostrou nada. Ah, agora sim, deu um alerta aqui, acho que tinha dado algum bug antes. Pronto, username already taken. Ah, porque ele criou como test. Porque eu dei um F5, então test não existia ainda. Então olha só, ele criou test, por isso que não deu erro. Agora se eu fico tentando criar, ele já fala que o username foi taken, já foi pego. E aqui ele acabou dando esse consoleLog aqui todas as vezes, porque aqui eu não uso nenhum earlyReturn nem nada disso. Poderia fazer um return dessa forma aqui para ele não executar o consoleLog nesse caso. Pronto, agora ele não faz mais o log do axisError. Ele vai dar o log apenas se for algum outro tipo de erro que aconteça às vezes no frontend. Show de bola, agora que a gente já fez a validação, uma das coisas que a gente tem que olhar aqui para a nossa aplicação é que a nossa aplicação, por mais que eu esteja criando o usuário nesse primeiro momento aqui, eu não estou autenticando o usuário. Concorda comigo? Ele não está criando senha. Eu não sei o email dele, eu não sei o telefone dele, eu não sei nada. Ele não está conectando com o Google. Ou seja, como que eu vou identificar esse usuário nas próximas etapas do cadastro se ele não fez login ainda? Eu não tenho uma informação para dizer que esse usuário está logado. Então eu preciso de alguma forma conseguir identificar o usuário até ele chegar no final do processo de cadastro ou pelo menos até ele logar, que seria na hora que ele conecta o Google Agenda, que a gente já consegue fazer o login dele, porque eu vou estar conectando com o Google. Ou seja, eu preciso de uma forma de saber quem é esse usuário entre os redirects aqui da minha aplicação, inclusive se ele fizer um F5, atualizar a página. Como que a gente consegue fazer isso? Na web, a melhor forma de fazer isso, e várias aplicações fazem isso com você, você deve saber, é utilizar cookies. Os cookies são a melhor maneira dentro do browser para a gente conseguir saber tanto no back-end, tanto na camada back-end, quanto no front-end, informações do usuário que está utilizando aquela aplicação. Inclusive muitos, até veio com o LGPD e tudo mais, mas muitos sites usam cookies para conseguir saber quem você é entre vários sites da mesma empresa, digamos assim. Bom, aí entra para uma discussão muito maior, mas aqui a gente vai utilizar cookies simplesmente para isso, de uma maneira muito simples para identificar o usuário entre o fluxo de cadastro. E para trabalhar com cookies aqui no Next, a gente pode simplesmente, aqui dentro do objeto Hack, a gente consegue obter os cookies, então Hack.cookies, por exemplo, e para devolver cookie, aqui dentro do REST, a gente tem um método setHeader, e aqui dentro a gente pode devolver um setCookie, por exemplo, informando quais são os cookies que a gente quer criar, digamos assim, quando essa requisição aqui for chamada. Só que eu não gosto muito dessa API, eu acho que essa API de trabalhar com cookies a partir do Hack do REST, ela é um pouco não developer-friendly, ela é um pouco estranha, então eu gosto de trabalhar com um outro pacote chamado Nukies. O Nukies nada mais é do que NextCookies, então é um pacote feito especificamente para a gente trabalhar com cookies dentro do Next. E aqui dentro dessa rota de criação do usuário, eu quero salvar então nos cookies de alguma forma que eu consiga identificar esse usuário, mesmo que ele dê um F5, mesmo que ele vá para outra página, a melhor forma da gente identificar o usuário é ou pelo ID ou pelo username. Eu vou botar o ID porque eu acho que o ID é um pouco menos sensível, digamos assim, ele não é uma informação tão fácil de entender o que isso quer dizer, então aqui eu vou importar de dentro do Nukies um carinha chamado SetCookie. E aí aqui embaixo, depois de eu ter criado o usuário, ou seja, somente depois que eu criei o usuário, eu vou chamar o SetCookie, e aí o SetCookie aqui a primeira coisa que ele precisa receber é um objeto, e dentro desse objeto eu posso enviar o REST, está vendo aqui? Então eu recebo esse REST aqui, lembra que é o REST que eu posso botar um header para enviar o cookie. Então é por isso que é importante, se você já está aqui, entender um pouco bastante sobre HTTP, entender o que são cookies, e entender que os cookies estão trafegados através dos cabeçalhos da nossa requisição e resposta. Então para eu setar um cookie eu preciso criar um header, um cabeçalho na resposta, chamado SetCookie, então por isso que eu preciso usar o REST aqui dentro do Nukies, para que ele consiga criar esse cabeçalho. Aqui eu vou dar um nome para o meu cookie, eu gosto geralmente que ele inicie com um prefixo relacionado à minha aplicação, então por exemplo eu gosto de botar arroba, o nome do meu app, por exemplo, IgniteCall, pode ser dessa forma, dois pontos, um nome específico, então aqui eu vou chamar de UserId, e aqui o valor, User.id. E aqui eu posso passar algumas opções para esse cookie, porque os cookies eles são bem maleáveis, a primeira coisa que eu posso passar, por exemplo, é um tempo de inspiração para esse cookie, e ele pode ser passado de duas formas, expires, então aqui está vendo que ele não está dando autocomplete, eu dou um ctrl espaço e ele não traz o autocomplete, isso é porque o seguinte, se eu venho aqui e dou um ctrl e clico em SetCookie, essa biblioteca por baixo dos panos, ela usa uma outra biblioteca chamada Cookie, só que essa biblioteca Cookie, ela não traz com ela, ela não traz nada de TypeScript, por isso que não está trazendo o autocomplete. Se eu instalar types barra cookie, como uma dependência de desenvolvimento, que são as tipagens dessa biblioteca, agora eu volto aqui e dou um ctrl espaço, agora sim ele trouxe. E aqui eu posso passar expires, que eu posso passar um objeto date do Javascript com a data que eu quero que esse cookie inspira, todo cookie precisa ter uma data de inspiração, o cookie ele nunca vai ser algo infinito. Ou eu passo o maxAge, o maxAge eu passo em segundos, então quantos segundos eu quero que esse cookie fica disponível. Por que eu vou setar essa opção e por que é importante a gente setar essa opção? Eu tenho que pensar, se a pessoa vai iniciar um processo de cadastro aqui na minha aplicação, por quanto tempo eu gostaria de, a pessoa preencheu aqui o username e o nome, clicou em próximo passo, saiu da aplicação, por quanto tempo eu quero manter, esse histórico que a pessoa fez já um pré-cadastro na minha aplicação, ou eu quero depois que ela faça tudo do zero de novo. Eu tenho que pensar nisso, então aqui eu vou manter, por exemplo, eu posso pensar sete dias, eu acho que isso é suficiente. Então se isso aqui é em segundos, eu posso pensar que 60 é um minuto, vezes 60 é uma hora, vezes 24 é um dia, vezes sete são sete dias. E aqui eu boto um comentário para quem for da manutenção no código saber exatamente o que isso aqui significa sete dias. Isso aqui é o famoso magic numbers que a gente tem que cuidar dentro do Clean Code. Outra coisa importante dos cookies é que os cookies eles são específicos de uma, eles são categorizados entre uma rota. Eu posso salvar um cookie que ele é específico, por exemplo, de uma rota da minha aplicação, ou um cookie que está disponível para todas as rotas da aplicação acessarem, consumirem, manipularem. Se eu quero que um cookie seja global, ou seja, todas as rotas podem acessar, eu preciso enviar aqui um path enviando barra. Barra quer dizer a raiz, ou seja, todas as rotas da aplicação podem acessar. Se eu tivesse aqui no path, por exemplo, test, apenas as rotas que começarem com barra test poderiam acessar esse cookie. Aqui no cookie tem mais um monte de opção que a gente pode trabalhar. Então tem http only, tem same site. Cara, tem muita coisa que a gente pode trabalhar, mas por enquanto para a gente está bom essas opções. E agora com isso a gente pode testar. Salvo isso aqui. E agora eu vou lá no Prisma Studio, eu vou deletar os dois usuários que a gente já tinha criado e eu vou criar um usuário novo. Então, Diego SF, Diego Fernandes. Agora eu vou abrir aqui o inspecionar elemento. Vamos em network, dou um próximo passo e vamos dar uma olhadinha aqui. Users, aqui em headers, response headers. Veja que ele já criou um response header, um cabeçalho set cookie. Então ele preencheu aqui, ignite call user id, igual o id do usuário, o max age aqui para a gente e o path barra. Se eu quero ver esses cookies de uma maneira diferente, eu posso vir aqui no Chrome dentro de application, cookies, localhost 3000. Aqui ele vai trazer de várias outras aplicações que eu tinha. Então, olha só, eu vou pegar e vou limpar tudo isso aqui para ficar mais claro a gente visualizar. Então tá aqui, ignite call user id, o valor, que é o id do nosso usuário e mesmo que eu dê um F5 na página, eu pego e dou um F5, o cookie, ele continua aqui. Ou seja, eu continuo tendo acesso ao id do usuário, mesmo quando ele sai, quando ele volta da aplicação. E é esse id do usuário que a gente vai conseguir utilizar depois para na hora que ele fizer login aqui, opa, abriu descorto sem querer, na hora que na página aqui de conexão com o Google Agenda, ele fizer login, eu consiga saber qual que é o usuário que está fazendo login, qual que é o usuário que está conectando a agenda. É o usuário que está ali no cookie, o id do usuário. Então o cookie é uma maneira ótima da gente persistir informações entre sessões e conseguir ter acesso a essa informação tanto no back-end quanto no front-end. Porque se a gente usasse algo como local storage, por exemplo, a gente teria acesso a isso somente no front-end e não no back-end da nossa aplicação. Então agora, bora continuar que tem bastante coisa aqui pela frente."
  },
  {
    "id": "d7bdcbb0-48bc-4cd7-a981-fc6055c41bcf",
    "title": "Criando o usuário no adapter",
    "transcription": "Nessa aula, depois de bastante código, a gente vai fazer a parte do createUser aqui. Só que o createUser, como eu falei, ele vai ser diferente, ele não vai criar o usuário. Eu preciso, na verdade, buscar qual que é o ID do usuário nos cookies, porque é lá nos cookies que vai estar o ID, digamos, daquele pré-cadastro que o usuário fez, com base nesse ID aqui, eu preciso preencher as demais informações que vêm nesse objeto user, como por exemplo, email, nome, avatar, dentro do registro do banco de dados que já existe, que tem esse ID aqui. Só que o problema aqui é que o Prisma Adapter, ele não tem acesso aos cookies, porque os cookies, se a gente for lembrar, quando a gente falou sobre cookies, na hora que a gente falou aqui, de criação do usuário, os cookies eu só consigo ter acesso a eles através desse objeto aqui, REC e REST. De dentro do REC eu tenho cookies, aqui de dentro eu tenho todos os cookies, e do REST eu posso criar ou deletar e vai modificar os cookies. Então, REC sempre para acessar, porque está sempre na requisição, e REST que é da resposta para modificar, fazer um processo de mutação. Então, a gente vai ter que mudar um pouquinho. E aí, aqui na documentação do próprio NextAuth, Getting Started, deixa eu ver se está aqui no próprio Getting Started. Aqui, deixa eu ver, Read More About How to Add Options, Documentation. Deixa eu ver se é aqui dentro. Initialization, aqui ó. Dentro da parte configuração e inicialização, se não me engano é aqui. Aqui embaixo a gente vai ver que tem duas formas de a gente inicializar o NextAuth, aqui nesse arquivo NextAuth. Uma delas é a gente só fazendo export default NextAuth, dessa forma, que é o que a gente está fazendo hoje. E aí, isso aqui é uma função API do Next, normal. Onde, por exemplo, essa outra aqui de criação do usuário, a gente tem acesso ao REC e REST. Só que está vendo que aqui no arquivo do NextAuth, em nenhum momento a gente tem acesso ao REC e REST. Essas variáveis não estão em nenhum lugar aqui dentro. Eu não consigo acessá-las. E aí, aqui na documentação, ele tem a diferença do SimpleInitialization e lá embaixo tem o AdvancedInitialization. E aí sim, ao invés de eu simplesmente dar um export default NextAuth, eu pego, crio uma função, tanto faz o nome dela aqui, para ela ter acesso ao REC e REST. Está vendo? Então, olha só, eu vou copiar isso aqui, colar aqui embaixo, fazer dessa forma, aí eu preciso importar o NextAPIRequest e o NextAPIResponse, aqui, de dentro do Next. E aqui eu chamo o nosso NextAuth, enviando para ele as opções como terceiro parâmetro. Então, eu passo Auth Options aqui dentro. Está vendo? Então, beleza. Agora, a gente tem acesso ao REC e REST. Porém, a gente ainda não tem acesso ao REC e REST lá dentro do Prisma Adapter. Então, a gente precisa enviar esse REC e REST até chegar lá no Prisma Adapter. Então, olha o que a gente vai fazer. É uma maluquice, mas vai dar certo no final das contas. Ao invés disso aqui ser simplesmente um objeto, o Auth Options, eu vou transformar isso aqui numa função. Então, olha só, export function, e eu vou trocar o nome para buildNextAuthOptions. E essa função, sim, vai devolver o NextAuthOptions aqui. Deixa eu copiar esse objeto inteiro aqui. E aqui eu vou dar um return nesse objeto. Beleza. E agora, aqui embaixo, eu posso chamar a função buildNextAuthOptions sem enviar parâmetros nenhum. Está tudo funcionando da mesma forma. A gente pode ver que o TypeScript avisa para a gente que não tem nenhum erro. Ela retorna o NextAuthOptions. Então, mais ou menos o que a gente tinha antes. Porém, veja só. Agora eu vou fazer que essa função buildNextAuthOptions aqui ela receba o REC e o REST. O REC do tipo NextAPIRequest e o REST do tipo NextAPIResponse. Olha só que legal. Agora aqui embaixo, quando a gente chama essa função, eu envio para ela também o REC e o REST. A gente está, aos poucos, botando para dentro essas variáveis. Agora que eu tenho o REC e o REST aqui dentro, quem precisa ter acesso a esse REC e o REST? O Prisma Adapter, não é? Então, eu posso fazer com que o Prisma Adapter receba REC, REST também. E aí a gente faz a tipagem aqui. Então, NextAPIRequest. E esse aqui, NextAPIResponse. Volto lá no meu NextAuth e envio o REC e o REST para o Prisma Adapter. E concorda comigo que agora, dentro do Prisma Adapter, eu tenho acesso ao REC e REST. Ou seja, eu tenho acesso a tanto acessar os cookies quanto setar novos cookies, caso seja necessário. E agora, aqui no Create User, o que a gente vai fazer? Eu vou usar aquela biblioteca que a gente tinha utilizado antes, que era o NUKES. Para fazer o quê? Usar um método chamado ParseCookies, que é para a gente buscar os cookies. O ParseCookies é para a gente buscar os cookies. Não existe um método para eu buscar um único cookie. Eu sempre trago todos os cookies. Então, aqui eu vou fazer o seguinte. Vou fazer uma desestruturação daqui a pouco. ParseCookies, e eu envio um objeto, e dentro dela eu preciso enviar o REC. Olha só, envio o REC aqui dentro. E aqui eu trago todos os cookies. Porém, eu quero um único cookie aqui da nossa aplicação, que é o IgniteCallUserIG. Então, eu posso fazer uma desestruturação, só que aqui, como o nome dele é um pouco esquisito, eu tenho que fazer a desestruturação dessa forma. Aspas, o nome esquisito, dois pontos e o nome que eu quero para essa variável. Então, eu vou chamar de UserIDOnCookies. Então, o ID do usuário nos cookies. E aí, aqui dentro, eu vou fazer o seguinte. Se eu não tiver um UserIDOnCookies, eu vou dar um throw, newError, UserIDNotFoundOnCookies. Se não, eu vou fazer o processo de conectar o usuário do Prisma, como eu estava falando, atualizar o usuário do Prisma. Então, const PrismaUser é igual a wait Prisma.user.update. E agora, eu tenho o ID do usuário, então eu posso procurar um usuário onde o ID seja igual a UserIDOnCookies. E os dados que eu vou atualizar são nome, que eu vou pegar de user.name, o user é o que está vindo aqui em cima, email, user.email, e avatar.url, user.avatar.url. E aí, depois que o usuário fez login, eu posso apagar o cookie, porque agora ele não vai mais ser utilizado. Para isso, eu tenho uma função do Nuke chamada destroy, cookie, que é para apagar. Então, a gente vai chamar destroyCookie, enviando para ela o res, agora. Sempre que a gente está fazendo uma modificação nos cookies, é o res. Se eu estou buscando, é o rec. Aqui eu passo o nome, então igniteCallUserID. E aqui, eu vou passar o path, que a gente já tinha explicado na hora que a gente setou os cookies. Para eu falar que eu quero apagar os cookies para todas as páginas. E esse método precisa devolver o usuário criado ali dentro do Prisma. Então, a gente vai copiar um return de outro que já existe. E pronto. Só que agora está dando um errinho aqui. Vamos dar uma olhada aqui. Tá, faltou um método dentro do nosso adapter que a gente apagou, que eu achei que não ia ser obrigatório, mas ele é, que é o deleteSession. Vamos criar ele bem rapidinho aqui embaixo. Ele é um método super simples. Cuidado só para criar no lugar certo aqui. Ele é um método muito fácil, muito tranquilo. Então, a gente vai fazer ele aqui embaixo rapidinho. Async.deleteSession. Recebe o sessionToken. E eu faço só o delete. Prisma.session.deleteWhere sessionToken é igual a sessionToken. Só isso. E você pode ver que agora já parou de dar erro em tudo. Aqui o Prisma User é o que eu vou usar aqui embaixo. Perfeito. Já parou de dar erro também. E pronto. Finalizamos. E agora a gente precisa testar o fluxo completo da nossa aplicação. Eu acho que vai dar um bugzinho, mas logo a gente resolve. O que eu vou fazer? Para a gente testar tudo, tudo, tudo, eu vou dar um F5 aqui na minha conta do Google. Vou tirar o acesso do Ignite Call. Vou fazer tudo do zero. Vou deletar tudo aqui dos cookies. Vou no banco de dados. Vou deletar os usuários que já existem. Então, deleta o usuário DiegoSF. A gente vai fazer o fluxo completo agora. Então, vamos lá. Vamos começar com a página. Register. DiegoSF. Diego Fernandes. Próximo passo. Beleza. Conectar o Google Calendar. E agora, quando eu conectar o Google Calendar, a gente tem que torcer para não dar erro. Eu acho que vai dar um erro ali, mas logo a gente fala sobre isso. Try signing in with a different account. Ele deu um erro, provavelmente. Ele só retornou uma página padrão ali. Mas, vamos lá. Ele deu um erro aqui. Get user by account. Account not found. Ele deu um erro lá no nosso Prisma Adapter. Na linha 74. Que foi provavelmente no método GetUserByAccount. Esse método aqui, ele não conseguiu executar. Provavelmente, ele caiu neste FindUniqueOrThrow. E aí foi um erro que eu errei. Por quê? Esse aqui não pode ser um FindUniqueOrThrow. Ele tem que ser FindUnique. E aqui eu tenho que fazer basicamente o seguinte. Se eu não encontrar um usuário, eu retorno nulo. Por quê? Esse método GetUserByAccount, aqui. Deixa eu até trocar aqui, inclusive. Account. Se eu não encontrar um account. E aí aqui embaixo eu faço const user igual account. Eu só mudei um pouquinho a estrutura. Porque se ele não encontrar, eu não consigo desestruturar o user dali de dentro. Mas por quê? No primeiro momento que o usuário log a primeira vez na nossa aplicação, a account ainda não existe. Ou seja, o NextAuth usa esse método GetUserByAccount exatamente para saber se o usuário nunca logou na nossa conta. E aí se a gente dá um FindUniqueOrThrow aqui, até pro primeiro login do usuário, pro cadastro, vai dar erro. Então a gente tem que cuidar com isso. Eu acho que até tem um outro método aqui embaixo, que a gente faz algo parecido. Deixa eu ver se esse GetSessionAndUser aqui pode retornar nulo. Ah, esse aqui não pode. Então a gente pode ver até por aqui. Não, ele pode sim. Então vamos ter que fazer o mesmo processo. Então, FindUnique. E aqui eu vou chamar isso aqui de Session. Se a Session não existir, eu retorno nulo. Se não, eu vou fazer a desestruturação ali da mesma forma. E aqui já tem Session, né? Então eu vou chamar isso aqui de PrismaSession. Show de bola. Deixa eu ver os outros lugares que a gente usa o FindUniqueOrThrow aqui no GetUser. O GetUser também pode retornar nulo. Então a gente tem que cuidar com isso. Foi um erro bobinho, mas tudo bem. Se o usuário não existir, retorna nulo. É importante esses nulos aqui, porque é isso que identifica pro NextAuth que o usuário não existe ainda. Que justamente ele precisa criar. Então a gente tem que cuidar com esses erros bobos aqui. Esse aqui também, o último método que a gente cometeu. Esse errinho. Então aqui, IfUserReturnNull. Show. Agora eu acho que acabou. Então, throw. Só tem esse aqui de cima, então não é um problema. E agora sim, vamos testar, né? Então deixa eu ver se ele não criou nenhum cookie aqui pra não ficar sujando. Criou, então vamos apagar. Fazer todo o processo do zero, tá? Que às vezes é cansativo, mas é importante a gente testar com exatidão em que a nossa aplicação tá funcionando. Deletamos o cookie, deletamos do banco de dados. Só falta deletar aqui o acesso da nossa conta do Google. Não tem problema se você não quiser deletar, tá? Ele vai só caminhar mais rápido ali. DiegoSF. Diego Fernandes, próximo passo. Conectar. E agora cruze os dedos aí do outro lado da tela. Acessar o Ignite.com e pedir o calendário. E agora... Show. Deu certo. E a gente via que deu certo, porque olha só, o cookie não existe mais dentro aqui do nosso navegador. Ou seja, o processo aqui de criar o usuário, né? Criar o usuário. Que deleta o cookie e funcionou. Cara, isso aqui é muito massa, assim. Ver isso tudo funcionando. E depois dessa aula, tira um tempo pra ler tudo o que a gente fez aqui e entender o fluxo da aplicação. A gente pode fazer junto caso você quiser isso, né? Então aqui no Google Chrome, olha só. Aqui no Prisma Studio, vamos dar uma olhada. Eu vou dar um F5. E aqui já tem um erro que eu sabia que ia acontecer. O avatar URL não tá preenchido. Mas a gente pode ver que o email, o nome tá. Se eu for nas outras tabelas, account, por exemplo. Já tá aqui account, olha só. Tem alguns campos que não foram preenchidos, tá vendo? Refresh Token ali. Mas não é um problema, logo a gente fala sobre isso. E no Session também já tem a nossa sessão aqui dentro. Por que o avatar URL não foi preenchido? Porque o Google não retorna o nome do campo como avatar URL. E aí, a gente precisa fazer da seguinte forma. Aqui no NextAuth, isso foram coisas que eu fui descobrindo com a vida. Não é tipo, ah, peguei e li a documentação. Cara, que nem eu te falei. Uma das coisas que você vai aprendendo como deve é a pesquisar. A entender a parte profunda da coisa, digamos assim. Aqui dentro do Google Provider, eu posso passar pra ele um método que se chama Profile. Tá vendo? Esse método Profile aqui, eu tenho acesso ao perfil do usuário. Que é exatamente as informações que o Google retorna pra gente quando a gente faz login. Como eu tô usando TypeScript, aqui pode ser dessa forma também. Como eu tô usando TypeScript, tá vendo que ele tá como N? Aqui eu posso tipar ele com dois pontos. Google Profile, que vem de NextAuth Providers Google. E aqui ele já fala exatamente os campos que tem nesse Profile. Por exemplo, que são os campos que o Google retorna. Olha só, o Google retorna todos esses campos aqui. E aí o que a gente quer fazer? Eu vou retornar daqui de dentro os dados que eu quero acessar da conta do usuário do Google. Então, por exemplo, o ID eu quero acessar. Isso tá dentro de Profile.sub. Sub, caso você não saiba, é um diminutivo pra... Mas o Sub é basicamente o que identifica o usuário unicamente. A gente usa esse termo geralmente dentro do JWT. Nome, Profile.name. Username, aqui não vem do Google. É algo que vem da nossa aplicação, por isso eu boto Username como Nulo. Email, Profile.email. E Avatar URL, Profile.picture. Que é o que vem do Google. O Google manda como Picture. Aqui agora, Type Null is not assignable to String. Deixa eu dar uma olhadinha aqui. Sub, Name, Email, Picture. O Username talvez? Deixa eu ver qual é o erro que tá dando aqui. Ah tá, porque o Username é incompatível. Porque ele tem que retornar um Awaitable User ou Undefined. É que o Username não vai ser Nulo, ele já existe. Só que aqui dentro, o NextAlpha não sabe que o usuário já criou o Username. Então, o que eu poderia fazer pra deixar isso aqui melhor? Deixa eu pensar. Aqui eu vou pegar e... Eu vou retornar um Username vazio. Não é um problema, por quê? Porque esse Username aqui vai ser usado somente em um lugar. Aqui no Prisma Adapter, no Create User, ele é trazido aqui dentro do User. Só que como a gente não tá atualizando o Username, não tem problema eu retornar. Qualquer coisa que eu retorne dali de dentro não vai ser utilizada. Então eu vou retornar ele como vazio mesmo. E vamos testar novamente. Então, eu vou... Eu posso apagar do banco ou só testar de novo. Eu vou apagar do banco, tá? Acho que é melhor pra gente testar o fluxo completo. Vou adotar aqui autenticação e tudo, e vou fazer o processo do zero. Então, Diego SF, Diego Fernandes. Próximo passo, conecta com o Google. Eu não desconectei lá da minha conta, então aqui o processo de conexão vai ser mais rápido. E pronto, já caiu aqui. E agora eu volto lá no Prisma Studio, dou um F5 e tá lá. O avatar já foi preenchido. Então, esse profile serve pra gente mapear, digamos, os campos internos aqui do NextAuth, do usuário, com o perfil que foi retornado do Google, com os dados que foram retornados do Google. E aqui a gente tem mais dados, tá? Tem várias informações que a gente consegue pegar lá de dentro. Nem todas são interessantes, né? Mas, bom, algumas aqui faz... Talvez faça sentido caso você queira buscar pra salvar, mas a maioria não faz. E assim, a gente finalizou, então, o fluxo de autenticação do usuário, salvando todas as informações do usuário aqui dentro do nosso banco de dados. Então, a gente tem acesso ao account, tem acesso ao session. E aqui desse account, a gente tem o access token. Esse access token aqui é o que a gente vai utilizar mais pra frente pra fazer chamadas pra API do Google no nome, digamos assim, do usuário. Ou seja, esse access token dá pra gente acesso ao calendário do usuário pra gente poder criar eventos. Então, mais pra frente a gente vai usar ele."
  },
  {
    "id": "051804cd-fb2f-4473-942d-f81d46e1c27a",
    "title": "Criação do projeto em Next",
    "transcription": "Bora lá! Nessa primeira aula o que a gente vai fazer é criar o nosso projeto utilizando o Next. E tem várias maneiras de a gente criar um projeto com o Next em si. Eu vou utilizar o npx create-next-app arroba latest. E aqui eu vou passar a flag use-npm porque eu quero estar utilizando o npm. Quando você tem mais de um gerenciador de pacotes dentro da sua máquina instalado, o Next acaba, às vezes, escolhendo o que você não quer usar. Eu tenho yarn, pnpm, npm, então a gente vai instalar nesse modelo. Vamos aguardar aqui a instalação finalizar. Vamos dar um yes aqui para ele fazer a instalação. Ele vai perguntar o nome do meu projeto. E aqui a gente vai chamar ele de ignite-call, que é o nome do projeto que a gente vai estar desenvolvendo aqui. TypeScript, sim. Se eu quero usar o slint, eu vou botar que sim. Mas mais pra frente a gente vai customizar a configuração do slint, então não tem problema. E agora a gente aguarda instalar as dependências aqui. Feito o projeto criado, a gente vai acessar a pasta. Abrir no VSCode e já começar a fazer uma limpa. Então, remover readme, remover pasta styles, criar uma pasta source, mover a pasta pages ali pra dentro. Na pasta pages, a pasta API eu posso deixar. Aqui dentro vem com alguns componentes, a gente não vai mexer em nada. Apenas aqui no index, que é a home, a gente vai deixar isso aqui o mais limpo possível. Então, remove todas as importações. E aqui na div, a gente coloca um H1, hello world. E pronto, o nosso projeto Next já está configurado. Logo a gente vai dar uma mexida nessas dependências aqui e no tsconfig também. Mas, por enquanto, é o que a gente precisa pra inicializar o nosso projeto. Legendas pela comunidade Amara.org"
  },
  {
    "id": "3e1988f3-9f43-41ed-8ef9-ff315d0b511b",
    "title": "Configuração do pageExtensions",
    "transcription": "Uma das coisas que é legal a gente configurar desde já dentro do Next é uma configuração chamada Page Extensions. Até se você já desenvolveu outros projetos com o Next onde envolva você ter estilizações dessas bibliotecas de CSS em JS, como é Styled Components, Stitches, Emotion e por aí vai, você sabe que, geralmente, quando a gente vai construir, por exemplo, as páginas da nossa aplicação, então imagina que eu tenha em algum momento uma página de contato. Vamos só exemplificar aqui. Então, geralmente, o que a gente faz aqui dentro do React, um padrão muito comum, é a gente ter, por exemplo, uma pasta chamada Contact, que é a página de contato, o componente de contato, e dentro a gente ter, por exemplo, um index.tsx, que é o componente, e um styles.ts, que é a estilização. Isso é muito comum da gente fazer um pattern muito comum, uma padronização muito comum da gente ter quando a aplicação tem a estilização através dessas bibliotecas de CSS em JS. Mas um problema que isso gera aqui no Next é que todo o arquivo criado aqui dentro da pasta Pages automaticamente vira uma rota na aplicação. Se você já criou outro projeto com o Next, você sabe disso, que, então, a gente teria aqui dentro da nossa aplicação, com essa estrutura, uma rota, por exemplo, localhost 3000 barra contact barra styles. Só que isso não faz sentido, porque styles a gente não quer que seja uma rota, a gente quer que isso aqui seja somente um arquivo de estilização que o Next não entenda que isso aqui é uma página dessa aplicação. Para isso, aqui dentro do Next Config, existe uma opção pouco explorada chamada Page Extensions, que a gente pode falar quais são as extensões de arquivos que o Next deve considerar que são páginas da nossa aplicação para criar rotas para esses arquivos. Então, aqui, a gente vai usar page.tsx, api.ts e api.tsx. Esses últimos dois, a gente deixa para explicar um pouquinho mais para frente, mas a única coisa que muda no desenvolvimento aqui, o que a gente tem que se preocupar na hora que está criando a nossa aplicação, é todo arquivo que a gente quer que seja uma página, ele precisa terminar com page.tsx. Então, agora, o Next só vai entender que arquivos aqui dentro que acabam com page.tsx, o nome do arquivo termina com page.tsx, são páginas da nossa aplicação. Então, aqui o index também, que é a home do nosso app, agora a gente já tem isso aqui funcionando. Eu vou até deletar a pasta contact, a gente não vai ter isso, era só uma exemplificação. Para garantir que isso aqui está funcionando, eu vou rodar o npm run dev de novo e a gente deve continuar conseguindo acessar o hello world aqui da nossa home. Mesmo após essa configuração. Está lá, hello world, só que o estilo aqui se perdeu. Vamos dar uma olhadinha aqui, body. Ele não está pegando os estilos do body. Isso deve ser por causa que o app e o document não foram carregados. O app e o document também precisam ter o page.tsx. Isso aqui é algo que eu acabei esquecendo, porque senão eles não vão ser considerados componentes para o Next carregar as nossas páginas. Então, agora já voltando aqui na aplicação, já está tudo funcionando da maneira que a gente tinha configurado previamente. Bora continuar o nosso app."
  },
  {
    "id": "8ec87416-7a0e-4e05-bd49-d3a259d1c152",
    "title": "Utilizando React Hook Form",
    "transcription": "Nessa aula, o que a gente vai fazer é basicamente integrar o React Hook Form, que é uma biblioteca incrível para a gente lidar com formulários aqui dentro do React, dentro aqui do nosso Claim Username Form. Então, vamos lá. Eu vou começar instalando o React Hook Form. Já vou deixar pré-instalado o Hook Form Resolvers e o Zod, que vão ser as bibliotecas que a gente vai utilizar depois para a validação dos formulários. Então, já vou deixar isso pré-instalado, mesmo que a gente não vá utilizar necessariamente agora nessa aula. Com isso, o que a gente vai fazer aqui dentro é basicamente criar uma constante aqui, fazer a desestruturação e chamar o UseForm, que vem de dentro do React Hook Form. E aí, aqui, a primeira coisa que a gente vai fazer é, de dentro desse UseForm, do retorno dele, a gente vai pegar a função register e, aqui no nosso textInput, a gente vai simplesmente passar . . . register e o nome do input. Aqui, a gente vai chamar ele de username. Vou salvar aqui para o S-Link organizar o nosso código. E agora, aqui também, eu vou pegar a função handleSubmit. Para isso, aqui no nosso formulário, eu passo onSubmit, handleSubmit, e aqui eu vou criar uma função própria para a gente lidar com o registro do usuário, e eu vou chamar essa função de handlePreRegister. Então, é um pré-registro, digamos assim, do usuário em si. E aí, eu passo ela dentro aqui do nosso handleSubmit. E aqui, agora, eu vou ter acesso aos dados que o usuário preencheu. Então, se eu faço um console.log aqui dentro, nesse data, por mais que ele não tenha ainda a tipagem, eu vou colocar N aqui, por enquanto, só para parar de dar erro, a gente volta aqui na nossa aplicação, dá um inspect, vem no console aqui, e agora, qualquer coisa que eu preencha aqui dentro, dou um reservar, pronto, está aqui o username sendo retornado. Só que é legal a gente trabalhar com o TypeScript aqui dentro, então, o que eu vou fazer em todos os formulários é criar aqui uma . . . deixa eu trocar o nome dessa função aqui para handlePlainUsername, acho que fica mais semântico com o nome do componente. E aqui, eu vou criar uma constante chamada ClaimUsernameFormSchema, que vai usar o Zod para definir qual que é o schema, a estrutura dos campos do nosso formulário. Então, a gente vai usar o Z, que vem de dentro do Zod, ponto object, então, o retorno do formulário sempre vai ser um objeto, esse data aqui sempre vai ser um objeto. E aqui dentro, eu vou falar quais campos existem. Então, o username, basicamente, existe ali dentro, que é uma string. A gente não vai colocar muita coisa aqui dentro, só que agora, eu vou, simplesmente, aqui no meu useForm, passar para ele a tipagem. Então, a gente vai fazer o seguinte, vou criar um type aqui dentro, ClaimUserNameFormData igual z.infer typeof ClaimUserNameFormSchema. O que isso aqui está fazendo? Ele está, basicamente, convertendo essa estrutura aqui do Zod, object, username e string, para uma estrutura do TypeScript. Então, se eu passo o mouse aqui por cima de ClaimUserNameFormData, olha só, ele é um objeto do TypeScript, onde o username é uma string. Se a gente estivesse usando, ao invés de uma string, um number, por exemplo, isso aqui agora, quando eu passasse o mouse por cima, o username seria um number. Então, é só uma forma da gente fazer, da gente inferir, inferir dentro do ecossistema de tipagem. É um termo que a gente usa para, quase que, definir de forma automática o tipo dos dados que a gente vai ter dentro do nosso formulário. E aí, a gente pode usar agora esse ClaimUserNameFormData, aqui como um generic no UseForm, para ele saber quais campos existem ali dentro. Então, quando a gente for fazer um registro, por exemplo, ou dar um control espaço, ele já sabe que existe username ali dentro. E também a gente pode usar esse ClaimUserNameFormData, aqui no lugar do data, para a gente saber exatamente com quais dados a gente está lidando. Então, eu poderia fazer data.username, já retorna para a gente. Então, a gente já consegue trabalhar com essa inteligência da ideia, por causa do TypeScript. Só que a gente ainda não está lidando com validação, nem nada disso, que a gente vai lidar nas próximas aulas."
  },
  {
    "id": "a7920c88-b749-4d62-8961-5dccfbde889b",
    "title": "Validação com Zod",
    "transcription": "O que a gente vai fazer nessa aula, então, é a validação aqui do nosso formulário e, para trabalhar com validação, a gente precisa usar os resolvers. Então, aqui dentro do useFarm, eu vou passar um objeto de configuração onde a gente consegue configurar várias coisas, mas o que a gente quer aqui é o resolver. Eu simplesmente passo resolver, dois pontos, ZodResolver, que ele precisa importar e ele não conseguiu determinar a importação automática, então, a gente vai importar de dentro de hookFarms barra resolvers barra Zod e, aqui de dentro, a gente importa o nosso ZodResolver. E, agora, aqui para o ZodResolver, a gente passa para ele o esquema do Zod para ele saber como ele deve validar o nosso usuário. Então, agora, ele já está validando como a gente consegue determinar isso. Se eu volto lá no Google Chrome, por exemplo, dou um F5 aqui na nossa página e tento... The default export is not a React component in page... Deixa eu ver o que eu fiz de cagado aqui. Index... Deixa eu restartar a aplicação para eu garantir que isso não é um erro só de cache. Sei lá. Como que eu sei que ele está validando? Lembra que a gente tinha colocado um console.log aqui no data. Só que, agora, se eu não preencho o usuário e tento clicar em reservar, ele está dando o console.log. Então, na verdade, ele ainda não está validando. Na verdade, ele está validando, só que a gente não criou nenhuma regra de validação. Então, por exemplo, se eu criar aqui que o username precisa ter, no mínimo, três caracteres, a gente salva isso aqui agora, volta e agora, quando eu clico em reservar, ele já não dá mais o console.log. Somente se eu digitar um usuário com, pelo menos, três caracteres, ele retorna para a gente. Outra coisa que... E aí eu posso dar Enter aqui para eu ir colocando as minhas outras validações. Outra coisa que a gente pode fazer aqui é validar o formato. Uma das coisas que eu quero evitar, e aí eu vou validar isso usando uma expressão regular, uma das coisas que eu quero evitar aqui dentro é que a pessoa coloque números ou símbolos, espaços, coisas muito complexas, porque o nome de usuário precisa ser... Sei lá, a gente vai permitir só texto e... E... Enfim, pode ser. Então, aqui eu vou, basicamente, fazer uma expressão regular. Então, barra, barra, para identificar que é uma expressão regular. Bota o til, para falar que o texto deve começar contendo. E aí, entre parênteses, a gente vai colocar qual é o nosso match. Então, qualquer letra, de A a Z. E aqui eu vou botar duas barras invertidas e o hífen. Para escapar o hífen, porque senão ele não entende que esse hífen aqui é uma parte que eu quero permitir. Ele vai achar que é um hífen de separação igual o Z aqui no A e Z. Então, aqui eu quero permitir letras ou hífen. E aqui, uma ou mais vezes. Então, o mais aqui, basicamente, vai determinar que o conteúdo desse cochete pode aparecer uma ou mais vezes. E aí, a gente vai colocar no final, depois, um sinal de dólar. Para dizer que o nosso texto precisa começar com isso aqui e precisa terminar com isso aqui também. Não é só conter isso aqui. Ele precisa começar e terminar com essas regras validadas. E aqui eu posso botar um barra para determinar que isso aqui é case insensitive. Então, ele vai fazer essa rejecção, mesmo que o texto que a pessoa digitou tenha letra maiúscula ou minúscula. E aí, eu posso salvar isso aqui agora e a gente pode testar. Então, olha só. Aqui está válido. Se eu boto um número agora, ele já não valida. Ele já não dá mais o console.log. Se eu coloco um arroba, já não dá mais. Então, aqui, se eu boto um hífen aqui agora, beleza. Ele funciona. Então, é só uma forma de a gente validar aqui. E aí, outra coisa que o Zod permite a gente fazer aqui dentro são transformações de dados. Isso a gente vai ver bastante. Mas aqui, para mostrar algo mais simples, se eu digito, por exemplo, o nome de usuário com letra maiúscula, ele retorna com letra maiúscula aqui dentro. Só que o nome de usuário não é tão legal a gente permitir letra maiúscula. Então, uma das coisas que o Zod permite, como eu mesmo falei, é fazer transformação. Eu posso simplesmente escrever .transform aqui dentro do username. Aqui, eu boto um MyArrowFunction. Aqui, eu vou receber o valor do username. Posso botar username também, caso, para ficar um pouquinho mais semântico. E aqui, eu posso fazer um username.to lowercase. E aqui, se eu salvo isso aqui agora, a gente vai ver que mesmo que eu coloque letra maiúscula aqui, quando eu clico em reservar, ele retorna para a gente o username com letra minúscula. Então, o Zod não é uma biblioteca apenas de validação. Ele é uma biblioteca também de transformação. A gente consegue fazer transformação de dados aqui dentro do mesmo esquema. Então, isso abre possibilidades para a gente fazer muita coisa legal. E você vai ver, conforme a gente desenvolve as outras páginas, a gente vai criar muitas transformações do Zod, principalmente quando a gente for desenvolver essa tela aqui dos horários. Tem bastante coisa legal que a gente pode fazer ali dentro. E agora, mesmo com a validação feita, a gente precisa mostrar os erros de validação em tela. Então, uma das coisas que eu vou fazer é aqui, por exemplo, em cada uma das validações, que é o min e o regex, a gente pode passar um segundo parâmetro com a mensagem de erro. Então, eu passo message, por exemplo, e aqui eu vou botar... Digite um nome de usuário com... ou melhor... É que tem que ser uma mensagem pequena para caber ali. Então, eu vou botar... O usuário precisa ter pelo menos três letras. Não sei se assim vai ficar pequeno o suficiente, mas a gente testa. Aqui também vou colocar uma mensagem. O usuário pode ter apenas letras e ifins. Ifins não tem acento. Vou salvar aqui agora, e a gente precisa mostrar essas mensagens em tela. Para a gente recuperar as mensagens de erro aqui, a gente vai acessar form state. E dentro de form state eu tenho acesso aos erros, e aqui eu consigo mostrar eles em tela. Se eu simplesmente jogar ele aqui embaixo do button, por exemplo, errors.username.message e salvar, mesmo que ele dê um errinho aqui, a gente vai ver que se eu tentar clicar em reservar, ele já mostra ali que o usuário precisa ter pelo menos três letras. E aí, se eu digito alguma coisa que é um número, ele já valida conforme eu digito. O usuário pode ter apenas letras e ifins. Então, aqui a gente vai fazer o seguinte. Eu vou criar um componente estilizado. Eu vou chamar ele de formError. Eu não vou chamar de formError, já vou te mostrar o porquê. Eu vou chamar ele de formAnnotationStyledDiv. E aqui a gente vai basicamente só dar um margem top, 2. E ali dentro eu vou ter um texto. Então, da mesma forma que eu tinha estilizado lá na home, eu vou fazer o seguinte. Eu quero estilizar o texto, e aqui ele precisa importar o texto de IgniteUI React. Eu quero estilizar o texto que tem aqui dentro. Eu vou dar um colorGray 400 no texto que eu tiver dentro desse formAnnotation. E aqui eu vou usar o formAnnotation, então ele já fez a importação automática dos meus estilos. E aqui dentro eu vou basicamente fazer uma... Vou colocar um text que vem do IgniteUI React, tamanho small, um pouquinho menor. E aqui dentro do texto eu vou fazer o seguinte. Se existir um erro.username, ou seja, se dentro desse carinha aqui, dentro do username, existir um erro, eu vou mostrar a mensagem de erro. Então eu vou mostrar errors.username.message. Se não, eu vou colocar uma mensagem padrão, digite o nome do usuário desejado, talvez. Por quê? Porque eu acho que... Ali já deu certo, deixa eu dar F5 pra mostrar como é que isso vai ficar. Eu acho que ficaria muito esquisito... Isso aqui eu posso tirar daqui, inclusive, e botar abaixo do form, pra não pegar o grid ali. Então eu vou colocar aqui embaixo, e por volta eu vou colocar um fragment do React, só pra eu conseguir encapsular esses dois elementos. Show, vai ficar aqui embaixo. Eu acho que ficaria muito esquisito a gente não ter esse default aqui. Por exemplo, isso aqui fica nulo. Porque quando daria o erro, olha só. Quando der o erro, ele... Tá vendo que ele faz um layout shift aqui, né? Ele acaba... Todo o layout acaba se modificando. Por que eu gosto de deixar esse texto padrão aqui, no lugar do erro? Porque assim, mesmo quando der um erro, ele só vai trocar o texto aqui embaixo. E ele não vai mudar todo o layout. Então olha só, agora ficou ali. Quando não tem nada, digite o nome do usuário desejado. Aí eu digito, deu erro, o usuário precisa ter pelo menos três letras. Digito alguma coisa, o usuário pode ter apenas letras e hífens. Digito um usuário válido e dou um reservar. E pronto, ele já dá tudo certo aqui pra gente conseguir trabalhar com esses dados. Então é uma forma daria pra gente melhorar isso aqui ainda mais. Por exemplo, quando for um erro, deixar talvez com uma cor vermelhinha. Não sei, a gente pode pensar. Ou, quem sabe, não ter essa mensagem, caso você não queira. Eu acho que vai muito do projeto e vai muito do que você acha que fica visualmente legal aqui dentro. Mas agora que a gente já tem os dados de usuário, a gente já pode começar a trabalhar com isso aqui. Trabalhar com outras páginas. Daqui pra frente tem bastante coisa que a gente vai criar."
  },
  {
    "id": "d0154664-f5f5-4eec-a0ba-544aebb14ea3",
    "title": "Formulário do cadastro",
    "transcription": "Nessa aula a gente vai conectar o nosso form de cadastro ao React Hook Form e também a gente vai aproveitar o tempo para fazer validação, exibir os erros em tela, então vai ser uma aula mais rápida voltada ainda ao formulário. A gente vai começar utilizando o UseForm do React Hook Form, basicamente a mesma coisa que a gente fez lá no Claim Username, então Register, HandleSubmit, FormState. Aqui no FormState eu vou pegar tanto os erros, mas eu vou pegar também um outro FormState que se chama IsSubmitting, que ele retorna basicamente quando o formulário está fazendo o processo de Submit, isso aqui é legal porque a gente pode, por exemplo, aqui no nosso botão colocar um Disabled enquanto o formulário está fazendo Submit, para o usuário não ficar lá clicando várias vezes só porque as vezes a API está um pouco lenta ou a internet do usuário está lenta, então é legal a gente desabilitar esse comportamento. Antes de mais nada eu vou criar também o nosso Schema, que são os campos que a gente vai ter no nosso formulário, então eu vou chamar aqui de RegisterFormSchema, importou Object, e aqui a gente vai ter o Username, o Username vai ser muito parecido com a validação que a gente fez lá no Claim Username, então eu vou até copiar ele aqui, e a gente bota o Username inteiro já aqui para aproveitar, e a gente vai ter o nome também, que também é uma String, e eu vou fazer uma validação também de no mínimo 3 caracteres, e eu vou botar aqui que o nome precisa ter pelo menos 3 letras. Show, agora a gente vai fazer mais ou menos a mesma coisa que a gente já fez lá, criar aqui um RegisterFormData, v.infer, type of RegisterFormSchema, e aí a gente vai usar este carinha aqui como um Generic aqui dentro, e também quando a gente criar aqui a nossa função, handleRegister, o data aqui ele vai ter também esse formato aqui, posso dar um console.log aqui no data para a gente validar que está funcionando, e agora a gente vai para o restante. Então, o que a gente vai fazer? Nos campos do formulário, a gente vai botar . . . Register, passando aqui o nome de cada campo, então este aqui é o Username, e aqui embaixo este aqui é o Name, salvo, a S-Lint já fez o seu trabalho aqui dentro, o handleSubmit a gente vai botar no form, então aqui onSubmit, handleRegister, então a gente faz uma concatenação aqui de função. E agora a gente vai usar os erros, então o erro a gente ainda não criou um componente para exibir esses erros ali dentro, então o que eu vou fazer? Lá nos meus estilos, eu vou criar um formError, que é igual a styled, aqui eu vou usar o texto que vem de dentro do próprio IgniteUI React, e eu vou definir uma cor aqui que não está no nosso Design System, que é um vermelho, então eu vou botar F7 5A 68, é um vermelhinho aqui bem legal, para a gente estar aplicando nos erros aqui da nossa aplicação. E aí, o que a gente vai fazer? Abaixo de cada input, aqui, abaixo do textInput de cada um deles, eu vou fazer uma condicional. Se existir dentro de errors, username, ou seja, se tiver preenchido, a gente vai retornar aqui dentro, formError, como ele é um texto, eu preciso colocar o conteúdo dele, então errors.username.message, e como ele é um texto também, eu posso definir o size, eu vou botar um small, para não ficar muito grande, ele não importou o formError, agora ele importou o formError, agora dá aqui o meu VS Code que morreu, voltou, e pronto. Agora a gente faz a mesma coisa aqui embaixo, só troca username por name. Show, bora testar, se eu venho aqui no meu formulário e dou um próximo passo, ainda não está mostrando os erros, porque eu não passei aqui o nosso resolver, ZodResolver, passando o nosso esquema, e aí, claro, ele não vai validar, voltamos, e agora sim, já retorna aqui os erros. Caso você queira customizar essas mensagens, de uma maneira que fique mais legal para você, fica à vontade, eu acho que assim já está bem show. Perfeito, a gente finalizou toda a parte de configuração aqui do nosso formulário, dentro dessa página, e agora falta a gente fazer o fluxo, porque, qual que é a ideia? A ideia é que a pessoa comece acessando essa página, ela preencha o usuário dela aqui, por exemplo, DiegoSF, quando ela clicar em reservar, eu quero que ela seja redirecionada para a página Register, já com o usuário preenchido conforme ela botou lá na página Home. Então esse é o fluxo, e aqui ela vai poder alterar, caso ela queira alterar esse usuário, preencher o nome dela e ir para o próximo passo, onde ela vai seguir para o restante do fluxo de cadastro aqui do Ignite Call, onde o próximo passo já é a conexão com a agenda do Google, depois os horários, a biografia e por aí vai, então bora finalizar isso com chave de ouro."
  },
  {
    "id": "b8c644ac-f778-4a7b-be3e-eba95e3816c4",
    "title": "Entendendo as API Routes",
    "transcription": "A partir dessa aula, o nosso projeto vai ficar bem interessante, porque a gente vai começar a trabalhar com as API Roots aqui de dentro do Next. E essas API Roots, até a gente... Você já deve ter ouvido falar, caso você já tenha estudado o Next, feito outros projetos aqui dentro do Ignite, as API Roots nada mais são do que formas de a gente ter rotas back-end na nossa aplicação dentro do front-end do nosso app. E quando isso surgiu, elas tinham um propósito muito claro, até existe um termo para isso, back-end for front-end, de serem utilizadas exclusivamente para operações back-end que são auxiliares na construção do front-end. O que eu quero dizer com isso? Quando a gente vai fazer, por exemplo, um processo de autenticação social, então a gente precisa comunicar com a API da Google para conseguir gerar um access token, para buscar informações do usuário e tudo mais, a forma que a autenticação social é feita dentro da web e dentro do mobile, por exemplo, é totalmente diferente. Ou seja, a gente precisa de uma camada back-end para realizar a autenticação social, porém, como essa autenticação social é muito diferente nos dois ambientes, mobile e web, não faz sentido a gente colocar isso no back-end principal da nossa aplicação, que é onde acessa banco de dados e tudo mais, porque isso é algo exclusivo, na verdade, da aplicação web. Ou seja, essa camada back-end que a gente tem aqui dentro da nossa aplicação front-end com Next, ela pode ser utilizada para isso, para a gente facilitar alguns trabalhos de operações que são específicas da web. Porém, com a evolução dessa camada, a evolução do próprio Next, a evolução do front-end no geral, essa camada back-end que a gente tem agora não só no Next, mas em grande parte dos frameworks front-end, o Nuxt, Remix e por aí vai, ela começou a ser utilizada até para mais coisas, facilitando, inclusive, a gente criar aplicações completas, aplicações full stack, back-end e front-end dentro de uma única codebase e sem voltar, digamos, aos problemas que a gente tinha no princípio, lá quando a gente fazia isso com outras tecnologias, fiz muito isso com PHP, de ter front e back na mesma linguagem, dentro do mesmo código, que era mais aqueles problemas da gente não conseguir reaproveitar a API, da gente ficar preso, da gente não conseguir ter a flexibilidade que o React traz nas nossas aplicações. Ou seja, a gente consegue sim construir um back-end inteiro da nossa aplicação dentro aqui do Next, que é o que a gente vai fazer aqui durante o Ignite Call. Só que, claro, isso não necessariamente exclui a gente criar um back-end separado em alguma situação. E aí, é muito difícil resumir, porque o mercado... Bom, a comunidade, o mercado, ele muda bastante conforme eu passo o tempo, então é muito difícil resumir aqui em qual momento isso aqui vai fazer sentido para qual tipo de projeto. Mas, na minha cabeça, no estado atual, no momento que eu estou gravando essa aula, em que momento faz sentido criar o back-end junto do código front-end? Eu acho que o primeiro momento que faz sentido para mim é você perguntar... A primeira definição é as pessoas que vão trabalhar no código front-end e back-end são as mesmas? Ou seja, os devs, as devs do meu projeto, todos são Fuestack? Se a resposta for não, já exclui totalmente essa opção, porque dificilmente isso vai fazer sentido e vai fazer muito mais sentido você separar back-end de front-end e nunca construir o back-end junto do front-end do seu projeto, porque não são as mesmas pessoas trabalhando em cima da mesma codebase. E aí, você respondendo sim para a primeira pergunta, então, são Fuestack? Eu acho que a segunda pergunta é você quer criar, de certa forma, um acoplamento do seu código back-end junto a um framework como o Next em si? Porque, de certa forma, você vai criar, o seu código vai estar dentro de um framework como o Next. Ele não vai funcionar fora do Next, a menos que você abstraia isso, aplique alguma arquitetura de port and adapter, adapte isso de alguma forma. Ele não vai funcionar fora do Next. E aí, essa pergunta vem com vários dependes. É muito difícil responder essa pergunta. Mas hoje, eu, Diego, particularmente, eu gosto de criar back-ends dentro do meu front-end quando eu estou criando algum projeto que eu sei que ele tem início, meio e fim. Ele tem um escopo fechado de aplicação e dificilmente ele vai crescer muito mais do que aquele escopo. Dificilmente eu pensaria em criar um back-end da minha aplicação dentro aqui, junto do Next, no front-end, em uma aplicação, por exemplo, que eu não sei até onde ela vai crescer, até quando ela vai crescer, porque eu acredito que, assim, ela vai acabar sendo mais limitada por estar dentro do Next do que vice-versa. Então, é basicamente as formas que eu uso para determinar isso. Mas hoje, durante esse módulo, eu quero te mostrar como a gente vai fazer a construção de um back-end completo dentro do Next e mostrar que, sim, é muito flexível e permite a gente ter uma produtividade enorme, uma produtividade monstruosa quando comparado com ter back-end e front-end separados. Então, a gente vai ver isso aqui na prática, porque, sim, existem vários casos de aplicação que faz sentido a gente ter isso, a gente ter o back-end ali, junto, próximo ao front-end da nossa aplicação. E aí, as API Roots aqui do Next, elas funcionam de uma maneira muito simples, assim como as páginas funcionam. Cada arquivo que a gente tem aqui dentro da pasta Pages é convertido para uma rota da nossa aplicação. E as API Roots, que são basicamente os arquivos que estão dentro aqui da pasta API, acontece a mesma coisa. Porém, quando a gente configurou o nosso projeto Next, lá dentro do Next Config, a gente configurou esse Page Extensions aqui. Então, a gente falou que apenas os arquivos que terminam com Page.tsx, que é o que a gente está utilizando para as páginas, API.ts e API.tsx, vão ser arquivos que vão ser convertidos em rotas e também em API Roots, em rotas específicas de API aqui do Next. Então, esse hello, por exemplo, a gente teria que trocar o nome dele para hello.api.ts, senão o Next não vai entender ele como uma API Root. E agora a gente pode ver que, basicamente, o que esse carinha aqui faz é ele simplesmente retorna um JSON com o nome John Doe. Então, o que a gente vai fazer aqui, com o projeto já rodando, se eu acesso localhost 3000 barra API, que é a nossa pasta API, e agora, aqui dentro, hello, por exemplo, a gente vai ver que ele retorna exatamente isso aqui. Só que isso aqui é importante dizer que funciona exatamente como uma rota back-end, caso você já tenha feito um back-end em outra tecnologia dentro do Node, como Express, Fastify, Nest. Isso aqui é uma rota back-end. A única diferença é que a gente não precisa determinar qual que é o endereço da rota, porque ele é determinado automaticamente baseado no nome do arquivo. Inclusive, a gente consegue trabalhar com parâmetros e tudo mais. E a gente vai ver isso ao longo das próximas aulas, é claro. E aqui dentro das API Roots, isso aqui está rodando com Node. Então, tudo que a gente poderia fazer dentro de uma aplicação escrita com Node, a gente pode fazer aqui dentro. Da mesma forma, a gente pode trabalhar com as APIs internas do Node, trabalhar com Crypto, trabalhar com Path, trabalhar com File System, a gente consegue trabalhar de diversas formas aqui dentro. O que vai diferenciar muito de como que essa API Root aqui vai executar é a maneira que a gente faz o deploy da nossa aplicação. Por quê? Se a gente faz o deploy da nossa aplicação Next num servidor tradicional, num Ubuntu da vida, a gente sobe lá um EC2 da AWS, um DigitalOcean e sobe a nossa aplicação, isso aqui vai rodar como um servidor Node tradicional. Ou seja, uma aplicação que fica rodando 24 horas e todas as operações que caem, elas são executadas por um serviço que está rodando ali em tempo real, o tempo todo. Difere do modelo, por exemplo, se a gente for hospedar essa nossa aplicação em ambientes como, por exemplo, o da Vercel, isso aqui já muda um pouquinho, porque a Vercel não mantém a nossa aplicação rodando 24 horas. Até para a economia de recursos, ela usa um modelo de computação serverless. Então, isso basicamente quer dizer que a nossa aplicação, esse código aqui, a nossa aplicação só vai rodar no momento que houver uma requisição. Isso é importante a gente entender, porque quando a gente trabalha em modelos serverless, por exemplo, se a gente for hospedar a nossa aplicação dentro da Vercel, existem algumas coisas que a gente não vai conseguir fazer nesse back-end aqui que está próximo ao front-end. A gente não vai conseguir trabalhar com coisas que precisam que o servidor fique rodando 24 horas. Então, por exemplo, WebSockets, não é possível, porque o WebSockets depende que o nosso servidor esteja ali em tempo real processando as mensagens e respostas. Então, não é possível trabalhar com WebSockets. Outra coisa que não é possível trabalhar é com long-running processes, que são processos de longa duração, como, por exemplo, filas. A gente não conseguiria ter filas dentro do nosso back-end quando a gente traz o back-end para próximo do front-end e hospeda ele em um ambiente serverless, como é, por exemplo, o ambiente da Vercel. Existem outras coisas que a gente não consegue trabalhar quando a gente coloca dentro do ambiente da Vercel, por exemplo, na Vercel e outros ambientes serverless. A gente não consegue trabalhar como, por exemplo, escrita de arquivos locais. Por quê? Porque a gente tem que entender que quando a gente executa a nossa aplicação num ambiente serverless, ela roda num ambiente que a gente chama de stateless. Stateless, nada mais é do que um ambiente sem estado. O que isso quer dizer? Cada vez que a nossa aplicação executa, ou seja, cada vez que uma pessoa faz uma requisição para a nossa aplicação, a nossa aplicação está rodando num container isolado, num ambiente de execução totalmente isolado dos outros ambientes de execução. Ou seja, se três pessoas estão usando a nossa aplicação, essas três pessoas estão acessando containers separados da nossa aplicação. Ou seja, versões da nossa aplicação executando em ambientes totalmente isolados. Ou seja, se eu salvo uma imagem no disco, ou faço upload e salvo isso no disco, essa imagem não vai ficar salva e não vai ficar disponível para outras pessoas que estão usando a minha aplicação. Por isso, a gente tem que cuidar, sempre que a gente for fazer upload, lidar com arquivos, sempre utilizar um serviço separado para esses arquivos. Então, subir num Amazon S3, num Google Cloud Storage, em algum serviço para armazenamento de arquivos. Mas isso aqui foi mais um overview sobre como funcionam as API routes, como isso depois vai para a produção, quando a gente faz o uso disso, quando a gente coloca a back-end unida ao front-end ou não. Mas isso aqui é muito uma opinião do momento, pode mudar no futuro, baseado de para onde caminhar o Next em si, para onde caminhar o framework, para onde caminhar a comunidade. Mas aí a gente volta aqui e tem uma nova conversa sobre isso. Por enquanto, essa é basicamente a minha opinião de quando a gente trabalha com isso. E esse projeto de Ignite.Cal vai ser perfeito para a gente ver o poder de a gente colocar o back-end junto ao front-end e a produtividade que a gente tem com isso, ou a facilidade que a gente tem com isso. Principalmente se você for dev, se o stack está trabalhando tanto com front quanto com back, você vai ver que é um negócio fantástico. Então, bora continuar com o nosso projeto. Começar criando a nossa primeira API route aqui, que vai ser uma API route feita para cadastro de usuário. Quando o usuário clica aqui em Próximo Passo, eu já quero cadastrar ele no banco. Então, já vai ter integração com o banco de dados e por aí vai. Bora lá."
  },
  {
    "id": "60e90ad5-496a-4bba-8846-2f6c0dd6144e",
    "title": "Configurando Prisma no Next",
    "transcription": "A primeira coisa que a gente vai fazer aqui é configurar a ferramenta que a gente vai estar utilizando para a comunicação com o banco de dados, que é o Prisma. Caso você nunca tenha utilizado o Prisma na sua vida, fica tranquilo, fica tranquila que eu vou mostrar isso aqui do zero. Mas, basicamente, a gente vai começar instalando o Prisma como uma dependência de desenvolvimento. E essa instalação que eu estou fazendo aqui do pacote Prisma é apenas da CLI do Prisma, a interface de linha de comando, para a gente conseguir executar os comandos do Prisma. Não é a dependência que a gente vai usar do Prisma em código para acessar o banco de dados. Que essa, agora eu vou instalar, é arroba Prisma barra client. Essa, sim, é a dependência que a gente vai estar utilizando na nossa aplicação para lidar com o banco de dados. Fazer leitura, escrita, atualização, remoção e por aí vai. O Prisma, ele é um ARM para Node, então como as API roots aqui do Next, elas rodam dentro do ambiente Node, a gente vai estar utilizando o Prisma. E o Prisma, ele facilita muito o acesso do banco de dados, assim como qualquer outro ORM. Porém, ele ainda traz um plus a mais, que ele é altamente integrado ao TypeScript. Então, o Prisma, ele consegue detectar automaticamente, determinar automaticamente quais são as colunas do nosso banco de dados e tabelas do banco de dados. E ele traz um autocomplete sempre que a gente for escrever alguma query. Então, ele sabe exatamente quais dados a gente pode inserir, quais dados a gente pode buscar, quais são os WHERE que a gente pode fazer, quais são os JOINS que a gente pode fazer. Porque ele gera automaticamente uma tipagem completa do nosso banco de dados com todas as tabelas, relacionamentos e tudo. Então, fica muito mais fácil a gente trabalhar com o banco de dados aqui na nossa aplicação. Com o Prisma instalado, para a gente fazer um init dele, eu posso rodar npx prisma init. E aqui a gente pode ver que ele traz para a gente, inclusive ele traz esse autocomplete, porque é um comando que eu já executei outra vez, que eu posso determinar qual que é o data source. Ou seja, qual que vai ser o tipo de banco de dados que eu vou estar utilizando aqui na minha aplicação. Quando a gente for fazer deploy dessa aplicação, provavelmente a gente vai utilizar um banco de dados como o MySQL, o Neon Database, por exemplo, o Postgres. Então, a gente vai trocar isso aqui depois. Mas, enquanto a gente está desenvolvendo a nossa aplicação, eu vou utilizar o SQLite. Então, eu vou passar essa flag chamada data source provider como SQLite. Só para ser mais fácil a gente não precisar subir docker, banco de dados aqui na nossa máquina, para não ficar sujando muita coisa. É importante dizer que o Prisma, a gente consegue fazer esse switch de banco de dados. Ou seja, eu quero parar de usar SQLite, quero começar a usar o MySQL sem trocar nada no nosso código. Então, vai ser depois simplesmente só trocar o URL de conexão, gerar as migrations do zero e pronto. Com isso, ele criou para a gente aqui automaticamente uma pasta Prisma com um arquivo chamado schema.prisma ali dentro. Ele criou um arquivo env também, que tem a nossa database URL aqui. E o Next, ele não usa geralmente o arquivo .env no gitignore, porque o Next tem env específicos por ambiente. Por exemplo, env.local, development, production e tudo mais. Então, só para esse arquivo env aqui, que é o único arquivo que o Prisma lê de variáveis ambiente, já que ele não lê do env.local ou esses outros arquivos que o Next suporta, eu preciso colocar esse env também aqui nos meus ignores aqui do gitignore. E assim ele não sobe para o GitHub, porque aqui vai ter a nossa URL de conexão. Aqui a gente pode ver que ele vai criar basicamente o arquivo de banco de dados como o dev.db. E é importante dizer que essa URL aqui é relativa ao arquivo do schema.prisma, porque é aqui dentro que ela está sendo utilizada. Então, ele vai criar o arquivo dev.db, que é o nosso banco de dados SQLite, aqui dentro da pasta Prisma e pronto. Basicamente é isso que a gente precisa entender. O Prisma, como é que ele funciona? De que maneira que ele funciona? Ele tem esse arquivo schema.prisma, e aqui dentro a gente vai utilizar uma sintaxe própria do Prisma para definir as tabelas, relacionamentos e campos do nosso banco de dados. E com isso, depois, ele vai converter isso em linguagem específica para criar as tabelas, em SQLite no nosso caso, para criar as tabelas, campos, relacionamentos e índices lá dentro do nosso banco de dados em si, que a gente vai ver logo o que a gente vai fazer aqui. Então, para começar, o que eu vou fazer aqui dentro? Eu vou começar criando aqui um model. Model é como o Prisma chama de tabela. Ele chama de model porque o Prisma suporta hoje bancos NoSQL, que daí não são tabelas, são collections, por exemplo. Então, ele chama de model, que é uma maneira genérica de se referir a uma entidade no nosso banco de dados. E aqui dentro eu vou chamar, então, modelUser. E eu basicamente, aqui dentro, preciso definir quais são os campos. É só importante dizer que ao trabalhar com Prisma aqui dentro do VS Code, é altamente importante que você tenha a extensão do Prisma instalada. E também, dentro das configurações do VS Code, existe uma configuração aqui que eu gosto de utilizar, que é esta configuração aqui. Eu boto para arquivos do tipo Prisma. Quando eu salvo o editor, ele faz uma formatação automática. Isso vai fazer com que ele arrume aqui o meu arquivo. Faz quase que um processo de prigger, de linting aqui dentro. Então, funciona bem legal. Vamos lá. Para o usuário, aqui eu vou começar falando que ele vai ter um id. Então, cada usuário que for cadastrado aqui na nossa aplicação, por exemplo, quando a gente cadastrar este usuário aqui, eu vou criar um id, que vai ser uma string. Eu boto um arroba id. Isso aqui é basicamente a forma do Prisma determinar que este aqui vai ser o campo primary key da nossa tabela. Então, a chave primária. E eu também vou botar aqui um arroba default, como sendo o uid. Eu basicamente estou dizendo aqui para o nosso banco de dados que este id aqui vai ser preenchido automaticamente com um id único gerado. O id, que é um id único universal, que ele gera uma string ali grandinha, mais seguro do que a gente gerar um autoincrement simplesmente. E aí, o usuário preenche aqui dois campos. Nome de usuário e nome. Então, é isso que a gente vai colocar aqui por enquanto. Nome de usuário, que é uma string, e nome. O nome de usuário, a gente quer que ele seja único. Então, eu posso botar um arroba unique aqui no final. E o Prisma vai automaticamente criar uma unique constraint para esta coluna no banco. Ou seja, não permitir que sejam cadastrados usernames duplicados. Outra coisa que eu vou fazer aqui dentro é colocar um campo createdAt. Vou colocar com um if aqui mesmo. Que ele vai ser do tipo dateTime. E o default dele vai ser now. now é uma função do próprio Prisma, que ele vai preencher este campo aqui com o valor atual do registro na hora que ele for inserido no banco de dados. E olha só, quando eu salvo aqui, viu que ele já formatou, colocou tudo aqui na mesma coluna. Isso é aquilo que eu estava explicando lá da configuração que eu tenho dentro do meu VSCode para ele fazer a formatação automática. Outra coisa que o Prisma faz, dependendo do projeto, eu não curto muito, ele vai criar o nome da tabela como user mesmo, nesse formato. Só que eu não gosto muito, eu gosto de criar a tabela sempre com lowercase, em caixa baixa, e também no plural. Então eu posso botar aqui arroba, arroba, map, depois de definir os campos aqui no final, e dentro eu coloco o nome que eu quero para a minha tabela. Então eu vou botar users. Eu consigo então que o nome da minha tabela seja users, eu prefiro dessa forma. Eu salvo isso aqui agora dentro do meu terminal. Eu vou rodar agora npx prisma migrate dev. Esse migrate dev vai ser um comando que a gente vai rodar somente em desenvolvimento, e ele basicamente vai fazer o seguinte, ele vai ler o nosso esquema.prisma e vai ver quais alterações tiveram desde a última vez que a gente visitou esse arquivo. Aqui ele percebeu, já automaticamente, que tem uma nova tabela chamada users. E agora ele está pedindo basicamente um nome para a minha migration. Migration é um termo que a gente usa muito lá dentro do back-end, caso você não trabalhe com back-end constantemente, mas é basicamente um histórico de alterações feitas no banco de dados. Então é como se fosse commit. Da mesma forma que existe o git, a gente trabalha com migrations no banco de dados. Então aqui eu vou falar exatamente o que eu fiz desde a última vez que eu mexi no banco de dados. E aí eu falo, por exemplo, create users. Eu não preciso dizer que é uma tabela, porque a gente está se tratando do banco de dados de SQL, então provavelmente é uma tabela, não preciso necessariamente falar isso. E agora a gente pode ver que ele criou uma pasta migrations. Aqui dentro eu tenho uma pastinha que tem a timestamp atual para a gente conseguir manter uma ordem de migrations, porque se em algum momento eu adiciono um campo e depois eu removo, eu preciso que a ordem seja mantida na hora que eu for executar isso aqui de novo, que eu for executar essas instruções SQL. E aí a gente pode ver que está ali no nome do arquivo também o create users, que a gente passou. E aqui dentro eu tenho o migration.sql, ou seja, o Prisma detectou automaticamente as alterações que eu fiz aqui dentro, que foi criar a nossa tabela de users, e ele já criou aqui dentro o create table users, todos os campos aqui. E como a gente tinha um unique constraint aqui dentro do username, ele criou também aqui para a gente automaticamente essa constraint, o create unique index, dentro do username, certinho já como a gente precisava. E agora também, com esse comando, ele já executou a nossa migration, ou seja, ele já populou o nosso banco de dados com essas alterações. Como que a gente pode ver isso? Eu posso, claro, utilizar um software qualquer na minha máquina para acessar o banco e visualizar isso, mas o Prisma traz isso automaticamente para a gente também, rodando NPX Prisma Studio. O Prisma Studio nada mais é do que uma interface para a gente olhar o nosso banco de dados. Então aqui dentro a gente pode ver que ele já mostra todos os models, que são as tabelas do banco de dados, como por exemplo o user. Clicando, ele já traz um sistema para a gente ver o nosso banco de dados. Então a gente vai ver que a tabela user tem aqui o campo id, username, name, created at, só que não existe nenhum cadastro feito aqui, porque, claro, a gente vai fazer o cadastro lá por dentro da nossa aplicação. Eu gosto bastante do Prisma Studio, se você quiser deixar ele rodando aí definitivamente para você ver o seu banco de dados, eu aconselho, eu acho legal. Geralmente eu gosto de deixar o Prisma Studio rodando, o Next rodando, e aí eu abro um novo terminal em branco aqui para eu fazer a instalação. Então eu mantenho aqui rodando o Prisma Studio e o Next, porém eu tenho um novo terminal aqui para fazer instalação de dependências, rodar comando e por aí vai. Show! Agora com as nossas migrations já executadas, a gente vai criar aqui dentro da pasta search um arquivo para a gente conseguir acessar o Prisma, conseguir fazer as queries a partir do nosso código aqui, fazer inserção e por aí vai. Então eu vou criar uma passinha lib dentro de um arquivo prisma.ts e aqui dentro eu vou importar de dentro de prisma-client o prisma-client e aqui eu vou exportar uma constante chamada prisma, que é igual a new prisma-client. Eu não preciso passar qualquer informação de conexão com banco de dados, URL, porta, usuário, senha, porque o Prisma vai entender automaticamente quais são essas informações de conexão do banco de dados a partir do nosso ponto env, a partir desse database URL aqui. Então ele vai ler automaticamente, quando eu fazer essa instância, ele vai ler esse arquivo env e vai saber exatamente qual que é as informações de conexão com o banco de dados que ele precisa seguir. E aqui dentro tem uma opção muito legal que eu gosto de utilizar, que é a opção de log. Então eu gosto de setar log query, porque assim o Prisma vai fazer automaticamente o log de todos os SQLs executados no banco de dados, ou seja, todas as queries executadas no banco de dados dentro do nosso terminal. Assim, na hora que a gente fazer a inserção, a gente consegue ver o comando insert, int e tal. Isso é legal para a gente às vezes debugar, saber se está executando da maneira que a gente esperava ou se a gente está executando queries desnecessárias, então por aí vai. Feito isso, pronto. O Prisma já foi feito o setup aqui dentro da nossa aplicação. Basta agora a gente começar a utilizar, que é o que a gente vai fazer aí a partir da próxima aula."
  },
  {
    "id": "0cb43a57-becc-4c87-ba08-fabe2ec49ea1",
    "title": "Criando oAuth com Google",
    "transcription": "Nessa aula, o que a gente vai fazer é a configuração necessária pelo lado da Google pra gente conseguir acessar informações do usuário através do login social da Google. Então, a gente precisa criar uma aplicação lá pelo lado da Google pra que quando o usuário faça o login, ele veja que ele está se autenticando através da nossa aplicação. A gente vai criar lá um app dentro da Google Cloud. E é importante salientar que é gratuito, a Google Cloud não vai te cobrar por esse serviço, então pode ficar tranquilo ou tranquila, mas você vai precisar criar uma conta. Se você já tiver uma conta da Google, vai ser um processo mais simples de setup. Então, eu basicamente vou procurar aqui Google OAuth. Vou cair nesse link aqui, como usar o OAuth 2 pra acessar APIs. Aqui ele tem uma documentação completa, caso você nunca tenha feito OAuth, caso você queira entender. Mas a gente vai basicamente precisar acessar o API Console, que é o console da Google Cloud. Caso você não tenha uma conta nesse momento, ele vai pedir pra você criar uma conta aqui no Google Console. Eu vou usar o meu e-mail da Rocket aqui pra eu não criar isso dentro do e-mail pessoal. Aqui eu já tenho o projeto da Rocket, tenho o projeto do Ignite e tudo mais. Pra gente ficar na mesma linha, eu vou criar um projeto novo aqui dentro. Vou chamar ele de Ignite Call. Organização Rocket City, beleza, vamos criar. Vamos aguardar um pouquinho, ele demora um pouquinho pra fazer a criação desse projeto. E aí a gente já pode começar a navegar e criar nosso app. Perfeito, projeto criado, tá selecionado aqui em cima, Ignite Call. A gente vai vir aqui na esquerda agora, tela de permissão OAuth. Vamos aguardar um pouquinho. E aqui agora a gente vai começar a configurar a nossa aplicação. E aí talvez eu não lembre de tudo aqui, eu tenho que consultar no outro app que eu já criei lá. Mas vamos lá, a gente tem primeiro User Type, Interno ou Externo. Aqui é Externo, não tem nem o que falar. Eu quero pra qualquer tipo de usuário, não só e-mails da minha org. Se não ele permitiria apenas e-mails que terminam com rocketcity.team, não faz muito sentido. Criar, e aqui a gente vai começar a colocar as informações. Então eu vou botar aqui Ignite Call, e-mail para suporte do usuário. Vou botar o meu e-mail mesmo. Logotipo, aqui a gente pode cadastrar, não necessariamente é obrigatório. E aqui a gente tem algumas informações, só que nenhuma delas é totalmente obrigatória. Apenas os domínios autorizados, aqui a gente já vai preencher. E aqui no endereço de e-mail do desenvolvedor, eu vou botar o meu e-mail, rocketcity.team. Aqui em domínios autorizados, deixa eu lembrar um pouquinho o que eu tinha já configurado. Porque isso aqui é uma parada que tu vai fazer uma vez, e depois tu esquece facilmente. E na documentação da Google não tem um guia, tipo, exatamente um passo a passo, aquela coisa muito simples. Então, deixa eu dar uma olhada no que eu já configurei aqui. Beleza, domínio autorizado aqui, localhost não precisa. Lembrei aqui agora, ele funciona normalmente. A gente precisa colocar somente o domínio que a gente vai utilizar na nossa aplicação em produção. Se você não tiver nenhum agora, não se preocupa com isso. Não precisa se preocupar que depois dá pra editar. A gente vai salvar. Agora vem a parte de escopos. Deixa eu dar uma olhadinha aqui, a gente não selecionou nenhum. Escopos aqui, basicamente a gente pode selecionar quais informações a gente quer solicitar de acesso do usuário. E sim, eu quero, por exemplo, acessar o calendário do usuário. Mas eu não preciso setar isso aqui dentro. Eu posso, lá na minha aplicação, na hora que o usuário vai fazer a autenticação, eu posso colocar manualmente quais escopos eu quero. Então eu posso controlar, digamos, a nível, no momento que eu vou fazer a autenticação, quais escopos. Então não preciso informar isso de uma maneira global, digamos assim, dentro aqui da API do Google, do app. Usuários de teste, também não tem que informar nada disso aqui. E a gente pode continuar. Perfeito, tudo certo, já não tem nada aqui pra gente configurar e já tá pronto. Tela de permissão off tá aqui. E agora a gente precisa criar as nossas credenciais. O único ponto aqui é que ele tá como teste, tá vendo? Pra isso aqui funcionar, a gente vai ter que vir aqui em publicar aplicativo e dar um confirmar. E pronto, ele já vai dar essa opção, a verificação não é necessária. Porque esse tipo de aplicação aqui, ele não precisa revisão do pessoal da Google. Tem alguns que precisam de revisão, tá? Perfeito, agora a gente vem pra credenciais, que é onde a gente vai configurar as nossas credenciais. A gente vai criar credenciais, id do cliente OAuth, que é o id que a gente vai utilizar dentro da nossa aplicação Next pra conseguir fazer a conexão OAuth. Aqui a gente vai selecionar aplicativo da web. Vamos dar um nome aqui, então seria legal botar um nome descritivo, né? Então vou botar, por exemplo, NextJS Client ou NextJS App, alguma coisa assim. E aí deixa eu até dar uma olhada como que eu configurei aqui no meu pra gente não se perder, tá? Vamos lá. Origens JavaScript autorizada. Então aqui no meu eu coloquei localhost 3000, que é onde eu tô rodando a minha aplicação. Eu não tenho certeza se por padrão ele permite que todos os endereços localhost acessem, então eu já coloquei ele pra garantir. E a URL de redirecionamento autorizado. O que é essa URL de redirecionamento, tá? Quando a gente envia o usuário pra página do Google, pra ele botar a conta do Google dele e fazer login, qual que é a URL que ele vai ser redirecionado de volta pra nossa aplicação? E quando a gente usa o NextAuth, existe uma URL específica, a gente não pode escolher qual URL o usuário vai chegar. Então o NextAuth, até se a gente for aqui, NextAuth callback URL. Deixa eu ver se ele fala sobre isso. Hmm, callback URL. Eu acho que ele não mostra aqui pra gente. Mas eu vou te falar agora já pra gente antecipar isso. Mas basicamente a URL de callback sempre vai ser o endereço da aplicação. Vai ser o endereço da aplicação, barra, API, porque API é onde vai estar as rotas do Next, e o NextAuth funciona também dentro do API, barra, auth, barra, callback. Se eu não me engano, é só isso. Deixa eu dar uma olhada aqui. Ah, callback barra Google nesse caso, porque como a gente tá fazendo login com o Google, a rota de callback pode servir pra vários providers. Então a gente bota o Google aqui dentro. Beleza. Podemos dar um criar. Show. E ele vai retornar isso aqui. Isso aqui é super importante pra gente. A gente precisa copiar isso aqui. Então, recomendo que tu faça um download do JSON, caso tu não vá copiar agora. Se não, vem aqui ó, copia, volta no FastCode, vem aqui em env, e a gente vai criar aqui uma seção a Google, ou auth. E aí a gente vai criar aqui o GoogleClientID e GoogleClientSecret. Show de bola. Já configurado. A gente dá um ok. Salva isso aqui agora. Eu acho que a última coisa que a gente precisa é configurar API de serviços ativados. Se eu não me engano, a gente tem que ativar a Google Calendar API aqui dentro. Então, pra que a gente possa acessar a API do Calendar. Então a gente vem aqui em ativar APIs de serviços. Meu Deus, meu gato tá berrando, eu não sei porquê. Calendar. Google Calendar API. Se não, a gente não vai conseguir criar eventos. E ativar. Pronto. Agora, pronto nada, porque não terminou ainda. Ficou só esse toast aqui que eu achei que era o sucesso. Show de bola. Aqui dentro, novamente, não se preocupa, não vai ser cobrado isso aqui. É só usar e bem tranquilo. Fechou. A gente configurou tudo. Agora com essas duas informações aqui, a gente já vai conseguir fazer login pelo usuário. Então o usuário já vai conseguir fazer login na nossa aplicação. E também a gente já vai conseguir manipular a API do Calendar pra criar eventos e por aí vai. Agora daqui pra frente é só código ali dentro do Next. A gente terminou tudo o que a gente precisava fazer aqui no Google. Posso até fechar tudo aqui, que a gente não vai mais utilizar. A gente vai direto agora pro Next Alpha."
  },
  {
    "id": "b31ce2a1-57f8-4b09-b4dc-6c8ba62acb89",
    "title": "Permissão de acesso ao calendário",
    "transcription": "Nessa aula, a gente vai ver sobre a parte de permissões. Então, quando a gente faz autenticação social, não só com o Google, com qualquer provider, GitHub e tal, a gente tem uma série de escopos, que geralmente é o nome dado a esse tipo de permissão. Então, escopos de acesso. O que eu vou pedir de permissão? E aí o usuário pode permitir ou não. E isso tem uma certa similaridade com quando, por exemplo, você baixa um aplicativo na App Store, na Google Play, que ele vai pedir, né, você quer permitir notificações? Sim ou não? Você quer permitir tal coisa? Sim ou não? Então, o usuário pode escolher. Só que aqui a gente vai ter que validar, porque se o usuário escolher não dar permissão pra gente no calendário, a gente não... Cara, a gente não vai permitir ele nem continuar, porque não tem lógica. Tipo, a aplicação funciona totalmente baseada no calendário. Então, acho que aqui na documentação do próprio NextAuth deve ter alguma coisa relacionada a escopo. Deixa eu ver aqui em Provider, Google. Deixa eu ver se aqui dentro ele fala alguma coisa sobre escopo. Não fala. E vou ser sincero, assim, que a maioria dessas documentações, quando elas são um pouquinho mais profundas, tá? Deixa eu ver aqui, Google Provider Options. Aqui tem, ó, Authorization, Parms, e aqui tem o escopo, tá vendo? Então, aqui tem um exemplo. Mas esse exemplo me parece desatualizado. Bom, acho que ele tá um pouquinho desatualizado. Mas todas essas configurações que são um pouquinho mais profundas, nem sempre você vai achar, tipo, na primeira página da documentação, tá? Eu tô te resumindo aqui, trazendo mastigado, mas muita coisa eu tive que quebrar bastante a cabeça pra ir pegando e entendendo, né? Mas vamos lá. Aqui dentro do NextAuth API, pra gente escolher os escopos, as permissões, a gente vai começar criando aqui um objeto chamado Authorization, beleza? Dentro de Authorization eu vou passar um objeto chamado Parms, e aqui dentro, Scope. E aí no Scope, eu não tenho certeza se a gente pode mandar dessa forma que ele colocou aqui, ó, mais reduzida, tá? Porque olhando pela documentação do Google, eu preciso enviar isso aqui de uma maneira um pouquinho diferente. Até se eu for aqui, ó, Google Protocols OAuth, deixa eu ver se eu consigo encontrar aqui, ó, Scope Google OAuth Scope Calendar, por exemplo, deixa eu ver se consigo achar aqui, ó, OAuth 2.0 Scopes for Google APIs. Olha só como é que ele pede pra eu enviar os scopes, uma URL completa. Então, se eu quero o calendário, por exemplo, eu preciso enviar isso aqui, ó, como Scope. E aí eu tenho acesso, por exemplo, a toda parte de calendário do usuário. Então, eu venho aqui, ó, e posso simplesmente colar essa URL inteira. Só que eu preciso de algumas informações do perfil do usuário também. Então, existe um Scope que se chama UserInfo, ó, e aí tem o UserInfo.email e tem o UserInfo.profile, que daí eu posso pegar também nome e foto. Se eu quero só email, eu boto só esse. Se não, eu boto nome e foto. E aí é só separar eles por espaço mesmo aqui, ó. Então, no espaço. Vou botar esses do UserInfo primeiro, porque eles são mais comuns. Então, email, profile. Não esquece de deixar um espaço entre eles, tá? Senão, vai dar bug. E agora, bora testar. Antes da gente testar, como a gente já fez autenticação com a nossa aplicação, talvez ele dê um bug. Então, uma das coisas que eu aconselho você fazer é você entrar na sua conta aqui do Google, é accounts.google, e aí eu tô logando com a minha conta pessoal mesmo. E aí, você vem em Segurança, Apps de terceiros com acesso à sua conta, e aí tá aqui, ó, Ignite Call. E aí, é importante, ou melhor, conectado com a conta Google, Apps de terceiros com acesso à conta. Isso aqui é o projeto de teste, tá? Quando eu tava codando o Ignite Call. Então, eu vou tirar também, só pra garantir, mas não é o nosso projeto de agora. O nosso tá aqui embaixo. Aqui, ó, Ignite Call. Então, eu vou remover todos que a gente vê com o nome Ignite Call aqui dentro. Tem bastante coisa. E, beleza. Agora, vamos dar uma olhada, vamos testar de novo, na verdade. Vamos voltar aqui na nossa aplicação, no F5, e ver se os escopos estão funcionando. Então, eu clico em Conectar, ele deve pedir todo o processo do Google de novo. Quando eu clicar em Diego agora, ele deve pedir os escopos, tá? O Google não verificou esse app. Não tem problema, tá? Isso aqui vai acontecer, porque a gente não colocou ele... ele tá como um app ainda, digamos, em fase de testes. Quando a gente colocar em produção, a gente tem que ir lá no painel e solicitar a revisão. Mas a gente pode vir aqui em Avançado e acessar o Ignite Call, sem problemas nenhum. E agora, olha só, ele pediu os escopos. Então, ele pediu permissão pra ver, editar, compartilhar e excluir permanentemente todas as agendas que você acessa no Google. Uma mensagem um pouco pesada, mas a gente precisa dessa permissão mesmo. E aí, agora, a gente clica em Continuar e a gente volta aqui pra dentro. Só que tem a chance do usuário não dar acesso pra gente, né? Então, a gente precisa, de alguma forma, lidar com isso. E aí é legal, porque o NextAuth tem uma série de configurações que a gente pode fazer. Uma das configurações que a gente pode fazer é, aqui embaixo de Providers, a gente passa uma opção chamada Callbacks. Callbacks nada mais são do que várias funções que elas são chamadas em momentos oportunos, em momentos comuns de um processo de autenticação. Por exemplo, existe uma função, que é a que a gente quer utilizar aqui, que se chama Sign In. Essa função Sign In, que a gente pode botar aqui dentro de Callback, é uma função que ela é chamada no momento que o usuário logou na aplicação. Então, assim que o usuário logou na aplicação, ou seja, que ele chegou do Google aqui no nosso app, essa função Sign In é chamada automaticamente. E aqui dentro dessa função Sign In, a gente pode pegar alguns parâmetros. Se eu dar um Ctrl Espaço aqui dentro, fazendo uma desestruturação e dar um Ctrl Espaço, eu tenho várias informações, tá vendo? Uma que eu quero aqui é o Account, dentro do Account eu tenho Scope. Scope é exatamente as permissões que o usuário deu para a nossa aplicação. E aqui dentro eu posso fazer o seguinte, olha só. Se eu não, e aqui eu vou fazer uma negação, se o Account.Scope não inclui o Scope, e aí eu vou copiar aquela URL Calendar, vou jogar aqui dentro, eu posso fazer o seguinte, eu posso fazer o seguinte, e aqui tá dando erro, Object is possibly undefined, Account, é que o Scope pode ser undefined, tá? Beleza. Se ele não me deu permissão, eu vou retornar ele para a página barra Register, barra Connect Calendar, que é a nossa página de conexão com o calendário, porém eu vou enviar um parâmetro aqui na URL, um query parameter chamado Error=\"Permissions\", para que lá na página a gente saiba que aconteceu um erro do tipo Permissions, e lá a gente mostre alguma mensagem. Eu não quero ter que criar uma outra página de erro, tá? Por isso que eu fiz isso aqui, mas se você quiser criar uma outra página de erro, à vontade. E aí o método Sign-In, ele pode receber dois retornos, né, e eu sou obrigado a dar um retorno, por isso que ele tá dando erro aqui. Se eu retorno uma String daqui de dentro, o método Sign-In sabe que é para onde ele tem que redirecionar o usuário. Se eu não retornar uma String, eu preciso retornar True ou False. True quer dizer, ok, tudo certo, deu boa. Falso quer dizer, não deixa o usuário se autenticar, deu erro. Só que como a gente retornou uma String, já é como se fosse um False, porém redirecionando ele para outra URL. E aqui eu dou um Return True, porque se ele tiver o escopo de calendário, então a autenticação tem que fluir normal. Por isso o Return True aqui dentro, tá? Toda essa documentação de callbacks aqui, ou você passa o mouse por cima, tem toda a documentação aqui dentro do Sign-In, ou, aqui embaixo, ou você pode acessar, simplesmente, a documentação aqui, do NextAuth, e você vai ver os callbacks mais comuns, né? Sign-In, Redirect, Session e JWT. E aqui ele explica, True, False, ou você pode retornar uma URL, como eu falei, tudo isso que eu estou te explicando aqui agora. Vamos testar isso aqui, então, olha só. Eu vou voltar aqui na minha conta da Google, vou remover o acesso do Ignite Call. Deixa eu validar que aqui embaixo foi tirado também, foi, beleza. Voltamos aqui dentro, eu vou clicar em Conectar, Diego Shell.f, e eu não vou dar permissão do calendário agora. Não vou dar permissão, vou dar um Continuar e ele tem que redirecionar para Connect Calendar com aquele Error. Olha, Error Permissions. E aí agora a gente tem que mostrar uma imagem aqui em tela, uma mensagem em tela, falando que deu erro de permissão, que ele tem que logar de novo e dar as permissões necessárias, senão não vai acessar a aplicação não."
  },
  {
    "id": "98cdfacf-d85a-4a33-8e5d-87765b0afc89",
    "title": "Página de disponibilidade",
    "transcription": "Nessa aula o que a gente vai começar a fazer é a página de disponibilidade, que é essa página aqui. E essa vai ser uma das páginas mais completas que a gente vai desenvolver aqui. Ela tem bastante recurso envolvido, bastante validação envolvida, então vai ser muito massa como que ela vai ficar. E bora lá. A gente vai começar então pela parte visual, estrutural aqui da página, e depois a gente já vai começar com a parte do formulário, que essa vai ficar muito, muito, muito legal. Vamos lá. Dentro de source pages, dentro de register, aqui eu vou criar mais uma pastinha. Eu vou chamar aqui de time intervals index.tsx styles.ts, e a gente vai começar com uma estrutura bem simples. O index aqui precisa ser .page.tsx, porque senão ele não vai virar uma página. Export default function time intervals. A gente pode reaproveitar, na verdade, a página de connect calendar, talvez, e só remover as coisas que a gente não for utilizar, então time intervals. Inclusive a página de connect calendar eu acabei de ver que eu esqueci de trocar o nome aqui. Então vamos mudar também o nome da função. E aqui agora a gente vai dar uma apagada em toda essa parte do connect box, connect item, tudo isso aqui. Deixar só o container, o que a gente vai reaproveitar, digamos, entre uma e outra. Aqui também eu vou tirar tudo, depois a gente cria do zero. E aqui eu também vou remover todos os imports não utilizados, e pronto. Pronto, isso aqui é a nossa página. Agora eu vou copiar os textos aqui, então quase lá. E aqui defina os intervalos. E aqui no multistep, agora o step é 3, a gente já está no terceiro step do cadastro. E agora a gente vai construir visualmente essa página aqui. E pra isso eu vou começar pelo arquivo de styles, é claro, usando a minha cola aqui. Então eu vou começar criando aqui um intervalbox, que vai ser a nossa box em si, que vai ficar por volta de tudo. Então eu vou importar tanto o style do IgniteUI React quanto o box em si. E aqui, essa caixa, ela precisa só basicamente definir um margin-top e um padding. O padding na verdade já vem até por padrão. Então eu vou só dar um display-flex nela e um flex-direction-column, porque o botão e essa seção aqui dos dias da semana está uma abaixo da outra. Então a gente faz dessa forma. Basicamente isso. Agora eu vou criar aqui o nosso intervals-container, que seria esse quadrado que fica por volta de todos os dias da semana. E eu vou criar ele como uma div mesmo. E aqui eu vou dar basicamente um border, um pixel-solid, usando a cor grey 600 do nosso design system, e vou botar um border-radius-median. E aqui eu também vou dar um margin-bottom 4, pra gente distanciar o botão ali abaixo. Porque eu não quero adicionar um estilo específico pro botão, vou usar direto o botão lá do design system. Deixa eu escurecer um pouco minha câmera, que tá um pouco dando mal. Tá bom, vai assim que hoje o dia tá bem solarado, tá entrando até na persiana aqui. E agora a gente vai criar o nosso interval-item, que seria cada um dos itens da semana aqui. Eu vou criar ele também como uma div. Aqui ele vai ter um display-flex, porque é checkbox, texto e os inputs um do lado do outro. Align-item-center. E aqui eu vou dar um justify-content-space-between. Por quê? Porque a gente pode ver que isso aqui tá totalmente alinhado pra direita, e o dia da semana totalmente pra esquerda, então tem um espaço entre eles. Então eu vou botar um container aqui também por volta do dia da semana, que é o checkbox mais o nome do dia, e um container aqui por volta dos dois horários, de início e final, pra eles ficarem alinhados certinhos. E também vou botar um padding de 12 em cima e embaixo, e de 16 nas laterais. E agora eu quero adicionar essa bordinha entre os itens, mas somente do segundo pra frente, digamos assim. Então eu gosto de usar um hackzinho aqui do CSS, que é basicamente usar um e-comercial mais e-comercial. Então ele vai aplicar somente do segundo em diante. Isso aqui é simples de entender, é só a gente pensar que eu quero aplicar um CSS somente no interval-item que tiver um interval-item antes dele. E aí aplica aqui, a gente bota um border-top, um pixel-solid-gray-600. Show. Agora, como eu falei, eu vou criar um container pra essa parte aqui, e um pra essa parte aqui. Então eu vou chamar de interval-day-styled-div, e aqui a gente vai botar um display-flex, bem simples, item-center, e um gap de 12 só pra distanciar o checkbox aqui, um pouquinho do texto. E aí a gente vai ter os nossos interval-inputs, que é o nosso outro container. Aqui também é display-flex, align-items, e aqui eu vou diminuir um pouquinho o gap pra ser 8 pixels aqui entre os inputs, não precisa ser muito grande. E é isso, agora a gente vai colocar tudo isso aqui em tela, e vai ficar bem massa. Vamos lá, começar colocando o nosso interval-box, e esse interval-box aqui, ele é aquela caixa, mas só que eu quero que ele seja um form, então eu vou botar um s-form aqui nele, pra que ele se comporte como um form, o submit funcione e tudo mais. Vou criar o interval-container, tudo importante dos estilos aqui, já de uma maneira mais automática. Dentro do container eu vou ter cada um dos meus itens, então interval-item, eu não vou criar pra todos os dias da semana por enquanto, vou criar só pra segunda e terça, pra gente ver como é que fica. E aí dentro do interval-item eu preciso do interval-day e do interval-inputs, que são os dois containers que a gente criou. No interval-day vai basicamente o nosso checkbox, então eu posso importar isso aqui lá do ignite-ui-react, porque a gente tem um componente de checkbox, e a gente vai colocar também um text que vem de dentro também do ignite-ui-react, que já está importado, então é só utilizar, e aqui ele não vai precisar de estilização nenhuma, ele vai pegar até os estilos padrão que a gente tem no design system. Aqui no interval-inputs a gente vai usar dois text-inputs que vem de dentro do ignite-ui-react também, e aqui ambos vão ter size small, porque eles vão ser um pouquinho menores, o tipo deles vai ser time, que ele abre um seletor no Chrome pra gente, não no Chrome só, mas em qualquer navegador pra selecionar especificamente um horário, e não uma data, e aqui quando a gente tem um input de horário, a gente consegue definir um step, que é basicamente qual é o intervalo que a gente quer permitir que o horário seja selecionado. Se o step for 5, a pessoa vai poder selecionar de 5 em 5 minutos, então vai aparecer por exemplo 8, 8.5, 8.10, 8.15, aqui no caso eu quero que seja de hora em hora, então a pessoa pode definir qual que é basicamente a hora de início e a hora de término, porque aqui no IgniteCall a gente vai partir do pressuposto que cada agendamento, horário marcado pelo calendário, ele dure uma hora. Não necessariamente isso tem que ser pra toda aplicação, e você pode configurar mais pra frente, pra isso ser configurável, o usuário escolher, mas aqui a gente vai botar dessa forma até pra ficar um pouco mais fácil. E aí a gente vai ter mais um input aqui embaixo, mesma coisa, que é o horário de término, então a gente ainda não cadastrou eles, eles vão ficar iguaizinhos. Se a gente for ver lá agora na nossa aplicação, então localhost 3000, barra register, barra time intervals, a gente vai ver como que tá ficando a página, que é basicamente dessa forma aqui, deixa eu tirar o zoom, bem legal né? Então a gente já tem o checkbox aqui funcionando, vamos criar mais um intervalo item aqui, e eu vou colocar aqui nele, terça-feira, só pra gente ver como é que fica, show de bola. Uma coisa que a gente pode ver aqui, o input do Chrome aqui, ele coloca esse reloginho aqui, que quando tu clica ele abre o seletor aqui, como eu falei. Só que eu não gosto, na verdade o reloginho tá preto, então a gente precisa alterar isso. E pra alterar isso, vou ser sincero que é bem chatinho, tá? A gente não consegue simplesmente no Chrome ir lá e escolher a cor, a gente tem que colocar o nosso próprio ícone e tal. Se eu quero modificar a cor do ícone que já tá ali, aí que eu falo que é um pouquinho mais chato, tá? Mas então a gente vai botar aqui dentro do intervalo inputs, eu vou fazer o seguinte, input, dois pontos, dois pontos, traço, webkit, traço, calendar, picker, indicator, tá? Sim, o nome é calendar mesmo não sendo um calendário de certa forma, o Chrome ele usa esse tipo de seletor aqui pra todos, tá? E aqui agora, olha, pra eu manipular eu vou ter que aplicar um filtro de cores, então eu não posso trocar cor direto, não posso trabalhar com background, color ou qualquer coisa assim, eu tenho que aplicar um filtro de cores. E aí o que eu vou fazer, olha só, primeiro eu vou inverter a cor que ele tem lá em 100%, se eu salvar isso aqui agora eu posso ver que tá totalmente branco já, tá vendo? Então eu inverti antes era preto, agora é branco. E eu vou também aplicar um brightness aqui de 30%, pra ele dar uma leve, como se fosse uma opacidade aqui, né? E aqui eu tinha colocado também um saturate 0%, deixa eu ver se isso aqui faz efeito, isso aqui não vai fazer efeito, a gente usa saturate 0% quando eu quero deixar ele preto e branco, né? Quero tirar a cor digamos assim, mas nesse caso que ele já não tem cor, não tem tanta necessidade, mas ali ele já ficou estilizadinho, tá legal, se quiser aumentar um pouquinho o brightness aqui pra ele ficar mais claro, você que manda nesse caso. E faltou só o nosso botão aqui embaixo, né? Então antes da gente fechar o nosso intervalbox, a gente vai criar aqui um button que vem também de IgniteUI React, o tipo dele vai ser submit, e aqui vai estar escrito próximo passo, e temos o ícone dentro que é o arrow right, que tem que vir de dentro do Phosphor React. Feito isso, salvamos, Chrome, e tá lá, já tá lá o próximo passo, já conseguimos selecionar aqui, e agora a gente vai começar a dar funcionalidade pra isso, ainda não colocamos todos os dias da semana aqui, mas agora a gente vai começar a dar vida pra esse formulário e vai ficar bem legal, você vai ver."
  },
  {
    "id": "bd39db54-a0b4-4b48-a194-8254e79698d7",
    "title": "Validação e transformação no Zod",
    "transcription": "Se a gente for aqui dentro da nossa aplicação, dentro do nosso HandleSetTimeIntervals, que é o método aqui para a gente conseguir obter os dados do form, no Submit, e pegar o data aqui, daquela mesma forma que a gente já tinha feito com o form antes, criando um TypeTimeIntervalsFormData, usando o z.infer, TypeOfTimeIntervalsFormSchema. Aqui dentro a gente ainda não definiu o formato do nosso form, validação, nem nada disso. Mas o que eu quero mostrar, no fim das contas, é que se a gente for aqui e der um console.log nesse data, e aqui dentro do Chrome a gente abrir o console e enviar o nosso formulário, a gente já recebe o array de intervalos com todos os campos aqui dentro. Só que eu quero modificar um pouco o comportamento e até conseguir validar algumas coisas aqui dentro, por isso que a gente vai começar criando o nosso schema. O nosso formulário tem um único campo chamado Intervals. Então a gente vai começar colocando esse campo aqui, Intervals, e ele é um array. Então a gente começa utilizando o z.array, e ele é um array com vários objetos dentro, cada objeto representando um dia da semana. Então dentro de z.array a gente precisa indicar qual é o conteúdo desse array. Então z.object para indicar que cada posição do array é um objeto. E aí dentro desse objeto a gente tem algumas propriedades. Nós temos WeekDay, que é um z.number, e aqui você pode ir até mais fundo. Por exemplo, eu sei que os dias da semana vão de 0 a 6. Então eu posso botar, por exemplo, uma validação aqui. É claro que no nosso caso ela sempre vai passar, mas para garantir, por exemplo, que o mínimo do dia da semana é 0, que é domingo, e o máximo é 6, por exemplo, que é sábado. Então aqui a gente pode ir brincando. O Enabled, que é um z.boolean, ele sempre vai ser true ou falso. E aí nós temos o StartTime, que é um z.string, e nós temos o EndTime, que é um z.string também. Perfeito. Até aí tudo bem. Agora se eu passar o mouse aqui em cima do TimeIntervalsFormData, ele já aparece aqui. WeekDay, Enabled, StartTime, EndTime. Só que não é isso ainda que eu quero fazer. Eu quero começar a fazer umas validações e transformações. E eu acho que é a primeira vez que a gente vai ver aqui nesse módulo sobre transformação de dados utilizando o Zod. O Zod é uma biblioteca muito incrível porque, além de ele servir para validação, como a gente consegue fazer aqui, falar que é obrigatório, não é, e tudo mais, ele serve também para transformação de dados. O que eu quero dizer com isso? Imagina que no nosso formulário a gente vá fazer o input de dados de uma forma, mas que eu queira que quando os dados cheguem aqui no nosso methodSubmit, aqui no data, eu quero que eles cheguem de outra forma. O Zod consegue fazer isso. E não só dentro do ReactHookForm, é claro, o Zod é uma biblioteca totalmente à parte. A gente está usando ele acoplado ao ReactHookForm aqui, mas daria para fazer todo esse processo de validação e transformação, sei lá, no backend caso eu queira, se fizer sentido. Então o que a gente vai começar fazendo? Aqui no final do array eu vou começar colocando uma validação que o length desse array precisa ser 7, porque eu tenho 7 dias na semana. Ou seja, eu sempre preciso receber todos os dias da semana dentro dos meus intervalos. Eu não posso receber um dia só. E olha só a primeira transformação que a gente vai fazer. Eu vou utilizar o método transform. Deixa eu quebrar a linha para ficar mais fácil de visualizar. Vou até botar a vírgula para baixo aqui. Vou botar ponto, transform. Opa, escrevi errado. O transform serve exatamente para a gente modificar o formato desse array. Ou seja, o transform recebe o array original de intervalos e eu posso fazer o que eu quiser com esse array. Por exemplo, eu posso pegar os intervalos, filtrar eles utilizando um filter, somente dos intervalos que estiverem com enabled true. Ou seja, acompanha comigo o raciocínio. O Zod vai pegar o array original e vai passar para essa variável intervals. E aqui de dentro o que eu estou fazendo? Eu estou retornando esse array original filtrado pelos itens somente que estão com enabled como sendo true. Olha só que interessante. Quando eu salvo isso aqui agora, volto na minha aplicação, mas agora eu preciso cadastrar o resolver do Zod. Então, Zod resolver e passo aqui o nosso esquema. O meu VSCode às vezes dá uma lagada. Passo o meu esquema aqui dentro. Voltando agora para a nossa aplicação, quando a gente dá um próximo passo, veja que ele retorna só cinco itens agora. Por quê? Porque ele removeu, ele filtrou os itens que estavam com enabled false, que era sábado e domingo. Se eu botar todos os itens como enabled false, apenas segunda-feira está com um enabled true. Quando eu dou um próximo passo, ele traz apenas segunda-feira. Ou seja, o Zod é incrível por causa disso, porque ele consegue transformar os nossos dados. E aí, eu posso pensar que eu quero fazer agora uma validação que o resultado desse transform aqui, ele precisa me retornar pelo menos um dia da semana. O que eu quero dizer com isso? A pessoa não pode desabilitar todos os dias da semana e dar um próximo passo. Não faz sentido. O array resultante aqui dessa transformação precisa ter pelo menos um dia da semana. Senão, ele não vai atender nenhum dia da semana e não tem lógica. Então, olha só o que eu vou fazer. Eu não posso utilizar o min como a gente usou aqui em cima, por exemplo, para verificar, ou utilizar o length, porque a partir do momento que eu transformei esse array, eu não posso usar os outros métodos auxiliares aqui do Zod para fazer validações. Eu tenho que utilizar um tipo de validação especial que o Zod chama de refine. O refine é muito parecido com o transform, porém, de dentro dele, eu preciso retornar true ou false. O array está válido ou não. Ou seja, da mesma forma que o transform, ele vai receber o array original de intervalos, só que agora, de dentro dele, eu preciso retornar um true ou false. Se eu retornar true, está válido, se não, está inválido. Ou seja, daqui de dentro, eu vou retornar se o intervals.length for maior que zero. Ou seja, o refine está fazendo o seguinte. Eu estou validando que o tamanho do meu array de intervalos que sobrou dessa transformação, ou seja, após o filtro, ainda tem mais de um elemento lá dentro. E o legal do refine é que como ele é uma operação de validação, assim como as outras operações de validação aqui do Zod, por exemplo, o mínimo, eu posso passar um objeto de opções aqui para ele e configurar a mensagem de erro. No refine também, eu posso passar um objeto de configurações aqui no segundo parâmetro e configurar uma mensagem de erro. Então eu posso falar, por exemplo, aqui numa mensagem, você precisa selecionar pelo menos um dia da semana. Agora a gente salva e pronto. A gente já fez aqui o refinamento do nosso formulário. Então, vamos testar. A gente vem agora aqui no Google Chrome. Se eu não selecionar nenhum dia da semana, se eu der um próximo passo, ele não tem que mostrar console.log nenhum, porque ele tem que cair no problema de validação. Então, olha só, já não mostra nada, então quer dizer que o Zod já validou. A gente só não está mostrando essa mensagem em tela ainda, porque ela está aqui dentro de errors, mas logo a gente coloca ali dentro. Outra coisa que eu vou fazer é que se a gente for para... Ou melhor, vamos colocar a mensagem de validação em tela e depois a gente continua, porque eu quero fazer mais ainda um pouquinho de transformação dentro desse array e vai ser mais fácil eu trabalhar com esses dados dentro do back-end. Mas vamos lá, vamos começar utilizando aqui o isSubmitting. Então, lá no nosso botão de próximo passo, eu vou desabilitar ele caso o isSubmitting esteja como true, se ele está enviando o processo de trocar os intervalos de horários ali. E aqui o errors aqui dentro, a gente vai fazer mais ou menos da mesma forma que a gente já tinha feito nos outros formulários. Então, aqui antes do botão, eu vou colocar o nosso erro e vou fazer da seguinte forma. Se dentro da propriedade errors.intervals, que é o único campo que a gente tem no formulário, houver uma mensagem de erro, ou eu posso fazer só dessa forma aqui também e já vai funcionar, eu vou mostrar o erro em tela. E aqui o erro eu quero que ele mostre vermelhinho, então aqui dentro de styles a gente vai criar uma constante formError é igual a styles.text que vem do IgniteUI React e aqui dentro a única estilização que a gente vai botar é um color sendo f75a68 e o margin-top, só para distanciar ele um pouquinho do topo, de 8 pixels ou 2. E aqui agora a gente vai colocar então o nosso formError do ponto barra styles e aqui eu preciso colocar a mensagem de erro, então é errors.intervals.message e aqui como isso aqui é um text, eu posso passar o sizeSmall para ele colocar o tamanho da fonte um pouquinho menor. Salvo isso aqui agora, voltamos aqui no Google Chrome, veja, já aparece diretamente o erro aqui dentro. Só que aqui eu botei o margin-top, eu vou botar na verdade o margin-bottom e até vou botar um pouquinho mais, vou botar 4 aqui para distanciar um pouquinho mais do botão. Então show, já apareceu ali, você precisa selecionar pelo menos um dia da semana, então ele já valida para a gente, se eu seleciono um dia da semana e dou um próximo passo, ele já tira a mensagem de erro porque ele fez aqui, depois do refinamento, ele já percebeu que já não tem mais nenhum erro aqui no nosso formulário. Mas vamos lá continuar porque ainda tem algumas coisas bem legais que eu quero te mostrar na próxima aula que vai explodir a sua cabeça em relação aos odds e a sua integração com o TypeScript."
  },
  {
    "id": "d6bb29e6-fdb4-4d8f-b592-2916eab9e608",
    "title": "Formulário de disponibilidade",
    "transcription": "Nessa aula a gente vai começar configurando a parte de formulário para dentro dos nossos intervalos. Então a gente vai utilizar o ReactHookForm nesse formulário. E esse aqui vai ser o formulário mais completo que você já desenvolveu com o ReactHookForm. Ele vai ser um formulário com bastante validação, bastante opções de renderização, de desabilitar. Então tem muita coisa massa. A gente vai começar utilizando o UseForm aqui dentro do ReactHookForm. E aqui dentro a gente vai começar já também criando o nosso schema, que é onde vão ficar as nossas regras de validação. Então eu vou chamar ele de TimeIntervalsFormSchema. E aqui eu vou estar utilizando o Zod, então eu vou importar o Z de dentro do Zod, Object. E aqui dentro a gente vai ter todas as nossas propriedades ali dentro. Aqui do formulário a gente vai obter acesso às propriedades Register, HandleSubmit. E aqui a gente vai ter mais algumas outras, como por exemplo FormState, que ele traz pra gente o estado de isSubmitting e também o estado de erros aqui dentro do nosso formulário. E aí agora a gente vai começar a utilizar essas opções. A primeira coisa que eu vou fazer aqui dentro é criar uma função chamada HandleSetTimeIntervals, que vai ser a função chamada quando o usuário fazer um Submit. E essa função eu vou utilizar aqui no IntervalBox, que é o nosso formulário. Só que eu vou envolver ela com a HandleSubmit que vem aqui do ReactHookForm. HandleSubmit, HandleSetTimeIntervals. E agora a gente tem vários dias da semana aqui dentro do nosso formulário. Cada dia da semana ele é uma posição dentro de um Array, a gente pode pensar. Então imagina que no momento que a gente for querer receber essas informações, eu quero que cada dia da semana ele esteja dentro de um Array. Então quando eu receber o Submit desse formulário, eu quero que por exemplo a primeira posição do Array seja da segunda-feira e tenha basicamente o dia da semana, que é a segunda-feira, vou botar um índice zero por exemplo, e tenha a data, o horário de início e o horário de término. E eu quero que isso seja para todos os dias da semana. Então 1, 2, 3, 4, 5, 6. Isso dentro do ReactHookForm, quando a gente tem um Array, mesmo aqui tendo um número limitado de opções, mas podendo ter mais opções se não fosse dias da semana, se fosse alguma outra coisa que a pessoa pudesse selecionar, a gente chama isso no ReactHookForm de FieldArray, que é quando a gente tem um campo dentro do nosso formulário que ele é um Array. E aí a gente vai fazer isso de uma maneira muito legal, olha só. Primeiro aqui no UseForm eu vou começar criando uma opção chamada DefaultValues, porque se a gente for parar para pensar, aqui dentro, cada uma dessas opções aqui, ela já vai ter um valor padrão quando chegar aqui na tela. Eu quero que quando o usuário chegue nessa tela, todos os dias da semana já estejam habilitados e todos os horários eu quero que eles estejam, sei lá, 8 às 18, ou 9 às 17, alguma coisa assim. Ou seja, eu já quero vir com um valor padrão. Então, aqui dentro de DefaultValues, eu vou começar criando o DefaultValue para uma propriedade chamada Intervals. E aí, como eu falei, cada dia da semana vai representar um objeto dentro desse Array de intervalos, que são os dias da semana. E aí eu vou começar criando esse intervalo da seguinte forma, olha, o dia da semana, que vai ser representado por WeekDay, começando em zero, representando o domingo. E aí, Enabled, que vai representar o checkbox, se ele está habilitado ou não. No caso do domingo, eu vou, por padrão, vir como desabilitado. E aí a pessoa pode habilitar a causa que ela queira. E eu quero que tenha uma propriedade StartTime, que é o horário de início, então eu vou botar 8 horas da manhã. E EndTime, que é o horário de término, que eu vou botar 18 horas. E agora eu vou fazer isso para todos os dias da semana, então segunda, terça, quarta, quinta, sexta e sábado. E aí nos dias da semana, que são segunda, terça, quarta, quinta e sexta, eu vou colocar Enabled como True, por padrão. E o horário vai continuar 8 às 18 em todos os dias, porém, domingo e sábado vão ficar desabilitados. E aí, como eu falei do FieldArray, como é que a gente vai fazer agora para, basicamente, o que eu quero fazer? Eu quero percorrer todos os dias da semana, ou seja, eu quero fazer um Map aqui dentro do React. E mostrar um conjunto, um intervalo item para cada dia da semana. Aqui dentro do React Hook Farm, a gente pode utilizar um outro Hook chamado UseFieldArray. O UseFieldArray basicamente permite a gente iterar, manipular, um campo do formulário que é um Array. E esse Array, inclusive, ele pode receber, como eu falei, mais valores ou menos valores. Aqui a gente tem um leque limitado, dias da semana são 7 e a gente sempre vai trabalhar com 7. Mas se você estiver no dia a dia construindo um formulário que ele é manipulável pelo usuário, o usuário pode adicionar mais opções ou remover, o UseFieldArray também é perfeito para isso. Aqui no UseFieldArray, a gente vai, basicamente, passar duas opções. Primeiro, o nome do campo, então, NameIntervals, o nome do campo que a gente está trabalhando. E a segunda opção que ele obrigatoriamente precisa receber é uma propriedade chamada Control. Essa Control aqui, ela vem de dentro do UseForm, então é só eu pegar ela aqui. Eu pego ela da desestruturação do UseForm e passo ela para o UseFieldArray. Basicamente, para o UseFieldArray saber que ele está lidando com este formulário aqui. Porque ele não consegue saber qual o formulário que ele está lidando. E aqui, ele vai retornar para a gente uma propriedade chamada Fields. Simplesmente. E agora eu posso percorrer essa propriedade Fields para mostrar cada um dos campos aqui dentro. Então, vamos lá. Eu vou começar deletando um dos intervalItem, o outro eu vou dar um Control X para recortar. Vou colocar aqui dentro uma iteração, então eu vou fazer Fields.map. Cada campo, aqui ele vai me retornar agora dentro de um Field. E aqui dentro eu dou um Return e mostro o meu intervalItem aqui dentro. Primeira coisa, ele já começou a dar alguns erros aqui dentro. E o primeiro que a gente pode ver é que a gente não colocou a propriedade Key. E aqui eu posso simplesmente botar Key. E quando eu dou um ponto aqui dentro, ele traz as propriedades que a gente colocou aqui dentro. Então, WeekDay, Enabled, StartTime e EndTime. Mas ele traz uma outra propriedade também, que é o Id. O Id é uma propriedade gerada automaticamente pelo próprio ReactHookForm, que é a maneira da gente identificar unicamente cada um desses campos aqui dentro. E pronto. Agora, se eu salvo isso aqui agora e volto lá para dentro, mostrou os sete campos. Porém, está tudo segunda-feira, porque a gente precisa trocar aqui no text para Field. E aqui a gente tem apenas o número do dia da semana. Então, 0, 1, 2, 3, 4, 5, 6. A gente precisaria conseguir mostrar exatamente o dia da semana baseado nessa propriedade. E aí eu vou te mostrar algo bem legal. Mas o que a gente vai fazer? A gente vai fazer separado. Então, aqui dentro de Search, eu vou criar uma pastinha Utils, que eu gosto de botar, às vezes, umas funções úteis. Uns helpers, para ajudar a gente em algumas opções. Aqui dentro eu vou criar uma função chamada GetWeekDays. E aqui, calma, eu não vou retornar um array simplesmente falando 0, quer dizer domingo. Porque a gente pode, em algum momento, internacionalizar nossa aplicação. A gente precisa, de alguma forma, trabalhar com a nossa aplicação já pensando no futuro. Então, aqui, olha só. Eu vou criar a export function GetWeekDays. E aqui, eu vou, basicamente, fazer o seguinte. const formatter é igual a new. E ntl, eu vou usar a API de internacionalização disponível nativamente do JavaScript. .datetimeformat ptbr, no primeiro momento, que é o que a gente está trabalhando. Aqui, eu passo a opção weekday como sendo long. Ou seja, a única informação que eu quero, eu quero formatar uma data, mas a única informação que eu quero é o dia da semana, no formato long. Ou seja, ele é escrito por extenso. E aqui, agora, eu vou fazer o seguinte. Eu vou criar um array com 7 posições. Só que eu quero que, basicamente, o array tenha esse formato aqui. Tem várias formas de criar, mas uma forma muito simples de criar aqui é a gente fazendo um array.from, que ele vai tentar converter uma outra estrutura iterável em um array. E aí, aqui, a gente pode botar um array.array 7 posições, que é o que eu quero. Isso aqui vai criar um array com 7 posições, porém, todas as posições contendo valores undefined. Ou seja, não dá pra trabalhar com esse array. E aí, eu uso um hackzinho aqui, que é o método keys. O keys vai, basicamente, retornar o índice. Então, pensa assim. Isso aqui, eu estou criando um array e retornando todas as chaves dele, todos os índices. Então, isso aqui, basicamente, retorna 0, 1, 2, 3, 4, 5 e 6. E aí, eu estou usando o array.from pra converter esse retorno aqui em uma estrutura de array. Então, a gente faz, basicamente, este funcionamento aqui. E agora, eu já consigo fazer um map. E aí, ele vai me retornar cada dia da semana, começando do 0 aqui. E aí, eu vou, basicamente, fazer o seguinte. Vou chamar aqui o nosso formatter.format. E aí, pra eu conseguir formatar, não pode ser só o dia da semana. Precisa ser um objeto date do JavaScript, senão ele não consegue formatar. Então, aqui, eu vou fazer um hack, basicamente. Eu vou fazer um new date. E aqui, eu vou utilizar um método chamado date.utc. UTC, a diferença aqui, é que a gente vai passar pra ele o ano, o mês e a data. E ele pode receber, também, horas, minutos, segundos e tudo mais. E ele vai retornar pra gente um number, que é o timestamp da data, pra gente conseguir trabalhar. E aí, aqui dentro, a gente vai passar a qualquer ano que seja. Então, aqui, na verdade, não pode ser qualquer ano. Tem que ser o ano e o mês, que o mês começa certinho no dia 1. E aí, ele vai retornar, olha só. Vai retornar aqui, se eu boto o dia da semana, aqui né, 0, 1, 2, 3. Olha só, botei aqui o getWeekDays. E agora, eu vou pegar aqui dentro do meu código, vou criar uma variável chamada weekDays, é igual a getWeekDays. E agora, lá na hora de exibir, eu boto, simplesmente, weekDays passando o dia da semana como um parâmetro, como um índice. Salvo, volto no Chrome e olha lá, domingo, segunda, terça, quarta, quinta, sexta e sábado. Então, ele já mostrou certinho os dias da semana. Só como eu quero que a primeira letra capitalizada, a primeira letra em caixa alta, eu vou fazer mais um map aqui, weekDay. E vou, basicamente, retornar da seguinte forma. Um texto, pode ser weekDay.substr, substring, 0, 1, .toUpperCase, ... Acho que dá pra usar até concat na string. weekDay.substring 1, que daí ele vai pegar do 1 pra frente. Salvo, voltamos lá e show, primeira letra já tá. Em caixa alta. E agora, que a gente já conseguiu mostrar todos os inputs, em tela e tudo mais, aqui a gente pode ver que ele não mostrou o horário. Porque, lá dentro dos nossos inputs, a gente não fez o registro, o register aqui dentro. Então, vamos fazer isso só antes da gente finalizar. E aqui, a gente vai, basicamente, passar o seguinte, . . . register. E aqui eu vou passar, usar o acento grave aqui, a crase, porque eu quero fazer uma interpolação. Então, aqui eu vou botar, basicamente, intervals, ponto. E aí, como é um array, eu preciso botar aqui, depois do ponto, o índice do array. Então, aqui eu vou botar index, só que eu preciso pegar esse índice daqui de cima, no map. O índice, digamos, desse input, desse item dentro dos intervalos, ponto, o nome do campo. Então, o nome do campo, lá em cima, é startTime. Salvo isso aqui agora, e vou fazer o mesmo processo no outro, só que o nome do campo é endTime. Salvo aqui, e agora, se eu volto lá no Chrome, olha só, ele já está preenchido com todos os horários, 8, 18 e tudo mais. Só que o checkbox aqui, ele não veio selecionado. Mas, a gente faz isso aí nas próximas aulas."
  },
  {
    "id": "d18eada6-3730-498b-9443-b2dd2c53088f",
    "title": "Input e output do Zod",
    "transcription": "Uma das preocupações que eu tenho quando eu lido com datas, com números no geral, dentro do back-end, é que é muito chato lidar com números quando eles estão em duas situações. Isso vale para datas, preços, tudo que tu pode imaginar. Primeira das situações, quando eles estão em número decimal. É chato lidar com preço no número decimal, por exemplo. Então, geralmente, a gente converte todos os preços para centavos, ou seja, multiplica ele por 100, porque assim a gente nunca vai ter casas decimais nos campos da tabela do banco de dados que tem preço. Só que, para datas, sempre que possível, é legal a gente tentar salvar no banco de dados a data completa, mesmo que a gente esteja lidando com horários, porque salvar a data completa é muito mais fácil de trabalhar. Se a gente realmente não for utilizar a data completa, e a nossa aplicação for um pouco mais simples, e eu precisar realmente salvar só o horário, eu recomendo você converter para minutos. Minutos, se você não for lidar com segundos do horário, como aqui a gente não vai lidar com horário quebrado em segundos, apenas em minutos, é muito mais fácil de trabalhar com minutos do que trabalhar com uma string dessa forma. Uma string dessa forma é muito difícil comparar, por exemplo. Um horário vem depois do outro? Não sei, é difícil, vou ter que ficar usando biblioteca para converter, para construir. Se eu tenho os minutos, é muito fácil eu saber se 18 horas vem depois de 8 horas, porque 18 vezes 60 é maior do que 8 vezes 60, e saber a diferença deles também é muito fácil. É só fazer 18 vezes 60 menos 8 vezes 60 e eu sei a diferença de minutos, caso eu queira converter para horas, eu divido por 60 e pronto, eu tenho a duração em horas. Então, antes de eu enviar essa informação startTime e endTime lá para dentro do backend, que é onde eu vou precisar salvar essas informações, eu quero converter esse startTime e esse endTime para minutos, e não para horas em formato de string. Então, o que a gente vai fazer? Olha que interessante. Nós vamos aplicar um novo transform aqui dentro, após aquele primeiro refine. Esse transform também vai receber os intervalos. E aqui, o que eu vou fazer dentro desse transform? Eu vou percorrer os meus intervalos, e para cada um dos intervalos, eu vou retornar um novo objeto. Dentro desse objeto, eu preciso retornar as informações que vão estar contidas em cada intervalo. Ou seja, cada intervalo eu preciso do dia da semana, ou seja, interval.weekDay, da mesma forma que eu preciso. Eu preciso da informação enabled aqui dentro, que a gente tem dentro do intervalo? Não, porque se eu estou transformando aqui em cima, removendo todos que já não estão enabled, essa informação eu não preciso, é óbvio que eles estão enabled, porque eu já estou removendo aqui em cima todos que estão disabled. Concorda comigo? Então, o enabled, a gente nem precisa mais dele. A gente nem vai precisar dele lá no back-end. No back-end só vai chegar os que já estão enabled. E agora, eu vou colocar aqui um novo campo. StartTimeInMinutes, que eu vou botar zero por enquanto, e EndTimeInMinutes. Veja que eu não tenho mais, eu estou sobrescrevendo cada um dos intervalos com novos campos. O único que está igual aqui é o weekDay. Eu estou sobrescrevendo StartTime, não tem mais, EndTime também não tem mais, e Enabled também não tem mais. E agora a gente tem StartTimeInMinutes, que ainda a gente precisa converter, e EndTimeInMinutes. Para fazer essa conversão em utils, eu vou criar uma nova função, convertTimeStringToMinutes. E essa função vai receber uma TimeString, que é basicamente isso aqui, por exemplo, 09 e 30. E o que ela vai fazer? Primeiro, eu vou dividir a minha TimeString onde eu tenho os dois pontos, para eu saber horas e minutos. E eu vou converter cada uma dessas partes, tanto o que vem antes dos dois pontos e depois dos dois pontos, em um número. Então, eu posso fazer um Map, porque o Split retorna um Array, e eu posso passar aqui dentro do Map o construtor da classe Number do JavaScript. Ou seja, ele vai pegar a mesma coisa que se eu fizesse isso aqui, pegar cada item do Array e passar aqui para dentro do Number. Mas como o Number já é uma função construtora, já vai funcionar dessa forma também. E aí, ele vai retornar na primeira posição do Array as horas, e no segundo, os minutos. E agora é muito simples, é só eu retornar horas vezes 60, porque cada hora tem 60 minutos, mais minutos. Caso você queira, mesmo que a multiplicação execute antes, caso você queira facilitar a visualização, aqui ele até remove, porque a multiplicação roda antes. Ele basicamente multiplica o tanto de horas que a gente tem por 60 e soma os minutos da hora. E agora aqui, eu vou utilizar o nosso método convertTimeStringToMinutes dentro do interval.startTime, que é a nossa String. Vou fazer o mesmo processo agora no interval.endTime. Se eu salvo aqui agora, volto no Google Chrome e vou selecionar mais alguns aqui, e vou trocar o horário desse aqui de 8 para 10, e fechando as 14. Vamos dar aqui um próximo passo. Veja aqui agora, o Array que ele retornou para a gente, não tem mais as propriedades enabled, nem a startTime, nem a endTime. Ele tem, na verdade, as propriedades startTimeInMinutes, 8 vezes 60, 480, 8 vezes 18, 1080. Ou seja, o minuto certinho, a contagem de minutos que tem em cada uma dessas horas. O dia 3 aqui, o WeekDay 3, que foi a quarta-feira, que a gente modificou para as 10 horas, o valor já está aqui 60, enquanto o endTime, que a gente modificou para 14 horas, está 840. Ou seja, agora a gente tem a data em minutos. E aí aqui, eu posso fazer mais uma validação, porque imagina que a pessoa seleciona no horário de início 10 horas e no horário de saída 9, por exemplo. Não faz sentido, porque isso aqui não tem lógica, começa às 10 e termina às 9 da manhã, não é possível se a pessoa voltar no tempo. Ou se a pessoa selecionar 10 e 10 também, também não tem lógica. A gente precisa que exista pelo menos uma diferença de 1 hora entre esses intervalos, abertura e saída. Então, 10 e 11 no mínimo, não interessa se for 10 o início, mas precisa ter pelo menos 1 hora de diferença. E aí, adivinha, nós vamos fazer mais um refinamento. O Zod é muito incrível por causa disso, a gente pode ir concatenando as coisas, como se fosse um processo, uma pipeline de verificações. E aqui, o que a gente vai fazer? Eu vou refinar o array de intervalos e aqui eu preciso retornar um true ou false. Então, eu vou fazer o seguinte, olha que legal, eu quero verificar se todos os itens do meu array cumprem com essa regra de existir pelo menos 1 hora. Ou seja, eu vou utilizar o método every, porque eu quero verificar se todos eles cumprem e não se um deles só cumpre, que daí seria o sum. Vou usar o every. E aqui dentro eu vou fazer o seguinte, eu quero verificar que o término do meu intervalo, que é o endTimeInMinutes, veja que agora eu só tenho aqui dentro, o Zod reconhece que eu só tenho aqui dentro os campos após a transformação. Por isso que ele aparece só esses novos campos. Isso é muito massa do Zod, porque se eu não tivesse esse transform ou se eu comentasse ele, olha só, quando eu volto aqui no control espaço agora, ele reconhece os campos originais antes da transformação, porque a transformação não existe mais. Cara, isso aqui é muito legal. E agora eu vou pegar o intervalo endTimeInMinutes menos 60, ou seja, se eu pegar o horário de término daquele dia específico, por exemplo, da quarta-feira, tirar 60 minutos, ou seja, uma hora atrás, isso aqui ainda precisa continuar sendo maior ou igual ao horário de início, para eu saber que existe pelo menos uma hora de diferença entre esses horários, concorda comigo? Se isso não acontecer, a gente pode, aqui no segundo parâmetro do refine, a mesma coisa que a gente fez lá em cima, colocar uma mensagem, por exemplo, o horário de término deve ser pelo menos uma hora distante do início. Salva isso aqui agora, voltamos lá dentro do Chrome e agora veja, se eu tento cadastrar 10 e 10, por exemplo, nos dois campos, dou um próximo passo, o horário de término deve ser pelo menos uma hora distante do início. Se eu troco para 11, dou um próximo passo, ele já passa e já me retorna o array. Massa demais, né? Só que ainda tem um último ponto aqui, para a gente terminar essa aula com chave de ouro, que eu acho que foi uma das aulas que mais explodiu sua cabeça nesse módulo, tenho certeza, que é o seguinte, se a gente passa o mouse aqui em cima do data, que é o que chega para a gente, está vendo que ele retorna aqui, intervals, weekday, start time in minutes, end time in minutes. Perfeito. Só que se você lembrar lá dos outros formulários que a gente criou, por exemplo, o formulário de cadastro lá na página de register, esse register form data aqui, que é o que a gente usa com a inferência do Zod, a gente usa também ele aqui no use form, porque assim ele facilita a gente, por exemplo, quando a gente for escrever os default values aqui, dar um control espaço, ele já retorna quais são os campos, ou na hora que a gente for dar o register aqui, ele já fala também quais são os campos. Se a gente não passa esse esquema aqui no use form, o React Hook Form não consegue saber nada disso. Então, se eu tentar botar aqui o use form, botando o nosso esquema e salvar, ele começou a dar erro nos intervalos. Está vendo aqui no default values? Por quê? Porque o nosso time intervals form data, o tipo dele é o tipo final do nosso esquema. Após todas as transformações, concorda comigo? Ele mostra aqui exatamente como vai ficar os nossos dados depois de todas as transformações. Ou seja, é o output, digamos assim, é a saída da nossa transformação do Zod. Só que aqui no default values, isso aqui é antes da transformação. É os dados de entrada, digamos assim. É o input, é como os dados vão ser inseridos e não como os dados vão ser retornados do Zod. Concorda comigo? Isso é muito legal porque o Zod, olha só, a gente consegue criar aqui dentro um time intervals form input, por exemplo, usando o Z.input, type off e o mesmo esquema. E esse aqui de baixo, para ficar na mesma semântica, ao invés de data, eu vou chamar de output. E aqui eu vou usar o Z.output, que ele faz a mesma coisa que o Z.infer, só que é uma forma mais semântica da gente ler que isso aqui agora vai representar os dados de entrada e isso aqui vai representar os dados de saída. Olha a diferença, quando eu passo o mouse por time intervals form output, ele tem os dados de saída, olha lá, start time in minutes, end time in minutes, ou seja, pós transformações. Quando eu passo o mouse por cima do input, ele tem os dados como eles vão entrar no nosso formulário, no Zod, que é exatamente os dados da maneira mais original, que é como a gente colocou lá no primeiro array aqui dentro. Então isso é muito massa porque agora, aqui dentro eu posso usar o input e lá embaixo, no meu Teira, eu posso usar o output. Ou seja, eu sei como que os dados vão entrar e como que os dados vão sair de dentro do Zod. Posso salvar aqui agora. Ele está dando esse errinho, mas na verdade é só porque o VSCode está meio lento aqui. Vamos ver, ele deu um errinho aqui. Time is implicit. Cara, isso é VSCode total. O VSCode eu não sei o que que é, mas eu posso, acho que, comprar um computador com 400 GB de RAM, que ele vai continuar travando. E perfeito, já está pronto. A gente volta no Chromium, dá um próximo passo. Está tudo funcionando ainda na aplicação. Claro que a gente não está cadastrando nada. Handle argument of type is not assignable to parameter of submit handler. Ah, tá. Porque ele está achando que a gente vai inserir os dados nesse formato aqui. Deixa eu verificar, porque não deveria estar assim. Ele deveria entender o output já automaticamente. Deixa eu dar uma olhadinha nisso. Bom, dando uma olhada no GitHub, pelo jeito o Zod lançou uma versão nova ontem. E, pelo jeito, essa versão nova acabou bugando. Esse funcionamento automático. Então, por enquanto, o que a gente vai fazer é só tirar aqui a tipagem do useForm. E usar somente o output aqui embaixo, e ele já vai parar de dar erro aqui embaixo. Se o meu VSCode não for lento demais. Mas é isso. Vai parar? Ou não vai parar? Parou. E não parou. Continuou dando erro. Types of parameters data and data are incompatible. Tá. A gente vai ter que fazer de outra forma aqui, então, para parar com esse erro. Por causa dessa atualização. Não sei se foi do Zod ou do ReactHookForm. Eu vou ter que investigar um pouquinho mais, abrir a issue lá. Mas para a gente resolver aqui o Zod. Investigar um pouquinho mais, abrir a issue lá. Mas para a gente resolver aqui de uma forma mais rápida. O que a gente pode fazer aqui para que esse erro pare? Nós podemos passar aqui o input. Normalmente. Pelo jeito, algum erro numa última versão mesmo da lib. O que eu fiz foi abrir uma issue aqui para ser verificado e corrigido o erro no ReactHookForm. Mas para a gente não ficar parado. E talvez até você chegar nessa aula e essa issue já tenha sido resolvida. E aí vale a pena até dar uma olhada aqui para ver se existe uma outra solução. Ou se é essa que a gente vai seguir mesmo. Mas, por enquanto, a gente vai resolver de uma maneira um pouco mais feia. Só para conseguir parar de dar erro. Porque a parte do erro aqui é ruim. Então tem duas formas de a gente resolver. A gente pode vir aqui e voltar com o nosso input. E aí, a gente poderia botar um expect de erro aqui do TypeScript. Só que eu não gosto muito. Então eu vou fazer da seguinte forma. Aqui o data eu vou trocar para N. E vou criar aqui o formData, por exemplo. Que é igual a dataS com o nosso output. Meio que forçar para o TypeScript entender que essa aqui é a tipagem. E aí para o ReactHookForm parar de dar erro aqui. Mas, com certeza, eu espero resolvendo. Porque eu não gosto muito de utilizar, nesse caso, o As aqui dentro ou o N. Mas eu vou seguir aqui qualquer coisa. Até atualizar a aula num próximo momento. Mas realmente é um bug da biblioteca. Porque eu tenho o mesmo código aqui na versão da biblioteca anterior. E está tudo funcionando. E é isso. Agora a gente já tem todos os campos aqui dentro. E a gente já pode começar a trabalhar com eles. Eu vou usar o console.log aqui no formData. Só para a gente visualizar o retorno. E estão lá os nossos intervalos que a gente já pode enviar esses dados para o back-end."
  },
  {
    "id": "f3a50ae0-3504-4f00-b064-bbd8ea361b9e",
    "title": "Persistindo intervalos",
    "transcription": "Agora que a gente aprendeu a trabalhar com a sessão do usuário server-side, ou seja, com isso a gente já consegue determinar, por exemplo, se o usuário está logado ou não para acessar alguma página, a gente pode fazer aqui dentro algo como se o usuário não tiver uma sessão, ou seja, se a gente não conseguiu recuperar uma sessão de dentro dos cookies da requisição, então a gente pode retornar uma resposta com status 401, de não autenticado, e é isso, a gente pode simplesmente dar um erro aqui dentro e isso já mostra que o usuário precisa estar autenticado. E agora a gente tem que trabalhar com os dados que vêm do body da requisição, então de dentro do rec.body virar os nossos intervalos aqui, que é o que a gente está mandando. Mesmo que a gente saiba o formato que a gente está enviando os intervalos aqui do front-end, não necessariamente eu gosto de, na camada do back-end, pegar e importar alguma tipagem daqui de dentro, por exemplo, exportar isso aqui e importar lá dentro da API do Next, porque são duas coisas que são quase que duas coisas diferentes, duas camadas que não deveriam se conversar de uma forma tão... não com esse nível de dependência, ou o server-side depender de uma informação que está no client-side aqui do formulário para saber qual é o tipo de informação que ele vai receber aqui dentro. Então, eu prefiro aqui, a gente pode ter duas formas, a gente pode simplesmente criar uma interface e definir qual é o formato dos dados que vão vir dentro do body, ou a gente pode também criar o próprio ZOD, então eu poderia criar aqui, por exemplo, um time-intervals-body-schema e usar aqui o ZOD, por exemplo, para falar que vai ter um objeto, dentro vai ter intervalos, que é um array de objetos, e cada um desses objetos aqui tem quais informações? WeekDay, StartTimeInMinutes, EndTimeInMinutes. E o WeekDay aqui é com... que é o meu case, então, WeekDay, que é um z.number, obrigatório, então não precisa colocar nada, StartTimeInMinutes também, z.number, e o EndTimeInMinutes, z.number. Aqui a gente nem vai fazer validação, necessariamente, a gente vai só aceitar os dados, o correto até seria fazer uma validação aqui, porque a gente não pode depender e garantir, por exemplo, que... a gente não pode depender de uma validação front-end, dentro do nosso server-side. Então, o mais correto seria a gente ter essas validações que a gente fez aqui no front-end também no back-end aqui dentro. Então, a gente repetir essas validações de StartTimeInMinutes aqui tem uma distância de uma hora, do EndTimeInMinutes e tudo mais, então isso aqui seria interessante a gente fazer. Mas, aqui então eu vou só simplesmente pegar esse TimeIntervalsBodySchema e realizar um parse no nosso Hack.body, e isso já vai automaticamente devolver pra gente aqui o nosso array de intervalos, e ele já vai retornar todo tipado, então o parse já retorna os dados tipados, então já traz pra gente aqui qual que é o formato dos dados. E é importante dizer que esse parse aqui ele vai disparar um erro caso o body não venha com esses formatos, então a gente não precisa se preocupar em fazer qualquer tipo de if. Caso eu quisesse que ele não disparasse um erro pra eu tratar o erro aqui embaixo, a gente teria que usar o SaveParse. O SaveParse ele faz o parse, mas ele não retorna o erro caso dê algum tipo de erro. E aí daqui de dentro do SaveParse ele vai retornar pra gente o input e o output, um erro ou um sucesso. E aí a gente vai trabalhar com esses dados aí. Mas aqui a gente vai usar o parse mesmo, porque eu quero que ele dispare um erro, porque aqui eu tô de certa forma também fazendo uma validação. E aí aqui dentro eu vou fazer um await, vou pegar o meu Prisma aqui pra eu trabalhar com o banco, .usertimeinterval que é o nome do nosso model, .create e aqui uma das coisas que eu posso ver é que o seguinte, aqui eu quero criar dentro do Prisma vários timeintervals, vários dados desse aqui. Só que infelizmente isso é uma limitação do SQLite, como a gente tá usando SQLite nesse momento, ele não suporta a gente trabalhar com um insert múltiplo. Eu acho tão bobo isso, mas o SQLite não suporta a gente fazer a inserção de vários registros no banco em uma operação só. Por isso aqui a gente não consegue usar um método do Prisma que se chama createMany, que ele criaria vários registros de uma só vez. Se você tiver a oportunidade aqui no momento que eu tô gravando essa aula, de ter um SQL, um Postgres rodando na sua máquina, eu só não vou colocar isso aqui agora, porque eu não quero ter que subir docker ambiente e ensinar docker nesse momento, ainda mais a gente tá no módulo específico da trilha de React e a maioria das pessoas às vezes tá rodando no Windows com WSL e tem bastante problema às vezes de integração com docker. Nesse caso aqui eu vou fazer a operação de uma maneira mais alternativa, mas o mais correto aqui é a gente já criar o nosso banco utilizando o MySQL aqui dentro do database, do Prisma, e aí o createMany vai funcionar sem problemas nenhum. Então se você tiver a oportunidade, sobe o MySQL, muda aqui a variável ambiente para o URL de conexão com o MySQL, deleta as migrations aqui, porque vai ter que criá-las do zero, roda o npx Prisma MigrateDef pra criar todas as migrations de novo, e pronto. A gente até vai fazer isso no final do módulo, mas é mais pra deploy do que necessariamente pra desenvolvimento. Mas o mais correto seria isso. Mas aqui como a gente não tem essa opção dentro do SQLite, a gente vai fazer de uma maneira diferente. Aqui o que eu vou fazer? Eu vou fazer um await promise.all ou seja, eu quero executar várias promises em concorrência, várias promises uma junta da outra. Por isso que eu não vou fazer um for, por exemplo, porque ele iria executar uma criação, depois que ela terminasse ia pra próxima, depois que terminasse ia pra próxima. Não, eu quero criar todos os registros ao mesmo tempo, em concorrência. E aqui dentro eu vou fazer o seguinte, eu vou pegar os meus intervalos, vou fazer um map. Então eu vou percorrer cada um dos intervalos e de dentro deles eu vou retornar prisma. usertimeInterval.create que é a nossa operação de criação enviando aqui os dados pra criar o registro. Então a gente vai ter o weekday, que vem de interval.weekday temos o nosso timeStartInMinutes que vem de interval.startTimeInMinutes o nosso timeEndInMinutes que vem de interval.endTimeInMinutes e o nosso userId que vem de dentro de session.user.id salvo aqui agora ele deu um errinho aqui embaixo session.user is possibly undefined, então vamos trabalhar com o ponto de interrogação aqui id does not exist on type name undefined email image isso aqui provavelmente é por causa da tipagem aqui que a gente vai ter que corrigir então, o que acontece a gente modificou lá no nextAuth aqui a gente modificou esse callback aqui session, adicionando o user e isso aqui o que acontece é que a gente está adicionando uma informação no retorno da sessão do nextAuth, só que internamente o nextAuth ele não eu acho que ele deveria fazer, mas ele não faz ele não lê o nosso código para saber que a gente adicionou uma informação nova aqui dentro do session então, dentro da biblioteca nas tipagens internas da biblioteca a session dele continua não tendo user ou se o user existe dentro de session, tem menos informações do que a gente retornou só tem o name, email e o image por exemplo, então o que a gente vai ter que fazer aqui dentro de arroba types nextAuth a gente vai criar uma interface chamada session e aqui dentro eu vou falar que dentro dela vai ter o objeto user que é do tipo user que é a outra interface que a gente declarou aqui em cima que tem todos os campos se eu salvo isso aqui agora e volto lá no meu time intervals, ele já para de daí e uma das coisas interessantes de entender do TypeScript que é algo que está acontecendo aqui é importante entender que quando a gente está declarando interfaces assim dentro do módulo nextAuth a gente não está substituindo a interface original, a user e a interface session, porque por padrão interfaces dentro do TypeScript ela tem um comportamento sempre de extensão, se a gente declara duas interfaces por exemplo session, elas não estão sobrescrevendo uma a outra elas reaproveitam a interface que já tem aqui em cima, pode ver que até não dá erro adicionando a nova informação aqui embaixo então quando a gente faz por exemplo interface session, a gente está estendendo a interface session que já existe dentro do nextAuth, adicionando o user lá dentro, nós não estamos substituindo a interface e é por isso que por exemplo na aula sei lá, algumas aulas atrás quando a gente criou a interface user aqui e adicionou os nossos campos o campo de email validate sei lá como era o nome daquele campo que a gente não conseguiu tirar daqui de dentro, ainda existia só que que era deixa eu até lembrar aqui pra gente não falar besteira que era aquele aqui ó, email verified aqui talvez pra eu conseguir tirar esse email verified eu teria que fazer alguma coisa tipo assim pra remover ele lá de dentro só que aí eu acho que não fica tão legal, eu vou deixar assim mesmo, não é muito um problema digamos assim agora a gente já fez então as criações consigo remover esse código e aqui embaixo no return claro que eu não vou retornar a nossa session em si eu vou retornar só um código 201 que simboliza criado com sucesso, ponto end, eu não preciso retornar informações dos dados criados no banco de dados, isso é uma misconception digamos assim um mito digamos assim de rotas de API principalmente rotas de criação isso é uma coisa legal, existe até um conceito que você já deve ter ouvido falar que é sobre CQRS que é Command Query Responsibility Segregation se não me engano que ele fala basicamente a responsabilidade de comandos e de queries quando a gente tem comandos que são operações de escrita, atualização até remoção, é legal a gente evitar retornar dados dessas chamadas e retornar dados sempre de queries sempre de operações get, operações que são feitas pra buscar dados isso aqui não necessariamente é um conceito que a gente está aplicando dentro dessa aplicação mas é algo também pra você ficar conhecendo, é algo que mudou um pouco a maneira que eu desenvolvo minhas APIs porque geralmente dentro de rotas de criação, de atualização eu evito retornar dados de dentro dessas rotas E show, agora a gente vai testar se está tudo funcionando, então voltamos aqui no Chrome já temos aqui alguns dados selecionados eu vou tirar, vou deixar apenas 2 dias da semana e na segunda-feira eu vou trocar pra 10 às 14 pra gente ter um pouquinho de modificação nisso, vou dar um próximo passo aqui dentro, ele chamou a nossa rota timeIntervals, deu 201 created, então provavelmente deu tudo certo então a gente vem aqui no VS Code agora vou abrir aqui o nosso um segundo terminal pra validar que deu tudo certo eu vou abrir o nosso banco de dados e aqui a gente pode ver que dentro de userTimeInterval já tem dois registros, representando então segunda-feira e sexta-feira, que foi o que a gente colocou lá dentro, exatamente, sexta-feira e aqui o timeStartInMinutes já está certinho, 10 horas e 8 horas da manhã, 14 horas e 18 horas, e aqui ele já tem a referência também pro usuário, o ID do usuário caso eu clique aqui no user, ele já abre qual é o usuário, no caso o único usuário que tem cadastrado na aplicação, eu então ele já guarda a referência aqui dentro e a gente consegue visualizar isso de uma maneira mais simples, e pronto, a gente terminou a nossa primeira rota que depende de autenticação que é a rota timeIntervals a gente tem mais uma parte na nossa aplicação agora pra finalizar essa etapa de cadastro que é essa parte de completar o perfil, então a biografia, avatar e aí a gente vai entrar numa parte bem massa da aplicação que é a parte de scheduling, que é a parte de calendário essa parte aqui tem muita coisa envolvida a gente vai construir esse componente de calendário do total zero, a gente vai fazer umas queries bem mais complexas aqui pro banco pra buscar disponibilidade então aqui tem bastante lógica envolvida mas vamos continuar aqui por partes terminar a nossa parte de cadastro com chave de ouro aqui, e aí depois a gente parte pro restante"
  },
  {
    "id": "f637784e-3668-46d4-8395-128b97ab3051",
    "title": "Página de atualização do perfil",
    "transcription": "Bora lá, o que a gente vai fazer nessa aula é a nossa última página aqui do processo de cadastro, que é a parte de atualização de perfil. Então, aqui dentro da pasta Register, dentro de Páginas, eu vou começar criando uma pasta chamada Update Profile. E aqui dentro eu vou criar o index.page.tx, lembrar da extensão para que ele vire uma página. Vou criar aqui o styles.cs também. E aqui dentro dos styles eu vou já deixar criado o Profile Box, que ele vai ser a caixa que vai ficar por volta de tudo. Então, eu vou importar do IgniteUI React, vou criar aqui um box também. E aqui eu vou logo adicionar alguns estilos. E eu também já vou deixar aqui pré-criado um carinha que eu vou utilizar, que é o Form Annotation. E ele também vai ser um style, porém agora text, que vem também do IgniteUI React. E aqui eu já posso deixar esse estilo pronto, porque ele é mais rapidinho. É só um grey 200 aqui na cor, que é basicamente a descrição que a gente vai ter aqui embaixo, da text area. É uma anotação, então eu já deixo criado isso aqui. Aqui no index agora, para reaproveitar, eu vou copiar o index do register, aqui dentro da pasta register, o index que tem aqui, eu vou copiar ele inteiro. Vou jogar dentro de Update Profile, e vou trocar todo lugar que tem referência para register para Update Profile. Aqui no schema também, então... Aqui no schema eu vou deletar tudo que tem aqui dentro. Vou trocar o nome de register.farm.schema para Update Profile Schema. Register.farm.data nos três lugares aqui para Update Profile Data. Aqui a gente não vai utilizar o holder, não vai usar o isAffect. Posso tirar esse setValue aqui da desestruturação. Aqui nesse handleRegister posso tirar o conteúdo inteiro, e vou trocar o nome do método para handleUpdateProfile. Deixa eu ver aqui. Deixa eu tirar esse import aqui. Algumas importações aqui eu posso remover também, que a gente não vai estar utilizando. E aqui agora, container, eu vou importar de ./.styles. Header também, que vem lá dos estilos globais da parte de registro. Então a gente está importando aqui dos estilos que estão na pasta register. Aqui no form eu vou trocar para profileBox. Aqui eu troco para handleUpdateProfile, que é o nome da nossa função. Lá embaixo onde tem form eu troco para profileBox também. E aqui, não é próximo passo, agora isso aqui vai ser finalizar, acho. Isso, finalizar. Aqui a gente não vai ter erro. Então aqui embaixo eu vou botar sobreVocê, que é para a pessoa botar a biografia. Tiro o placeholder. Troco textInput por textArea, que vem de IgniteUI React. E o register aqui vai ser view. E embaixo aqui do textArea eu vou botar o nosso formAnnotation, que a gente criou. Lá dentro, que é um text. E dentro dele eu vou copiar o texto que tem aqui no Figma. E eu só vou trocar o size dele para small. Ele importou o formAnnotation do lugar errado, deixa eu ver aqui. Ah, na verdade ele nem importou, então deixa eu importar aqui de ponto barra styles. Já está certinho. Aqui em cima tem essa outra label, nome do usuário. Eu vou tirar o conteúdo dela, porque aqui dentro a gente vai colocar o avatar. Então eu vou colocar um text aqui. E eu vou escrever foto de perfil. Acho que é o que está lá dentro do Figma, exatamente. Aqui o bio está dando erro, porque a gente não colocou ele no esquema. Então aqui eu vou colocar bio.z.string. Por enquanto não vou colocar qualquer tipo de validação. Erros a gente nem vai utilizar, porque não vai ter validação, como eu bem falei nesse formulário. Vai ser um formulário mais simples. Tiro o text.input aqui de dentro também. E pronto, nossa página está pronta. Teoricamente eu posso já acessá-la. Está aqui a minha aplicação rodando. Prisma Studio está rodando aqui na direita também, já para garantir. E eu vou abrir aqui então localhost 3000. Deixa eu fechar aqui algumas coisas que eu tenho abertas. Barra register, barra update profile, para a gente dar uma olhadinha como é que está ficando. Só que aqui a gente vai ter que atualizar um pouco dos estilos aqui dentro da página do update profile. Então aqui nessa box aqui em cima eu vou dar um margin-top 6, para distanciar ela um pouquinho do header. E aqui a gente vai fazer o seguinte, eu vou botar um flex-direction-column. Só que precisa do display flex também. E aqui eu vou pegar toda a label que tem aqui dentro e eu vou fazer o mesmo processo. Display flex e flex-direction-column. Para ela ocupar toda a largura que ela já vai dar uma line-items-stretch. Aqui em cima eu vou dar um gap 4 e aqui eu vou dar um gap 2. Esse 4 ali em cima é para distanciar um input do outro e também do botão. E esse 2 aqui é para distanciar a label do input em cima e também do annotation aqui embaixo. Show de bola. Então estruturalmente, visualmente a página está pronta. Só que a gente precisa colocar o avatar aqui em cima. Se a gente for olhar o layout do Figma, eu posso ver que ele tem esse botão de selecionar foto para a gente atualizar o avatar. Só que essa parte de atualização de avatar eu acho que ela ia ter muito conteúdo para não muitos ensinamentos. Então eu vou deixá-la de lado por enquanto para a gente não fazer atualização de avatar. Até porque o avatar já vem de dentro do Google. Geralmente essas aplicações que usam autenticação social, que são muito baseadas em autenticação social. Elas usam diretamente a foto de perfil que vem de dentro do Google. Então eu vou fazer isso. Eu vou usar direto a foto do Google. Não vou criar um input aqui de atualizar o avatar. Não é uma coisa muito complexa de fazer. O Next por si só, a própria back-end do Next funciona como qualquer outra API Node. Então a gente poderia fazer a parte de upload de avatar. Muito semelhante como a gente faria em qualquer outro serviço em Node. A única diferença é que aqui no caso do Next, a gente teria que fazer o upload da imagem para dentro de um serviço especializado em upload de arquivos. Então Amazon S3, Google Cloud Storage, algum serviço assim. Não é legal a gente fazer upload de imagem ou upload de qualquer outro arquivo e armazenar dentro do banco de dados. Ou armazenar nos arquivos físicos aqui, porque os arquivos físicos nas aplicações modernas devem ser stateless. A gente não deve armazenar qualquer tipo de arquivo físico que a gente pretende manter na nossa aplicação por muito tempo. Isso é errado. Só arquivos temporários. Então show de bola. Agora que a gente já preparou, vamos começar mostrando o avatar do usuário logado. Para eu garantir que eu estou logado, eu não lembro porque eu acho que eu limpei o cache da minha aplicação. Deixa eu garantir aqui em cookies. NextAuthSessionToken, então aqui tem um cookie de autenticação. Então quer dizer que eu estou logado. Para eu obter informações do usuário logado, eu tenho que fazer basicamente um const session. É igual a use session aqui dentro da nossa aplicação. E aqui eu vou dar um console.log session para a gente visualizar. Eu dei um voltar aqui. O que eu fiz? Eu vou dar um console.log session aqui para a gente visualizar o que está sendo exibido. Então eu vou dar um F5 e olha só. Ele trouxe aqui data, status, authenticated. E aqui dentro tem o user, tem todas as informações do usuário. Só que eu queria que você parasse para prestar atenção aqui em um ponto que é super importante. Você está vendo que teve em algum momento aqui esse console.log que eu coloquei. E aqui tudo bem ele mostrar várias vezes. Isso não é um problema porque ele mostra várias vezes. Porque como a gente tem vários hooks aqui dentro, esses hooks fazem operações que muitas vezes levam a novas renderizações desse componente. Então por isso que ele dá o console.log de novo. É normal isso acontecer no React. E não necessariamente isso é um problema de performance. Não necessariamente porque um componente renderiza várias vezes, ele está sendo lento ou qualquer coisa assim. Isso não é verdade. Se tiver algum cálculo muito pesado aqui dentro, aí sim a gente parte para fazer algum tipo de memoização, use memo, use callback, por aí vai. Mas não é o caso aqui. Mas o ponto que eu quero te mostrar aqui desse use session, se você for perceber, é que no primeiro console.log que ele deu aqui, ele trouxe um data undefined status loading. O que isso quer dizer? No primeiro momento que ele foi buscar a sessão do usuário logado, as informações do usuário logado, essa informação não está disponível em tempo real. Porque se a gente for ver aqui dentro de application, dentro de cookies, a única informação que a gente tem aqui do usuário é um token de sessão. Mas não necessariamente isso aqui traz para a gente informações do usuário. Eu não tenho nome, e-mail e ID do usuário armazenados aqui dentro dos cookies. Eles não ficam armazenados aqui dentro. Eles estão armazenados lá na nossa sessão, porém lá pelo lado do server side do Next. Ou seja, quem sabe as informações do meu usuário, é a parte back-end do Next em si, porque ela consegue buscar do banco de dados. Mas o front-end, para ele conseguir saber informações do usuário, ele precisa ir lá no back-end e falar, me devolve aí as informações do usuário. Ou seja, se a gente for aqui na aba Networks, dar um F5 aqui na nossa página, a gente vai ver que em algum momento, deixa eu trocar aqui para fetch.xhr, ele faz uma requisição session, está vendo? Então, o que acontece? O Next, por baixo dos panos, está fazendo uma requisição do front-end do Next para o back-end do Next, para o server side do Next, buscando e falando, olha, me retorna as informações do usuário logado. E aí, como ele está enviando o token, aqui do next-auth-session-token, o back-end devolve para ele os dados do usuário logado. Só que isso aqui demora um pouquinho para executar. A gente até pode ver aqui, demorou, claro, porque a gente está em local, então, demorou, sei lá, 20 milissegundos, eu não consigo ver diretamente aqui dentro, mas se eu der um zoom aqui, eu conseguiria ver. Ah, em timing aqui, eu consigo. Ela demorou ali, 12 milissegundos para retornar. Mas, claro, isso aqui a gente está em local, então, é super rápido, porém, mesmo assim, existe um certo delay de momento, digamos assim, em que a sessão do usuário ainda não está disponível dentro do client-side da minha aplicação. Ela sempre precisa ser carregada assincronamente, digamos assim, para a gente obter os dados do usuário da maneira mais atualizada possível. E aí é o ponto que eu estou querendo entrar em você. Será que tem alguma forma no next, usando o next-auth, do primeiro momento que a gente quiser buscar a sessão do usuário, essa sessão já estar disponível para a gente desde a primeira chamada e não precisar fazer qualquer tipo de estado de loading? Sim. E é isso que eu queria te mostrar exatamente nesta aula, antes da gente continuar fazendo qualquer regra de lógica ou qualquer coisa assim dentro desta página. E para isso, a gente vai ter que utilizar a função getServerSideProps do next. Então, deixa eu pegar aqui o tipo do TypeScript. getServerSideProps. Aqui precisa ser um async. Aqui ele recebe o contexto, se eu quiser desestruturar esse contexto e pegar o REC e o REST separados, aqui eu posso pegar. E aqui ele precisa devolver propriedades, que são as propriedades para a gente prepopular o nosso componente aqui com algumas informações. E aí o ponto aqui que é muito legal, que se a gente for parar para pensar, eu não sei se em algum momento você já utilizou o next-auth na sua vida, mas se a gente entrar lá dentro do nosso app, a gente vai ver aqui dentro, quando a gente fez a instalação do next-auth, que a gente importou esse carinha aqui, o SessionProvider, next-auth-react, está vendo? E a gente envolveu toda a nossa aplicação nesse SessionProvider. E nesse SessionProvider, a gente pode ver que a gente passa para ele uma propriedade Session. E essa Session vem de dentro de PageProps. PageProps é tudo o que a gente retorna de dentro do nosso GetServerSideProps. Só que por padrão, em todas as páginas, esse Session aqui está undefined, ele não foi carregado. Porque em nenhuma página eu tenho GetServerSideProps até o momento na minha aplicação. Ou seja, em nenhuma página eu tenho GetServerSideProps retornando o Session. Por isso que aqui no app, o Session sempre está undefined. E é por isso que aqui no Chrome, num primeiro momento, a Session vem carregada com Undefined. Porque em nenhum momento eu já estou dando um valor pré-definido para ela, não estou fazendo o carregamento dela. E assim, o NextAuth carrega a Session somente no momento que eu uso um UseSession. Ou seja, somente no momento que eu preciso dessa informação. Só que se a gente retornar daqui de dentro do GetServerSideProps alguma informação para a propriedade Session, e deixa eu ver se eu consigo fazer só um exemplo aqui, botar tipo Oi, teste. Deixa eu ver se isso aqui vai funcionar, eu não tenho certeza. Mas se eu retornar um Session dali de dentro e der um console.log agora aqui na minha Session, não sei se o Next vai permitir. Olha só, ele retornou dentro já do primeiro carregamento aqui da Sessão, Oi, teste. E é claro que depois ele vem e carrega as informações corretas, mas só que num primeiro momento ele não vem mais com Undefined. Então, se eu for parar para pensar, lembra que lá dentro da nossa rota de API, no TimeIntervals, eu usei aqui uma função para carregar a Sessão do usuário. Como essa função aqui é ServerSide, e dentro aqui do UpdateProfile, o que eu boto aqui dentro do GetServerSideProps também é ServerSide, ou seja, código BackEnd, código Node, eu posso usar essa função de carregar a Session também aqui dentro. Então eu importo aqui o UnstableGetServerSideSession, importo o BuildNextAuthOptions, e aqui no Session eu posso simplesmente retornar. Só que aí começou a dar erro aqui dentro. Por quê? Porque o BuildNextAuthOptions, a gente fala que o REC e REST que ele recebe aqui, eles são do tipo NextAPIRequest e NextAPIResponse. Só que o REC e o REST, aqui de dentro do GetServerSideProps, eles não têm a mesma tipagem. Apesar de eles terem sim os cookies lá dentro, que é o que a gente precisa aqui dentro, porque a gente usa lá no Prisma Adapter para pegar os cookies. Apesar dos cookies existirem aqui dentro também desse REC e desse REST, posso até fazer REC.cookies, por exemplo, algumas informações não são iguais entre esses dois objetos. Então o que eu preciso fazer? Aqui no BuildNextAuthOptions eu preciso falar que esse REC é do tipo NextAPIRequest ou NextPageContext REC. O REC que está dentro do NextPageContext. Esse carinha aqui dentro é o context. Se eu passo o mouse por cima dele, ele é do tipo GetServerSidePropsContext, mas que no fim das contas é o NextPageContext. Ele só estende aqui e tudo mais, mas não tem problema a gente entrar tão fundo aqui. Se eu volto aqui no NextAuth, agora no REST eu vou fazer a mesma coisa. NextPageContext, porém REST. E agora eu preciso fazer esse mesmo processo lá dentro do Prisma Adapter. Então a gente vai só colar aqui e importar o NextPageContext aqui dentro e a gente vai ver que todo o resto volta a funcionar sem problemas nenhum. Agora eu salvo. Vou continuar com o meu console logo aqui dentro. Venho na página do F5 e olha só, a gente tem desde o primeiro carregamento as informações do usuário já pré-definidas aqui. Ou seja, a gente não precisa se preocupar com em algum momento a gente ter algum tipo de estado de loading na tela para carregar os dados do usuário, porque esses dados do usuário já vão vir carregados no primeiro momento que essa página for carregada por causa do GetServerSideProps. E agora sim a gente pode continuar, mostrar o avatar aqui dentro e finalizar a atualização do perfil do usuário. Bora lá!"
  },
  {
    "id": "167836d7-8a05-45d1-9dc8-a16a2012f3cc",
    "title": "Página de agendamento",
    "transcription": "Bora lá, então. A gente vai continuar nossa aplicação agora. E a gente vai começar pela parte de criar a página de agendamento aqui dentro. Se a gente for olhar no Figma, é esta página aqui. Então, a gente vai começar criando basicamente o perfil aqui. Esse tooltip que tem aqui, toast, isso aqui é do desafio. Não tem nada a ver com o layout da aplicação em si. A gente não vai implementar isso, mas a gente vai implementar o calendário e esse cabeçalho aqui. Então, eu vou começar criando, primeiramente, antes de mais nada, a nossa página do schedule. Então, eu vou começar criando aqui uma folder chamada schedule, porque a nossa rota começa com o schedule. E aqui dentro a gente vai ter várias páginas. Várias não, na verdade. É uma só, mas a gente vai ter toda a estrutura de componentes e tal na parte de agendamento. O que eu gosto de fazer nesses casos, por exemplo, o schedule é parametrizado. Então, schedule e aí DiegoSF, que vai ser o username. O que eu gosto de fazer aqui é criar uma pasta com o parâmetro do next, por exemplo, username, que eu vou receber o usuário. E dentro dela eu crio o index.page.tsx, ao invés de criar já diretamente, por exemplo, dessa forma assim. Porque mais pra frente, se eu tiver mais páginas, mais pra frente, tipo a Diego, barra, alguma coisa, eu não preciso mudar a minha estrutura. Então, sempre que eu tenho parametrizado assim, se puder botar em pasta, fica melhor. E vou criar aqui também o styles.ts. No styles, já pra deixar semi-pronto, eu vou criar um container, que ele é styled div. E eu vou criar aqui um user header, que é a parte onde vai ficar os dados do usuário aqui em cima. Então, pra simbolizar os dados do usuário. A gente não vai ter mais muita coisa. E aí aqui agora, deixa eu pegar minha colinha aqui pra não me atrapalhar. A gente vai ter a nossa página. Então, export the full function schedule. E aqui eu vou retornar basicamente o nosso container, que vem dos estilos aqui. O nosso user header. Dentro do user header eu vou ter os dados do usuário, de avatar e tudo mais, aqui o texto. Por enquanto eu vou botar só algo fictício, então eu vou botar aqui o endereço do github mesmo. Então, github.com barra diego3g.png. Ele vai baixar a minha imagem. Vou colocar aqui um heading, também lá do IgniteEY React, com o meu nome, Diego Fernandes. E um text, também do IgniteEY React. Só pra mostrar alguma coisa em tela. E logo a gente dá uma estilizada nisso aqui. E aí aqui embaixo eu vou ter o meu calendário, que logo eu vou começar a criar. Mas antes disso, vamos terminar aqui de fazer a estilização base da nossa página. Então aqui eu vou botar um MaxWidth de 852. Esse 852 representa o calendário aberto, então esse aqui é o MaxWidth. Ele é um pouquinho maior que o 820 porque ele tem um padding na direita e na esquerda, de 16. Então dá 32, 820 mais 32, 852. Então eu já vou até colocar esse padding aqui. Então 0 e 4, que é 16. E dá 32 no total. A imagem eu vou botar 80 em cima, alto nas laterais pra centralizar. E 4 aqui embaixo só pra, caso a tela fique um pouquinho menor, ele não fique grudado embaixo. É isso por enquanto. E aqui no UserHeader a gente vai dar um display. Flex, FlexDirectionColumn, AlignItemsCenter. E aqui eu vou fazer mais ou menos algo que a gente já tinha feito em outra página, que era estilizar somente o heading que tá aqui dentro. E a gente vai fazer isso com o text também. Só que tem que importar do IgniteUI React. E aqui dentro a gente vai dar um LineHeight Base no heading. Por padrão ele tem um LineHeight um pouquinho maior. Porque cabeçalhos geralmente a gente aumenta um pouquinho o LineHeight. E aqui um MarginTop, 8 pra distanciar ali do avatar. E o text aqui a gente vai botar só um ColorGray a 200. Volta aqui e pronto. Já tá aqui o nosso cabeçalho, tudo certinho. E aí a gente tem que começar com o nosso formulário. Mas antes disso, essa página aqui de Schedule, isso aqui é o caso perfeito pra gente ter uma página estática dentro do Next, se a gente for parar pra pensar. Porque tirando os dias aqui que a gente vai calcular de forma dinâmica, quais dias estão disponíveis ou não, essas informações aqui em cima, por exemplo o avatar, o nome, a descrição, são informações que não faz tanto sentido a gente carregar elas do total zero toda vez que essa página inicializa. Porque são informações difíceis de mudar. E uma página estática vai trazer muito mais performance pra essa página aqui, que é um ponto de entrada principal da nossa aplicação. Então aqui eu quero desde já aplicar um comportamento de página estática aqui dentro. Então olha só, a gente vai fazer um export const getStaticProps aqui dentro. Importar o getStaticProps aqui do Next. E essa página aqui ela precisa retornar props. Que são as props aqui estáticas que a gente vai ter. E aí o que acontece? A gente recebe o username aqui como parâmetro. Então eu vou pegar ele através de username, string, rec. Opa, o rec precisa vir daqui de dentro. Na verdade eu não preciso pegar, não é rec né, porque as páginas estáticas não tem rec e res. Eu não tenho isso porque as páginas estáticas não são criadas em tempo de execução na nossa aplicação. Elas são criadas no momento da build, ou pelo menos a primeira versão delas. Então no momento da build não existe uma requisição. Então eu não tenho como buscar, por exemplo, parâmetros da requisição. Eu tenho que usar esse parms aqui específico do getStaticProps. E aí de dentro deles eu vou pegar o parms.username, que é o meu nome de usuário que está vindo daqui de cima. Aqui ele está dando um rinho, parms is possibly undefined. Então vou só botar um ponto de interrogação, porque é só a maneira que o Next tem tipado esse parms. Não necessariamente isso é o que vai acontecer. E aí o getStaticProps, uma das coisas que é importante a gente entender, é que ele sempre vai ser executado no lado do servidor. Ou pelo menos da maneira que a gente vai configurar ele aqui. E como ele sempre vai executar do lado do servidor, a gente pode trabalhar aqui dentro dele como se a gente estivesse no back-end. A gente vai estar no back-end. Eu posso fazer qualquer tipo de query no banco de dados, acessar dados sensíveis e tudo isso. Por isso eu posso buscar as informações do usuário a partir do username, que é o que está aqui na URL, diretamente fazendo uma chamada no banco. Então eu posso pegar o prisma.user.findUnique, por exemplo, e username é igual o username que eu recebi aqui em cima. E aí eu posso fazer o seguinte. Caso não tenha encontrado nenhum usuário, eu posso retornar daqui de dentro. Ele até traz pra gente esse notFound, que é o 404. Então ele vai dar erro 404, ele vai mostrar a página de 404 do Next, que inclusive também é customizável. Basta você criar um arquivo aqui de 404 dentro da pasta Pages. Caso ele encontre o usuário, aí o que a gente vai fazer? Eu vou retornar dentro de props.user. E aqui dentro eu vou mandar o nome do usuário, que é o que a gente precisa ali. A gente precisa da bio do usuário e da imagem de avatar. Então avatar.url eu vou mandar com camelCase nesse caso aqui, que é user.avatar.url que vem lá de dentro do banco de dados. E agora aqui dentro a gente pode criar um schedule.props falando que eu recebo o user aqui dentro. Tenho o nome que é uma string, bio que é uma string e avatar.url que é uma string. Obtenho dados dessas props aqui dentro, name, bio e avatar.url e mostro elas em tela. Avatar.url, vou botar um texto alternativo aqui também. Na verdade o texto alternativo aqui não é necessário, porque como já tem o nome embaixo, ele já vai conseguir identificar. Schedule.props, claro, isso aqui é user e aí aqui dentro é user. Porque a gente está enviando essas informações lá dentro, elas estão dentro de um objeto user. Salvo aqui agora, volto no F5 agora. GetStaticPathsIsRequired, isso aqui é um errinho, por quê? Porque como o username aqui não é fixo, ele é parametrizado, ele é dinâmico, ou seja, a gente precisa gerar uma página estática por usuário, a gente precisa obrigatoriamente informar no next o método getStaticPaths, que ele simboliza, ele diz para o next quais são os usuários que a gente quer gerar páginas estáticas no momento da build da nossa aplicação. Aqui eu acabei esquecendo de uma outra coisa importante, que é quando a gente cria uma página estática, além das props retornadas aqui embaixo, eu preciso retornar também o revalidate. O revalidate é um número em segundos que indica de quanto em quanto tempo eu quero que essa página seja recriada após o primeiro acesso, que ela seja gerada novamente. Porque não dá para deixar infinito aqui, daria, mas não é legal, porque se em algum momento as informações aqui do usuário mudarem, avatar, imagem, a gente quer que essa página em algum momento ela se atualize. Então aqui eu posso botar, por exemplo, 60 para simbolizar 1 minuto, vezes 60 para simbolizar 1 hora, vezes 24 para simbolizar 1 dia, por exemplo, e aí eu só boto aqui em comentário 1 dia, ou seja, essa página vai atualizar 1 vez por dia somente, e não mais do que isso. E aí, aqui, voltando para o getSettingPaths, o que acontece é, quando a gente tem uma página no Next que ela é estática e ela tem um parâmetro que é dinâmico, por exemplo, username, que vem da URL, a gente obrigatoriamente precisa criar esse método, porque a gente já viu isso anteriormente, que quando eu rodo yarn build ou npm run build, dependendo do gerenciador de pacotes que você está utilizando, a build aqui do Next, ele vai automaticamente gerar todas as páginas estáticas no momento da build. E no momento da build, ele não sabe qual é o parâmetro username aqui para gerar as páginas estáticas. Então, eu preciso ter o getSettingPaths aqui dentro, que fala quais são os usernames, quais são os parâmetros aqui dentro, que eu quero gerar de forma estática já desde o primeiro momento da build do Next. E aqui nesse caso, eu vou simplesmente retornar paths como sendo vazio, um array vazio, para ele não gerar nenhuma página estática no momento já da build. Gerar conforme os usuários forem acessando essas páginas. Ou seja, só quando alguém acessar a página, é que ele vai gerar ela de forma estática. Porque aqui, pensa, pode ter um milhão de usuários cadastrados, não tem uma forma fácil de eu conseguir determinar quais são os usuários que faz sentido eu gerar a página estática já no momento da build. Então, eu boto paths vazio e uso aqui um fallback como blocking, porque ele vai simplesmente, quando o usuário tentar acessar uma página que ela ainda não foi gerada de forma estática, ele vai buscar os dados no banco, vai gerar a página estática tudo pelo lado do server-side do Next, e quando estiver pronto, vai mostrar para o usuário. É isso que o fallback blocking faz, mas a gente já falou sobre isso em outros momentos. Vamos voltar aqui, F5 no Google Chrome já está lá. Diego Fernandes citou Rocketseat 2, que é a build que a gente tinha colocado. E prontinho, agora a gente já pode prosseguir construindo o nosso calendário e continuando aqui a nossa página."
  },
  {
    "id": "2afd168b-0258-4ba6-9062-87719541cd2b",
    "title": "Estrutura visual do calendário",
    "transcription": "Nessa aula a gente vai criar a estrutura base, visual, desse nosso calendário. E é importante a gente entender que essa parte aqui de schedule, de agendamento, ela é semelhante, digamos, à parte de cadastro porque ela é feita em etapas também. Tipo, a primeira pessoa seleciona o dia, daí aparece esse box para ela selecionar o horário, depois que ela selecionou o horário aparece um form para ela colocar mais informações. A diferença é que eu não vou criar isso aqui em três rotas diferentes, até porque para aparecer essa caixa de horários aqui é só aparecer um componente a mais. Então, eu vou fazer, digamos, isso aqui tudo vai ser a mesma página, só vai exibir coisas diferentes em tela se a pessoa já selecionou alguma coisa ou não. Entende? Então, o que eu vou fazer? Eu vou criar aqui dentro de username uma pastinha chamada schedule form, que vai ter as etapas, digamos assim. E aí dentro do schedule form eu vou ter duas etapas. A calendar step e a confirm step. A calendar é quando o calendário está em tela. Então, isso aqui ou isso aqui, as duas fazem parte do calendar step, que é o passo do calendário. E isso aqui é a confirm step, que é quando está a confirmação em tela. E por que eu não vou criar isso aqui em páginas diferentes? Eu acho que é importante dizer isso. Porque aqui em cima, cada página, cada parte do cadastro, ele já ia adicionando um banco de dados, ele já ia fazendo, digamos, um progresso. Aqui embaixo não tem como, porque a pessoa seleciona um dia, eu não tenho como criar já alguma coisa no banco de dados para reaproveitar, enviar. Eu teria que enviar na URL e tal. Então, eu acho que eu vou criar tudo o mesmo componente que fica mais fácil. O processo aqui é um pouquinho mais rápido, da pessoa selecionar data, horário e já aparecer o formulário. Por isso que eu vou tomar essa decisão aqui. Aqui no schedule form, então, eu vou criar um index.tsx, vou criar aqui um export function, schedule form. Mais para frente aqui eu vou ter um tanto de verificações, mas, por enquanto, a única coisa que eu vou fazer aqui dentro dele é retornar o próprio calendar step, que é o que a gente vai trabalhar agora. Então, aqui no calendar step, export function, calendar step. Vou dar um return aqui div, só para a gente... Dúvida? Div, não. Div, aqui no schedule form. Então, agora eu retorno aqui de dentro, calendar step. E aqui na nossa página, abaixo aqui do user header, eu vou colocar o nosso calendar, ou melhor, nosso schedule form. Mais para frente eu vou dar um pouco de estilizado nele. E aí aqui no calendar step é onde vai ficar o nosso calendário em cima. E aqui vamos começar trabalhando nessa estrutura por volta. Então, mostra o mês, o ano. A gente vai trabalhar em praticamente tudo aqui. Só que, antes da gente trabalhar isso, a gente precisa criar o container que vai centralizar esse intelo, essa box aqui. Então, vamos começar a fazer isso. Então, aqui no calendar step eu vou criar um styles.ts, export, const, container, styles, que vem de ignite.yreact, box, que também vem de ignite.yreact. E aqui no calendar step, então eu vou botar um lugar nessa div, o nosso container. Salva, voltamos aqui. E agora aqui eu vou começar colocando margem 6 em cima, alto, 0, padding 0, porque eu quero tirar o padding padrão, que já vem na caixa. Mais para frente a gente vai ver. Basicamente eu quero tirar o padding porque depois eu vou abrir essa lateral aqui para a direita. E aí essa bordinha aqui, ela ocupa até em cima, então não posso ter o padding. Está vendo essa linha branca aqui? Então, por isso que eu estou tirando o padding e depois eu trabalho com o padding de forma separada. Aqui eu vou botar um display grid. O display grid vai me ajudar aqui a conseguir alinhar os elementos em tela. Aqui, position relative. Por enquanto é isso, eu não vou colocar mais muita coisa aqui dentro do calendar step. E aqui dentro eu vou ter o nosso calendário em si. O nosso calendário, que é esse componente aqui, especificamente essa parte aqui, isso aqui é o nosso calendário, isso aqui vai ser a parte depois que eu vou criar. Mas esse calendário aqui, eu estava pensando até, eu vou criar como um componente separado, aqui do próprio calendar step, vou criar aqui dentro do src, como um componente global, algo maior do que simplesmente um componente diretamente. Porque esse componente aqui ficou bem massa, e a gente vai construir um componente bem completo. E ele é um componente que com certeza daria para virar uma biblioteca no futuro. Então, por isso que eu vou criar ele separado, porque ficou muito legal a forma que ele vai ficar no futuro construído. E aí esse componente aqui, já deixa eu pegar aqui um pouquinho da estrutura, a gente vai criar aqui também um export function calendar. Aqui nos estilos, eu já vou deixar previamente criados alguns estilos aqui. Por enquanto, calendar container. Esse calendar container aqui eu vou criar como uma div mesmo. Aqui a gente vai ter também o nosso calendar header, que eu também vou criar como uma div. O header vai ser esse carinha aqui, setembro 2022 e os botões ali na direita. Então dentro dele eu vou ter o calendar title, que é o setembro 2022, ele vai reaproveitar o text que eu já tenho lá do design system. E eu vou ter o calendar actions, que é os botões lá da direita. Logo eu vou estilizar todos eles, só estou deixando meio que a estrutura pronta. Aí eu vou ter o meu calendar body, que ele vai ser uma table, que é os dias da semana. Então eu criei table porque isso aqui dá pra ver claramente que é uma table, então é até mais fácil alinhar as coisas quando eu estou com um formato de table aqui, quando realmente parece uma tabela. E é isso, o último que eu vou estilizar aqui, eu vou criar o calendar day. O calendar day é cada um dos dias aqui dentro, só que ele não vai ser a td da table em si, porque ele precisa ser clicável, então eu vou colocar ele dentro da td, dentro de cada célula da tabela, e ele vai ser um button, porque o usuário precisa clicar nele, pra selecionar aquele dia. Pronto, todos os componentes aqui estão criados, e aí a gente vai criar mais ou menos a estrutura visual aqui do nosso calendário. Então return, então ela vai ficar calendar container por volta de tudo, dentro de calendar container eu vou ter o nosso calendar header, dentro eu vou ter o nosso calendar title, no calendar title a gente vai ter exatamente isso aqui, setembro e 2022, então eu vou escrever aqui, a gente já está em dezembro, então dezembro, e vou botar dentro do expo 2022, só pra gente depois colocar uma estilização diferente entre um e o outro. Aqui eu vou ter as minhas calendar actions, e aqui eu vou colocar dois botões, não preciso ter qualquer tipo de funcionamento deles por enquanto, e aí eu vou usar os ícones caret left do Phosphor, e o caret right, que são aquelas flechinhas menores. Beleza, depois do calendar header a gente já vai pro nosso calendar body, e aqui no calendar body é uma tabela, temos que lembrar disso. Então aqui eu vou botar um thead, que vai ser os dias da semana, aqui vai ter um tr, e cada th aqui representando um dia da semana. Deixa eu fechar o calendário aqui, pronto. Agora eu vou ter domingo, segunda, terça, quarta, quinta, sexta, sábado. Aqui talvez até pros dias da semana seria bom a gente reaproveitar aquele carinha que a gente já tinha criado. Aquele carinha que a gente já tinha criado em utils, aqui é o getWeekDays. Então a gente poderia reaproveitar esse carinha aqui. Vou até criar uma função separada aqui, ou talvez a gente poderia receber uma opção aqui. Olha que legal, a gente poderia criar aqui o getWeekDays.parms, aí a gente poderia ter um tipo short, que é um booleano, aí a gente poderia receber esse parâmetro aqui, short, padrão dele é falso. E aí aqui eu faria o seguinte, aqui dentro eu faria o seguinte, se short, vou retornar de uma forma, se não eu retorno o que eu já tinha. Se for short eu vou retornar weekDay.substring03.toUpperCase. Então se for short eu vou retornar os três primeiros caracteres do dia da semana, e aí em toUpperCase. Isso aqui, teoricamente, agora vai me retornar todos os dias da semana, então deixa eu até testar isso aqui. shortWeekDays é igual a getWeekDays, passando short como true. E aí aqui eu posso fazer um shortWeekDays.mapWeekDay, e aqui eu mostro o nosso th, a gente passa uma key para ele, pode ser o próprio weekDay, e dentro weekDay. Deixa eu tirar tudo isso aqui. E faltou um ponto no final aqui, que a gente tem ali. Salvo, volto no Chrome. Não tem nada em tela ainda, porque lá no meu calendar.step eu não importei o calendário aqui dentro do container, que é o componente que a gente está criando ali. Então calendar, que vem lá de components, salvo, show. Domingo, segunda, terça, quarta, quinta, sexta e sábado. Ficou legal, cara. Volto aqui, então agora a gente vai criar o nosso thBody, que é o conteúdo aqui do calendário. E aí aqui eu não vou criar inteiro, mas cada linha aqui vai ser uma linha de dias. Então se a gente for ver aqui, cada tr vai ser uma linha de possíveis dias, só que depois a gente vai ter que calcular certinho, porque aqui começa na quinta-feira e tal, vai ter que ter uns cálculos bem completos aqui, vai ficar bem legal. Mas aqui só para a gente exemplificar, eu vou criar, por exemplo, tem que ter sete tds, então representando cada dia da semana ali, só que pode ser que alguns deles estejam vazios, como são por exemplo aqui, vou até mostrar esse próprio calendário. Então por exemplo, se ele estiver vazio aqui, ele tem que, bom, ele não vai ter conteúdo nenhum. Deixa eu até ver como é que eu fiz isso aqui certinho para eu validar. Bom, por enquanto eu vou deixar vazio, mas mais para frente, por exemplo aqui, eu vou botar o calendar day, que é aquele nosso botão, e dentro vai ter o dia. Então 1, por exemplo, nesse aqui 2, nesse aqui 3, e por enquanto é isso. Voltamos aqui, está ali, 1, 2 e 3, na quinta, sexta e sábado. Eu meio que simulei a primeira linha aqui. Eu não vou criar todas, porque vai dar muito trabalho. Mas agora a gente tem que estilizar isso, e temos que também depois criar essa lista aqui na direita. Então bora continuar, porque por enquanto é a parte visual, mas quando chegar na parte de funcionamento aqui do calendário vai ser bem interessante, porque aqui a gente vai fazer tudo rima."
  },
  {
    "id": "ba447f90-2259-49c2-841d-b63dfabf9d72",
    "title": "Página de confirmação",
    "transcription": "Para a gente ficar totalmente livre de CSS daqui para frente, eu vou finalizar a última página da aplicação, que é a página de confirmação, essa aqui. E aí, depois, como eu falei, a gente está mais livre para focar nas funcionalidades. A gente tinha criado aqui no VS Code a parte de Confirm Step e Calendar Step. Então, aqui dentro do Schedule Form, que é o nosso componente que determina qual dos dois vai mostrar. Por enquanto, a gente está mostrando direto o Calendar Step, porque a gente não tem qualquer tipo de if aqui dentro, mais para frente, a gente vai ter que criar. Mas o que eu vou fazer aqui é, na nossa Confirm Step, já começar criando o nosso componente. Então, eu vou começar criando o index.tsx mesmo, não é uma página diretamente, ele é utilizado dentro de outra página. Export Function, Confirm Step. E aí, aqui dentro, a gente vai ter a nossa div, sei lá o que mais a gente vai ter aqui dentro. E aí, aqui no lugar do Calendar Step, eu vou mostrar agora o nosso Confirm Step ao invés do Calendário. Vou comentar aqui o Calendar Step por enquanto, porque a gente não tem o if. E aí, no Confirm Step aqui, a gente vai começar a trabalhar agora na parte visual e na estruturação. Isso aqui vai ser um formulário, como qualquer outro que a gente tenha aqui dentro. Pera aí, que está dando um chiaço aqui no meu ouvido. Eu vou começar trabalhando, então, em alguns componentes. Então, eu vou criar aqui o Estilos. E aí, eu vou deixar alguns estilos pré-criados. Então, a gente vai ter... Vou criar aqui Form. Vou chamar de Confirm Form. É igual a Styled. Vou usar o Box mesmo. A gente vai ter também Form Header. Aqui eu vou usar Style Div, que vai ser o header que vai ficar aqui, as nossas... isso aqui, o horário e tudo mais. Eu vou ter Form Error, que é um Styled Text. Ignite UI React. E Form Actions, que vai ser uma div. Voltamos para a nossa página. A gente vai botar aqui o nosso Confirm Form. S Form, porque ele é uma box, por padrão, ele é uma div, então, tem que trocar isso aqui. Aqui dentro, eu vou ter uma Function, Handle, Confirm, Confirm Scheduling, por exemplo. E aí, aqui no On Submit, a gente vai chamar essa função. Depois, eu vou botar o Use Form aqui, então, tem bastante coisa. Aqui, a gente vai ter o nosso Form Header. E dentro, eu vou ter basicamente dois textos. Os textos, eu tenho que importar do Ignite UI React, que tem que cuidar para importar certinho. E aqui, a gente vai botar dois ícones, o Calendar Blank, no primeiro texto. E aí, vai estar escrito aqui, eu vou botar essa data aqui. E eu vou ter mais um texto embaixo. E o ícone vai ser o Clock, que também vem do Phosphor React, já importou. E vai ser o horário, por exemplo, 18 horas. Abaixo do Form Header, a gente vai ter a nossa Label, com cada um dos campos. Então, a primeira Label aqui, vou botar o texto aqui dentro dela, vai ser NomeCompleto. E aí, se eu lembrar lá do Register, eu estou trabalhando com os textos com tamanho menor, SizeSmall. TextInput, que importa do Ignite UI React, Placeholder, seu nome. Aqui depois vai ter os Register, FormError também. Aqui tem mais uma Label, que é para o endereço de e-mail. Então, vou copiar isso aqui. Endereço de e-mail. Tá. Desculpa. E por último, Observações. Isso aqui vai junto no Invite. TextArea. E aqui, Placeholder. Não precisa, não tem. E aqui por último, a gente vai botar o nosso FormActions, que a gente importa lá dos estilos também. Porque aqui dentro eu vou ter dois botões. Então, o importante de Ignite UI React, o primeiro escrito cancelar, e o segundo, confirmar. Esse segundo aqui, ele vai ser do tipo Submit. E esse aqui de cima, ele vai ser do tipo Button mesmo, para não ter ação de Submit. E ele vai usar a Variant do nosso Design System, Tertiary. E aí, se eu salvar, vou botar aqui no Chrome. Perfeito, está aqui o nosso TextArea. Só que ainda, visualmente, ele não está muito legal. Então, vamos lá. Confirm Form, a gente vai botar aqui MaxWidth 540, Margin 6, Alt 0, Display Flex, Flex Direction, Column, Gap 4. E aí, para cada Label ali dentro, a mesma coisa, Display Flex, Flex Direction, e Gap, só que o Gap é um pouquinho menor. Perfeito, já dá para ver que está quase legal. No Form Header, Display Flex também, para ficar um do lado do outro. E aqui o Align Items, Center, e Gap 4. E agora, a gente vai botar também um Padding Bottom 6, Margin Bottom 2, e Border Bottom 1px, Solid Gray 600, para dar essa borda aqui, entre o Header e o restante aqui. E aí, eu vou fazer o seguinte, vou pegar os Texts que existem dentro do Form Header, e vou dar um Display Flex, Align Items, Center neles também, para o Equalizer. Align Items, Center neles também, para o ícone e o texto ficarem alinhados. Um Gap 2 para distanciar o ícone do texto. E aqui, no ícone, eu vou trocar a cor deles para Gray 200, e posso até modificar o tamanho deles aqui um pouquinho. Show de bola, fica um pouquinho maior. Legal. Então, acabamos aqui, o formulário está ok, só falta aqui embaixo. O erro aqui, eu posso já deixar pronto, é algo que a gente já fez em quase todos, F75A68. A gente vai usar a cor vermelha ali. Form Actions aqui, é bem tranquilo, é só para botar um botão do lado do outro e todos eles alinhados lá na direita. Então, por isso que eu vou botar o Justify Content Flex End para eles ficarem aqui, na direita. E aí aqui, eu vou botar um Gap 2, só porque ali parece que já tem um espaçamento e não tem, e agora quando eu dou um Focus mesmo assim, fica um espaçamento. E é isso. Vou botar um Margin Top 2 aqui para distanciar eles um pouquinho mais do formulário aqui. Show. E é isso. Nosso formulário visualmente está pronto, ainda falta a parte do React Hook Form, essas coisas assim, mas isso a gente faz depois."
  },
  {
    "id": "cfaa2e58-48ee-493f-8c09-b920b31a8ded",
    "title": "Navegando nos meses",
    "transcription": "Nessa aula a gente vai começar a trabalhar no nosso componente de calendário e pra isso aqui dentro de Schedule, dentro de Schedule Form, eu vou trocar aqui de volta pro nosso Calendar Step, pra mostrar o calendário em si. E dentro de Calendar Step, onde tem o Is Date Selected como True, eu vou colocar como Falso, especificamente pra aparecer somente o formulário por enquanto. E aqui a gente vai começar primeiramente por essa parte, essa funcionalidade aqui em cima do mês atual e passar e voltar o mês. Então a gente vai começar de uma maneira mais simples e depois a gente vai aumentando. Então aqui dentro do Calendar, que é o nosso componente em si, a gente vai começar criando um estado aqui dentro que vai anotar qual que é a data atual, pra eu ter referência assim que o componente é exibido em tela pra mostrar aqui o mês e o ano atual. Então aqui dentro de Use State, eu vou simplesmente utilizar um New Date, por exemplo, que eu posso ter a data atual. Porém, uma das coisas que a gente já sabe do JavaScript, se você não sabe já deveria saber, é que a API de datas aqui do JavaScript é extremamente limitada e muito ruim de se lidar. Principalmente quando a gente precisa fazer manipulação de datas, mostrar diferentes formatos e tudo mais. Existe até uma especificação para uma nova API do JavaScript chamada Temporal, que é uma nova API que está ainda em RFC, mas antes do beta, em discussão. Que é uma API totalmente nova pra trabalhar com datas dentro do JavaScript, só que é algo que vai demorar ainda pra entrar, eu acredito. Então não tem porque a gente tentar se basear nela ou qualquer coisa assim. E pra isso eu vou utilizar uma biblioteca. A gente tem várias bibliotecas de datas no JavaScript. Uma que eu curto bastante, tenho cada vez mais curtido utilizar é o Date.js, porque ele tem uma pegada bem funcional de como lidar com datas e eu acho bem legal. E ela é muito, muito, muito leve. Então o que a gente vai fazer aqui no Current Date, ao invés de iniciar aqui com um New Date, eu posso passar uma função dentro do Use State. E tudo que eu retornar daqui de dentro vai ser o valor inicial dessa variável que eu vou estar armazenando no meu Use State. E aqui dentro eu vou chamar o Date.js, veja que ele já trouxe a importação automática aqui. Porém, eu vou dar um ponto set Date 1. O que eu estou fazendo aqui? Eu basicamente criei um novo Date.js, que é um objeto de Date, porém eu estou setando o dia, dia 1. Ou seja, eu só quero saber a informação do mês e do ano, eu não preciso saber a informação do dia. Por isso aqui eu boto o dia 1, porque depois vai ser mais fácil eu trabalhar com esse objeto aqui. E aí eu vou ter aqui o nosso Current Date e o Set Current Date para eu atualizar esses valores. E agora aqui embaixo, em dezembro de 2022, eu posso basicamente mostrar informações sobre esse carinha aqui. E aí o que eu vou fazer aqui agora? Olha só, eu vou pegar aqui uma variável, criar uma variável chamada CurrentMonth, só para não fazer esse cálculo aqui dentro do render. Geralmente eu evito colocar muito código aqui, tem condicional e tudo mais. Eu prefiro fazer as vezes a condicional aqui antes, alguma coisa e já ter uma variável para usar diretamente ali embaixo. Então aqui eu vou fazer basicamente um CurrentDate.format e aqui eu vou usar o mmmm. Esse formato aqui do djs é basicamente o mês por extenso. E agora se eu pego esse CurrentMonth e mostro ele aqui dentro, a gente vai ver que ele já mostrou aqui dezembro de 2022. E aqui eu quero o meu CurrentYear também. E aí eu vou dar um CurrentDate.format yyyy. E eu jogo aqui dentro do nosso CurrentYear, então já está aqui dentro. É o que era atual, por isso que ele já ficou certinho aqui. Só que, como a gente pode ver, ele está em inglês, então eu preciso converter isso. E aí como é que eu vou fazer isso? Aqui dentro de Lib, eu vou criar um carinha chamado djs. Aqui dentro é bem simples. Eu vou importar o djs dentro de djs. Vou importar djs.locale.ptbr E aqui eu vou dar um djs.locale.ptbr E pronto, agora basta eu importar esse arquivo djs em algum lugar que seja global na minha aplicação. Então, por exemplo, aqui no app. Vou importar ele aqui antes de tudo. Então import./.lib/.djs E pronto, agora ele vai ficar global já para todas as páginas do locale.ptbr Inclusive, se eu volto aqui no Chrome, no F5, está aí. Dezembro de 2022. Só que está vendo que aqui o D ficou em minúsculo. Então o certo era eu capitalizar isso aqui. E eu posso fazer da mesma forma. Se a gente lembrar lá no utils, lá dentro do getWeekDays, eu tinha uma função que ela capitalizava. Que é basicamente pegar o primeiro caractere, fazer um toUpperCase e fazer concático o restante do caractere. O que eu vou fazer aqui para ficar melhor é eu vou criar uma function à parte chamada capitalize. Se bem que eu acho que... css.capitalize.textTransform.capitalize. Acho que tem, né? Ah, tem. Então eu não vou fazer isso não. Eu vou voltar e aqui no nosso calendar.title eu vou botar um textTransform.capitalize. Salva. Volta. Está lá. Dezembro de 2022. Já fica mais fácil. Não preciso ficar fazendo isso no Javascript em si. Deixa eu fechar aqui. Fecha, fecha. Fechei o calendário também que era o que eu estava trabalhando. E agora a gente vai criar duas funções aqui em cima do nosso calendário. Uma vai se chamar handlePreviousMonth e uma function handleNextMonth. E aqui a previous vai basicamente fazer o seguinte. const previousMonthDate é igual a currentDate. Ou seja, eu quero pegar a data atual, ponto. E aqui o Date.js tem uma função chamada subtract. Para eu subtrair o que eu quiser de tal medida. Então eu quero subtrair um da medida. Dou um ctrl espaço. Olha só, ele traz todas as opções aqui. A gente pode escrever month, mas como é um só eu vou botar month aqui. Então eu quero pegar a data atual e subtrair um mês dela. A data atual, digamos, que está salva aqui no estado. E aí eu vou dar um setCurrentDate com esse previousMonthDate. E a gente vai fazer o mesmo processo aqui no handleNextMonth. Porém, ao invés de subtrair, a gente vai fazer um add. Então vai adicionar um mês. E agora a gente vai usar essas funções aqui, o handlePrevious e o handleNext, aqui embaixo nos nossos botões. Então no caretLeft a gente vai botar handlePreviousMonth. E aqui seria bom, como a gente está tendo só um ícone aqui dentro, colocar talvez nesse button aqui um title previousMonth para ficar um pouquinho mais acessível. E aqui nesse button aqui também nextMonth. E aqui onClick handleNextMonth. Show! Voltamos ao Chrome. Agora se eu navego aqui, novembro, dezembro, posso ir para janeiro de 2023. Eu consigo navegar, então ele vai adicionando ou subtraindo um mês da data que a gente tem disponível. É isso. Por enquanto a gente ainda não está trabalhando com as datas, mas já estamos avançando."
  },
  {
    "id": "621bf4f4-dc05-4c50-83da-82b6df7bed57",
    "title": "Finalizando cálculo de dias",
    "transcription": "Show, bora continuar aqui calculando. Então, pra gente conseguir saber quantos dias a gente vai precisar do próximo mês, eu preciso pegar qual que é o dia da semana do último dia do mês. E aqui eu vou fazer o seguinte. Pra eu pegar o último dia do mês, eu tenho que fazer currentDate.setDate currentDate.get.daysInMonth DaysInMonth me retorna quantos dias eu tenho no mês. Se eu setar o dia da data no total de dias do mês, eu estou pegando o último dia do mês. E aí, se eu dou um ponto getDay, isso aqui me retorna, se eu bem entendi o código que eu escrevi, 6. 6 que simboliza sábado. Dezembro termina num sábado, que quer dizer que eu preciso nenhum dia a mais pra ser calculado. Correto? Se eu termino num sábado. Porém, mesmo assim, como eu posso navegar entre os meses, depois a gente consegue testar num que tem pra ver. Mas vamos lá. O que eu vou fazer aqui? O que eu vou fazer aqui? const nextMonthFillArray é igual a Array.from length 7 menos lastWeekDay mais 1. Por que lastWeekDay mais 1? Porque isso aqui me retorna sempre um dia, se a gente for pensar, um dia atrás. É porque aqui o length 7, eu tenho 7 dias na semana. Mas começa do zero. Então, eu não posso falar que eu tenho 6 dias na semana. Eu acho que pra entender ficaria melhor 7. E aí eu somo 1 aqui no lastWeekDay porque fica mais claro na minha opinião. Porque ele começa do zero, então 1 nesse caso seria o domingo, não o zero. E aqui a gente vai fazer algo parecido com o que a gente fez lá em cima. Então eu pego o i. E aqui eu vou fazer o seguinte, eu quero pegar a currentDate. E aí pra ser mais fácil eu vou fazer o seguinte, const lastDayInCurrentMonth. Vou pegar esse código aqui e vou jogar nessa variável. Vou usar essa variável aqui embaixo. Porque aqui embaixo eu posso reaproveitar o lastDayInCurrentMonth.add e mais 1. Aqui ele tem que retornar nada, vazio. No mês de novembro, deixa eu voltar aqui. Ele retornou 3. Quinta, sexta e sábado, certinho. Porque provavelmente acaba na quarta. Show, agora a gente tem os nossos dias. Então eu vou criar uma variável agora chamada calendarDays. Que ela é um array pra eu somar tudo isso aqui numa coisa só. O que eu vou fazer aqui dentro? Eu vou somar tudo que eu tenho no PreviousMonthFillArray. Tudo que eu tenho no DaysInMonthArray. E tudo que eu tenho no NextMonthFillArray. Massa, né? E agora, algumas coisas disso aqui a gente quer dar uma formatada. Porque olha só, os dias que são do mês anterior. Eu quero que eles estejam desabilitados no calendário. Então eu vou fazer o seguinte, daqui de dentro eu vou fazer um map. Vou pegar a data. E eu vou retornar daqui de dentro a própria data. Porém, disabled como sendo true. Então no PreviousMonthFillArray. No NextMonthFillArray também. Então o disabled vai como true. E no DaysInMonth o disabled vai como falso pro padrão. Beleza? Então os dias do mês anterior estão desabilitados. Os dias do próximo mês também estão desabilitados. Porém, os dias do mês atual estão habilitados. E aqui no final eu posso retornar o nosso calendarDays. Outra coisa que a gente precisa fazer aqui agora. É dividir isso aqui em semanas. Porque cada semana ela precisa ter sua própria TR. Table Row ali. Então eu preciso separar isso aqui em semanas. Pra ser mais fácil eu conseguir iterar aqui. Fazer um map aqui embaixo do nosso render. Pra eu navegar entre as datas do calendário. Então aqui vamos lá. const calendarWeeks E aqui eu vou fazer um calendarDays.reduce Sim, reduce. E aqui eu vou obter de dentro desse reduce. Eu vou iniciar ele com um array vazio. Que é um array de semanas. E pra gente trabalhar isso aqui. Já que a gente está trabalhando com o TypeScript. Eu vou fazer o seguinte. Aqui em cima eu vou criar uma interface. Chamada Calendar Week. Cada semana ela vai ter o seguinte. Um número da semana. Então semana 1, semana 2. E os dias da semana. Nos dias da semana vai ser um array. Cada dia vai ter a data. Que é do tipo dayjs.dayjs Um objeto do tipo dayjs. E o disabled que é um boolean. Lembra que foi isso que a gente colocou lá dentro. Date e o disabled. A gente só não calculou o número da semana. E aqui embaixo eu vou criar um type. CalendarWeeks Porque no plural agora é um array disso aqui. O nosso reduce no final das contas. Ele precisa produzir um objeto. Um array na verdade. Nesse formato aqui. CalendarWeeks Então aqui no reduce. Eu vou dar um generic nele. E passar o nosso CalendarWeeks. Porque assim ele já sabe que esse array aqui. Que ele está recebendo no final. É um array nesse formato aqui. Até se eu tentar colocar um objeto dentro dele. E dar um control espaço. Ele já traz para a gente o IntelliSense. E aqui agora. Dentro do reduce a gente recebe. O array. Esse array aqui. Que é o array final que a gente vai montar. Então vou chamar de Weeks. E cada um desses dates aqui. Então eu vou botar como o underline. A gente pode receber aqui dentro também. O índice. E a gente pode receber. O array original. E calma que eu vou te explicar. O que é isso aqui. Mas é bem legal. A gente vai aprender bastante coisa. Nesse reduce aqui. Mas vamos lá. Se eu passo o mouse em cima de Weeks. A gente pode ver que Weeks é CalendarWeeks. Deixa eu dar um return aqui vazio. Só para parar de dar erro. Pronto. O CalendarWeeks. É basicamente esse carinha aqui. Cada iteração do reduce. Eu posso modificar esse array. Para no final reduzir ele a uma variável só. Que é o nosso CalendarWeeks aqui que a gente está querendo calcular. Ou seja Weeks é a informação que eu vou manipular. Somente essa. Então toda vez que eu quero adicionar alguma coisa. Eu venho aqui Weeks.push. Mexo nela como eu quiser. O underline que eu coloquei aqui. Só porque a gente não vai utilizar. Ele é cada um dos dias que eu tenho dentro do meu CalendarDays. Então como eu estou percorrendo o CalendarDays. Ele é cada um dos objetos que eu coloquei aqui dentro. Só que eu botei um underline. Porque eu não vou... Nenhuma informação que está dentro desse objeto. É importante para mim. Porque eu quero separar. Os dias. Os itens que eu tenho no meu CalendarDays. Cara deu 7. Fechou. Vai para o próximo. Então não é pelo conteúdo que eles tem. O índice é muito melhor para mim. Porque o índice ele vai. 0, 1, 2, 3. Bateu 6. Porque começa em 0. Que seria 7 itens. Fechou. Fechou uma semana. Próxima semana. Concorda comigo? E o original aqui. Ele me retorna um array original. Que é o CalendarDays aqui. Eu não tenho necessidade de usar o... Original aqui. Eu posso simplesmente usar o CalendarDays. Mas uma das coisas legais do original aqui. É que a gente pode manipular essa variável. Da maneira que a gente quiser. E ela nunca vai modificar o valor da... Variável que está aqui fora. Então é legal também. Porque a gente consegue abstrair em algum momento. Essa função aqui. Para uma function separada. Que não tem o contexto do CalendarDays. Então imagina que isso aqui fosse uma função separada. Então por exemplo. SplitDaysInWeeks. Até faz sentido o nome da função. Eu quero separar. Vários dias em semana. Então eu venho aqui por exemplo. Coloco no lugar daquela função. Esse SplitDaysInWeeks. E ele não tem mais o contexto. Daquele. Ele não sabe mais o que é essa variável CalendarDays. Se eu tento usar ela aqui dentro. Já não funciona mais. Então por isso que o original existe. E isso não existe só no Reduce. Existe no Map, no Find, no Filter, no Avering, no Sum. Qualquer método. Porque a gente tem acesso ao arreio original. Para a gente conseguir trabalhar com ele como um todo. Mas isso aqui foi só para exemplificar. Eu vou voltar aqui. Para a gente chegar no que estava antes. A partir daqui a gente vai começar. A calcular os dias da semana. E mostrar isso em tela. Para calcular aqui vai ser bem simples. Vamos lá. A gente vai fazer o seguinte. Acompanha o raciocínio comigo. Const. Week. HasNotEnded. Ou seja, vou criar uma variável. Que vai ser um booleano. Que indica se a gente já chegou no fim. De uma semana ou não. Ou seja, se eu já completei um array com 7 itens. Representando uma semana. E ela vai ser o seguinte. A negação de I.Módulo 7. Ou seja. Se o meu índice. Não for divisível por 7. Quer dizer que eu não cheguei no momento que eu quebro a semana. Concorda comigo? E aí. Se. A semana. Não terminou. Ou eu poderia. Para evitar o sinal de negação. Week. HasEnded. E aí fica. Week. HasEnded. Se a semana não terminou. Eu vou pegar o. Weeks. Ponto. Push. I.Módulo 7. Vai retornar. True. True. Tá. Aqui na verdade. A lógica é um pouquinho diferente. Pera aí que até eu me perdi na lógica que eu estou botando na minha cabeça. Me dá um segundo para eu recapitular tudo. Aqui para o código ficar um pouquinho melhor. O que acontece? Aqui ao invés de a gente verificar o final da semana. Eu vou fazer o seguinte. Essa variável vai ser True. Quando a gente começar. A criar uma nova semana. New Week. E aqui eu vou verificar se o módulo. Do I por 7. É igual a 0. Isso aqui já vai retornar um booleano. E aí. Por exemplo. O primeiro dia que a gente for pegar. O índice 0. Módulo. 7. Ele retorna 0. Ou seja, quer dizer que é o primeiro dia. De uma nova semana. Que eu já percorri outros 7 dias. Que vai dar módulo 7 de novo. Vai dar 0. Ele vai começar a calcular uma nova semana. Então assim fica melhor. Quando ele chegar para calcular uma nova semana. Eu vou fazer o seguinte. Weeks.Push. Vou criar uma nova semana. Aqui dentro eu vou botar Week. Como sendo o I. Dividido por 7. Mais 1. Porque eu não quero que o Week comece em 0. A primeira semana comece em 0. Quero que ela comece em 1. Como o módulo retorna 0. Semana 1. Semana 2. Semana 3. Semana 4. E os Days. Eu vou pegar o meu Array. Original. Slice. Começando do I. Até I mais 7. Ou seja, 7 dias. E agora. Aqui embaixo desse IF. Eu vou retornar as nossas Weeks. E agora. Deixa eu dar uma olhadinha aqui. Deu certo. E agora deixa eu retornar esse Calendar Weeks. Daqui de dentro. Deu certo. Olha lá. Cada semana com 7 dias exatos. Então semana 1 com 7 dias. Semana 2 com 7 dias. Semana 3. Semana 4. Semana 5. Então a gente já está com todas as semanas aqui. E a gente já pode exibir isso em tela. Vamos lá exibir isso em tela. Só para finalizar com chave de ouro. Então Calendar Weeks. Map. E aqui eu tenho a minha Week. Return. Tr. Aqui a nossa Key vai ser Week. Ou eu posso desestruturar aqui para ficar um pouquinho melhor. Então Week. E Days. E aqui dentro. Então nesse ponto Map. Cada dia da semana. Eu quero retornar um Td. Deixa eu pegar certinho. Um Td que tenha o Calendar Day aqui dentro. Dessa forma. Aqui na Key. Eu vou botar o Day. Deixa eu ver o que eu usei aqui na Key. É Day. Date. Deixa eu desestruturar até isso aqui para ficar mais fácil. Date e Disabled. São as duas informações que a gente tem. Aqui eu vou usar o Date.toString. Só para pegar alguma coisa única. Cada dia é único. Então o toString vai retornar único. Aqui dentro eu vou mostrar. Date.getDate. Vai pegar o dia. Lembra que não é Day. Porque Day é dia da semana. Horrível. E aqui no Calendar Day. Eu vou fazer o seguinte. Disabled. Ele vai botar Disabled aqui no nosso botão também. E aqui embaixo eu vou tirar todos os outros TRs que a gente tinha. Se eu voltar lá para o nosso calendário. Tá lá o nosso. Até dia 30. Tudo desabilitado. Eu posso ir navegando nos outros meses. Muito massa. E o calendário vai se formando automaticamente. Conforme eu navego aqui nos meses. Preenchendo o fio no começo e no final. Com os dias do outro mês. Permitindo a gente clicar somente nos dias. Desse mês. Massa demais."
  },
  {
    "id": "f103c17b-e443-4479-9528-a8943008bf4f",
    "title": "Preparando calendário",
    "transcription": "O que a gente vai fazer nessa aula é deixar a estrutura do nosso calendário um pouco mais preparada para os próximos passos, que é quando a gente vai conectar isso com o nosso backend para conseguir mostrar aqui no calendário, por exemplo, somente as datas que realmente estão disponíveis, porque se a gente tiver, por exemplo, esgotado algum dia, seria legal ele não estar disponível, tem todas essas coisas. Mas uma das coisas que a gente já pode fazer, por exemplo, aqui dentro do DaysInMonthArray, que a gente retornou disabled como falso, é, por exemplo, se o dia já passou, ele tem que estar como desabilitado. Então eu posso fazer, por exemplo, se a data.endofDay, e esse endof, ele retorna o horário 23, 59, 59, ou seja, eu quero saber se o dia já passou, mas para isso eu preciso ter a referência do dia inteiro. Então, se 23 horas e 59 minutos e 59 segundos desse dia específico já passou, ou seja, é anterior à new date, ele tem que estar como desabilitado. Então, olha só, no F5 aqui, em novembro, em dezembro que eu estou aqui, dia 19 ainda não passou, porque eu botei 23 horas e 59. Se eu não tivesse botado isso, talvez já teria passado, concorda comigo? Então, dia 19 ainda está habilitado, porque ainda não passou 23 horas e 59, então eu pego o final do dia, e os dias de antes eu já não consigo clicar, tá vendo? Então, quando eu vou para janeiro de 2026, aí aparece todos. Então a gente já fez uma primeira verificação. Mas nem é isso que eu queria fazer aqui especificamente. Lembra que a gente tinha deixado aqui no código algumas coisas que estavam a se fazer, digamos assim, né? Uma das coisas que eu vou fazer aqui no Calendar é criar uma interface chamada Calendar Props, aqui dentro, SelectedDate, Date, e OnDate, SelectedDate, Date, Void. O que eu estou fazendo aqui, né? Basicamente eu estou criando uma porta de entrada e saída para o nosso componente, para que outros componentes possam passar para ele a data selecionada e vice-versa, né? Aí o que a gente vai fazer é, lá embaixo, nos nossos botões aqui de cada um dos dias, o CalendarDay aqui, OnClick, eu vou passar uma função, que é as nossas propriedades aqui, eu já desestruturei. OnDateSelected, e eu passo o nosso Date.toDate. E veja que eu estou passando agora como um objeto Date nativo do JavaScript, porque como esse componente aqui usa o Date.js, mas não necessariamente toda a minha aplicação vai usar o Date.js, então para quando algum componente externo for se comunicar com esse meu componente, é legal que ele possa se comunicar com objetos Date nativos do JavaScript, e o nosso componente que lide para trabalhar com isso. E aí aqui, por enquanto é isso. E aí agora, o que a gente vai fazer? Aqui eu tenho esse SelectedDate aqui que eu ainda não utilizei, mais pra frente eu vou utilizar. Mas agora, esse nosso componente Calendar, ele é utilizado aqui dentro do CalendarStep. E aí no CalendarStep, a gente vai fazer o seguinte aqui dentro. Eu vou criar aqui um estado, const SelectedDate. set SelectedDate igual a useState do tipo Date nulo. Começa como nulo, porque não tem nenhuma data selecionada, então aqui pode ser Date ou nulo. E aí eu vou fazer um... Deixa eu só ver aqui. Basicamente, aqui no nosso Calendar, eu vou passar pra ele o SelectedDate como sendo SelectedDate. E aqui vai dar erro, porque lá no Calendar eu não falei que ele pode ser nulo, então ele pode ser Date ou nulo, não Undefined. E aqui, o onDateSelected eu passo o nosso set SelectedDate. Será que assim já vai dar boa? Já. E agora, o isDateSelected aqui, eu vou simplesmente fazer uma condicional caso eu tenha algo dentro do SelectedDate. Então olha só, eu volto aqui pro Chrome agora. Quando eu selecionar o dia, ele já abre o TimePicker aqui do lado. E é isso basicamente que eu queria carregar. Porque agora, a gente vai ter dois tipos de rotas no Backend, de operações no Backend, pra gente executar aqui. Porque eu preciso saber quais dias estão disponíveis, e pra saber os dias disponíveis não é só pelos dias que já passaram ou não passaram. Porque se o dia 21 aqui eu clico nele e não tem mais nenhum horário disponível, ou seja, todos os horários aqui estão ocupados, não faz sentido nem o dia 21 aqui estar habilitado. Então, eu tenho que fazer uma query aqui bem mais complexa pra eu conseguir obter essas informações. Fora isso, aqui na direita eu também tenho que, mesmo que o dia 21 tenha horários habilitados, aqui na direita eu tenho que falar quais horários estão disponíveis e quais não estão. Pra pessoa poder clicar somente nos que estão disponíveis. Então são duas operações que a gente vai ter que fazer aqui no Backend. E por isso que agora eu só queria deixar esse código já meio pronto, digamos assim, pra gente poder fazer isso daqui pra frente. Então, bora lá!"
  },
  {
    "id": "51a5017c-8915-46a6-9890-d54a79265f97",
    "title": "Carregando horários disponíveis",
    "transcription": "Nessa aula, então, a gente vai terminar a nossa parte de disponibilidade, nossa rota, e também mostrar os horários disponíveis ali na interface. Bora continuar aqui dentro, então, na rota de Availability, e o que a gente vai fazer agora é, basicamente, procurar por todos os agendamentos marcados por qualquer usuário nesse dia aqui específico que a gente está buscando. E aí, então, o que a gente vai fazer? Olha só. A gente vai procurar por blocked times igual await prisma.scheduling, ou seja, vou procurar por todos os agendamentos, findMany, onde o userId seja igual ao id desse usuário que eu estou buscando, ou seja, todos os agendamentos para um usuário específico, onde a data comece em, ou seja, igual, esse GTE significa greater than or equal, então, eu estou procurando por todos os valores onde a data seja maior que ou igual a referenceDate.set, ou melhor, a gente pode usar o .setHour, .startHour, .toDate, porque o prisma só aceita data, então eu preciso converter esse aqui num date do JavaScript, ou menor ou igual a referenceDate.setHour and Hour. Então, lembra que a gente criou esse startHour and Hour, que ele retorna, por exemplo, 10 e 18, a hora que começa e a hora que termina. Aqui embaixo, eu estou procurando todos os agendamentos que foram feitos com esse usuário entre esses dois intervalos, entre 10 horas e 18 horas, então ele vai me retornar todos esses agendamentos. E aqui agora, eu só preciso fazer um cross, fazer uma interseção entre esses valores, eu preciso pegar todos os horários disponíveis e validar que não existe um agendamento naquele horário. Simples assim. Então, aqui a gente vai criar o availableTimes igual possibletimes.filter, vou percorrer todos os horários possíveis, porém filtrando eles, e eu quero validar que não existe, eu quero manter apenas quando não existe um blockAtTimes.sum, ou seja, pelo menos um, onde o blockAtTimes.date, isso aqui é um date do javascript, então eu posso dar um getHours, seja igual a time, que é a nossa hora que a gente tem aqui dentro de possibletimes. Então, e aqui também no blockAtTimes, quando eu seleciono, eu não preciso trazer todos os dados do scheduling, pra mim é importante trazer pelo menos somente a data, eu não preciso do restante das informações. Então o que isso aqui vai fazer? Se eu tiver um array aqui em possibletimes, que seja, por exemplo, 8, 9 e 10, vamos supor, os três horários possíveis que o usuário selecionou, vamos supor que ele botou que trabalha das 8 às 11, 8 às 10. E o availableTimes, ele vai passar por cada um desses aqui, validando que não existe nenhum blockAtTime, ou seja, nenhum registro na tabela de scheduling, onde bate esse horário aqui com a hora do agendamento. E agora, aqui embaixo, eu vou retornar tanto possibletimes quanto availableTimes pra gente validar se deu certinho. Então olha lá, vou botar F5, cannotReadPropertiesOfUndefinedReadingFindMany, deixa eu fazer o seguinte, Prisma, deixa eu reiniciar aqui o meu servidor pra validar certinho, deixa eu ver aqui, vou reiniciar o Prisma Studio também já, pra garantir, deixa eu dar F5, beleza. Olha só, possibletimes 10 às 16, availableTimes 10 às 16. Agora o que que eu vou fazer, tá? Eu vou criar um agendamento, então aqui no Prisma Studio, eu vou na tabela Scheduling, vou criar um novo registro, o i dele vai gerar sozinho, na data, eu vou colocar essa data aqui, 2022-12-20, você pode colocar a data aí no dia que você tá vendo, então cuidado que eu não apago o T, porque isso aqui é do TimeZone, e aqui no horário, a gente tem que colocar ele, mais 3 horas, o que que eu te indico, vai em outro, acho que aqui vai funcionar, não tem problema, vamos colocar aqui por exemplo, se começa as 10 horas, vamos colocar aqui 13, porque ele vai gravar sempre em UTC, no Brasil a gente tá em UTC-3, então só cuidado com isso, sempre no banco de dados, sempre em UTC, nunca salva no horário local, e aqui é 13 horas mesmo, nome aqui eu vou botar Diego, tanto faz, Diego rouba teste.com, observante não precisa, aqui no User eu seleciono DiegoSF, que é o usuário que a gente tá trabalhando, e pronto, vou dar um Save, e agora se eu dou F5, veja que o horário das 10 já sumiu aqui de availableTimes, porque ele não tá mais disponível, e aqui eu posso, se eu quiser, ir criando mais pra gente validar, mas esse aqui não é o ponto, eu vou agora mostrar isso aqui na interface em si, então a gente vai lá pro nosso Calendar Step, que é onde eu tenho os horários aqui dentro, e agora a gente precisa mostrar esses horários aqui na nossa lista, e aí pra começar de uma maneira mais simples, a gente vai fazer o seguinte, eu vou criar aqui um estado, chamado Availability, UseState, vou criar ele por enquanto como nulo, logo a gente já bota a tipagem certinha, e aqui vou criar um UseEffect pra gente carregar esses dados da API toda vez que o SelectedDate mudar, se eu não tiver um SelectedDate, eu vou retornar nulo daqui de dentro, opa, botei um cochete aqui, que não era pra estar aqui, porque se não tiver uma data selecionada, não preciso carregar né, se tiver a data selecionada, eu vou fazer um API.get, barra, Users, barra, aqui a gente precisa do nosso Username, então o Username ele tá aqui na rota né, então a gente consegue pegar ele daqui de cima, então a gente vai fazer um const Router igual a UseRouter do Next, e aí const Username é igual a Router.query.username, aqui ele retorna novamente String, String Undefined, a gente vai converter isso aqui pra String dessa forma, e aqui dentro eu vou usar esse Username, então ele precisa ser uma dependência do meu UseEffect, e aí o que eu posso fazer, se eu não tiver um SelectedDate, o Username ele sempre vai existir pra chegar aqui, senão nem vai cair na rota, Username, barra, Availability, e aqui a gente precisa passar como parâmetro né, parms, que é os query parms, a nossa data em si, então Date, e a gente pode passar aqui o nosso SelectedDate.getUtcDate, deixa eu ver o que que isso aqui retorna, só pra gente validar tá, então console.log SelectedDate.getUtcDate, CannotReadProperties.getUtcDate, porque ele pode ser vazio tá, não tem problema, deixa eu só validar o que que isso aqui retorna pra gente enviar isso aqui no melhor formato lá pra dentro, então quando eu clico aqui ó, ah, ele retorna 20, não é isso que eu quero, getUtcDateFullYear, getTimeZone, toLocale, toUtcString talvez, deixa eu ver como que retorna aqui, não, não é dessa forma que eu quero, eu vou pegar, eu vou fazer diferente tá, aqui ó, eu vou fazer um ponto format, yyymmdd, então ele vai pegar só ano, mês e dia, eu não preciso das outras informações, só que SelectedDate ele é um date em si né, então aqui eu teria que botar ele por volta do construtor do Date.js pra trabalhar ele como um formato de date aqui né, perfeito, e agora é, quando isso aqui finalizar, porque que ele tá dando erro aqui, type, null, the file is not effect callback, ah, tem um return aqui né, ah, perfeito, e agora aqui dentro eu vou dar um ponto then, a response, console.log response.data, vamos validar agora se isso aqui tá funcionando, então, dá um F5, ah, type is invalid, isso aqui às vezes dá um erro, ah, deixa eu rodar o servidor de novo, não acho que seja algum erro no código, é, às vezes ele dá um bug, então aqui ó, ele não pode ter rodado ainda, availability, beleza, não rodou, quando eu seleciono o dia, por exemplo, dia 20, ele tem que rodar, ah, então tá lá ó, availability, 2022-12-20, trouxe aqui os dados certinho, deixa eu ver se foi no console.log, tá lá ó, possible times e available times. Com essas informações agora a gente vai começar a mostrar a lista de disponibilidade aqui na sidebar."
  },
  {
    "id": "fc10c6fc-a188-4762-9420-aa638e4f12c8",
    "title": "Configurando React Query",
    "transcription": "Aqui na nossa aplicação, antes de a gente continuar, a gente fez a nossa primeira chamada para API que a gente faz um GET. Então, é a primeira vez que aqui na nossa API, a gente busca uma informação, como foi esse caso de buscar a disponibilidade. Só que eu não consigo mais trabalhar dentro do React com chamadas API nesse formato, porque uma das coisas que a gente pode perceber, por exemplo, se eu vou no dia 21, ou melhor, dia 20, ele carrega do zero, então ele faz a chamada aqui do zero. Isso tem um loading, principalmente se eu venho aqui, por exemplo, e determino que a minha internet é um pouco mais lenta. Então, por exemplo, eu clico no dia 26, 27, ele demora pra caramba pra atualizar, tá vendo? Por mais que pareça que ele já atualizou, ele demora, na verdade, ele faz depois que ele atualiza. Então, eu acabo perdendo um pouco de performance, perco o cache, se a pessoa vai estressando vários dias aqui. E fora que a API, eu acho que ela não fica tão sugestiva usando o UseEffect, porque o UseEffect é um hook de SideEffects, e fazer chamadas dentro do UseEffect é um pouco estranho. Por isso, sempre que eu vou lidar com chamadas API, eu gosto de trabalhar com o React Query. Pra isso, a gente vai instalar aqui a biblioteca, e vai configurar ela no nosso projeto. É bem simples, não tem muita configuração pra gente se preocupar, é mais realmente os benefícios que ela traz. Então, aqui dentro de lib, eu vou criar ReactQuery.ts, e aqui dentro eu só vou exportar. QueryClient é igual a new QueryClient, que vem de dentro do ReactQuery. E aí, lá dentro do nosso app, a gente precisa colocar a nossa aplicação inteira por volta, tanto faz aqui o que vem primeiro, mas por volta do QueryClientProvider, que vai receber como parâmetro o client, que é igual a QueryClient, que importa de lib ReactQuery. Feito. Agora, a gente vai mudar um pouquinho como que a gente faz essa nossa query. Então, eu vou comentar isso aqui, vou comentar também o nosso estado aqui em cima, availability, tirar esse console.log, e aqui a gente vai fazer da seguinte forma, const, igual useQuery, then stack ReactQuery, e aqui a gente vai dar uma chave pra ela, uma key, que é uma maneira da gente identificar essa query unicamente, e é importante que contenha nessa chave todos os parâmetros possíveis dessa query, porque ela vai ficar cacheada, então não é legal a gente dar o mesmo nome se ela for parametrizada, ou seja, se ela for dinâmica, ter algum parâmetro envolvido. Então aqui, eu vou botar dentro de um array, availability, que identifica, e eu vou criar um outro objeto aqui, por exemplo, que contém isso aqui, essa formatação. Então, o nome vai ser selectedDateWithoutTime, só a data sem o time, especificamente. E aqui, mais ou menos dessa seguinte forma, preciso também verificar se isso aqui existe, se não, ele precisa ser nulo. E aqui, então, eu vou botar o nosso selectedDateWithoutTime. E aí, no segundo parâmetro, é a operação em si, o fetch que a gente vai fazer, e aí aqui dentro, eu vou fazer um const response igual await, eu preciso fazer, na verdade, essa chamada aqui, então, deixa eu tirar o comentário, aqui, deixa eu mudar o get aqui pra cima, e aqui no parâmetro, a gente vai enviar o selectedDateWithoutTime, e aqui eu dou um return response.data. Aqui no useQuery, se eu quero mostrar qual é o valor que vai ser retornado, eu posso botar aqui um sinal de menor e maior, e passar lá a nossa interface availability, pra mostrar que o data retornado daqui de dentro vai ter esse formato aqui. Salvo aqui, feito. Daqui de dentro, agora eu posso obter o data, posso obter o isLoading, caso eu queira mostrar algum sinal de carregamento, mas eu vou pegar apenas o data, e o nome dele eu vou trocar pra availability, que era o mesmo nome que a gente estava usando no estado antes, pra gente reaproveitar o mesmo nome. O único ponto importante aqui, é que eu quero executar essa query aqui, lembra que lá dentro do useEffect a gente tinha esse if, eu só quero executar ela caso tenha um selectedDate, então aqui embaixo, no terceiro parâmetro, eu posso botar uma opção chamada enabled, ou seja, eu só quero executar ela caso exista um selectedDate, então eu boto dois sinais de exclamação, dois sinais de negação, pra ele executar somente caso tenha um selectedDate. Feito isso, deixa eu apagar o restante do useEffect, eu acho que isso aqui já fica muito mais amigável e melhora também a usabilidade da aplicação, mas ela deve continuar funcionando normal, então eu clico dia 20, carregou, veja. E agora eu vou clicar, por exemplo, dia 26, que vai carregar outro aqui, perfeito, carregou. E agora, quando eu volto pra dia 20, mesmo que eu tenha uma internet lenta pra caramba, então eu vou botar aqui, 3G, por exemplo, clico dia 20, já está automaticamente carregado, porque isso aqui está armazenado em cache, agora que a API terminou, depois ele recarrega, invalida aqui e repõe os dados, mas ele tem um cache, então eu clico em dia 26, que já tinha sido carregado antes, pronto, já está disponível ali, e a chamada API nem terminou, daqui a pouco ela termina. Então, show de bola, a gente já mudou aqui e instalou o React Query, e agora a gente pode continuar pras demais rotas da nossa aplicação, deixa eu tirar esse UseEffect aqui em cima, que a gente não está utilizando, e bora lá."
  },
  {
    "id": "a9919920-139e-478d-a090-d6669d2a590c",
    "title": "Finalizando query de dias lotados",
    "transcription": "Nessa aula a gente vai continuar a nossa query aqui, que vai ficar bem extensa, mas vai ficar muito massa, porque a gente vai usar bastante coisa do SQL aqui envolvida, bastante cálculo de data, que é uma das coisas mais difíceis de trabalhar dentro de banco de dados, dentro de query, que são as datas, assim. Comparar datas é um negócio bem chatinho, então pode ter certeza do que a gente está criando aqui. É um negócio, assim, bem alto nível mesmo. Vamos lá. Primeira coisa que a gente fez, a gente buscou todos os schedulings aqui dentro, né? Só que a primeira coisa que eu quero fazer aqui dentro é agrupar os meus schedulings pelo dia, porque eu estou buscando todos os schedulings do mês e do ano. E agora eu quero agrupar eles por dia, então se eu der um group by, extract, ou seja, eu quero extrair uma informação da data, por exemplo, day from s.date, se eu salvo aqui agora, dentro da F5 vai dar erro, porque tudo que eu coloco no group by precisa estar no select, obrigatoriamente, então vou selectar dessa forma aqui, extract, e aqui em cima eu posso renomear até se eu quiser, então, por exemplo, eu quero renomear isso aqui para date, salvo. Se eu volto aqui agora, olha só, ele trouxe para a gente, agora apenas, não trouxe todas as informações do scheduling, trouxe apenas o dia que eu tenho schedulings, né? Só que, para mim, o dia que eu tenho schedulings não é o mais importante, eu preciso saber quantos schedulings eu tenho naquele dia, então vou dar uma vírgula aqui e vou botar count s.date as amount. Se eu salvo aqui agora... O que eu fiz de errado aqui? Tá, é porque eu estou retornando tudo em uma porrada só. O que eu vou fazer, talvez, é um console.log nisso aqui e retirar ele do retorno aqui, porque, pelo jeito, ele não está conseguindo serializar o retorno em JSON, então, agora, no console.log, ele deve conseguir mostrar. Está ali, olha, amount, só que ele veio como 2n, que é um beginnt, né? A gente vai ter que... Depois a gente vai converter isso, não é um grande problema, tá? Mas aqui eu já sei, então, que no dia 20 eu tenho dois horários ocupados, certo? E agora, dentro dessa query, eu quero saber qual que é o total de horários que eu tenho naquele dia disponíveis, e aí eu vou fazer uma verificação. Cara, o total de horários ocupados é igual, ou maior ou igual, tanto faz, que o total de horários disponíveis. Então, vamos obter, agora, o total de horários disponíveis que eu tenho nesse dia específico. Então, aqui, olha só, eu vou fazer um left join. UserTimeIntervals, que é a nossa tabela de disponibilidade. Vou chamar ela de UTI. Meio feio, mas é isso aí. OnUTI.weekDay, ou melhor, aqui... Não, é isso mesmo. UTI.weekDay é igual a função weekDay do MySQL. E aqui, cara, é uma das coisas que lidar com data é muito chato. Muito, muito chato. O dia da semana no MySQL começa em 1. 1 é domingo. No JavaScript, domingo é 0. Então, pra validar aqui o dia da semana corretamente, como começa em 1, eu vou pegar e vou adicionar ao s.date um dia. Então, a gente usa a função dateAdd um dia. Por quê? Porque se for 0, vai ser 1, e aí por diante, porque começa com 0. E aqui, agora, o que a gente quer saber é quantos horários eu tenho disponíveis nesse intervalo aqui. Então, aqui, por exemplo, eu posso fazer o seguinte. A divisão de UTI.timeEndInMinutes menos UTI.timeStartInMinutes menos timeEndInMinutes. A divisão disso aqui por 60... Deixa eu botar entre parênteses aqui pra ficar... Pode ser, tanto faz. Isso aqui vai me retornar o size, por exemplo, quantos horários eu tenho disponíveis. Então, deixa eu dar F5 aqui. O que acontece? A gente não pode fazer isso aqui sem colocar no groupBy. Mesma coisa, né? Então, aqui, eu vou pegar isso aqui e vou colocar no groupBy também. A gente é obrigado a fazer isso. Voltamos. Console.log tá lá. Ele retornou date, amount, e o size aqui ficou como menos 2. Beleza, porque faz sentido, né? Eu tô pegando o timeStart e tirando o timeEnd. É o contrário. Eu tenho que pegar o timeEnd, que sempre vai ser maior do que o timeStart. E agora a mesma coisa aqui embaixo. Corrigi. Dá um F5. E tá lá, 2 e 2. E agora, o que a gente quer fazer? Eu quero validar, eu quero retornar daqui de dentro, todos os registros que sobraram dessa listagem aqui, em que o amount seja maior ou igual ao size. Amount maior que size. Que daí quer dizer que o tanto de agendamentos que eu tenho naquele dia é igual ou superior. Superior nunca vai ser, mas é igual, pelo menos, ao tanto de disponibilidade que eu tenho naquele dia. Ou, se o size retornar zero, eu também vou retornar aquele dia lá como sendo um dia não disponível. Porque quer dizer que o usuário não tem disponibilidade nenhuma naquele dia. Então, eu salvo. Vou dar um F5 aqui agora. E pronto. Ele retornou, então, dia 20. Com dois schedulings marcados e eu tinha duas disponibilidades. Pra eu testar isso aqui, eu posso, por exemplo, aqui no meu Prisma, onde eu tenho um scheduling, os dois no dia 20, eu vou trocar um deles pra dia 21, tá? Salvo. Volto lá. Dou um F5. E a gente vai ver que ele não retorna mais. Porque não está totalmente ocupado. Por causa desse having que a gente colocou aqui no final. Se esse having aqui tivesse comentado, aí ele retornaria. Dia 20 e dia 21, tá vendo? O dia 21 o size veio como nulo, porque... Aqui, na verdade, esse size igual a zero, eu acho que ele nem tem necessidade. Nem tem necessidade isso aqui. Isso aqui já está bom. Então, agora... Perfeito. Então, a gente já fez o cálculo. E agora, eu volto lá no Prisma Studio. Vou voltar isso aqui pra dia 20. Pra ele ficar com o dia lotado. Vou dar um F5. E está ali, dia 20. A gente já sabe que é o dia que está lotado. Agora, o que a gente vai fazer, tá? Aqui, eu vou falar que eu quero somente os dias, né? Eu quero somente esse número aqui, o 20. O resto, pra mim, não é tão importante. Então, const blockedDates é igual a blockedDates.raw.mapItem.date Que é a única informação que eu quero. Aqui, ele está dando erro, porque é do tipo unknow. Então, aqui no query.raw, eu posso falar... Acho que aqui eu não consigo botar a tipagem. Acho que talvez dê aqui, então. Array de date. Isso é uma string nesse caso, né? Isso aqui que está sendo retornado é um número, talvez. Só que aqui ele está dando erro, deixa eu ver. Botar aqui dentro direto não vai dar boa, acho. Eu vou fazer o seguinte. Vou botar desse lado aqui. Falar que o retorno disso aqui vai ser um array. Onde a data é um número. E agora sim, o blockedDates vai ser um array numérico. Se eu boto o retorno dele aqui dentro, salvo. Volto no Chrome, dou um F5 e pronto. BlockedDates 20. E agora, lá no nosso front-end aqui, no calendário. Calendar. A gente tem BlockedWeekDates, agora vou ter também o BlockedDates. Aqui no retorno da nossa API. E lá embaixo, aqui na nossa verificação. Vou fazer mais uma condicional aqui no disabled. BlockedDates.BlockedDates.IncludesDate.GetDate. Se o dia aqui da nossa data está nas datas bloqueadas, também. Sai dali então, do calendário. Dou um F5. Perfeito. Dia 20. Não era para estar aparecendo aqui. Deixa eu validar aqui. A gente está retornando. Dezembro.BlockedDates 20. BlockedDates.BlockedDates.IncludesDate.Get. O date aqui dentro. Deixa eu ver. Tá. Dando uma investigada aqui, olha só. Year 2012.Month 11. Ele está fazendo a requisição lá para o back-end, buscando as datas bloqueadas do mês 11. Cara, lidar com datas é uma paixão dentro da programação. Por quê? Porque o JavaScript começa o mês no zero. Janeiro é zero. É incrível. Então, aqui no mês, eu vou enviar ele sempre com mais um aqui para o back-end, para buscar a data correta. Então, dou um F5 aqui agora. Ah, tá aqui com um slow 3G, peraí. Agora sim, o dia 20 já está bloqueado, porque não tem mais horários disponíveis no dia 20. E o dia 26 e o dia 27, que ainda tem horários disponíveis, ele não está mais bloqueado. Sim, a gente terminou de fazer todas as verificações de bloqueio aqui dentro do calendário. Foi bastante coisa, eu sei. É cansativo de certa forma, é muita coisa. Mas assim, eu não queria deixar a aplicação rasa, sem colocar em prática o que uma aplicação real teria que ter. Sabe que são todas essas verificações. E talvez até mais. Então, isso é super importante. Tudo o que a gente construiu aqui é coisa que você provavelmente em algum momento da vida vai enfrentar. Esse trabalho com datas é uma coisa bem chata, bem complexa. Só que se a gente conseguiu já antecipar esse trabalho que você vai ter no futuro aqui dentro do Ignite Call, que beleza. Porque em algum momento que você for precisar trabalhar com datas, você vai lembrar disso. Vai lembrar de todos esses métodos que a gente utilizou aqui, que dá para aprender bastante coisa. E é isso, bora continuar, porque a gente ainda não finalizou a aplicação. Para finalizar a falta, realmente, a gente terminar a parte aqui de confirmação do agendamento. Colocar ali o nome, e-mail, criar o agendamento e integrar com a agenda do Google. Bora lá."
  },
  {
    "id": "b3e836b5-5502-4f8d-99a4-cf92d0f14838",
    "title": "Fluxo da confirmação",
    "transcription": "bora lá então a gente vai começar a preparar agora o nosso fluxo aqui para a parte de confirmação e o que eu quero dizer com o fluxo para a confirmação a gente está selecionando hoje aqui a data e isso lá dentro do nosso calendar step fica aqui dentro de selected date fica a nossa data selecionada show de bola, só que lá dentro do schedule form aqui que é basicamente onde a gente tem o componente do calendar step ou seja aqui dentro a gente quer basicamente conseguir poder escolher entre devo exibir o calendar step ou devo exibir o confirm step eu preciso ter aqui é a data selecionada do usuário também só que é importante entender que lá no calendar step aqui esse estado que a gente tem o selected date é especificamente a data selecionada e não o horário selecionado pelo usuário porque aqui embaixo no horário selecionado que a gente criou esse time picker item a gente nem colocou on click ainda aqui ou seja a gente nem criou essa funcionalidade ainda então o que eu vou fazer aqui tá eu vou aqui dentro do calendar step eu vou receber uma propriedade chamada on select date time pra ficar um pouco mais claro que quando o usuário selecionar tanto a data quanto o horário eu quero chamar essa função enviando a informação da data que é um date lá pra cima ou seja pra quem está chamando esse componente calendar step que é o nosso schedule form eu vou pegar essa função aqui dentro e aqui agora a gente vai é criar deixa eu talvez minimizar isso aqui e aqui nós vamos criar então uma função chamada handle select time e veja que não é date time tá porque porque essa função ela vai ser chamada quando o usuário selecionar o time específico o horário e não a data porque a data a gente já selecionou previamente então aqui ó eu vou basicamente chamar essa handle select time passando o horário e aí se a gente tem o horário e aqui eu não botei pra ela receber um parâmetro por isso que está dando um bug aqui mas se a gente está tendo o horário ou seja que o horário do usuário é que o usuário selecionou e a gente tem a data que ele selecionou a gente consegue criar um objeto date que tem todas essas informações juntas então vou criar um objeto chamado date time ou date with time o que você preferir e aqui a gente vai usar o date.js novamente passando o nosso selected date que é a nossa data selecionada no calendário .setHour com a nossa hora ou seja eu tô pegando a data selecionada colocando a hora selecionada e aqui pra garantir que a gente vai estar no começo da hora eu vou dar um startOfHour pra ele colocar os minutos segundos milésimos centésimos tudo zero pra gente não ter qualquer tipo de erro nesse ponto e aqui dentro eu vou chamar a nossa função onSelectDateTime passando o nosso date with time porém eu preciso isso aqui é no formato de data então aqui eu dou um ponto to date no final e ele já quebrou ficou bem legal e aí eu já passo lá pra cima como um formato de data e aí agora teoricamente lá no meu schedule form eu consigo ter um SelectedDateTime que é um estado e ele vai armazenar basicamente date ou nulo né e aqui eu vou passar pra nossa calendar step o nosso a função onSelectDateTime setSelectedDateTime que é o nosso estado e aqui eu vou fazer simplesmente uma condicional e aí aqui no react eu posso fazer a condicional até sem substituir esse return eu posso fazer por exemplo se eu tenho uma SelectedDateTime eu posso dar um return aqui em cima ele vai ser um early return então não precisa nem else nem nada disso não precisa fazer um operador ternário aqui dentro e aqui dentro eu vou mostrar então o nosso confirm step show de bola vamos testar aqui agora vou salvar volto no Chrome e agora vou selecionar por exemplo o dia de hoje 11 horas e ele já aparece o nosso confirm step porém lá dentro do confirm step eu preciso mostrar os dados aqui da data e do horário selecionado por isso o confirm step também precisa saber qual que é a data e aqui para ficar um pouco mais semântico eu vou chamar de scheduling date porque agora como a gente saiu digamos do contexto de calendário onde o calendário poderia ser utilizado em qualquer situação dentro da nossa aplicação não necessariamente só para a parte de agendamento a confirmação por sua vez ela está totalmente atrelada ao agendamento é a confirmação do agendamento então lá dentro faz mais sentido chamar a data de data do agendamento assim fica mais claro depois para trabalhar com essa informação e aqui vou passar o nosso SelectedDateTime lá dentro do confirm step agora eu vou receber esse scheduling date que é do tipo date ele é obrigatório né até para mostrar esse componente scheduling date e agora a gente pode mostrar aqui em tela as informações certinho então por exemplo date with time vou pegar aqui o nosso day.js já importou vou pegar aqui o scheduling date.format e aí a gente pode simplesmente formatar aqui dd por exemplo boto coxetes para escapar d que representa isso aqui agora o nosso mês por extenso mmmm novamente d e o ano yyyy e aí nós já temos aqui o nosso melhor a nossa data somente né então chamar de describe date e aqui nós temos vou criar o nosso describe time que também vai fazer o day.js no scheduling date porém o format aqui agora vai ser hhmm se não me engano nesse formato e um hzinho aqui no final e aí aqui a gente bota o describe date aqui a gente bota o nosso describe time e vamos testar então já deu certo 21 de dezembro 2022 11 horas que é o horário que eu selecionei e aqui o cancelar ele precisa voltar para a tela anterior né então o que eu vou fazer aqui ó dentro do nosso scheduling form eu vou criar é uma função chamada handleClearSelectedDateTime que ela basicamente vai preencher o selectedDateTime com nulo né e aí aqui dentro do confirmStep eu vou mandar eu vou receber na verdade uma função como propriedade onCancelConfirmation isso aqui não precisa receber nenhum parâmetro tá é só uma função que ela vai ser disparada e até vou pegar aquela aqui nas propriedades onCancelConfirmation ela vai ser uma função que vai ser disparada quando o usuário clicar no botão de cancelar então aqui onCancelConfirmation e aí lá no schedule form a gente vai passar onCancelConfirmation como o nosso handleClearSelectedDateTime e aí eu volto aqui no Chrome olha só o fluxo vai ficar bem legal a gente seleciona o horário dá um cancelar e ele volta para o calendário então a gente vem selecionando de novo já tá dando tudo certo e a gente consegue voltar então para o original e agora o nosso fluxo aqui já tá tudo pronto fluxo de confirmação falta a gente realmente enviar esses dados aqui para o back-end e comunicar com a nossa API do Google também para criar o evento lá dentro da API"
  },
  {
    "id": "27acc8c8-8f37-4632-9077-6392b9d2b212",
    "title": "Refresh de token do Google",
    "transcription": "A primeira coisa que a gente vai ter que fazer aqui na nossa aplicação é que, se você lembra, quando a gente criou a autenticação com o Google, eu falei que esse access token, que é o token que a gente tem configurado para conseguir acessar a API do Google em nome do usuário que logou na nossa aplicação para poder criar eventos, trabalhar com a API, mexer no que a gente quiser, ele tem uma data de expiração. E o expiresAt está aqui do lado, em Unix Timestamp, só que isso aqui é um tempo curto. Então, se uma pessoa se cadastra na nossa aplicação e daqui a um mês ela vai receber, por exemplo, um agendamento, esse token com certeza já expirou. Eu não consigo mais trabalhar com ele, ele tem um tempo menos de um dia de expiração. Então, a gente precisa ter uma forma de conseguir atualizar esse token. E a gente chama isso de uma estratégia de refresh token, que é muito comum dentro do ecossistema de autenticação, seja com JWT ou Auth, que basicamente é a gente chamar a API do Google, enviando um segundo token, esse que tem uma data de expiração muito maior, geralmente meses, e esse token refresh pode ser trocado por um access token, novamente, válido, com uma data de expiração menor, mas que permite a gente trabalhar com a API. E a ideia aqui é, quando a gente troca por esse access token, a gente recebe um novo refresh token que a gente pode usar numa segunda vez para trocar. Isso é uma estratégia de segurança para que o access token não fique disponível por tempo indeterminado. E, bom, não cabe a gente entrar aqui em tantos detalhes, mas você poderia pensar, tá Diego, mas como é que isso me traz segurança? Porque o refresh token, se ele pode ser trocado por um access token, então eu posso ter um access token para sempre. Sim e não. O ponto é que o access token nunca é gravado no banco de dados, a gente chama ele de um token stateless, ou seja, ele é muito rápido quando uma pessoa faz uma requisição para a API do Google ou para qualquer outra API que usa esse mesmo mecanismo, o access token, como ele não é salvo no banco de dados, ele é apenas checado em runtime, baseado em algum secret que a gente tem ali no file system, uma chave secreta, qualquer coisa assim, é muito rápido a gente validar que esse token é válido. A gente não salva ele no banco de dados toda vez para falar, ah, esse token é válido ou não, bater no banco de dados, seria totalmente jogar performance fora ali, muitas operações de input e output ali no banco de dados. Enquanto isso, o refresh token é salvo no banco de dados. Então mesmo que a pessoa rouba o access token, o refresh token, se a gente expirar o refresh token de uma maneira manual, ou seja, remover ele do banco ou falar que ele é inválido, a pessoa nunca mais vai conseguir trocar um refresh token por um access token novamente. Então por isso que existe essa logística de ter dois tokens e tudo mais. Mas vamos lá. O que eu queria te mostrar basicamente está dentro da própria página aqui do NextAuth. Se a gente vem em documentação, provider, e nós viemos aqui em Google, aqui embaixo tu vai ver que tem uma opção aqui, olha só, um danger gigante. Google only provides refresh token to an application the first time a user signs in. Ou seja, não preciso nem traduzir, né? O Google só dá um refresh token na primeira autenticação do usuário. Só que isso é ruim, né? E aí ele tem aqui, pra forçar que o Google reenvie um refresh token, o usuário precisa remover a application da conta dele e fazer o login de novo. Hum, ruim, né? Alternativamente, você pode passar opções nos parâmetros do objeto autorização, lá dentro do NextAuth, que vai forçar o refresh token a sempre vir dentro do processo de login. However, entretanto, isso vai pedir confirmação do usuário toda vez que ele for fazer login. E não tem problema, tá? Essa questão de pedir a confirmação. E aqui então, a gente vai acessar o nosso NextAuth API, e aqui lembra que aqui dentro de params a gente já tinha enviado alguns scopes, porém a gente vai enviar também esses três carinhas aqui, ó. Hum, exatamente. Show de bola. A gente vai enviar então prompt consent, access type offline e response type code. E agora a gente vai testar. Pra gente conseguir testar, a gente vai ter que fazer login de novo aqui na nossa aplicação. Hum, vamos ver... Eu acho que é melhor eu fazer o processo todo do zero, tá? Pra gente realmente não se perder. Então o que eu vou fazer? Eu vou apagar os meus usuários do banco. Deixa eu ver aqui, eu acho que ele não apagou. Eu não criei o cascade aqui nos deletes, né? Então eu preciso apagar primeiro o account, a nossa session. Vou apagar aqui o nosso user time interval, o nosso scheduling e os nossos users. Ou seja, eu estou basicamente limpando o banco de dados. Podia ter feito mais facilmente, né? Só deletar o banco e rodar os migrations do zero, mas tudo bem. A gente já veio até aqui, então tá tudo certo. Tá tudo limpo, zero registros em tudo. E agora a gente vai fazer o processo de se cadastrar na aplicação de novo pra ver se o token ali é salvo. Refresh token. Diego SF, Diego Fernandes. Próximo passo, conectar com o Google. Show, Diego.show.f. Avançado, acessar o Ignite account. Sim. Perfeito, próximo passo. Vamos selecionar aqui o normal já, o que vem. E aqui, um CTO at Rocketseat. Show. Deu tudo certo. E agora lá no Prisma Studio, vamos abrir a tabela accounts e tá lá. A gente pode ver que agora dentro do refresh token, a gente já tem essa informação preenchida. E com esse refresh token, a gente pode então solicitar sempre um token válido pra dentro da API do Google pra gente conseguir fazer qualquer operação lá dentro da API. Então, bora continuar."
  },
  {
    "id": "1514d2be-bf47-46b4-9a8c-90378815dac8",
    "title": "Configurando o Next Auth",
    "transcription": "Nessa aula, o que a gente vai fazer é o setup e o teste também do NextAuth dentro da nossa aplicação. Então, aqui em Get Started, a gente vai vir aqui ó, npm install, NextAuth, vamos lá. E aí ele fala pra gente adicionar uma API root, que a gente já sabe o que é, que é um arquivo dentro da pasta API. Então, to add NextAuth to a project, create a file called, então olha só o nome do arquivo, não é simples, dentro da pasta pages-api-auth. Então, aqui dentro de pages-api, a gente vai criar uma outra pasta auth, e dentro a gente vai criar aquele arquivo lá, cochete, ponto, ponto, ponto, NextAuth, fecha cochete, como a gente está usando o TypeScript, troca JS por TF. E aqui é importante entender, no Next, o que é isso, né. Basicamente, cochete serve pra gente receber algum tipo de parâmetro, então ela é uma rota parametrizada. Quando eu coloco cochete na rota parametrizada, eu basicamente estou dizendo, opa, se a gente tem dentro de API, então localhost, 2.0.0.0, localhost 3000, por exemplo, barra API, barra auth. Quando eu boto cochete, eu estou dizendo que eu posso colocar qualquer coisa aqui dentro. E essa qualquer coisa é um parâmetro que vai ser repassado pra dentro da nossa rota, pra dentro do arquivo. Assim como no Express, a gente tem, por exemplo, o cochete ele funciona da mesma forma que a gente tem o dois pontos lá, que a gente pode receber um parâmetro. Quando eu boto o ponto, ponto, ponto, eu estou dizendo, basicamente, que eu posso ter múltiplos parâmetros sendo enviados ali pra dentro. Como que seriam múltiplos parâmetros? Seriam, basicamente, várias informações, cada uma separada por barra. Então, não interessa quantas vezes eu bote barra, qualquer coisa aqui, no final, ele vai sempre redirecionar pra essa mesma rota, enviando cada um desses carinhas aqui, como um parâmetro lá pra dentro do NextAuth, e aí a gente pode acessar. A gente não vai acessar, na verdade, quem vai acessar isso é o próprio NextAuth, que ele já automatiza essa parte pra gente. Aqui dentro do arquivo do NextAuth, a gente vai copiar aqui o exemplo dele, e claro que aqui eu vou mudar algumas coisinhas. Então, ele cria, basicamente, um carinha chamado AuthOptions. Como a gente está usando TypeScript, eu gosto de tipar isso aqui. Então, a gente pode tipar isso aqui com dois pontos, NextAuthOptions, que ele não conseguiu importar automaticamente, mas isso aqui existe, e existe lá de dentro do NextAuth. E pronto. E dessa forma, a gente já consegue dar um control espaço aqui dentro, e ele já traz todas as opções do NextAuth. Aqui o exemplo dele, ele traz uma configuração usando o GitHub, só que a gente vai usar o Google. Então, eu vou trocar aqui pra GoogleProviders, e aqui a gente troca pra GoogleProvider. E aqui, já começou a dar erro. O GoogleProvider aqui, ele pede que a gente envie o ClientId, que eu vou mandar o nosso Process.env, e aí o nome da variável lá, que era o GoogleClientId, que a gente ia salvar. E ele pede também o nosso ClientSecret, que eu vou mandar Process.env.GoogleClientSecret. Deixa eu só validar se era esse mesmo nome. Show, show de bola. E aqui ele tá dando erro. TypeString undefined is not assignable to typeString. E aqui, o mais correto seria a gente fazer um parse dessas variáveis, e validar que elas não poderiam estar vazias. Mas só por enquanto, eu vou basicamente fazer um... se não tiver setado, ele simplesmente bota um valor vazio, e aí vai dar erro. Não necessariamente tem um problema agora. Pra testar, eu acho que tá ótimo assim. A gente pode salvar isso aqui agora, e vamos continuar o tutorial lá do NextAlpha. Beleza, vindo aqui pra baixo, outra coisa que ele pede é pra gente acessar a página App, e a gente vai colocar o SessionProvider. Então eu vou importar SessionProvider de dentro de NextAlpha.react, e eu vou colocar ele por volta do nosso componente. E esse SessionProvider precisa receber uma propriedade Session, que vem de dentro dos PageProps. Então eu vou copiar o PageProps aqui, a gente vai botar ele no lugar deste aqui, e pronto. Basicamente o que eu tô fazendo aqui é uma desestruturação. Então de dentro do PageProps, eu tô tirando a Session, caso ela exista, e o resto continua sendo PageProps. Então ele tira a Session lá de dentro, passa pro SessionProvider, o resto, que já era o que vinha antes aqui dentro, continua sendo repassado pro nosso componente, que é a nossa página dentro do Next. Achou? Perfeito, vamos dar uma olhada aqui embaixo. E agora ele já mostra como que a gente faz o processo de autenticação, que é o que a gente vai testar aqui agora. Lá no nosso Connect Calendar, aqui dentro do Index, a gente vai fazer o seguinte. Aqui embaixo, no nosso botão de conectar, no OnClick, eu vou chamar uma Arrow Function, e aqui dentro eu vou executar o método SignIn. Vou dar um CTRL espaço aqui. Esse método SignIn, ele precisa vir de dentro do NextAuth, que ele não conseguiu puxar automaticamente. Então, vamos lá. Import from NextAuth barra Client, se eu não me engano. SignIn, deixa eu pegar aqui, Connect Calendar, SignIn vem de NextAuth barra React. E aqui eu pego SignIn, e aqui eu chamo o método SignIn, e aí eu passo como parâmetro qual que é o Provider, Google, pra ele fazer o login com Google. Show de bola. Posso voltar aqui no Chrome agora, e a gente vai testar se está funcionando. Como a gente mudou uma variável ambiente, eu acho que o Next, eu não tenho certeza se ele carrega, eu acho que a última versão do Next ele recarrega sozinho, então vamos testar. Vamos lá direto pra aplicação, dar um 5 aqui só pra garantir. Vou clicar em Conectar. Erro. This page could not be found. API barra Auth, barra Error. Vamos lá, com calma. API barra Auth, NextAuth, está aqui dentro. Eu vou reiniciar o meu servidor só pra garantir que não é algum tipo de cache. Então, Register barra Connect Calendar. Vamos tentar de novo. Realmente está dando erro, então vamos entender o que está acontecendo aqui dentro da nossa página. Process, Env, Google Client ID, Google Client Secret, Connect Calendar, Sign In, Google, Pages. Já lembrei. Lembra que a gente falou que todas as rotas da API precisam terminar com .api.ts? E é isso que a gente errou. Então, o NextAuth também precisava terminar com isso, senão ele não funciona. E aí ele já dá um erro aqui embaixo. No Secret, está vendo? Se a gente até abrir o link que o erro dá pra gente. Basicamente, o que acontece? O NextAuth, como ele lida com toda a parte pra gente de geração de token, ele cria pra gente toda essa parte de JWT, todos os tokens pra nossa aplicação, comunicar front-end com back-end de uma maneira segura, a gente precisa ter um Secret. O Secret, pra quem já trabalhou com JWT, sabe que é um segredo, como o nome da variável já diz, utilizado pra assinar o token. Essa assinatura torna aquele token, de alguma forma, impossível de ser manipulado, a pessoa poder incluir uma informação naquele token, porque com essa assinatura, o token, se a pessoa troca alguma coisa ali dentro, ele fica invalidado, a assinatura não bate mais. Então, o Secret é uma informação que vai ser utilizada pelo Next apenas na camada server-side, na camada back-end, ou seja, não é algo que vai ser usado pelo front-end do Next, é utilizado pra construção desses tokens. E aqui ele até dá uma dica, que a gente pode criar um Secret usando o OpenSSL, se você estiver no Mac ou no Linux, o OpenSSL já existe por padrão, se você estiver no Windows, eu acho que você não consegue usar o OpenSSL, mas não tem problema, porque o Secret pode ser qualquer coisa, aqui ele só dá uma dica pra você conseguir gerar um aleatório. Aqui dentro a gente vai criar uma variável, como ele chama, NextAuthUnderlineSecret, e a gente joga qualquer coisa, aqui literalmente pode ser qualquer coisa. Essa barra aqui, ela pode ser problemática, então pra garantir eu vou botar aspas duplas por volta, pra ele não entender essa barra, porque ele tava até dando um bugzinho ali, então vamos deixar com aspas duplas, que é melhor pra garantir. Show, já carregou, já recarregou o env, então vamos testar novamente. Localhost, na verdade, register barra connect calendar, a gente vem agora em conectar, e ele deve abrir o site da Google agora. Aí, ele já pede aqui agora qual conta que eu quero usar, para prosseguir para o Ignite Call, legal, então ele já mostra aqui a minha aplicação, e aqui, posso clicar em diego.shell.f, por exemplo, e pronto, tô logado. E claro que ainda falta muita coisa, mas o NextAuth, ele transforma o processo de login muito tranquilo. Como que eu sei que eu tô logado? Primeiro, a gente pode fazer um teste muito rápido, eu posso vir aqui em Application, dentro de Cookies, eu vou ver que tem aqui vários cookies do NextAuth, ou seja, o NextAuth, ele criou vários cookies aqui, então, cross-site request forgery, se não me engano, esse aqui é um cookie para a gente evitar um tipo de ataque específico, callback URL, e o session token, esse session token aqui, é o token JWT, gerado pelo próprio NextAuth, para comunicação entre o front-end e o back-end da nossa aplicação. Não é algo que a gente precisa se preocupar agora, é um token sem payload e tudo mais, a gente vai conseguir customizar ele no futuro, caso a gente queira, mas para a gente realmente saber que a gente está autenticado, olha que legal, aqui na página Connect Calendar, eu posso usar um hook do React, do NextAuth, chamado useSession, e esse useSession aqui, que deveria estar sendo importado automaticamente, não sei porque meu TypeScript está meio bugadinho, esse useSession aqui... Cara... Por que que meu... Por que que está tão lento? É muito louco, porque o VS Code dá umas travadas, não sei se acontece com você, mas eu quase não tenho memória, processador, para realmente precisar travar, mas tudo bem. Quando a gente usa esse useSession aqui, agora a gente consegue, através dessa session aqui, obter informações do usuário logado. Então, só para mostrar, estou só exemplificando, vou botar aqui, por exemplo, um texto qualquer, e aqui dentro eu vou tentar mostrar json.string.py, session.data, então todos os dados que estão na sessão do usuário. Salvo aqui agora, volto na aplicação e olha lá, ele já mostra aqui para a gente, deixa eu botar aqui um pré por volta, aí ele não quebra a linha, mas tudo bem. Olha só, aqui tem um json com todos os dados do usuário, o Diego Fernandes, meu e-mail, a minha imagem de perfil, a data que expira o meu acesso a essa conta. Então, basicamente eu posso entender que eu estou logado, esse token JWT já tem todas as informações ali para a gente. Mas agora, claro, a gente não vai usar esse session necessariamente agora, a gente ainda precisa fazer mais coisas, porque apesar de que a gente conectou com a conta do Google, a gente não pediu permissões para o usuário para a gente acessar os calendários, e a gente precisa pedir essa permissão no momento do login, porque senão depois a gente não consegue mais obter essa permissão. Então, vamos fazer isso agora."
  },
  {
    "id": "80e341de-3829-4476-9f18-491a64962524",
    "title": "Finalizando Adapter do Prisma",
    "transcription": "Vamos continuar os métodos do nosso adapter. No getUserByAccount() aqui a gente vai fazer um pouquinho diferente. Eu vou começar buscando no meu banco de dados os dados da account, especificamente. Então, eu vou utilizar o prisma.account.findUniqueOrThrow() E aqui o findUniqueOrThrow() é basicamente eu quero encontrar uma account e caso ele não encontre ele dispara um erro. Porque aqui é obrigado que a account exista. E aqui a gente tem... eu preciso buscar... Lembra que eu falei que lá na account, que é a relação do usuário com alguma rede social, algum provider de OAuth. Eu tenho o provider, que aqui vai ser tipo Google, GitHub, e-mail, que seria para e-mail e senha. E o provider.account.id A soma desses dois campos aqui forma um campo único. Ou seja, só pode existir um provider.account.id para cada provider, para cada usuário. Então, aqui no where do prisma, até lá dentro do nosso esquema, a gente criou aqui um unique, provider e provider.account.id Então, aqui no where, quando eu dou um CTRL e espaço, ele traz que a gente pode procurar pela soma desses dois campos. Então, eu passo dessa forma aqui e agora ele já traz os dois campos aqui dentro. Provider e provider.account.id Que aqui no nosso caso, ele está em QML Case. Então, eu faço dessa forma. E aí, da nossa account, eu preciso buscar o usuário, porque esse método aqui é getUserByAccount e não getAccount. Então, com o prisma, a gente consegue aqui dar um includeUserThrough. Basicamente, ele traz agora junto com a account, o user. Então, agora, daqui de dentro, eu posso fazer o seguinte. A gente pode fazer logo uma desestruturação aqui em cima, user. E aqui, basicamente a mesma coisa que a gente fez nos demais. Então, retornar o usuário. No updateUser, a gente recebe os dados aqui do user. Então, a gente vai fazer aqui dentro um await prisma.user.updateWhereId é igual a user.id. E os dados que eu quero atualizar. Os dados que a gente pode atualizar do usuário, até dando uma olhada aqui. id não pode atualizar, username não. É nome, email e avatar. Eu acho que são as únicas opções. Então, nome é user.name, email é user.email e avatar.url é user.avatar.url. E aqui embaixo, esse método também precisa devolver o usuário. Então, a gente faz aquele mesmo return que a gente tem lá em cima e devolve aqui embaixo. Faltou alguma coisa aqui. Type string property id is incompatible. id pode ser undefined. Ah, porque ele está como partial. Tá, aqui o id não vai ser undefined, não existe isso. E aqui embaixo, o update, será que ele retorna? O user retorna. Então, vamos fazer o seguinte. Aqui, eu vou chamar isso aqui de const prisma user. E aí a gente usa o prisma user aqui embaixo. Porque por causa desse partial aqui, ele entende que todos os campos podem não existir. Mas isso não é verdade. E aí são algumas coisinhas do NextAuth que não tem muito como a gente mudar. A gente tem que trabalhar com elas. Mas não faz sentido. O usuário nunca vai existir sem o id. Então, é por isso que ele causa alguns bugs chatinhos aqui que a gente tem que lidar, infelizmente. Vamos lá. No caso do deleteUser, aqui. Esse method deleteUser, ele não é obrigatório. A gente não precisa implementar ele. Até porque na nossa aplicação a gente nem criou uma funcionalidade de remoção do usuário. Então, não tem problema. LinkAccount, tá. O que é esse linkAccount? Basicamente, é quando o usuário loga com um provider. Por exemplo, ele já tinha uma conta antes com o Google e agora ele está logando com uma nova, com o GitHub. E aqui, infelizmente, a gente é obrigado a implementar todos. E é legal porque a gente já vai aprendendo também. Isso aqui, basicamente, o que a gente tem que fazer? Criar uma nova account. Então, a gente vai criar aqui. E dentro de data vai estar todos os dados da nossa account. Então, são bastante dados. Vamos lá. UserId, account.userId. Type, account.type. Provider, account.provider. Tem bastante informação, tá. Provider, account.id é igual a account.providerAccountId. A única diferença é que um do lado está com o Snake Case e o outro com o Camel Case. RefreshToken, account.refreshToken. AccessToken, expiresAt, account.expiresAt. TokenType, account.tokenType. Scope, account.scope. IdToken, account.id. E o último, sessionState, account.sessionState. Beleza. UnlinkAccount, também não é obrigatório. CreateSession, aqui, mais rapidinho. É basicamente a gente fazer um prisma.session.create. Com os dados userId, que é o userId que vem aqui nos parâmetros. Expires, que também vem dos parâmetros. E sessionToken, que também vem dos parâmetros, aqui de cima. E aí a gente precisa retornar, daqui de dentro, essas três informações de novo. Então, userId, sessionToken e expires. Feito isso, a gente vai para o próximo, que é o getSessionAnyUser. E, novamente, é um pouquinho maior esse. A gente vai fazer um await. Prisma.session.findUniqueOrThrow. Where sessionToken é igual ao sessionToken que eu estou recebendo daqui de cima. E aqui, como eu preciso retornar o usuário, eu vou também fazer aquele include do Prisma para trazer os dados do relacionamento do usuário. O usuário que está relacionado com aquela session. E aqui eu pego a session. Ou melhor, aqui eu vou ter a session, exatamente. E aí, para desestruturar, eu vou fazer da seguinte forma. Na verdade, eu vou tirar o user dele de dentro e todo o restante eu vou botar em uma variável chamada session. O mosquito chato. E aqui eu preciso retornar, então, uma porrada de dados. Preciso retornar session e preciso retornar o user. E na session, se eu vou dando Ctrl e espaço, ele já fala o que eu preciso retornar. Então, userId, que eu pego de session.userId. Expires, que eu pego de session.expires. SessionToken, que eu pego de session.sessionToken. E do user, é basicamente os campos que a gente já tem lá em cima. Então, a gente pode reaproveitar aqui em algum lugar que eu pego. Vou só trocar de PrismaUser. PrismaUser.portUser, que é o que eu já tenho aqui em cima. Show. DeleteSession a gente não vai utilizar. O UpdateSession a gente precisa. E ele vai ser parecido com o Update que a gente fez aqui no usuário. Vou até copiar só pra gente reaproveitar a lógica, mas vai ser diferente. Então, aqui vai ser PrismaSession. AwaitSessionUpdate. Ela vai ser baseada no Token. Então, where SessionToken. A gente vai atualizar os dados. Aqui, eu consigo pegar userId e expires, que eu não estava no exemplo. Então, aqui no data, eu vou mandar o expires e o userId, que é igual ao userId que eu pego daqui de cima. E aqui no retorno, eu preciso retornar todos os campos. Então, SessionToken, userId e expires. Aqui. Type undefined. SessionToken. Deixa eu ver o erro certinho aqui. Type of userId are incompatible. Type string undefined is not assignable. Por que o userId? Ah, tá com uma string undefined aqui. Então, vamos usar igual a gente fez antes. PrismaSession.userId. PrismaSession.expires. E aqui, PrismaSession.SessionToken. Eu uso os dados que foram retornados do banco de dados. Estamos quase acabando o nosso adapter. E sim, é bastante código. Eu sei que aqui é um processo quase de copia e cola. Mas é uma coisa que a gente vai ter que fazer mais cedo ou mais tarde. Porque não tem como fazer por partes esse PrismaAdapter aqui. Porque, como a gente está usando TypeScript, o Prisma iria reclamar. A gente não tem como cadastrar um adapter ali no NextAuth incompleto. Então, faltam... Esse CreateVerificationToken e o UseVerificationToken, na verdade, eles não são necessários, se não me engano. E pronto. Nosso adapter está finalizado. Faltou apenas o método create. Mas, para eu te mostrar já como que a gente usa esse adapter, basicamente... Deixa eu fazer o seguinte. Vou retornar um nulo aqui. Será que ele já para de dar erro? Tá, ele não vai parar de dar erro. Mas tudo bem. Aqui dentro do NextAuthApiTest, a gente vai passar aqui dentro uma propriedade chamada adapter. E aí, aqui dessa propriedade, a gente vai chamar a nossa função PrismaAdapter. Cuidado para importar PrismaAdapter da que a gente criou, e não do NextAuthPrismaAdapter. Então aqui, PrismaAdapter, do que a gente criou. Chama a função. E pronto. A partir desse momento, o NextAuth já vai saber como que ele vai persistir as informações do usuário no banco de dados, porque ele vai usar os métodos que a gente criou. Falta o último método, que é o createUser. E aí, acabou. Copia e cola de código. A gente vai ver como tudo isso vai funcionar. E, bom, vai ficar bem legal no final das compras."
  },
  {
    "id": "8b61209f-deac-46db-b483-48a229a512de",
    "title": "Corrigindo listagem do histórico",
    "transcription": "E agora, na nossa última aula aqui desse módulo, uma das coisas que ficou faltando aqui, que eu acabei esquecendo, que você provavelmente fez a navegação aqui para a página do histórico e percebeu, é que quando a gente está navegando para a página do histórico, ele fica com a tela toda em branca. E até, meu Deus, parece que abriu o sol aqui contra mim. Mas, se a gente der uma olhada aqui no console, o erro que está acontecendo, ele está falando, basicamente, que o erro está acontecendo dentro do método toDate, que é chamado no compareAsk, que é chamado no formatDistanceTo, que é chamado no formatDistanceToNow. Se eu clicar aqui no index, ele fala exatamente onde está dando o erro aqui para a gente, por causa dos sourceMaps. E aqui dentro, a gente tem o erro nessa linha aqui. Isso está acontecendo porque, como a gente tinha visto antes, quando a gente salva os dados do histórico aqui, dos ciclos da nossa aplicação, o localStorage só suporta strings. Então, ele não suporta outros tipos de classes, objetos, como é o Date. Então, essa data aqui também precisa ser convertida usando o newDate. O newDate, o que ele vai fazer? Se o valor que a gente passar aqui já for uma data, não vai acontecer nada. E, se for mais string, ele vai converter para uma data em si. Então, salvando isso aqui agora, eu volto e pronto. Nosso histórico já voltou a funcionar. Não tem muita preocupação quanto a isso. E pronto. Agora sim, a gente está com a aplicação finalizada. E, poxa, essa aplicação aqui foi demais. Foi muito massa o estágio que a gente chegou e o tanto de coisa que a gente aprendeu. Foi uma aplicação longa, talvez para você cansativo em alguns momentos, mas eu tenho certeza que o número de coisas que você aprendeu aqui foi satisfatório, foi recompensador, digamos assim, no final. E, só para a gente dar um recap aqui, vamos dar uma olhadinha em tudo o que a gente viu nessa aplicação. A gente falou aqui dentro sobre estilização. A gente viu o StyledComponent pela primeira vez. A gente falou sobre roteamento com React Autodown, que a gente não tinha feito anteriormente. A gente falou sobre contextos, que foi uma das coisas mais incríveis que a gente conheceu nesse módulo e uma das coisas que você mais vai utilizar no seu dia a dia trabalhando com React. A gente falou sobre reducers, que é um formato de você trabalhar com dados complexos e realizar ações em cima de listas complexas de dados e conseguir ter um único local para armazenar essas informações e gerir essas informações. Pô, o que mais que a gente viu aqui? Eu já nem lembro. Vamos dar uma olhada no package.json aqui. A gente falou sobre o Imer também, que é uma forma de a gente trabalhar com a imutabilidade de uma maneira mais simples. A gente falou sobre o React Hook Form e a validação utilizando o Hook Form Resolvers, usando os God também. Então, esse módulo aqui, com certeza, ele foi o módulo mais completo que eu já gravei sobre React na minha vida toda. Então, se você chegou até aqui, parabéns. Foi, com certeza, um grande avanço e um grande aprendizado. Mas bora pra cima que ainda tem muita coisa pela frente. A gente se vê por aí. Valeu!"
  },
  {
    "id": "6c824b12-bcae-4ea1-be71-b4dd92ee91d1",
    "title": "Salvando estado no storage",
    "transcription": "Uma coisa aqui que eu vou fazer para a nossa aplicação ficar melhor é salvar as informações aqui dos ciclos no storage do browser. Assim, quando a gente dá um F5 na página, a gente não perde e não tem que criar todos os ciclos do zero. Isso é legal até porque, como a nossa aplicação não está usando uma API, um back-end, salvando essas informações do banco de dados, a gente tem alguma forma de manter isso ali em algum lugar. Porque, bom, o usuário que vai estar utilizando uma aplicação como essa, que tem como ideia pegar o histórico de ciclos que ele já tenha criado previamente, precisa ter essas informações salvas ali. Então, o que a gente vai fazer? Aqui no meu contexto, eu vou criar um useEffect, porque eu quero que toda vez que o meu cycleState mudar, independente de qual seja o motivo, eu vou salvar isso aqui no meu localStorage em si. Então, deixa eu até pegar minha cola aqui. Vai ser super simples. A gente vai criar aqui uma variável, vou chamar de state.json. O localStorage só suporta que a gente salve texto dentro dele, então eu vou fazer um json.string.py do meu estado. E eu vou dar um localStorage.setItem. Aqui eu vou dar um nome e aqui eu salvo o valor. E aí, aqui uma dica. Quando você for salvar informações no localStorage, primeira dica, sempre coloque um prefixo com o nome da aplicação. Eu, como padrão, gosto sempre de botar arroba e o nome da minha aplicação. Então, por exemplo, igniteTimer. E aí, dois pontos, o nome da informação. Então, vou chamar aqui, por exemplo, de, nesse caso, cycleState, que é o nome da informação aqui. Por quê? Porque como a gente está trabalhando em localhost, é muito comum, se você salvar nomes genéricos aqui, quando você está trabalhando com várias aplicações ao mesmo tempo, uma substituir o valor da outra no localStorage. Porque todas as aplicações no nosso localhost vão dividir o mesmo localStorage. Então, nesse caso, eu gosto sempre de botar o prefixo com o nome da aplicação, para não ter chance de outra aplicação substituir. E aí, o nome do meu localStorage. Outra dica, que daí é muito mais para produção do que para desenvolvimento, é a gente colocar aqui uma versão, digamos assim, dessa informação que eu estou armazenando no estado. Então, aqui, por exemplo, vou botar 1.0.0. Por que eu coloco uma versão? Por que eu versiono o nome dessa informação que eu estou salvando no storage? Porque, se em algum dia eu precisar trocar essa variável, salvar um valor diferente, quem estiver com o valor antigo pode acabar ocasionando algum bug na minha aplicação. Então, o que eu quero dizer com isso? Imagine que, por exemplo, hoje eu estou salvando a informação em um formato. Imagina que, no futuro, eu pegue e salve essa informação em outro formato. A pessoa que está no formato antigo, assim que ela abrir a aplicação, vai dar erro, porque ela está com o formato dos dados desatualizado. E aí, a nossa aplicação vai tentar ler esse formato para salvar, para recuperar os dados que estavam armazenados no storage, mas vai dar erro, porque está no formato errado. Então, é legal a gente definir assim, porque depois, quando eu trocar aqui a versão, pronto, quem estava com a nossa aplicação no formato antigo, digamos, aquelas informações vão ser inúteis, elas não vão mais ser utilizadas. E aí não vai mais dar erro. Então, eu gosto sempre de fazer nesse formato aqui que a gente está vendo. Então, dessa forma eu já salvo. A gente pode ver que só de eu dar um F5 aqui na aplicação, eu venho aqui em Application, venho no meu Local Storage, eu já vou conseguir encontrar aqui Ignite Timer, Cycles State. E aí eu posso até filtrar por Ignite Timer e eu vejo só da minha aplicação. E aí já está aqui. E agora se eu venho aqui, adiciono um projeto, 20 minutos, dou um Começar, ele já mantém sincronizado, já está atualizando aqui o nosso Local Storage. E agora se eu dou um F5 na aplicação, não deu nada. Por quê? Porque eu estou só salvando no Local Storage, eu não estou recuperando, digamos assim, esses dados. E aí como é que a gente vai fazer aqui? O UseReducer pode receber um terceiro parâmetro, olha que legal, eu posso enviar um terceiro parâmetro para o meu UseReducer, que é uma função, e essa função é disparada, digamos, assim que o Reducer for criado, para eu recuperar os dados iniciais do meu Reducer de algum outro lugar. Então aqui dentro eu posso fazer, por exemplo, const StorageStateAsJson igual LocalStorage.getItem, coloco o mesmo nome, e aí se eu encontrar algum dado aqui dentro, eu vou retornar um json.parse nesse StorageDataAsJson aqui. E agora se eu dou um F5 na minha aplicação, vou criar aqui agora um projeto 1, 20 minutos, vou dar um Começar, e agora se eu dou um F5, ele voltou, só que ele deu um erro aqui, e a gente já vai ver o porquê desse erro, provavelmente porque a data que eu estou salvando aqui agora está sendo salva como String, a gente vai ter que melhorar um pouquinho. Inclusive eu tinha visto um projeto esses dias, mas eu acho que não vale a pena utilizar aqui, que era um parser de json mais profundo, porque hoje o que acontece? Quando a gente transforma uma estrutura de dados JavaScript para json, a gente acaba perdendo o tipo dos objetos. Deixa eu ver se eu até anotei isso aqui, mas eu acho que não. Às vezes eu vejo umas coisas legais e esqueço de dar um star. Então, por exemplo, se eu tenho uma data salva num objeto, e eu salvo esse objeto no local Storage, essa data é salva como sempre String, porque o json não suporta diferentes estruturas de dados, ele é só número ou String, ou Array, mas ele não suporta datas, por exemplo, ou qualquer outro objeto mais complexo. E aí a gente acaba tendo esses erros. E aí a gente vai ter que lidar com esses erros dentro da nossa aplicação, ao invés de num momento aqui de realizar um parse. Mas talvez aqui seria de a gente utilizar essa biblioteca, mas tudo bem, eu não quero usar mais uma biblioteca aqui, a gente consegue resolver isso aí sem problemas. Então, esse erro aqui hoje, esse Not a Number, ele aconteceu lá no meu Countdown. Então, se eu abrir aqui Pages, Home, Countdown, porque aqui dentro eu estou pegando a data do ciclo ativo, que eu espero que seja uma data, e ela está vindo como uma String. Então, talvez a melhor maneira de eu resolver isso aqui, deixa eu até dar uma olhadinha aqui na minha cola, se eu tive que resolver isso também. Eu acredito que sim. Deixa eu olhar aqui rapidinho. Boa, já encontrei aqui. O que a gente vai fazer? Aqui nesse ActiveCycle.startDate, eu vou botar por volta dele um newDate também. Isso aqui o que ele vai fazer? Se esse startDate for uma String, ele vai converter em uma data. Se ele já for uma data, ele não vai fazer nada. Então, isso aqui já deve ser uma data. Se ele já for uma data, ele não vai fazer nada. Então, isso aqui já deve resolver a nossa aplicação. Aqui a gente pode ver que ele está vindo como 20, porque esse código aqui está demorando um segundo para executar. Então, ele demora um segundo pelo menos para fazer o cálculo inicial. E aqui ele dá esse setSecondsPassed na diferença em segundos. A gente poderia otimizar isso, mas eu acho que... Como é que a gente poderia otimizar isso? Aqui no nosso index, ou melhor, lá no meu contexto, onde eu tenho esse estado aqui, amountSecondsPassed, hoje eu estou iniciando ele sempre com 0. Aqui eu poderia fazer o seguinte. Botar uma função aqui dentro, retornar 0. E aí eu posso, dentro dessa função, fazer um cálculo aqui para retornar um valor diferente. E aí eu venho aqui, eu copio esse código aqui, secondsDifference, vou importar essa função aqui, differenceInSeconds. Aqui o nosso activeCycle, ele vem... Deixa eu copiar esse código aqui, vou ter que colocar aqui em cima agora, essa desestruturação aqui para ficar mais fácil. Esse activeCycle também, vou colocar aqui. O activeCycle aqui, agora eu vou fazer o seguinte. Se eu tiver um activeCycle, eu vou retornar a diferença em segundos. Eu vou retornar a diferença em segundos da data atual para a data que o ciclo começou. Então agora eu não vou iniciar o meu amountSecondsPassed sempre com 0. Eu vou, no começo que eu estou declarando, assim que eu declaro esse useState, eu posso usar uma função, assim como a gente fez para o reducer aqui, para calcular qual é o valor inicial dessa variável. E assim eu retorno o valor realmente da diferença em segundos, caso não seja 0. Então vamos testar isso agora. Agora ele já está começando direto. Se eu dar 5 aqui, ele vai começar direto já com a data correta. Massa, né? Então a gente otimizou isso aqui. É uma coisa até que eu não tinha previsto na aula, mas a gente codou junto aqui porque observamos o problema juntos e já codamos. Então ficou bem legal. Um errinho que eu acabei deixando passar aqui e que a gente tem que cuidar é que aqui na inicialização do nosso contexto, do nosso reducer, se a pessoa não tiver nada, o usuário não tiver nada dentro do storage com essa chave, ele não vai cair dentro desse if e não vai retornar nada daqui de dentro. Só que essa função de inicialização do estado aqui do reducer, ela sempre precisa retornar algo. Nesse caso aqui, o que eu vou fazer? Eu quero que quando o usuário não tenha nada no storage, eu retorne o meu reducer vazio, que seria exatamente o conteúdo que eu tenho aqui nesse segundo parâmetro que eu estou enviando para o useReducer. Para eu não duplicar isso, tanto aqui no segundo parâmetro, quanto aqui dentro do return, porque são os mesmos resultados, um atalho que eu posso utilizar é aqui nessa função que eu passo como terceiro parâmetro, eu posso receber o nosso initial state, que é exatamente o conteúdo do segundo parâmetro. Então veja que quando eu passo o mouse por cima de initial state, ele me traz exatamente a tipagem, o formato que está o meu estado aqui. E agora, aqui de dentro, eu posso dar um return initial state. Nesse caso, se o usuário não tiver nada no storage, ele vai retornar exatamente o valor do segundo parâmetro como o valor inicial para o nosso reducer, e assim não vai dar bug quando não tiver nada salvo ali no storage."
  },
  {
    "id": "32e3dd9d-04b0-41a2-ad70-66e3efee186a",
    "title": "Extensão de interfaces",
    "transcription": "Uma das coisas aqui que talvez possa ter passado na sua cabeça, mas talvez não, é que a imagem aqui do HTML, ela recebe um monte de propriedades. Ela não recebe só class, source, out. Se eu der um ctrl espaço aqui, inclusive, na nossa imagem, eu vou ver todas as outras propriedades que ela pode receber. Por exemplo, uma imagem pode ter um title. Se eu quero permitir que, ao chamar o componente avatar, por exemplo, lá no comentário, na sidebar ou no post, possa ser passado um title, eu preciso ter isso no TypeScript. Eu preciso falar, olha, aqui pode haver um title, que é uma string, assim como a gente fez com o out, assim como a gente fez com o source. E aqui eu pego o title, e aí eu mostro o title aqui dentro. Mas eu vou fazer isso para todas as propriedades da imagem? Porque são muitas, né? Mas são muitas, né? Será que eu vou fazer para cada uma delas? Não, a gente não precisa fazer. Quando a gente tem um componente, e esse componente aqui, o retorno dele, é uma tag HTML, como o image nesse caso, ou um button, ou qualquer coisa assim, e a gente quer permitir que os outros componentes que chamarem esse componente, como a gente está fazendo aqui, por exemplo, o avatar, possam, além de ter propriedades que nós criamos, como essa hasBorder, as outras propriedades que possam receber aqui, sejam, por exemplo, todas as propriedades que uma imagem pode ter, todos os atributos que uma imagem pode ter, ou todos os atributos que um button pode ter. A gente precisa usar algo que a gente chama de extensão dentro do TypeScript. Então, o que acontece? Aqui de dentro do React, se a gente procurar por attributes, opa, ficou um S a mais, attributes, a gente vai ver que aqui embaixo ele exporta para a gente algumas interfaces de atributos, como, por exemplo, a HTML, ou melhor, a Image HTML Attributes. Opa, importei errado aqui. Se eu clicar em Control e clicar em cima do Image HTML Attributes, olha só, é uma interface do TypeScript com todas as propriedades que uma imagem, que o elemento image do HTML pode receber. Então, o elemento image pode receber alt, cross-origin, decoding, height, loading, referer policy, sizes, src, src-set, usemap, width. E além de receber todas essas propriedades, a gente vê que essa interface aqui, ela estende uma outra interface chamada HTML Attributes, que são atributos que qualquer elemento no HTML pode receber. E aí, se eu clicar aqui, a gente vai ver que tem muita, muita, muita coisa. Ou seja, aqui no Avatar, se aqui na nossa interface Avatar Props nós estendermos o Image HTML Attributes, e aí, quando eu uso esse Image HTML Attributes, se eu clicar Control de novo aqui, a gente vai ver que ele tem esse menor e maior, esse generic, que a gente já conheceu na última aula, que ele espera aqui, que a gente passe, qual que é o elemento. Então, aqui eu não sei o porquê disso, sendo bem sincero, eu não acho que isso deveria ser obrigatório, mas já que o React pede, a gente precisa passar aqui com sinal de menor e maior, toda vez que a gente vai usar essas interfaces HTML Attributes, seja do Image, do Button ou de qualquer coisa, porque tem de tudo, a gente passe aqui o nosso HTML Image Element, nesse caso é uma imagem, e esse HTML Image Element, assim como a gente fez lá no nosso post, aqui embaixo, ele é uma interface global, então eu até posso clicar em cima dele aqui, mas a gente vai ver que isso aqui é global, a gente não precisa importar de nenhum lugar. E agora, as propriedades que eu tenho aqui dentro, que elas existem dentro de uma tag Image tradicional, eu não preciso mais colocar aqui, então Search não precisa, porque já existe na Image, Out não precisa, porque já existe na Image, Title não existe, não precisa, porque já existe na Image. E mesmo assim, eu posso recuperar essas propriedades aqui. Então, por exemplo, se eu dou um Control espaço aqui dentro desse objeto, ele vai me falar todas as propriedades que existem dentro da tag Image, todas. E aí eu posso pegar aqui o nosso Search, o nosso Out, o nosso Title, para mostrar aqui dentro. Inclusive, quando eu chamar o meu componente de avatar, vou até dar um Enter aqui agora para a gente separar as propriedades, quando eu chamo o meu componente de avatar em outro componente, quando eu chamo o meu componente de avatar em outro componente, eu venho aqui e dou um Control espaço, ele já me fala também, olha, todas as propriedades da nossa Image. Só que tem um problema aqui. Por mais que eu esteja recebendo as propriedades Search, Out e Title, novamente, eu estou limitado, porque eu estou utilizando apenas as propriedades Search, Out e Title. E só estou passando Search, Out e Title. Ou seja, se aqui no comentário eu passar para o avatar qualquer outra propriedade, como um OnClick, por exemplo, isso aqui não vai funcionar. Porque em nenhum momento eu estou pegando o OnClick aqui e passando para o nosso Image. Daí eu teria que novamente fazer OnClick e passar OnClick para cá. Só que isso aqui é muito chato. Novamente, eu teria que repetir isso aqui para todas as propriedades da imagem. E aí tem um hackzinho muito legal que a gente pode utilizar aqui no React, que é o seguinte. Quando eu faço a desestruturação das nossas propriedades, e aqui eu pego, por exemplo, a propriedade HasBorder e coloco em uma variável HasBorder, que daí eu posso usar aqui, HasBorder. Se eu quero pegar todas as outras propriedades restantes, eu posso usar algo que a gente chama de REST Operator. Então, eu posso dar um . . . props aqui. O que isso aqui vai fazer agora? Se eu der um console.log nessas nossas props, e deixa eu comentar o restante das linhas aqui. Se eu salvo isso aqui agora e volto aqui no Chrome e dou um F5, deixa eu ver. Eita, parou de funcionar. Deixa eu rodar aqui o nosso código de novo. npm run dev A gente nem testou se estava funcionando, mas está aqui. Ele só rodou na porta 3.000, eu estava rodando na porta 3.001. Então, aqui no vit-config, eu lembro que a gente tinha configurado, acho que era server e dentro port. Está vendo que até aqui dentro, só por eu estar utilizando o TypeScript, ele já preenche automaticamente. A gente já sabe, né? Vou escrever o server port. Eu estava usando a 3.001. No seu computador, se você está usando a 3.000, não tem problema nenhum. Então, npm run dev, está aqui, 3.001. Agora sim, vou rodar a aplicação de novo. A aplicação aqui está rodando. As imagens pararam de funcionar, tudo bem, porque a gente tirou lá. E agora eu posso ver que ele deu aqui o console.log. Está vendo que no console.log dessas props que a gente colocou aqui, ele trouxe o search da image. E ele trouxe em alguns momentos o alt vazio, porque ele foi passado o alt em algum lugar. Aqui, nos comentários, ele trouxe o alt vazio. Se eu tivesse colocado qualquer coisa aqui, ele traria o alt preenchido. Ou seja, agora, dentro desse objeto props, eu tenho todas as propriedades, menos a resborder. Ou seja, eu estou tirando a resborder de dentro do objeto de propriedades. E o que sobrou, ou seja, o resto, por isso rest operator, eu estou jogando dentro de um objeto chamado props. E agora eu posso vir aqui no nosso componente e fazer o seguinte. Boto chaves, ponto, ponto, ponto, props. Agora eu estou usando o spread operator para pegar cada valor que eu tenho dentro desse objeto props e passando como uma propriedade para minha tag image. E agora eu vou salvar isso aqui. Eu volto no código e tudo está funcionando. Inclusive, veja que eu não passei em nenhum momento o search, nem alt, nem title. Mas, se eu inspeciono aqui a nossa imagem, a gente vai ver que ela está com o search conforme eu coloquei. Inclusive, se eu volto lá no comentário e coloco agora alguma coisa como, por exemplo, um onclick. Coloco uma função. Alert hello world. Salvo. Venho no Google Chrome. Clico na minha imagem. Não deu certo porque eu não posso usar um onclick na imagem. É isso? Você não me permite? Na verdade, isso aqui é a imagem do comentário. Hello world. Então, toda propriedade agora que a gente passar para o avatar vai ser automaticamente enviada para o nosso image. Porque a gente está pegando aqui todas as propriedades e repassando para dentro do image. Isso aqui é muito importante a gente saber porque a gente vai cair em vários momentos que a gente vai precisar usar dessa estratégia quando a gente for utilizar TypeScript nas nossas aplicações React. Um ajuste muito rápido que eu percebi depois de gravar é que aqui no app.tsx a gente também vai ter um erro do TypeScript acontecendo aqui nessa propriedade content. Isso porque quando a gente criou a nossa listagem de posts aqui, por mais que a gente tenha falado aqui dentro que no conteúdo do nosso post os tipos sempre vão ser parágrafos ou links, para o TypeScript, quando eu passo o mouse por cima de posts, veja que ele entende o type dentro do content como sendo uma string, ou seja, qualquer string e não apenas parágrafos e links. E lá dentro do meu componente post eu falo que o meu content, o type dele, precisa ser obrigatoriamente parágrafo ou link. E aqui eu tenho várias opções de como eu poderia otimizar isso, mas uma ótima opção aqui, até para facilitar na hora da gente escrever os posts aqui dentro trazer um pouco de inteligência para o VS Code, quando eu dou um ctrl espaço e ele sugerir, é eu adicionar a tipagem nessa variável posts falando exatamente qual que é o formato que eu espero que ela tenha. E aí aqui eu posso ou criar uma interface para o meu post aqui separada e declarar exatamente qual que é o conteúdo que o meu post tem que ter, o id, o autor e tudo mais, ou a gente pode até reaproveitar a tipagem que a gente já criou no próprio post para trabalhar com isso. Então o que eu vou fazer? Aqui dentro, ao invés de receber dentro do meu post as propriedades author, publishedAt e content eu vou falar que essas propriedades aqui, na verdade vou falar que o componente post, ele recebe apenas uma única propriedade chamada post e ela vai ter o formato exatamente como era antes, author, publishedAt e content. E aqui eu vou falar então que eu recebo essa propriedade post e não port, aqui eu vou pegar então de dentro do meu post e aqui eu tenho que só prefixar post em todos os lugares que eu uso essa variável. Falta mais dois locais aqui. Aqui embaixo, mais nenhum local, show, já não está mais dando erro. E agora o que eu posso fazer é exportar essa interface post daqui de dentro e aqui no meu arquivo principal eu posso importar de dentro de components barra post a minha interface post, porém veja que o nome da interface é igual ao nome do componente. Nesse caso a gente tem duas alternativas, a gente pode fazer um import type, só que aqui o nome vai continuar ficando duplicado, eu poderia renomear aqui dentro, só que nesse caso eu prefiro que a gente renomeie a interface para algo como por exemplo post type, dessa forma a gente evita que a gente tenha nomes duplicados e aí eu importo de dentro do meu componente post o post e o post type, não preciso criar duas importações porque eu já tinha uma importação lá dentro. E agora aqui dentro de post eu vou falar que o formato desse array aqui precisa ser post type e cochetes no final para ele ser um array. E aí a gente já começa a perceber que tem outros erros aqui, por exemplo post type aqui dentro ele não declara que pode ter um id, então vamos colocar aqui um id numérico e pronto, aqui não dá erro, no conteúdo do post também não dá, apesar de a gente não estar utilizando o id. E agora a última correção aqui no componente post, ao invés de eu enviar author, content e published at, agora eu vou enviar todo o meu post lá para dentro do meu componente. E assim fica mais fácil agora, inclusive quando eu adicionar mais informações dentro de cada post, eu vou ter todas essas informações através da propriedade post, eu não preciso ficar me preocupando em enviar cada vez uma propriedade nova aqui para dentro do componente."
  },
  {
    "id": "a67d44ba-235f-40df-9d54-e0e53038a6b6",
    "title": "Entendendo contextos",
    "transcription": "O que a gente vai fazer nessa aula é começar a entender sobre Context API dentro do React. A Context API, então, como eu já falei antes, é uma maneira de a gente compartilhar informações entre vários componentes do nosso app de uma maneira mais simples, sem precisar ficar utilizando várias e várias propriedades para ficar repassando essas informações e evitar aquele problema de prop drilling que eu falei na última aula. E aí, como o nosso app não está funcional, está dando erro pra caramba porque a gente deixou um monte de arquivos aqui bagunçados, o que eu vou fazer aqui para exemplificar como que a Context API funciona antes da gente adaptar a nossa aplicação real para usar esse conceito, é criar aqui, pode ser dentro da pasta Components, pode ser, vamos criar na pasta Source mesmo, só um exemplo, um outro componente chamado Home, mas ele é só um componente temporário, a gente logo vai remover esse componente, que ele tem o intuito de simular a nossa página Home que a gente tem aqui, mas como ela está cheia de erro agora, eu não quero usar ela especificamente para mostrar como funciona. E aí nesse componente Home, eu vou simplesmente criar aqui uma função Home, e aqui de dentro eu vou retornar um H1 escrito Home, e aí lá no nosso app.tsx eu vou comentar esse return que a gente tem aqui hoje e retornar apenas Home daqui de dentro. Cuida para a importação que você fazer da Home não ser de dentro de Pages barra Home, tem que ser Home só. É a Home que está aqui na raiz e não que está dentro da pasta Pages. Posso comentar o restante do código aqui, se eu salvo isso aqui agora e volto para o nosso localhost, está lá apenas aparecendo Home. E aí aqui dentro, para continuar simulando, eu vou criar outros dois componentes dentro do mesmo arquivo mesmo, como isso aqui é temporário, não é o que eu vou manter, com certeza no dia a dia a gente não vai fazer isso, mas como é para exemplificar, eu vou criar outras duas funções que são dois componentes, um chamado Countdown e outro chamado NewCycleForm, assim como a gente tem também lá dentro dos nossos componentes aqui da Home. Então é um exemplo bem próximo do que a gente tem lá. E aqui eu posso fazer um return H1, NewCycleForm, e aqui um return H1, Countdown. E aí aqui dentro da Home eu posso colocar aqui, pode ser uma div, e colocar os dois componentes aqui dentro dessa forma. Perfeito. E agora a gente vai partir para contexto. Então, como a gente viu antes, quando a gente não utiliza contextos, o que a gente precisa fazer é, nós criamos uma variável, por exemplo, ActiveCycle, que ela tem o valor de 1, por exemplo, e aí se eu quero que essa variável ActiveCycle tenha o seu valor acessado dentro dos componentes NewCycleForm e do Countdown, eu preciso enviar para ambos, via propriedades, essa variável. E aí eu pego essa propriedade aqui, e aí eu uso lá dentro. Mas o que a gente quer evitar é exatamente isso. Então, como que a gente pode utilizar da Context API do React para resolver isso? Eu vou começar importando, de dentro do React, uma variável, uma função chamada CreateContext. O CreateContext nada mais é do que uma função, e aí eu preciso armazenar esse contexto numa variável, e aí o nome dessa variável tem que ter alguma relação com o tipo de informação que eu vou guardar dentro desse contexto. Então, como aqui a gente está querendo criar um contexto para manter as informações relacionadas aos ciclos da nossa aplicação, eu vou criar aqui um CyclesContext. Mas o nome aqui é totalmente irrelevante, você pode dar um nome que fizer mais sentido para você. E aqui eu dou um CreateContext, e aqui dentro do CreateContext a gente coloca aqui, dentro dos parênteses, qual que é o valor inicial desse contexto. Então, se você vai armazenar uma única variável dentro do contexto, por exemplo, esse contexto aqui vai armazenar somente a informação do ciclo ativo da minha aplicação, do ActiveCycle. Beleza, eu posso então, se o ActiveCycle aqui é 1, eu posso começar o valor aqui com 1. E aí pronto, já resolve. Mas geralmente a gente utiliza contextos para guardar mais informações, para ter mais informações sendo retornadas de dentro dele. Então, geralmente a gente usa um objeto aqui dentro do CreateContext, e aí a gente aqui dentro fala, olha, eu vou ter uma informação que se chama ActiveCycle, e o valor dela é 1, esse é o valor inicial, digamos assim. Perfeito, posso tirar essa variável daqui de baixo. E agora, se eu quero compartilhar essa informação com esses dois componentes, eu utilizo de uma outra função do React, um hook, chamado UseContext. E aí dentro do meu NewCycleForm, eu posso escrever const, igual a UseContext, passo o nome do contexto, a variável do contexto aqui entre parâmetros, e de dentro dele eu posso buscar o meu ActiveCycle. Então, posso fazer a mesma coisa nos dois componentes, veja que eu não passei nenhuma propriedade para eles, e agora eu consigo acessar daqui de dentro o id do ciclo ativo, por exemplo, ou melhor, aqui não tem id, é só o número mesmo, então eu consigo acessar o ciclo ativo diretamente aqui do corpo do componente. Então, salvo isso aqui agora, veja que eu tenho 1 e 1, que é o valor que eu passei aqui. Se eu mudo aqui para 5, ele muda nos dois lugares ao mesmo tempo. Ou seja, isso aqui é como se fosse uma variável compartilhada entre dois componentes. Porém, tem um problema, aqui dentro do meu componente, se eu colocar agora um botão aqui dentro, que ele vai alterar o ciclo ativo, e quando a gente clicar nesse botão, eu tentar fazer algo como ActiveCycle, agora não é mais 1, ou melhor, não é mais 5, e é 2, por exemplo, e aí o flint já arruma o código para mim, ele está reclamando aqui que é uma constante, que eu não posso alterar, mesmo que eu coloque como uma let, olha só o que vai acontecer. Quando eu clicar em alterar ciclo ativo, eu clico e nada acontece. Ou seja, quando eu crio um contexto, e eu compartilho uma informação inicial do contexto com vários componentes, eu não posso modificar essas informações. Então, o meu contexto tem o mesmo valor para sempre. Tá, Diego, e se eu quiser modificar as informações, porque a gente sabe que a ideia aqui do ciclo ativo, o nosso ActiveCycle, vai mudar com o tempo, conforme o usuário cria mais ciclos e tudo mais. Aí muda um pouquinho, e aí a gente vai ver como fazer isso aqui. O que a gente tem que fazer nesses casos? Como a gente já viu anteriormente, sempre que a gente tem uma variável no React, que ela vai ter o seu valor alterado com o tempo, principalmente baseado em ações que o usuário faz, cliques em botões e tudo mais, essa variável precisa ser um estado. Só que aqui, hoje, ela não é um estado. Ela é uma variável primitiva, um número. E aí, o que a gente vai fazer? Aqui dentro da nossa Home, que é o componente que está por volta dos componentes que precisam das informações do nosso contexto, é muito importante ir com calma e entender o que a gente está fazendo. Veja só. Aqui dentro da Home, e por que na Home? Porque é na Home que a gente vai criar o nosso estado, que vai armazenar o nosso ActiveCycle. Porque a Home é o componente que está por volta dos outros componentes, ou seja, o componente pai dos componentes que precisam dessa informação. Se eu crio esse estado aqui dentro do Countdown, por exemplo, essa condição já não se satisfaz. Porque o Countdown está dentro da Home, está aqui. Ou seja, o Countdown não está por volta do NewCycleForm. Ou seja, o NewCycleForm não vai conseguir ter acesso a essa informação. Sempre que eu quero que as informações sejam acessíveis por contexto, os dados do contexto sempre precisam estar no componente mais por fora possível dos sub-componentes que precisam acesso a aquela informação. Isso vai ficando mais claro com o tempo. A gente coloca aqui o ActiveCycle. E agora, ao invés de setar o valor do ActiveCycle diretamente pelo valor inicial, aqui eu posso até deixar o valor inicial 1, por exemplo, o que eu vou fazer é o seguinte. Aqui no lugar dessa div, ou até por volta dela, não tem problema, a gente vai colocar um componente do React que vem de dentro do meu CyclesContext. O nome dele é CyclesContext.Provider. A gente vai colocar esse Provider por volta dos componentes que eu preciso que tenham acesso a informações do contexto. E esse Provider aqui recebe um valor. E aqui nesse valor eu preciso enviar quais informações eu quero que sejam compartilhadas entre todos os componentes que estão dentro desse Provider. E aqui, novamente, se eu quero enviar uma informação primitiva, um número, só um número eu posso, mando um 5 aqui. Mas, geralmente, a gente envia um objeto daqui de dentro com todas as informações que a gente quer enviar. Por exemplo, o nosso ActiveCycle. Se eu salvar o nosso código aqui e executar, a gente vai ver que o valor aqui agora é 0 por quê? Porque eu iniciei o nosso ActiveCycle com 0. Então, por mais que lá em cima eu tenha setado um valor inicial dele para 1, o que prevalece é o nosso valor do Provider, sempre. Mas, se eu clicar para alterar o ciclo ativo, que altera o valor dessa variável para 2, não vai funcionar. Porque a gente já sabe que para alterar um estado no React, não é dessa forma aqui. A gente precisa chamar a função setActiveCycle. Tranquilo, mas essa função setActiveCycle está aqui no componente Home. Como que eu vou ter acesso a ela aqui no meu componente NewCycleForm, que é o componente que está tentando alterar o valor de ActiveCycle? É simples, a gente pode enviar o setActiveCycle também dentro do contexto. E aqui ele está dando erro por quê? Porque aqui em cima, quando eu criei o meu contexto, eu falei que dentro dele a gente ia ter apenas o ActiveCycle que tem o número 1. Então, meio que o TypeScript está entendendo que o meu contexto sempre vai ter esse formato aqui. E aí, só para a gente não ter erros aqui agora, e mais pra frente, claro, que a gente vai melhorar isso aqui, eu vou, aqui dentro do createContext, fazer o seguinte. Eu vou inicializar ele com um objeto vazio e colocar aqui um asAny. Isso aqui é só meio que eu estou pedindo para o TypeScript não ficar tentando decifrar ou tentando forçar que eu siga um padrão de tipagem dentro do meu contexto, para eu poder enviar o que eu quiser ali por dentro do contexto. Mais pra frente a gente vai melhorar isso, só para o TypeScript não ficar incomodando a gente agora durante essa explicação mais inicial. E agora eu vejo que o erro já saiu daqui, e que inclusive eu posso acessar agora a função setActiveCycle de dentro do meu NewCycleForm, olha só. Então agora eu tenho acesso a essa função, e aqui eu dou um setActiveCycle para 2, por exemplo. E olha que massa agora. A partir do momento que eu clico no alterar ciclo ativo, ele altera para 2, não só no componente NewCycleForm que chamou essa função, mas lá no countdown também. Ou seja, o countdown está usando a informação do ActiveCycle aqui do contexto, ou seja, se essa informação muda dentro do NewCycleForm, ela vai mudar em todos os outros lugares que estão utilizando o mesmo contexto. Ou seja, veja que eu não tenho propriedades nenhumas sendo passadas aqui para esses componentes, e mesmo assim eles conseguem acessar uma informação do componente Pie, que no caso aqui é a nossa HomePage. Então, contexto é basicamente isso. Não tem nada além de complexidade em cima disso. E assim a gente termina a nossa explicação inicial sobre contextos, e agora o que a gente vai fazer é adaptar a nossa aplicação para utilizar contextos com os novos aprendizados que a gente teve aqui. Mas antes, claro, eu vou apagar essa página Home, se você não quiser apagar para lembrar disso aqui, anota, mas eu vou apagar nossa página Home, e aqui no nosso app eu vou voltar o código como estava antes, para a gente voltar com a nossa aplicação quebrando aqui, e agora a gente partir para resolver."
  },
  {
    "id": "9ee5caf2-9d23-46c9-a91a-435a2418319c",
    "title": "Ajustes no Design System",
    "transcription": "E aí, Dev, aqui é o Diego do Futuro, e depois que eu terminei de codar o IgniteCall, que, na verdade, é o projeto que a gente usa esse Design System aqui, eu percebi que alguns componentes aqui do Design System iam precisar de algumas alterações. Então, eu estou voltando aqui no final desse módulo para fazer algumas alterações em algumas coisas aqui do projeto do Design System e explicar o porquê que a gente vai fazer essas alterações, para quando a gente utilizar esse projeto para construir outros projetos com essa interface, com esse padrão de interface, já está tudo mais pronto. A primeira coisa que a gente vai mudar aqui no projeto, rapidinho, é que eu percebi, e isso é mais um erro que foi cometido aqui na aula, é que aqui no NPM, no TurboRunBuild, o filter aqui não está funcionando, porque aqui eu não devo passar o nome da pasta, o nome da pasta packages, e sim apenas o nome da pasta do subpacote, digamos assim, dentro do nosso monorepo. Então, aqui eu passo somente o nome da pasta que está dentro de packages e passo o sinal de exclamação na frente para falar que eu quero evitar rodar o build na pasta docs. Então, isso aqui já vai facilitar bastante e a partir de agora a gente vai ver que a build nunca vai rodar na pasta docs quando a gente estiver fazendo uma nova publicação de alguma release. Logo, a gente testa isso juntos. A próxima coisa que eu vou fazer aqui é, dentro do meu TextInputStories, aqui dentro no prefixcal.com, eu vou também colocar um placeholder aqui, como por exemplo, yourusername, para que ali dentro do storybook apareça esse placeholder dentro desse stories aqui do TextInput. Isso aqui é mais uma melhoria do que uma correção, digamos assim. A próxima coisa que a gente vai fazer é, dentro do avatar styles, a gente tem aqui que o avatar, por padrão, tem uma largura e uma altura, aqui com a variável 12 aqui do stitches, que daria 48, se eu não me engano. Só que eu percebi que lá dentro do próximo projeto, a gente vai usar, na verdade, o avatar com tamanho 64 e não 48. Então aqui, ao invés de a gente criar uma propriedade para aumentar o tamanho ou diminuir o tamanho do avatar, eu vou setar o avatar, por padrão, com uma largura e altura de 16 aqui, que vai dar 64 pixels lá no final. Próxima coisa que a gente vai ajustar é dentro da box, que eu coloquei um padding aqui de 4, isso aqui daria 24 pixels, e aqui eu vou trocar para 6, que daria 32 pixels, se eu não me engano. Estou errado? 4 vezes 8, 24. 6 vezes 8, 48. Tudo bem, a gente vai trocar aqui para 6. 4 vezes 8, 32. Por isso que estava errado, mas show. Matemática forte aqui. Próxima coisa que a gente vai ajustar aqui é dentro do nosso button. O que eu vou ajustar aqui? Eu acabei não colocando nenhum tipo de manipulação de estilo no foco do botão. Eu acho que fica um pouco feio a gente não controlar o foco do botão em si. A gente vai, pelo menos, ajustar aqui um pouquinho o foco. O que eu vou fazer? Eu vou copiar esse disabled aqui e vou criar uma nova estilização para focus. E aqui o que eu vou fazer? Ao invés de utilizar border, outline, que de certa forma eles modificam o tamanho, o box model aqui do nosso botão, eu gosto de utilizar para focus o box shadow, que é uma forma de a gente ter quase que uma borda externa a um elemento. E aí eu passo aqui 0 no eixo X, 0 no eixo Y, e eu passo 0 de blur, ou seja, ele não vai criar aquela shadow que vai esmaecendo a opacidade. E aqui eu boto 2 pixels, que é o tamanho da borda. Isso aqui vai ser como se fossem 2 pixels de borda, de outline no botão. E aí aqui dentro do box shadow, se eu só tentar passar a cor gray, sem, não vai funcionar. Porque o box shadow não entende que as variáveis do stitches que eu passo aqui para dentro são cores. Então no stitches a gente tem um hack para isso. Se eu não quero usar o box shadow color separado e tal, eu posso botar aqui o $colors, $gray, sem. Então eu estou falando que eu quero, das cores do stitches, puxar a cor gray sem. Então ele vai puxar certinho, e aqui eu posso passar qualquer variável, qualquer tipo de configuração lá do stitches, para ele reaproveitar essa variável aqui dentro. Show de bola! Lá dentro do checkbox styles, agora aqui dentro, eu percebi que também dentro do nosso focus, quando eu estou com o foco, ele aplica essa borda sólida aqui dentro. Só que essa borda é perdida quando o usuário já fez o check, e não está com o foco no input. Ou seja, fica estranho, porque quando o usuário clica no checkbox e preenche ele, fica com uma corzinha verde de fundo, quando o usuário tira o foco daquele checkbox, ele volta para a cor de borda cinza. Só que é estranho, né? Então o que eu vou fazer? Quando eu estiver com o focus, ou eu estiver com o data state checked, aí sim eu vou colocar a borda. Então a borda se aplica nessas duas situações, tanto no foco, quanto quando eu já estou com o state checked aqui dentro. Show de bola! Agora a gente vai fazer uma última alteração de estilo, que é lá dentro do meu text input styles, a última alteração que a gente vai fazer, e aí a gente já executa aqui para verificar. Aqui eu vou fazer algumas alterações, que eu percebi lá que ia ser necessário. Primeira configuração que a gente vai ter aqui dentro, é que lá dentro dos meus projetos eu vou ter dois tamanhos de input. Inputs que são um pouquinho menores e inputs maiores. E aí o que eu vou fazer é criar uma variante aqui dentro do stitches. Então eu vou dizer que o nosso input pode variar pelo size, que é o tamanho, ele pode ter um tamanho small e ele pode ter um tamanho median. E aí o tamanho median aqui provavelmente é o tamanho padrão desse input, então eu vou passar um default variance aqui dentro, size median, para ele sempre usar por padrão esse aqui, caso essa informação não seja setada. Aqui no small, o que eu vou fazer? Eu vou copiar esse padding que eu tenho aqui em cima, de 3 e 4, eu vou botar dentro do median. No small eu vou colocar o padding de 2 e 3, veja que eu reduzi 8 pixels de cada uma das laterais, então aqui fica com 16 e 24 respectivamente, em cima e embaixo, e na direita e na esquerda. E outra coisa que eu percebi que se comporta melhor, é ao invés de utilizar align items baseline aqui, utilizar o align items center mesmo, que fica com um visual mais legal quando a gente vai utilizar esse input lá dentro. E a última coisa aqui embaixo, no prefix, eu botei esse sinal de dólar, o sinal do e-comercial, dois pontos placeholder, só que no CSS é dois pontos, dois pontos placeholder. Só no placeholder a gente precisa usar esse double, dois pontos aqui, não dá pra ser um só, senão ele não aplica esse estilo color gray 400 aqui. E aí a última coisa que a gente vai fazer aqui, deixa eu dar uma olhadinha aqui, dentro de packages, react, source e dentro de index, a gente não re-exportou o nosso styles aqui, que é o arquivo que está dentro da pasta styles, esse index aqui. E aqui dentro desse index aqui, eu preciso re-exportar, ou seja, o meu design system precisa exportar essas variáveis aqui pra quem estiver instalando, pras aplicações que estiverem instalando o meu design system, porque senão elas não vão conseguir utilizar as variáveis que eu estou definindo dentro do meu design system. A ideia do design system é sim oferecer um leque de componentes pras outras aplicações usarem, mas não só os componentes, as cores, os tamanhos de fonte, pra que mesmo que a pessoa não utilize de um componente específico do meu design system, mesmo assim ela possa reaproveitar os tokens. Então aqui no meu index, ao invés de exportar somente os componentes, eu vou também exportar tudo que eu tenho dentro da minha pasta styles no arquivo index, eu não preciso passar index aqui porque ele já vai entender automaticamente. Assim quem importar o meu design system já vai conseguir ter acesso a todas essas variáveis que a gente está exportando daqui de dentro. Último ajuste agora que a gente vai fazer, que não é de estilização, é lá dentro do nosso componente text input, na parte do JSX dele. Por quê? Uma das coisas que a gente tem que cuidar quando a gente cria esses componentes, tanto no nosso design system ou numa biblioteca de componentes qualquer, é que existe uma propriedade especial do React que ela não vem através das props, que é a href. A href no React é uma forma da gente acessar a referência para o elemento na DOM, ou seja, a referência nativa do JavaScript para aquele elemento dentro da árvore de elementos do HTML. Então a href é o que nos dá acesso, por exemplo, a gente executar métodos direto no input. Por exemplo, fazer um focus, fazer, por exemplo, um addEventListener. A href permite a gente fazer isso. E lá no IgniteCall a gente vai precisar acessar a href do nosso text input, porque é a href que é utilizada pela maioria das bibliotecas de formulários para a gente conseguir obter acesso ao valor do input, adicionar coisas como blur, focus, essas coisas assim como eu expliquei antes. Então eu preciso, aqui dentro do meu componente text input, aceitar que ele receba a href. Hoje isso não acontece, eu não consigo enviar uma referência do React para esse text input. O que a gente vai fazer aqui dentro? Aqui ao invés de eu simplesmente exportar uma function text input, eu vou trocar isso aqui para uma constante. Veja que o resultado operacional não vai mudar nada. Mas por que eu troquei isso aqui para uma constante? Porque agora a definição da função é isso aqui. Então eu posso dar um Ctrl X nisso aqui, que é o meu componente em si, perfeito? E agora a gente vai usar uma função do React chamado forwardHalf. E dentro dessa função forwardHalf, eu vou colocar a definição do meu input. Só que agora no meu forwardHalf, veja que quando eu passo o mouse por cima, ele traz aqui que ele aceita dois genéricos do TypeScript, como se fossem dois parâmetros de tipagem. Então eu posso passar aqui para ele um sinal de menor e maior, e aí no segundo parâmetro é as nossas propriedades. Então eu posso simplesmente botar aqui o text input props, depois a vírgula. No primeiro parâmetro, o que a gente vai fazer aqui dentro? Eu vou pegar e utilizar uma função que vem de dentro do React, que se chama elementHalf. Ela serve para a gente extrair a tipagem de um outro componente, de um outro elemento, a tipagem da referência de um outro componente. Por que eu quero fazer isso? Porque lembra que esse text input, por baixo dos panos, ele está usando este input aqui, que vem de dentro do stitches, certo? E esse input aqui, ele é um input style aqui e tudo mais. Eu posso reaproveitar a referência que eu poderia passar para esse input, tanto que se eu vier aqui, input, está vendo? Esse aqui é meu input. E eu escrever half nele, veja que ele já está aceitando uma referência. Se eu passo o mouse por cima aqui, ela é do tipo HTML, input, element e tudo mais. Eu poderia criar isso aqui do zero, ou digamos reaproveitar a referência que esse input aqui já recebe. Então basta eu passar elementHalf e o nome do tipo, que é o input. Só que aqui tem que ser typeOf, porque input é um componente e não uma tipagem. Salvo, o Slint já arruma aqui o código para mim, e agora já está pronto. O nosso text input agora já pode receber a half. A única diferença é que agora, aqui na função do meu componente, aqui nos parâmetros, além de eu receber as props, que é o primeiro parâmetro, no segundo parâmetro agora eu posso acessar a half do meu componente. Se eu passo o mouse por cima, olha só, react-forwarded-half-html-input-element. Então ele já entende certinho. Agora eu venho aqui no input e passo a minha half para ele. Legal, né? Show! Assim a gente corrigiu todas as coisas aqui. E o que a gente vai fazer agora é uma atualização do nosso pacote aqui dentro do nosso design system. Aqui então agora a gente vai executar npm run changeSet. Vamos dar um enter aqui agora, aguardar um pouquinho. Ele já detectou que a gente fez alterações no pacote ignite-ui-react. Então eu vou selecionar apenas esse pacote para essa changeSet. Aqui ele vai perguntar quais pacotes a gente quer que tenha um majorBump. Aqui se eu dou um enter, ele já passa para me perguntar quais vão ter um minorBump. E aqui eu vou na verdade dar mais um enter, não vou selecionar. E ele vai entender que eu estou fazendo uma alteração, uma patch. Uma alteração que ela não modifica, digamos assim, não tem break in change e não modifica muito o comportamento. Mais um ajuste, digamos assim, que é o que a gente está fazendo aqui. Bora adicionar um summary aqui que é exatamente o que a gente fez. Então eu vou adicionar aqui add some fixes to future projects. Claro que aqui o mais correto seria a gente ter detalhado muito bem o que a gente fez aqui dentro. Então vamos até botar aqui add option to pass reference to text input and adjust some styles. Show. Beleza. Já criou aqui. Já vai fazer um patch aqui no nosso pacote. Se eu acesso aqui no React, ele ainda está com a versão 1.0, se não me engano, que foi a versão que a gente rodou a última vez. E agora a gente vai rodar o npm run version packages. Perfeito. Ele já atualizou. Então aqui a versão do ignite-irai-react para 1.0.1. Veja. E ele criou também o nosso changelog aqui com as alterações que a gente fez. E agora o que a gente pode fazer é a gente pode deixar o nosso próprio CI aqui rodar o comando de release para a gente não se preocupar. E aqui nas documentações, tudo deve funcionar normalmente. Então o que eu vou fazer? git status, isso aqui hoje está rodando na branch main, isso aqui também na branch main. Show. Vamos lá. git add, git commit, fix add have to text input and adjust styles. git push, origin main, vou dar um force aqui porque eu tinha git log, gh-repoview, deixa eu dar uma olhadinha aqui só no meu repositório. git remote-v. Já fiz o ajuste aqui, que eu estava numa outra branch. Então agora sim, git push, origin main. Vamos aguardar ele enviar lá para dentro do GitHub. Aqui eu já tenho o repositório aberto. E agora a gente vai ver que ele vai começar a rodar o CI aqui dentro. E aqui dentro do release, que é o mais importante para a gente, eu tenho que garantir que ele não vai rodar o build da pasta docs, que foi a alteração que a gente fez. Então bora só dar uma olhadinha nisso para ver se está tudo certo. Veja que aqui ele está rodando o processo de build e os pacotes que ele está rodando, exatamente o slint-config, react-tokens e ts-config. Ele não está rodando o processo de build na documentação. Aqui ele deu um erro na publicação do npm, mas é porque o meu token de autenticação aqui dentro mudou porque eu mudei o repositório de organização. Mas aqui eu não vou me preocupar porque se você configurou certinho conforme foi a nossa aula sobre publicação no npm, essa parte aqui o seu vai rodar tudo certinho. O meu é só por causa do token aqui no npm. Como eu botei na organização da Rocketseat, tirei do meu repositório pessoal, não tem o token do meu npm aqui na Rocketseat e eu também não quero adicionar o token do meu perfil aqui direto. Mas show de bola, a gente resolveu então a maioria dos problemas aqui no nosso design system."
  },
  {
    "id": "edabf8af-3fc0-41a7-9b34-d04adcae1416",
    "title": "Reset do formulário",
    "transcription": "Uma coisa que ficou pendente antes de a gente fazer aqui a listagem do histórico em si é a parte do Reset do formulário. Então, a gente tinha comentado essa parte. Deixa eu até fechar aqui grande parte dos arquivos, fechar aqui. E aí lá dentro da ROM, nós comentamos esse Reset que vem de dentro do formulário. E lá no nosso contexto, quando a gente cria um novo ciclo, a gente comentou o Reset aqui também. E aí, se você lembrar, uma das coisas que eu bati muito a tecla aqui nas últimas aulas foi a questão da gente não trazer a biblioteca React Hook Form aqui pra dentro do contexto. Parece que um dia a gente trocar essa biblioteca ou qualquer coisa assim, o contexto fica intacto. A gente só tenha coisas do próprio React ou bibliotecas que só são usadas no contexto, que não são usadas no restante do código. Então, o que eu vou fazer? Olha só que legal. Essa função createNewCycle que eu tenho aqui dentro do contexto, eu vou fazer com que ela não chame essa função Reset. E aí, lá na minha ROM, eu vou criar uma segunda função, digamos assim, pode ser aqui. Eu vou chamar de handleCreateNewCycle. E aí, só uma questão de padronização. Por que essa função aqui, o nome dela eu dei como createNewCycle e essa eu dei como handleCreateNewCycle? Porque essa função aqui, eu vou chamar ela diretamente de um evento. E eu gosto, quando eu chamo uma função a partir de um evento, de dar o nome dela com handle na frente. Então, ao invés de agora eu chamar a função createNewCycle, que vem lá de dentro do contexto, eu vou chamar a handleCreateNewCycle e agora essa função aqui vai chamar a createNewCycle. Olha só que interessante. Então, aqui essa função recebe os dados, que é newCycle.fromData e ela chama a createNewCycle passando os dados. E ela também reseta o formulário. Olha que legal. Agora, a gente completou a função de Reset. Ela fica aqui na ROM, ela não mexe lá no contexto, ou seja, o nosso contexto não fica sabendo dessa função Reset e assim tudo fica bem organizadinho aqui no nosso código."
  },
  {
    "id": "5690bff7-caab-49fe-b5ed-d4f0de349da9",
    "title": "Criando um projeto React",
    "transcription": "Nessa aula o foco é a gente fazer a construção, o setup do nosso primeiro projeto React utilizando o Vite. Então aqui nos próprios sites do Vite eu clico em Get Started. E aqui eu vou ver um pouco das maneiras de eu conseguir criar esse meu primeiro projeto. Mas pra criar o primeiro projeto é super importante que você tenha o Node instalado. E eu não vou passar aqui o passo a passo pra você instalar o Node dentro do seu sistema, até porque isso não é uma coisa difícil de fazer. O próprio site aqui já dá as instruções pra você fazer. A única coisa que eu recomendo é que você instale a versão LTS. Então aqui, por exemplo, a versão LTS atual no momento que eu estou gravando essa aula, a Long Term Support, é a 16.15. Se você quiser fazer uma instalação do Node um pouco melhor, digamos assim, já um pouco mais avançado, principalmente pra você que já está no Ignite, uma das coisas que eu recomendo na hora de instalar um Node da vida é utilizar um Version Manager. O que é o Version Manager? Basicamente é uma ferramenta que permite você controlar múltiplas versões do Node, inclusive atualizar e voltar versões do Node na sua máquina de uma maneira mais fácil. Assim você pode ter vários projetos na sua máquina executando versões de Node diferentes por causa que um projeto precisa de uma versão, o outro de outro, e por aí vai. Existem vários Node Version Managers, acho que o mais famoso é o próprio NVM, mas eu não gosto muito de utilizar o NVM, vou ser sincero, eu utilizo um outro. Então eu vou procurar aqui que é o N, o nome dele é só N mesmo, por isso que eu procurei por N Node Version Manager e eu vou cair nesse projetinho aqui, github.com barra tj barra n. Ele é um projeto com bem menos stars que o NVM, só que eu particularmente uso ele aqui no meu dia a dia e eu gosto muito de utilizar. Para instalar o N aqui, caso você já tenha instalado o Node previamente na sua máquina, é só usar o próprio npm install -g n e pronto, já sai utilizando. Existem outras formas de instalar o N, como por exemplo utilizando o curl. Se você está num ambiente Unix com Linux ou com Mac, você pode simplesmente executar o curl aqui e ele faz a instalação. Você pode instalar via gerenciador de pacotes, como no Mac, utilizando o homebrew ou o macports e aí acho que você consegue também instalar aqui pro Windows. Eu acho que pro Windows a melhor forma de você instalar é instalar o Node antes e depois instalar o N dessa forma aqui. Então, depois que você tiver instalado com o N aí, você pode simplesmente vir aqui no seu terminal e dar por exemplo um n install lts e ele vai automaticamente procurar qual que é a versão lts do Node, instalar e a partir de agora eu já tenho a versão lts instalada aqui na minha máquina. Se eu precisar de em algum momento instalar uma versão específica do Node, como por exemplo eu quero utilizar a versão 18 do Node, eu rodo n install 18 e aqui eu já tenho o nosso projeto aqui rodando na versão 18. Mas eu prefiro utilizar a versão lts e aí então a gente vai usar a versão sempre lts. Agora com o Node instalado e já com o Node rodando aqui na minha máquina, como eu mostrei, Node-v, npm-v, que é o Node Package Manager, a gente vai conseguir criar o nosso projeto em convit. E aí pra criar o nosso projeto convit, a gente vai executar esse comando aqui, npm create vit-latest. Pra isso deixa eu acessar aqui a pasta do Ignite, onde eu vou colocar os meus projetos, vou criar aqui uma pastinha aulas e aqui dentro eu vou começar criando um projeto dando npm create. Opa, deixa eu entrar na pasta aulas, agora sim. Criar o projeto, y, vamos aguardar aqui um pouquinho. O nome do projeto, eu vou chamar esse projeto de 01-fundamentos-reactjs. Aqui a gente pode escolher qual que vai ser o template para o meu projeto, qual vai ser o framework ou a biblioteca que eu estou utilizando. E aqui nesse caso, especificamente, eu vou estar escolhendo React, claro. E aqui ele permite a gente escolher variantes do template. Ou seja, eu quero um template com o JavaScript tradicional ou com o TypeScript. Eu vou começar criando o projeto com o JavaScript tradicional, mas depois a gente vai anexar o TypeScript nesse projeto. E anexar TypeScript num projeto que já existe é super tranquilo. Então a gente pode começar criando aqui o template com o JavaScript e depois a gente fala sobre o JavaScript em si. A partir de agora, opa, eu vou acessar aqui a nossa pasta, Fundamentos do React, e a gente vai abrir essa pasta aqui no Visual Studio Code. Eu já estou com o meu Visual Studio Code aqui configurado e já está rodando. Se você quiser utilizar outro editor, fica à vontade. Eu prefiro utilizar o Visual Studio Code aqui nas aulas porque é mais fácil. E aqui dentro a gente vai ver a estrutura que foi criada aqui do nosso projeto. E é importante para a gente entender os primeiros conceitos do React. Abrindo aqui o terminal do VS Code, eu vou começar executando npm run dev. E aqui, antes de mais nada, eu preciso instalar as dependências. Então eu vou rodar um npm install ou npm i para ele fazer a instalação das dependências. Aguardar aqui um pouquinho. Beleza. E agora npm run dev. Ele já vai executar o nosso projeto no endereço localhost 3000. Abro esse endereço no browser. E aqui o meu vai estar dando problema porque eu estou com outra aplicação rodando nessa porta 3000. Então eu acho que eu consigo talvez trocar a porta que a aplicação Vit está rodando para a gente não ter esse problema. Então deixa eu ver se eu consigo trocar a porta server.port. Talvez seja isso. Então, pelo que eu entendi, eu tenho que criar um arquivo de configuração do Vit aqui dentro. Aqui eu passo server.port e eu vou botar na 3001. Só porque eu tenho uma outra aplicação rodando na porta 3000 que eu não quero fechar agora. Mas você não precisa fazer esse código. Pelo menos a gente descobriu alguma coisa nova juntos. E agora npm run dev. Pronto. Já está rodando na 3001. Abro. E aqui está a minha aplicação rodando. É uma aplicação bem simples que basicamente quando eu clico nesse botão, count is zero, eu consigo aumentar o contador aqui múltiplas vezes. É claro que é uma aplicação muito simples, mas o Vit já traz algumas coisas configuradas para a gente. Uma das coisas mais legais que o Vit traz é o que a gente chama de Fast Refresh. Fast Refresh nada mais é do que a gente alterar a nossa aplicação e refletir automaticamente no browser de forma instantânea. Então, por exemplo, eu tenho meu browser aqui do lado rodando. Eu vou abrir aqui algum arquivo. Um arquivo, por exemplo, pode ser na pasta source o arquivo app.jsx. Está vendo aqui? E dentro desse arquivo a gente vai ver que tem aqui um monte de código embaralhado. JavaScript com HTML. Não se preocupa com isso agora. Mas se eu trocar aqui onde está escrito hello-vit-react para hello-ignite e salvar, a gente vai ver que é praticamente instantâneo a alteração aparecendo aqui no browser. Então, a gente não precisa ficar recarregando o nosso browser a cada alteração que a gente faz. Agora, outra coisa que eu vou fazer aqui, voltando o VS Code aqui para a tela inteira, é a gente dar uma limpada na nossa estrutura antes de a gente começar a entender o que o Vit criou aqui de estrutura para a gente. Para isso, eu vou começar removendo todos os arquivos aqui dentro da pasta source, que são css, svg. Então, vai sobrar no final apenas o app.jsx e o main.jsx. Nós vamos abrir o arquivo main.jsx e tirar a importação aqui em cima do css, está vendo? Aqui no app.jsx vamos tirar também a importação do css e do svg. E aqui dentro dessa function app, a gente vai, dentro desse return, tirar toda a HTML que tem aqui dentro, toda essa div, e vamos no lugar apenas escrever h1 hello world. Aqui eu vou tirar também esse código useState, que a gente não vai falar sobre ele agora, e também vamos tirar essa importação aqui em cima. Então, esse código no final vai ficar bem simples. Se eu salvar isso aqui agora e voltar lá para o meu navegador, a gente vai ver que a única coisa que aparece é hello world. Então, é a única coisa que a gente deixou aparecendo aqui em tela. E aí vamos lá, porque agora é importante a gente entender como é que o React está mostrando esse hello world em tela, a partir dessa estrutura que a gente criou. Antes de mais nada, a gente vai ver que nós temos um arquivo index.html aqui dentro do nosso projeto. O index.html, se você já trabalhou com HTML, é claro que você já trabalhou com HTML, você sabe que é o primeiro arquivo carregado pela nossa aplicação web. A partir desse index.html, nós temos aqui o head, algumas metatags, o title da nossa página, que inclusive é o title que aparece aqui em cima, a gente pode mudar depois. Aqui dentro, a gente vai ver que nós temos apenas duas coisas dentro do body. Nós temos uma div, id root, e nós temos um script type module. Isso aqui é importante, porque lembra que eu falei que o Vite utiliza dos ECMAScript modules nativos do browser, ou seja, o formato de importação e exportação que existe nativamente nos novos browsers, por isso isso aqui é altamente importante. E aí, ele está falando aqui que o primeiro arquivo que a nossa aplicação, o arquivo JavaScript que a nossa aplicação vai carregar, é o arquivo que está dentro de source.main.jsx. A gente já vai falar sobre esse arquivo, vai falar sobre a extensão JSX, mas o mais importante da gente entender aqui é por que a gente tem apenas uma div id root aqui dentro do nosso body, e lá no nosso HTML aparece esse hello world aqui, sendo que ele não está aqui no body da nossa aplicação. Uma coisa legal da gente fazer aqui é nós inspecionarmos o elemento aqui no hello world, abrir aqui a nossa árvore de elementos, e a gente vai ver que nessa árvore de elementos eu tenho aqui a nossa div id root, exatamente da mesma forma que está aqui no nosso HTML. E dentro dela eu tenho o h1 hello world. Então, como que isso veio parar aqui dentro? Se a gente abrir esse arquivo main.jsx, que é o primeiro arquivo JavaScript carregado aqui pela nossa aplicação, a gente vai ver um código bem interessante dentro dele. Esse código aqui, esse main, importa o react, importa também o react-dom-client. O que é esse react-dom? Lembra que eu falei que o react pode ser utilizado para a criação de interfaces tanto web quanto móveis, com react-native, quanto para TV, quanto para VR. Então, o react em si, apenas react, é o pacote responsável pelo core do react, o coração do react, onde tem as funcionalidades que são compartilhadas entre todas essas interfaces, todos esses ambientes, todos esses clientes, seja react-native, seja react para web, seja TV, seja VR. O react-dom é a integração do react, o core do react, com a DOM. O que é a DOM? Você já deve ter ouvido falar. É o Document Object Model, que é a representação do nosso HTML através do JavaScript. Então, quando a gente importa o react-dom, a gente está integrando o react para funcionar no ambiente web, no browser. E aí, é importante que a gente vai ver que algo acontece aqui embaixo. Nós chamamos um método chamado createRoot de dentro do react-dom, e esse createRoot recebe um parâmetro que é qual é o elemento raiz da nossa página HTML. E aí, o elemento raiz da nossa página HTML, nesse caso aqui, é o root. E o que vai acontecer daqui pra frente agora é que o react vai criar o HTML, CSS e todo o JavaScript da nossa aplicação dentro dessa div root, que é o nosso elemento raiz do HTML. Ou seja, diferente de uma aplicação tradicional, que a gente já viu, quando a gente constrói uma aplicação SPA, toda a interface da nossa aplicação é construída a partir do JavaScript. Ou seja, é o JavaScript que constrói a interface da nossa aplicação. A interface não fica aqui direto nos arquivos HTML. Ela fica dentro do JavaScript, e o JavaScript tem total controle sobre essa interface. Assim, fica muito mais fácil a gente conseguir manipular essa interface também, fazer com que alguma coisa apareça, alguma coisa suma de tela, porque o JavaScript conhece a interface como um todo. E aqui esse método, esse arquivo, ele chama esse método render. E dentro desse render, a gente vai ver que nós estamos utilizando uma sintaxe aqui, muito semelhante ao HTML, onde a gente escreve, por exemplo, image, input, a gente tem aqui os nossos buttons, que é essa sintaxe de utilizar o menor e o maior aqui no final. Porém, a gente não está utilizando tags HTML aqui, a gente está utilizando, sim, componentes do React, que funcionam, na grande maioria das vezes, muito semelhante a tags do HTML. Mas a gente vai falar sobre componentes mais pra frente. E aí, aqui, chamando o render, o que ele está fazendo? Ele está renderizando algo que é interno do React, que é esse strict mode. A gente nem precisaria disso agora, eu só não vou tirar porque isso aqui é legal a gente utilizar. E aí, dentro desse React strict mode, ele está renderizando, e quando eu falo renderizar, quer dizer, mostrar em tela, o nosso app. O nosso app, aqui, é um arquivo importado, então está aqui o nosso app, que nada mais é do que uma função que retorna um HTML. Ou seja, se eu trocasse aqui o app também por um H1, escrito rocketseat, a gente vai ver, salvando isso aqui agora e voltando para o browser, eu tenho rocketseat escrito na tela. Ou seja, o React nada mais está fazendo do que jogar esse conteúdo aqui, do JavaScript, lá pra dentro do nosso elemento com id root, que está aqui dentro do HTML. Então, a mágica do React, e não só do React, em todas essas bibliotecas de construção de SPAs, está em criar o HTML e tudo o que o usuário interage a partir do JavaScript. Inclusive, se a gente for aqui no browser, acessar as configurações do browser aqui no ladinho, e aqui embaixo nós desabilitarmos o funcionamento do JavaScript, pelo lado do browser aqui, e eu tentar dar um refresh na página, a gente vai ver que nada mais aparece em tela. Porque toda a interface da nossa aplicação é construída pelo JavaScript. Se a gente desabilita o JavaScript, nada mais aparece em tela. Isso é um problema? Depende, mas a gente vai ver um pouco mais sobre isso ao longo do tempo. Mas a gente tem então aqui, já entendendo os primeiros conceitos, eu vou voltar aqui no Visual Studio Code, vou voltar aqui para como estava antes, que é o app, salvar, e nós já temos aqui então, nossa aplicação com o Hello World aparecendo em tela, que é como estava aparecendo antes. E assim a gente criou o nosso primeiro projeto React, e claro, agora a gente precisa começar a construir as nossas funcionalidades aqui dentro."
  },
  {
    "id": "343ed6b1-28a2-4f89-9d98-9056beea71f7",
    "title": "Fundamentos do Redux",
    "transcription": "Bora lá então começar a falar um pouquinho sobre o Redux, uma das bibliotecas mais famosas do ecossistema React. O Redux é a ferramenta de gerenciamento de estado mais antiga que a gente tem dentro da comunidade React e, consequentemente, muitos projetos que você for dar manutenção ao longo da sua carreira como programador ou programadora front-end podem estar utilizando o Redux, principalmente se forem projetos mais antigos e é por isso que a gente está conversando um pouquinho sobre o Redux. Mas calma, não necessariamente quer dizer que o Redux não possa ser utilizado em novos projetos React. O grande diferencial de Redux da maneira que ele era utilizado antigamente para como ele vai ser utilizado hoje em dia nas aplicações é o tanto de complexidade que a gente precisa utilizar para escrever, para utilizar o Redux dentro da nossa aplicação React. E aqui eu vou te mostrar durante as próximas aulas um pouquinho de como o Redux se tornou uma ferramenta muito mais simples do que ela era antigamente. Mas antes de mais nada, o que é o Redux para a gente entender um pouquinho de fundamentos dessa ferramenta, o que ela se compara, quais são as alternativas, como funciona essa ferramenta. O Redux nada mais é, como eu falei antes, uma ferramenta de gerenciamento de estado. Quando a gente fala sobre estado no React, a gente tem que pensar que é toda informação que é armazenada com o propósito de exibir alguma informação em tela ou manipular alguma ação que o usuário faz para exibir alguma informação em tela. React é uma ferramenta altamente reativa, ou seja, dado as informações que a gente possui dentro do estado da nossa aplicação, e o estado pode ser aquele estado que a gente tem no componente diretamente, ou o estado que a gente tem compartilhado entre vários componentes, como a gente já conhece da Context API dentro do React. Dado essas informações, conforme elas alteram, a gente exibe coisas diferentes na interface. A gente exibe um pedaço da interface que não estava exibido antes, a gente mostra um usuário logado, a gente mostra uma mensagem de login. Ou seja, dado o estado da nossa aplicação, a gente precisa exibir coisas diferentes na interface. E o Redux é uma ferramenta que, diferente do estado tradicional do React, onde a gente tem pequenas partezinhas de estado compostas dentro de componentes minúsculos dentro da nossa aplicação, ele difere desse conceito, trazendo uma proposta de estado global na nossa aplicação. O que é o estado global? O Redux traz essa ideia onde a gente, além de poder ter esses estados em cada componente da nossa aplicação, a gente possa ter também um grande estado chamado de Store, que é compartilhado entre toda a aplicação. E geralmente esse estado pode ser acessado por todos os componentes da nossa aplicação. A grande ideia por trás desse estado compartilhado entre todos os componentes é criar a ideia de uma centralização de estado e uma forma que a gente possa fazer com que toda a aplicação possa ter acesso a todas as informações e fazer modificações em todos os componentes ao mesmo tempo. E isso, por muitas vezes, foi necessário. Porque a Context API do React, até o ano de 2017, 2018, ela era muito precária. Ela era muito ruim, muito difícil de trabalhar. Principalmente na época que a gente trabalhava com classes dentro do React. Ou seja, a gente não tinha uma ferramenta oficial do time do React, a não ser o próprio Redux, para fazer esse compartilhamento de informações entre vários componentes da nossa aplicação. E por isso que o Redux se tornou uma ferramenta muito famosa. Porque ele permitia a gente fazer esse compartilhamento de dados entre todos os componentes da nossa aplicação de uma forma muito mais simples do que o React fornecia com a antiga Context API, que não é a que a gente tem hoje. Tá Diego, então quer dizer que com a Context API que eu tenho hoje, eu não preciso mais do Redux? Na verdade não. Não é isso. Porque muita gente confunde a Context API com o Redux, simplesmente porque com ambos a gente pode fazer compartilhamento de informações entre mais componentes. Mas existe uma grande diferença entre a Context API e o Redux, que é exatamente o Redux ser uma ferramenta de gerenciamento de estado. Enquanto a Context API é simplesmente uma forma da gente compartilhar informações entre componentes. Tá Diego, mas qual é a diferença? Quando a gente usa uma ferramenta de gerenciamento de estado, a grande ideia é que a gente tenha uma arquitetura para a gente trabalhar com o histórico do nosso estado, com a timeline do nosso estado, a linha do tempo. Ou seja, uma forma mais arquitetada da gente realizar alterações no estado, dado ações que o usuário realiza. Enquanto a Context API, a gente simplesmente tem uma informação que é compartilhada entre todos os componentes, e aí a gente tem que criar portas de entrada para fazer alterações nessa informação. E a gente vai entender. A grande, talvez, forma da gente comparar o que seria mais comparável do Redux com a Context API, é se a gente criar um contexto e dentro desse contexto a gente utilizar o hook do React do useReducer. O useReducer, que é um hook do React bem famoso, que ele é tipo um useState, porém um pouquinho mais trabalhado, ele é totalmente baseado no Redux, tanto que no Redux a gente vai conhecer o conceito de reducers, e a grande ideia é que o useReducer traz uma forma de a gente criar um reducer, que é exatamente uma estrutura para a gente fazer um gerenciamento de estado local dentro do nosso componente. Então, o que se assemelha mais ao Redux seria uma combinação de Context API junto com o useReducer. E como eu falei, o Redux foi uma ferramenta que se tornou muito popular antigamente, porque a gente não tinha muita padronização dentro do React, nem provinda do próprio time do React, de como que a gente trabalhava com essas informações que a gente precisava compartilhar entre vários componentes da nossa aplicação. E aí uma das coisas que eu gostaria até de antecipar para você, antes da gente sair codando, porque quando a gente sair codando você vai entender muito mais para o que que serve o Redux e como que a gente coda com o Redux, mas a gente tem, geralmente, numa aplicação front-end, três tipos de estado. A gente tem o estado local, o estado global e o estado do servidor, que é muito importante a gente entender. Estado local, geralmente, é aquela informação, aquela variável que a gente salva dentro de um componente específico. Então, imagina que eu tenha um componente de abas e eu quero salvar qual que é a aba ativa. Então, eu tenho um estado ali que armazena qual que é a aba que o usuário clicou para mostrar qual aba está aberta, qual aba está selecionada. Então, isso a gente chama de local state. O global state, por outro lado, já é aquele estado que eu preciso compartilhar entre toda a minha aplicação ou pela grande maioria dos componentes da minha aplicação. Aqui a gente pode pensar, por exemplo, o estado do usuário logado. Então, eu quero compartilhar a informação do usuário que está logado na nossa aplicação com todos os componentes. Assim, eu posso mostrar coisas diferentes ali em tela, dado a informação se o usuário está logado ou não, dado o nome, e-mail do usuário, essas informações que são públicas. Então, global state e local state. E a gente tem um terceiro state que é muito comum nas aplicações front-end, que é o server state. Isso aqui significa, toda vez que eu faço uma requisição para o back-end para buscar alguma informação, uma lista de dados, uma informação única, o detalhe de alguma informação, algum registro do banco de dados, esse dado que é retornado para a gente, geralmente a gente salva dentro de um estado também. Porque no estado, quando a gente salva essa informação no estado, dada as alterações que a gente faz nesse estado, a interface responde a essa informação. Ou seja, a gente tem três tipos de state dentro do React. A gente tem o UI state, que é todo o estado usado para mudar a interface, e aí entra o local state e o global, o local que é dentro dos componentes e o global. E nós temos o HTTP state, o server state, que é o estado que é provindo das requisições que a gente faz para o back-end. E aqui eu só estou trazendo essas três comparações porque, antigamente, a gente usava o Redux praticamente para esses dois carinhas aqui. Então, antigamente, como o React não tinha muita padronização de como a gente fazia requisições HTTP para o back-end, se a gente usava access, se a gente não utilizava, se a gente utilizava o Redux para isso, ou seja, antigamente o React, a comunidade, era uma terra sem lei. Então, a gente usava o Redux praticamente para tudo, tanto para a parte de estado global da nossa aplicação, quanto também para a parte de server state, ou seja, para fazer requisições HTTP para o back-end, tanto também, muitas vezes, até para local state. Ou seja, a gente acabava usando o Redux de forma desnecessária, muitas vezes de forma intensiva para todo tipo de estado aqui dentro do React. Porém, hoje, com os conceitos muito mais bem definidos dentro da comunidade, a gente usaria o Redux somente para o estado global. Ou seja, se eu tiver alguma informação que eu quero compartilhar entre todos os componentes. E aí, para o local state, a gente usaria o próprio state do React, o próprio use state do React. A gente pode usar também a context API aqui nesses casos, ou até JTAI, por exemplo, alguma outra alternativa. Tem também aqui o recoil, tem algumas outras alternativas de gerenciamento de estado que a gente poderia usar aqui. Enquanto para o server state, muitas vezes agora a gente está usando algumas ferramentas. Se você está usando o Next, na sua versão 13, ele já lida com isso automaticamente. Mas se você está criando uma aplicação React sem o uso de um framework, existem ferramentas como o próprio React Query, SWR, o próprio Redux Toolkit também, que é uma ferramenta que integra com o Redux, que é exatamente para gerenciar server state. Ou seja, gerenciar as informações que são providas do back-end ali dentro do front-end. Uma forma da gente manter essas informações compartilhadas entre os componentes. Então, o Redux tem o seu lugar muito mais bem definido hoje em dia comparado com antigamente. Mesmo assim, a gente tem alternativas para a gente trabalhar com o gerenciamento de estado dentro de aplicações React que por muitas vezes ainda podem ser melhores do que trabalhar com o Redux. A gente não precisa forçar a utilização do Redux em todas as nossas aplicações. E aqui alguns exemplos. A gente pode utilizar um combo de Context API junto com UseReducer para ter um resultado semelhante ao que o Redux faz, só que muito mais simples e um pouco até mais limitado que o Redux. Mas a gente tem algumas ferramentas que tem o propósito de trazer um funcionamento de gerenciamento de estado de uma maneira mais simples. O Zustand, que é uma ferramenta que a gente vai ver também ao longo das próximas aulas, totalmente comparável ao Redux, e ela tem a ideia de trazer um Redux muito mais simplificado, muito mais simples de utilizar, muito mais leve. A gente vai conhecer o que é o Zustand, mas o propósito é muito semelhante ao Redux, por isso que a gente vai ver essas duas ferramentas ao longo dessas aulas. E a gente tem o Jotai. O Jotai é uma ferramenta que eu gosto muito. Inclusive, ela é criada pelo próprio criador do Zustand, que tem o objetivo de substituir a Context API. Qual é a grande diferença da gente usar Context API ou Jotai comparado com usar Redux e Zustand, que são os comparáveis aqui? Quando a gente usa o Redux ou o Zustand, a ideia é que a gente tem um estado global, um estado centralizado, que ele pode ser compartilhado em toda a aplicação. Enquanto, quando a gente usa Context API ou o Jotai, a gente tem vários estados. A gente tem vários pequenos estados compartilhados entre alguns componentes da nossa aplicação. Então, quando a gente usa o Jotai ou a Context API, a ideia é que a gente tenha pedacinhos de estado dados os componentes que a gente precisa que tenham acesso a aquelas informações. Enquanto, quando a gente usa o Redux ou o Zustand, a gente tem apenas um grande estado que a gente chama de Store, compartilhado entre toda a aplicação, como bem já falei. E aí a gente precisa entender um pouquinho como que funciona a arquitetura do Redux e também é muito semelhante a arquitetura que o Zustand usa, que é a arquitetura Flux, que ficou também muito famosa aí no ecossistema React, lá no comecinho de tudo, lá em 2016, 2017, 2018, até chegar depois a Context API e começar a tirar um pouco isso da comunidade, principalmente para iniciantes. Mas a arquitetura Flux funciona da seguinte forma. A gente tem os nossos componentes, a gente chama isso na camada de View. E esses componentes, sempre que eles querem fazer algum tipo de alteração nesse estado, pensando que é um estado global, eles precisam disparar uma ação. Essa ação, ela nada mais é do que uma função que diz exatamente o que o usuário está querendo fazer. Então, adicionar um produto ao carrinho, calcular o preço de um frete, ou seja, é uma ação disparada através de um clique do usuário em algum botão, qualquer coisa assim, a gente já está acostumado. É uma action, é uma função, como qualquer outra. Essa função por si só, ela não faz nada. Ela não é uma função que vai fazer uma alteração no estado. Ela simplesmente fala para o Redux, fala para o nosso estado, que o usuário fez tal ação. Então, o usuário quer adicionar este produto ao carrinho, mas ela não adiciona o produto no carrinho, ela não mexe no estado. Ela só dispara um evento. Por outra vez, o Redux, nesse store roxo, ele tem vários reducers. Os reducers são as formas de a gente separar o nosso estado em pequenos pedacinhos. Por mais que tenha um grande estado, a gente tem uma forma de separar eles, de categorizar esses estados. Então, imagina que eu estou desenvolvendo e-commerce, eu posso ter um reducer de carrinho, eu posso ter um reducer de usuário logado, eu posso ter um outro reducer de, sei lá, favoritos. Então, eu tenho vários pequenos estados, vários pequenos pedacinhos do meu estado, e esses reducers, por sua vez, podem ouvir as ações que são realizadas pelo usuário. Ou seja, como eu falei, eu posso ter um reducer de carrinho, que é um pedaço do meu estado, usuário logado, e posso ter um reducer de favoritos do usuário. Se lá na interface, o usuário disparar uma ação de adicionar um produto ao carrinho, qual desses reducers aqui deveria ouvir essa ação para fazer algum tipo de alteração? E aqui, claro, o nosso reducer de carrinho, ele vai falar o seguinte, opa, toda vez que houver uma ação disparada de adição de um produto no carrinho, eu quero pegar qual que é o produto que está sendo adicionado ao carrinho e adicionar no meu array aqui de carrinho. E eu posso fazer com que mais reducers ouçam a mesma ação, ou apenas um reducer ouça aquela ação. E aí, quando ele ouve essa ação, ele faz a alteração no estado que reflete as alterações na interface. Então isso aqui é basicamente um pouquinho da arquitetura Flux. É claro que quando a gente vê isso aqui no código vai ficar muito mais claro do que simplesmente olhar aqui para um diagrama, mas essa é a ideia básica do Redux. A gente tem componentes que disparam ações, o nosso estado ouve essas ações, ele ouve o disparo das ações, realiza as alterações que, por sua vez, voltam aqui para a interface em forma de dados. E isso aqui é basicamente uma arquitetura de eventos. Não é uma arquitetura direta de simplesmente realização de alterações. É uma arquitetura de eventos porque a Vue dispara um evento e não necessariamente isso aqui vai realizar alguma alteração no estado. Eu posso ouvir dentro do meu estado aquele evento para então fazer algum tipo de alteração aqui dentro. E eu vou te mostrar isso na prática daqui a pouco. Mas isso aqui era só um pouco da introdução do Redux. Como eu falei no código vai ficar muito mais claro. Então bora criar o nosso projeto."
  },
  {
    "id": "1814d157-cc56-4a87-9675-d14ec23e11a5",
    "title": "Criando store do Redux",
    "transcription": "Bora lá então, a gente vai começar criando o nosso projeto aqui dentro pra começar a trabalhar com o Redux. E o meu projeto aqui, eu vou utilizar o Vite para criar esse projeto. Então, eu vou chamar ele de React-Redux-Sustained. E vou usar o npm aqui pra instalar as dependências. Na verdade, ele nem vai instalar as dependências ainda. Vou selecionar o template de TypeScript. Legal. Acessar aqui, React-Redux-Sustained. Abrir isso aqui no VSCode. Dar um pouquinho de zoom. E a gente vai rodar aqui um npm install pra ele ir instalando as dependências. Enquanto isso, eu posso dar uma limpada aqui no meu projeto. Vou tirar aqui assets, css, remover tudo isso aqui. Vou lá na pasta app. Removo tudo também. Isso aqui também. Isso aqui posso remover por complexo também. Vou deixar apenas um h1, hello world. Vou tirar esse export default. Vou trocar aqui por um export nomeado, então sem default. Volto no main. Boto aqui as chaves por volta, porque eu troquei o export. Tiro o index e pronto. Nosso projeto já está bem mais limpo. Aqui no public posso remover esse svg aqui do Vite também. Aqui no index, vou trocar o título pra React-Redux-Sustained. Perfeito. Dou um enter aqui. Tiro o favicon. E perfeito. Já estamos prontos aqui pra continuar. O que a gente vai fazer aqui agora é, primeiramente, instalar a parte do Redux. E pra usar o Redux aqui dentro, até seguindo a própria documentação, hoje em dia é recomendado que a gente utilize o Redux Toolkit, que é uma ferramenta que, como eu falei, facilita muito o uso do Redux dentro da nossa aplicação React. Antigamente a gente não usava o Redux Toolkit. A gente usava uma outra ferramenta, que inclusive está aqui na ROM do Redux, que é o React-Redux. Só que a gente não usa mais o React-Redux. Ele é muito mais complexo de trabalhar com o Redux na nossa aplicação. Por isso a gente usa sempre o Redux Toolkit. E a gente vai começar instalando o Redux Toolkit. Então a gente simplesmente faz o npm install Redux Toolkit. E aqui embaixo tem alguns exemplos de como a gente pode fazer a instalação. E aqui tem um exemplo básico também de como a gente faz o uso do Redux. A gente não vai entrar muito aqui nesse mérito. A gente vai diretamente pra configurar o Redux aqui dentro da nossa aplicação. Feito isso, instalado o Redux Toolkit, a gente vai começar criando uma pasta chamada store, que seria esse nosso estado global compartilhado entre toda a aplicação. E aqui eu vou criar um arquivo index.ts. E aí pra gente criar o nosso store, eu vou importar de dentro de Redux Toolkit uma função chamada configureStore, perfeito? E aqui eu vou exportar uma constante chamada store, que é igual a configureStore. E a gente vai configurar o nosso estado aqui dentro. Quando eu dou um ctrl espaço, eu posso ver que eu tenho algumas propriedades que eu posso passar pra esse configureStore. A mais importante agora pra gente é essa propriedade chamada reducer. O reducer é exatamente as informações que a gente vai compartilhar entre todos os componentes da nossa aplicação. Lembra que eu falei lá, até quando eu estava explicando o Redux, que a gente pode ter, apesar de ter esse estado global compartilhado entre todos os componentes da nossa aplicação, a gente pode ter pequenos pedacinhos compartilhados. A gente pode ter pequenos pedacinhos de estado. Então, se eu tenho um e-commerce, eu posso ter um reducer, que é um pedaço do estado só pro carrinho, outro só pra autenticação, outro só pros favoritos. Ou seja, são formas de eu organizar meu estado, separar eles em pedaços menores pra não ficar muita coisa num lugar só. E aqui dentro do Redux Toolkit, a gente chama isso de slice. De fatias. Então, se eu importar aqui de dentro do Redux Toolkit um carinha chamado createSlice, eu vou ver que eu tenho uma função que eu posso criar esses pedacinhos. Então, pra gente começar a entender como que funciona, vamos criar aqui a nossa primeira slice, que é a nossa primeira fatia do estado, que é um pedaço do estado. E pra ser mais fácil a gente entender, eu vou criar uma fatia de todo. Então, eu vou criar aqui a todoSlice, é igual a createSlice. E esse todoSlice, esse createSlice, ele devolve pra gente, ou até se eu desestruturar ele aqui, algumas coisinhas. O mais importante que eu quero aqui é o Reducer. Mas logo a gente já vai falar sobre isso. Então, eu vou botar apenas todoSlice dessa forma. Toda slice, toda fatia, que é toda categorização do estado, todo pedaço menor do estado, ele precisa ter um nome. Então, eu vou dar aqui um todo. Ele precisa ter um initial state, que é qual que é o valor que isso aqui vai iniciar. Então, eu vou iniciar com array vazio, ou vamos iniciar já com alguns todos aqui. Então, fazerCafé e EstudarRedux. E ele precisa ter os Reducers, que logo a gente vai falar sobre isso. Por enquanto, eu posso deixar isso aqui vazio. E agora aqui dentro do ConfigureStore, no Reducer, eu passo um objeto com quais são as minhas fatias, os meus Reducers aqui dentro. Então, eu vou passar aqui todo, e aí eu passo para ele todoSlice.Reducer, dessa forma aqui. Prontinho, a gente já está pronto para começar a utilizar o Redux na nossa aplicação. O que eu vou fazer? Aqui dentro do app, eu vou criar uma pastinha chamada Components, e eu vou criar dois componentes aqui dentro. Eu vou criar o TodoList, que a ideia desse TodoList é listar todos os todos. Então, eu quero que ele tenha uma ul, e aqui dentro esteja FazerCafé, esteja EstudarRedux, esteja todos os nossos todos. E eu vou criar um outro componente, que é o AddTodo, que ele vai ser um formulário para adicionar um novo todo dentro da nossa lista. Então, veja que são... São dois componentes separados. E a ideia é que esses dois componentes possam se conversar, porque eles vão estar utilizando o estado global da aplicação. Aqui a gente vai ter o OnSubmit. Logo, eu já vou criar toda a estrutura. Então, a gente pode criar um estado. Aqui, o nosso input Value. É mais ou menos criar um formuláriozinho, algo mais simples aqui. Podemos dar uma quebrada aqui nos campos para não ficar muito desorganizado. Só estou criando um formulário bem simples aqui para a gente também... Show. E aqui eu posso dar um console.log new Todo, e eu vou ter o meu Todo, certo? Show. Agora, aqui dentro do meu app, eu vou mostrar os dois componentes. Então, vou botar aqui uma div, e dentro TodoList, e o nosso Add Todo embaixo. Se eu salvar isso aqui, rodar isso aqui no meu navegador, a gente vai ver que está ali, né? Fazer café e estudar Redux. Claro, se eu vier aqui e adicionar alguma coisa, não vai para dentro da minha lista, porque, por enquanto, esses componentes não estão se conversando. A primeira coisa que eu quero fazer é permitir que o nosso TodoList acesse as informações do nosso estado, que é exatamente esse store aqui que a gente configurou. Para fazer isso, a primeira coisa que a gente precisa fazer é permitir que todos os componentes da nossa aplicação possam acessar os dados do store. O Redux, por baixo dos panos, ele continua utilizando a Context API do React. Por isso, na Context API, quando eu quero que a minha aplicação acesse, tenha acesso aos dados que estão dentro do meu contexto, eu preciso usar um provider do meu contexto. Para isso, eu vou instalar também aqui dentro o React Redux, que é a integração do React com o Redux. Por mais que o Redux seja muito famoso na comunidade React, o Redux pode ser utilizado em todas as bibliotecas front-end. Ele pode ser utilizado no Angular, pode ser utilizado no Vue. Por isso que o Redux Toolkit é uma biblioteca agnóstica, de biblioteca de UI. Então, a gente precisa instalar o React Redux para usar o Redux com o React. Feito isso, eu vou utilizar aqui de dentro do React Redux. O nosso provider. E aí eu vou até renomear ele para ReduxProvider, para ficar um pouquinho mais semântico, que é exatamente o nosso ContextProvider. Se você já usou a Context API em algum momento, você sabe o que é isso. Ele vai compartilhar todas as informações do contexto com esses componentes aqui. E agora, eu preciso passar obrigatoriamente para ele uma propriedade Store. E o Store é exatamente aquela variável que a gente configurou aqui dentro do arquivo. Este carinha aqui. Show de bola. Agora, dentro da minha TodoList, eu posso importar de dentro de React Redux uma função chamada UseSelector. E aqui dentro, eu posso fazer o seguinte. const Store é igual a UseSelector. E simplesmente, eu estou falando o seguinte. O State aqui é todo o Store do Redux. Poderia até trocar para Store o nome. E aqui, eu preciso passar essa função para falar, olha, esse aqui é o Store do Redux. E aqui de dentro, eu posso falar quais informações eu quero retornar dali de dentro. Eu estou retornando todo o Store. Ou seja, se eu der um const Log aqui nesse Store, salvar e voltar aqui para a nossa interface, eu vou ver que ele vai retornar todo o nosso estado do Redux. Está aqui. É um objeto. É um objeto que dentro eu tenho tudo, que é exatamente a chave que eu coloquei aqui. Se eu botasse a chua chua chua, voltaria. A chua chua, está vendo? E aqui dentro desse todo, eu tenho os meus dois todos. FazerCafé e EstudarRedux, que é exatamente o estado inicial que eu tenho para essa fatia aqui, para esse Reducer. Perfeito? Aqui, se eu não quero usar o estado todo, eu posso pegar apenas o que eu quiser. Por exemplo, eu não quero o Store todo, eu quero apenas o Reducer de todo. Então, eu pego Store.todo. Aqui ele vai dar errinho de TypeScript. Logo a gente fala sobre isso, tá? Mas agora, se eu pego e dou um login nisso aqui, veja que ele vai trazer apenas o array com os meus todos. E aí eu posso fazer um map aqui dentro. Para cada todo que eu tenho, eu vou mostrar uma li com o meu todo ali dentro. Vou botar uma key aqui também para não dar erro do React. Salvo isso aqui e veja que agora isso aqui está refletindo o que eu tenho no meu estado. Se eu vou lá no estado e altero o InitialState aqui para conter mais uma opção, como por exemplo, EstudarZustan, salvo isso aqui, já aparece o EstudarZustan lá dentro. Só que agora eu quero poder adicionar novos todos aqui dentro da nossa lista. Então, eu quero preencher aqui dentro. Quando eu clicar em adicionar, eu quero que ele venha aqui para cima. Então, a gente vai ver um pouquinho como que a gente trabalha com actions aqui dentro do Redux."
  },
  {
    "id": "e656fa6c-9a29-49ab-8f33-eb5660bb28b1",
    "title": "Disparando actions no Redux",
    "transcription": "O que a gente quer fazer nessa aula é permitir que o usuário adicione novos todos aqui dentro da nossa lista. Então, o que a gente vai fazer é, aqui dentro do nosso store, mas especificamente dentro do nosso slice, da nossa fatia aqui do estado de todos, aqui dentro do reducers, por mais que o nome aqui seja um pouco, talvez, com duplo sentido, aqui dentro a gente vai adicionar quais ações a interface pode fazer dentro do nosso estado. Então, a gente vai separar, basicamente, quais ações o usuário pode disparar. Então, por exemplo, eu vou criar uma aqui que se chama add, que ela é específica para adicionar novos itens ao estado. E aqui eu gosto de usar essa sintaxinha dessa forma, beleza? É com uma arrow function, né? E aí toda action aqui do reducer, ela recebe sempre duas informações, state e action. E aqui dentro eu vou só dar um console.log nisso aqui, pra gente ver o que está vindo aqui pra dentro. Ou melhor, state, vírgula, action, dessa forma. Perfeito, não vou mexer mais nada aqui dentro. E agora, o que eu vou fazer daqui de dentro? Eu preciso exportar, de alguma forma, essa função add, pra que o front-end, o componente, consiga chamar essa função aqui. Então, aqui embaixo, eu, por enquanto, vou fazer o seguinte. Export, const, e aí eu vou desestruturar o nosso todo-slice.actions. E aqui de dentro eu posso exportar a nossa função add, especificamente. Então, ações são todas as ações que o usuário pode fazer pra alterar alguma informação dentro do nosso estado. Vou salvar isso aqui agora. Lá no meu addToDo agora, eu vou importar de dentro de React Redux uma função chamada useDispatch, e eu vou importar de dentro do meu store a função add, pra eu adicionar uma nova informação, um novo todo. Agora, aqui dentro, eu vou fazer const dispatch igual a useDispatch, e agora eu uso esse dispatch aqui pra chamar a função add, e dentro dessa função add eu posso enviar qualquer coisa. Então, se eu enviar qualquer coisa, salvo isso aqui agora, veja que quando eu volto aqui no meu navegador, se eu escrever oi e mandar um adicionar, ele vai dar aquele console.log, isso aqui que tá sendo exibido aqui dentro. É exatamente esse console.log que eu coloquei aqui dentro, tá? E aí, olha só, ele mostrou no primeiro valor o array que eu já tinha, olha só. Então, esse console.log, ele mostrou o array que eu já tinha, então o state é o que eu já tenho no meu estado, que é fazer café, estudar Redux, estudar Zustand. E ele mostrou dentro de action, exatamente isso aqui, type todo barra add e payload qualquer coisa. Então, o que acontece? Toda ação que a gente dispara no Redux, ou seja, toda ação que acontece lá na interface, no componente, que precisa realizar algum tipo de alteração em alguma informação contida no nosso estado aqui do Redux, ela sempre vai ter esse formato aqui. Isso aqui é um padrão do Redux desde que o Redux surgiu lá em 2015, 2016, já nem lembro. Que é um type, que é basicamente um valor único para todas as ações que a gente tem no Redux. Então, ele identifica qual ação tá sendo disparada. E o type, ele é sempre um conjunto do nome do reducer, então tá aqui o nome da minha fatia, né? Seguida do nome da ação, add. E o payload são as informações que vieram dentro do disparo. E aqui o payload, ele pode ser qualquer coisa, eu poderia mandar um objeto, por exemplo, e dentro mandar o texto do todo, por exemplo, new todo. Então, quando eu salvo e clico em adicionar, veja que agora o payload, ele tem new todo dentro dele, new todo, oi. E eu tenho também o meu array aqui, aqui ele usa um proxy, então por isso que aqui no console.log do navegador ele acaba não mostrando certinho. Mas o que a gente vai fazer aqui agora do nosso estado é, se eu tenho dentro do meu state, o array que eu já tinha anteriormente na minha lista de todos. E dentro do action, eu tenho o valor do novo todo que eu quero adicionar, agora basta eu fazer o seguinte, adicionar o novo todo aqui dentro do state. Então, o que eu vou fazer? state, o state ele é um array, tá? .push, e aqui dentro eu quero adicionar o novo todo. Então, action.payload.new todo. Dentro do payload é que está vindo o texto do new todo aqui que eu quero adicionar. Salvo isso aqui agora, volto e olha só que interessante. Estudar, react, clico em adicionar, pronto, já foi ali pra dentro. Ou seja, agora a gente fez o fluxo completo aqui dentro do Redux. A gente começou criando um store, o store é o estado global, toda a aplicação vai ter acesso a todas as informações do store. A gente entendeu como que a gente faz pra separar o nosso store em pequenos pedacinhos, que a gente chama aqui dentro do Redux Toolkit de fatias, usando essa propriedade reducer. Então, aqui eu posso ter um pra tudo, outro pra carrinho e por aí vai. A gente entendeu como que a gente cria ações no Redux, que são as portas de entrada pra realizar alterações no estado. E a gente entendeu como conectar tudo isso aqui com os componentes do React, usando o useSelector pra buscar informações do estado e usando o useDispatch pra realizar alterações no estado, pra disparar ações no estado. Então, isso aqui é basicamente o fluxo completo do Redux aqui dentro. Só que, uma coisa que não tá tão legal ainda, é que não tá muito bem integrado ao TypeScript isso aqui. Pode ver que eu até tô com o tipo unknown aqui dentro. Então, o que a gente pode fazer? Aqui no store, eu vou exportar uma função chamada useAppSelector, só pra não ficar igual o outro nome, useSelector, pra não se embabacar na hora da importação. E aqui de dentro, eu posso importar, de dentro do React Redux, dois carinhas aqui, o useSelector, e posso importar também o typed useSelector hook. E aqui de dentro, o que eu vou fazer? Eu vou tipar isso aqui com o typed useSelector hook, e vou falar que isso aqui é basicamente o meu useSelector. Só que ele vai tá tipado, né? Aqui o typed useSelector hook, ele recebe, ele precisa receber um parâmetro que é o tipo do meu estado global. E aqui, o que a gente vai fazer? Eu vou simplesmente fazer um typeof store.getState. Só que aqui eu vou pegar e vou separar isso aqui numa variável. Então, eu vou botar export type rootState, fazer dessa forma, e eu passo o rootState aqui dentro. Isso aqui tem na própria documentação lá, se tu for no guia de TypeScript do Redux. O que a gente tá fazendo? Essa função getState aqui, ela retorna todo o meu estado. Quando eu uso o typeof getState, ele retorna o formato do meu estado. Olha só. Eu tenho o todo, que basicamente é um array com várias strings. Isso aqui é o meu estado atualmente. E aí, eu criei uma nova função, selector, pra eu usar o meu useSelector, igual eu fiz lá na todo list, porém tipado. Então agora, se eu trocar esse useSelector por useAppSelector, veja que agora ele vai estar tipado. Então aqui no store... Deixa eu ver... Isso aqui é uma função. Eu acho que eu vou ter que... Ah, óbvio, né? O getState é uma função. Então, se eu uso o typeof, ele vai pegar o tipo da função. Na verdade, eu quero o tipo do retorno da função. Então aqui eu posso usar, na verdade, o returnType do TypeScript, que ele retorna o tipo de retorno. E aí aqui dentro, typeof. Então agora o rootState vai ser exatamente o objeto que dentro tem tudo. Então salvo, volto na todo list. Agora vejo que aqui ele já traz exatamente o que eu tenho. E ele já sabe que isso aqui é um array de strings. Então já fica muito mais fácil eu usar o Redux tipado aqui dentro, com o TypeScript nos meus componentes. Salvo isso aqui agora. Beleza, a aplicação funcionando. Digito aqui, dou um adicionar. E aqui, no meu addToDo eu posso vir aqui e dar um setNewToDo vazio, depois de eu criar ele, né? Então salvo, boto aqui, dou um adicionar e ele já limpa o nosso formulário."
  },
  {
    "id": "1950c6a3-05d0-4826-8f8f-7cafbca2f937",
    "title": "Utilizando Redux DevTools",
    "transcription": "Uma dica se você vai utilizar o Redux em algum projeto é instalar uma extensão no seu navegador que ela está disponível tanto para os navegadores baseados em WebKit como Chrome, Edge, Work e também o próprio Firefox que é a Redux DevTools e você pode procurar isso na própria loja de extensões do navegador, o nome dela é exatamente esse aqui ó, Redux DevTools e essa extensão depois que você instala ela você pode tanto clicar nela ou abrir aqui o inspecionar elemento depois de ressaltar o navegador e vai ter uma nova aba chamada Redux aqui embaixo, olha só, essa aba é muito legal, eu vou até dar um F5 aqui para recarregar a página porque essa aba aqui ó, você consegue vir aqui em State e você consegue observar exatamente o seu estado global do Redux, mas o mais legal disso aqui é que quando você faz alguma alteração no estado, por exemplo, vou adicionar um novo todo e clique em adicionar, ele mostra aqui na esquerda todas as actions que foram disparadas, ele mostra o meu estado, é claro, e como que esse estado está conectado e tudo mais e se eu clico aqui na action eu consigo saber exatamente os dados que foram disparados, o type da action, o payload da action, exatamente o chart dela, eu consigo também ter um log de tudo o que foi feito aqui no meu estado e essa ferramenta aqui ela é bem complexa e bem, digamos, completa, eu nem acabo usando ela por completa, mas ela é bem legal mesmo, ela mostra exatamente onde que a action foi disparada, em qual componente, é bem completo mesmo e ela mostra até um possível teste que eu poderia criar, um teste unitário para testar que isso aqui está funcionando, então isso aqui é bem legal porque eu posso copiar isso aqui e jogar no meu projeto e pronto, ele já vai estar funcionando e aqui ele mostra também o diff, isso aqui eu acho que é uma das coisas mais legais, que é dado essa action aqui que aconteceu, isso aqui foi o que aconteceu no estado, o diff, ele adicionou um novo todo na terceira posição do array com o texto novo todo e outra coisa muito legal é que eu consigo navegar na linha do tempo do meu estado, então aqui embaixo eu tenho uma timeline que eu consigo rodar ela e eu posso fazer o seguinte, eu posso vir aqui adicionar mais alguns estados, vou criar mais alguns e aqui conforme eu vou voltando ele vai desfazendo as ações que eu fiz e eu posso vir aqui, dar um play e ele vai rodar uma após a outra, isso aqui é bem legal e tem muita coisa como eu falei, tem muita coisa, eu posso disparar actions daqui de dentro, então essa ferramenta aqui, essa extensão ela é indispensável para quem trabalha com Redux no dia a dia porque você consegue ter um log de tudo o que está acontecendo, então você pode pular aqui para um momento no estado, na linha do tempo da sua aplicação, isso aqui é muito legal mesmo, então recomendo altamente que você utilize isso aqui no seu projeto conforme você estiver utilizando Redux."
  },
  {
    "id": "a29db6ef-49bc-4306-ad99-279ba5a57fc9",
    "title": "Estrutura base da UI",
    "transcription": "Agora que a gente já entendeu os fundamentos do Redux, a gente vai construir uma aplicação mais complexa usando o Redux, claro, e o que eu vou fazer aqui agora, então, é apagar o que a gente fez até agora pra gente começar algo do zero e algo mais organizado, né? Então, eu vou começar apagando os componentes aqui relacionados a todo, e aqui no meu store eu vou apagar esse meu todo slice, vou deixar os meus reducers aqui vazio, vou apagar também esse const add, o resto aqui eu posso até deixar, tá? Então o resto a gente nem vai mexer muito aqui no store, porque a gente vai usar algo parecido daqui a pouco. No app aqui eu vou remover, então, add todo, aqui posso remover isso aqui também, e beleza, vamos começar criando a nossa aplicação. A nossa aplicação aqui não vai ser uma aplicação muito complexa, então ela vai ter uma única página, eu poderia codar tudo aqui dentro do app, mas pra ficar um pouquinho mais organizado eu vou criar uma pasta pages, que seriam as páginas, as rotas da aplicação, e aqui eu vou criar uma única página, que eu vou chamar de player.testx, vai ser um componente, como qualquer outro, e aqui dentro eu vou escrever apenas modif player, e aqui no app, player, perfeito. Pra não ficar uma interface feia, né, eu não gosto muito de desenvolver quando a interface é muito feia, eu vou estar utilizando o tamed CSS aqui pra gente criar uma interface, e aqui em get started a gente vem na opção using postcss, eu vou instalar essas três dependências, tamed postcss e outperfixer, e vou rodar npxtamed init, aguardar um pouquinho que a instalação, beleza, roda o init, ele vai criar um arquivo tamed config, e aqui em content eu vou falar onde que vão estar os meus arquivos testx, então eu venho aqui e falo que dentro da pasta source, toda pasta que estiver aqui dentro, todo arquivo que termina com testx pode ter classes do tamed, né, salvo isso aqui agora, e pronto, teoricamente o tamed já está configurado, preciso só, na verdade, criar aqui uma pasta styles, e dentro eu vou criar um global.css, jogo essas três linhas aqui do tamed, e aí é importante que esteja com a extensão do postcss instalada, e com a extensão do tamed também instalada no vascode pra que ele entenda aqui o autocomplete. E agora no meu app, ou no meu main, tanto faz, eu importo styles.global.css, feito isso, a gente vai agora testar se o tamed está funcionando, então aqui no meu navegador, eu acho que eu tenho que reiniciar a aplicação, deixa eu ver aqui no pages player, nessa jive, botar um class name, bgblack, para ver se fica preto, ainda não, então deixa eu ver o que eu estou esquecendo, app, styles, global, dar um inspecionar aqui, bgblack, tá, o tamed não está aplicando, deixa eu ver se eu fiz a importação correta, store does not have a valid reducer, não é um problema, peraí que alguma coisa, ah, eu acho que eu já sei o que eu errei, aqui, quando eu dou o tamed init, se eu não me engano, quando eu uso o vit, deixa eu até vir aqui, aqui ó, eu preciso usar esse \"-p\", aqui no final, então deixa eu ver se eu consigo rodar de novo, beleza, porque ele precisa criar esse postcssconfig aqui ó, se não, não funciona, e aí beleza, agora eu acho que teoricamente o tamed vai funcionar, volto lá, beleza, agora sim, já está preto ali, o texto não está aparecendo, mas não é um problema, e agora a gente vai criar uma estrutura base aqui de como que vai funcionar a nossa aplicação, o que a gente vai estar desenvolvendo aqui nessa aula é um player de música, na verdade não é um player de música, perdão, é um player de vídeos, muito semelhante ao player que a gente usa, que você está usando, aí na plataforma da Rocket para assistir as aulas, então ele vai ter um vídeo principal e na direita ele vai ter vários módulos das aulas, o usuário vai poder navegar pelas aulas, pelos módulos, e isso vai exercitar bastante conceitos aqui de dentro do Redux, tá? Eu vou começar, então, utilizando, claro, o tamed-css aqui, para criar uma interface eu vou começar botando uma div com hscreen, que vai ocupar a tela toda na sua altura, e uma cor zinc, que é um cinza 950, ou seja, bem escuro, e aqui usando a extensão do tamed-css eu consigo ver todas as classes que eu posso utilizar, e text-zinc 50, ou seja, vou inverter um pouquinho as cores, pode ver que a tela já ficou preta, e agora o texto que eu coloco aqui dentro vai ficar quase branco, um cinza bem clarinho. Outra coisa que eu vou fazer aqui é dar um flex, um justify-content-center e um align-item-center para que todo o conteúdo da tela fique centralizado, então pode ver que o player já vem aqui para baixo, tirar o zoom aqui que estava um pouquinho, e agora aqui dentro a gente vai desenvolver a interface do player em si, então vou criar uma nova div com flex também, e eu vou definir a largura dela como 1100 pixels, eu não vou fazer isso aqui responsivo, então não vou me preocupar muito com isso, mas se você quiser, fique à vontade, vou definir um flex-direction-column e um gap de 6, a gente já vai entender para que que é isso, e aqui dentro agora eu vou ter duas sessões, então vou ter uma div e vou ter a parte do main, essa div principal aqui é onde vai aparecer o conteúdo da aula que está sendo reproduzida no momento, então o título e algumas informações no cabeçalho, digamos assim, e abaixo dela é onde vai ficar o nosso player do vídeo e também a sessão de módulos e de aulas. Nessa primeira div aqui em cima eu vou começar botando um flex-items-center, justify-between porque eu quero que a parte do título da aula e o módulo dela fique totalmente à esquerda, e vou criar um botãozinho de deixar feedback que fique totalmente à direita, então vou começar pela parte que mostra a aula atual e o módulo e tudo mais, então vou criar uma div aqui com flex, flex-col porque eu quero que fique um abaixo do outro, gap-1 para dar um pequeno distanciamento, aqui eu vou ter o título da aula, então vou botar fundamentos do Redux, por enquanto vai ser tudo estático, esse título aqui eu vou colocar nele um text 2xl que é um tamanho de 24 pixels e um font-bold, negrito, e abaixo eu vou ter um span, por exemplo, módulo 01, para falar qual é o módulo que pertence àquela aula, ou melhor, vou botar o nome do módulo ao invés do índice, então módulo, posso botar desvendando o Redux, uma coisa assim, e aqui no span eu vou botar um text small que vai diminuir a fonte para 14 pixels e um text zinc 400, se eu salvo isso aqui e volto lá na aplicação, como que já está ficando, bem legalzinho, aqui eu gosto de fazer também no global.css, pegar o body e fazer um webkit font-snooping-anti-aliased, salvo e a fonte vai ficar mais detalhadinha, fica mais bonito a fonte, aqui abaixo do header, isso aqui é o header da minha aplicação, posso até, enquanto que eu não criei componentes, fazer dessa forma aqui, header, aqui embaixo eu vou ter um botãozinho para deixar feedback, então eu vou já criar esse botão, deixar feedback, e aqui eu vou instalar uma biblioteca de ícones, eu vou usar o Lucid React como biblioteca de ícones, ou pode ser, na verdade, pode ser, tanto faz, a biblioteca de ícones, se quiser usar o Phosphor, acho que existem várias que são muito boas aí, e eu vou pegar um ícone aqui de chat, deixa eu ver se eu tenho, talvez, Bubble Message, Message Circle, deixa eu ver aqui, Lucid.dev.io.chat, essa aqui eu quero Message Circle, aqui dentro do botão, vou colocar esse ícone, e vou colocar nele aqui um className, w4h4, para ele ficar com 16 pixels, e no botão aqui eu vou colocar algumas classes também, flex, itemCenter, um gap2, para distanciar o ícone do texto, deixar o feedback, rounded, bgViolet500, que é um roxinho, PaddingX3, que dá 12 pixels nas laterais, PaddingY2, que dá 8 pixels em cima e embaixo, TextSmall, FontMedium, TextWhite, salvo, e volto, já está ali, meu botãozinho de deixar feedback. Para não ficar tão feio, eu vou dar um hover aqui, quando o usuário passar o mouse por cima, eu vou trocar o bg, escurecer um pouquinho, um violet600, então fica já bem legal. Agora que a gente já fez o header da nossa aplicação, a gente vai para a parte principal aqui do nosso main, então aqui no nosso main, eu vou começar usando um relative, um flex, um overflow hidden, já mostro o porquê desse overflow, rounded, large, border, borderZinc800, bgZinc900, e aqui vou utilizar também um shadow, que ele vai criar um leve sombreamento. Então está aqui embaixo, como não tem nenhum elemento dentro dele, ele praticamente nem está aparecendo, e aqui dentro a gente vai ter basicamente duas seções, eu vou ter uma div, que ela vai ocupar o máximo do espaço possível, por isso eu vou usar o flex1, que vai ser a parte onde vai estar o meu vídeo, então vou até escrever vídeo aqui dentro, o vídeo vai ficar aqui na esquerda, e na direita eu vou ter a lista de módulos, então aqui eu posso criar um aside, que vai ser a listagem de módulos, então aqui dentro eu vou utilizar um w80, que vai dar 320 pixels de largura, vou usar um border L, que vai dar uma borda na esquerda, no momento que ele se conecta com o vídeo em si, vamos utilizar também um borderZinc800, que é a cor da borda, um bgZinc900, e aqui, pra gente começar a visualizar isso aqui, eu vou botar uma altura fixa, por enquanto, vou botar um h600 pixels, depois eu vou tirar isso aqui, então salvo, e pronto, essa aqui vai ser mais ou menos a estrutura do nosso player, aqui vai ficar o vídeo, aqui vão ter os módulos com as aulas pro usuário ir clicando e navegando entre os vídeos que a gente vai ter aqui na esquerda. Então a gente ainda tem que terminar de construir a nossa interface, e também conectar ela com o Redux em si."
  },
  {
    "id": "f4f594e3-cb1d-44a6-bcd7-114eee5aebb4",
    "title": "UI dos módulos e player",
    "transcription": "Nessa aula a gente vai terminar a interface da nossa aplicação, então eu vou construir a parte de módulos e de aulas aqui, que na verdade vai ser bem simples, tá? Então eu vou começar criando uma div aqui por volta, vai ser a div que vai ficar por volta de cada módulo, então cada módulo vai ter uma div dessa aqui, e dentro dessa div eu vou ter um botão que vai servir para o usuário abrir o módulo, então cada módulo aqui vai ser collapsible, digamos assim, então clica e ele abre, um acordeon, digamos assim, então clica e ele abre, e é isso. Aqui nesse botão, que vai ser para o usuário abrir o módulo, dentro desse botão aqui eu vou escrever basicamente o... a gente vai ter algumas informações aqui, então por enquanto eu vou deixar na verdade vazio, tá? Por volta do botão eu vou fazer o seguinte, vou botar um flex, WFULL para ele ocupar toda a largura, item center, GAP 3, BGZINC 800, PAGING 4 que dá 16 pixels e HOVER BGZINC, na verdade HOVER... vou deixar sem HOVER por enquanto. Aqui dentro daí eu vou ter uma div que vai mostrar qual que é o módulo, então por exemplo... ih, chegou, peraí, ih, já cheguei comendo ali e meu cachorro ficou maluco, mas aqui dentro desse botão eu vou ter primeiro qual que é o número do módulo, então vou jogar aqui 1, simplesmente, e eu vou botar nessa div aqui... pode ser um spot também, tá? Vou botar uma div. Flex, H10, W10, porque eu quero que ele fique uma bolinha assim com o número, tá? Rounded Full, Item Center, Justify Center, para que o número fique bem centralizado, BGZINC 950 e Text Extra Small. Salvo isso aqui agora, olha ali como é que ficou, legal né, ficou bonitinho. E agora eu preciso aqui do ladinho o nome do módulo e eu vou botar também quantas aulas tem. Aqui abaixo dessa div, olha, criar uma nova div, flex, flex-col, gap 1 para distanciar um pouquinho, text-left, e aqui eu vou botar strong, o nome do módulo, então desvendando o Redux, acho que era isso que a gente tinha colocado lá no topo. Depois vai ter mais módulos, a gente vai buscar isso da API, tudo certinho. E aqui eu vou ter um span, text-extra-small, text-zinc-400 com o número de aulas, por exemplo, isso aqui tem 12 aulas, salvo e show, ficou já bem massa. E aí por último eu vou colocar aqui no final, depois dessa div, um ícone, vou pegar o caret, deixa eu ver, talvez chevron, isso, chevron-down, que vem lá do lucid, já importou aqui automaticamente. Vou botar aqui nele um classname w4h4, ml-alto para ele jogar totalmente lá para a direita, e vou botar aqui um text-zinc-400, talvez ele fique um pouquinho pequeno demais, vou aumentar ele um pouquinho aqui, show, acho que assim já ficou bem legal. Perfeito, a gente já tem então a estrutura aqui do módulo, e agora a gente vai para a estrutura de aulas. Então, abaixo aqui do nosso botão, eu vou criar um nav, que é onde vão ficar os links das minhas aulas, vou botar aqui também um position-relative, flex, flex-col, gap-4, e p6, page-6 que dá 24 pixels, e agora eu vou colocar as minhas aulas aqui dentro. As minhas aulas vão ser simplesmente, nesse caso aqui, botões, e dentro da aula aqui eu vou começar, bom, já vou estilizar esse botão, flex-item-center-gap-3, text-small-text-zinc-400, e aqui agora, dentro da aula, eu vou botar um iconezinho, então deixa eu ver se eu tenho um icone de vídeo, isso pode ser esse aqui ó, vídeo, pode ser esse, vídeo, que vem do lucid-react, e nesse icone aqui eu vou botar nele um w4h4 e um text-zinc-500, escrevi class-name aqui com letra maiúscula, fora isso vai ter o título da aula, então, fundamentos do Redux, pode ser dentro do span ou não, vou botar no span aqui, pra ficar mais organizado, e um outro span, que é a duração da aula, nesse span aqui eu vou dar um ml-alto pra ele jogar totalmente pra direita, um font-mono-spaced, text-extra-small, e um text-zinc-500, vou botar a duração lá, 9 minutos e 13 segundos, salvo, vamos ver como ficou, olha ali, ficou bonitinho, ficou bem legal, e agora se eu pego esse botão aqui e vou replicando ele, teoricamente eu vou ter várias aulas, legal, isso aqui é mais ou menos a estrutura que a gente vai ter, então, a gente já terminou o CSS base, e agora eu preciso do player do vídeo aqui na esquerda, e bora fazer isso então, o que a gente vai fazer aqui dentro, eu vou começar aqui onde a gente colocou vídeo, eu vou colocar uma nova div aqui dentro, class-name, e aqui eu vou falar que ela vai ocupar a largura toda, um bg-zinc-950, e aqui eu vou colocar uma classe chamada aspect-video, que ele vai fazer com que essa div aqui, ela siga o aspect-ratio de um vídeo, que é 16 por 9, 1980 por, bom, 1920 por 1080, ou 18720, então, se o usuário redimensionar a tela, essa div aqui ela sempre vai seguir o aspect-ratio de um vídeo, e aqui dentro eu vou colocar o meu player com o vídeo do YouTube, pra isso eu vou usar uma biblioteca chamada react-player, que é uma biblioteca bem legal, que ela permite eu fazer embed de vídeos de várias sources, de vários providers, então, YouTube, Vimeo, essas coisas assim, e aqui eu vou importar player de dentro de react-player, ah, o nome é igual, então, eu vou trocar aqui pra react-player, mais pra frente eu vou separar em componentes, aí eu posso voltar o nome, e aqui dentro, então, agora eu vou botar esse react-player, e aí, a primeira coisa mais importante aqui, eu vou jogar nela um width, 100%, height, 100%, vou botar controls como sendo true, ou nem precisa passar, acho que só dessa forma já tá bom, e a URL do vídeo, aqui na URL do vídeo, a gente pode pegar qualquer vídeo do YouTube, e aí botar a URL do vídeo aqui, por exemplo, https://www.youtube.com.br watch v=\", e aqui bota um id de algum vídeo lá do YouTube, eu peguei um id qualquer aqui de um vídeo que a gente tinha mais antigo aqui na Rocket, só pra mostrar, salvo aqui agora, volto no arq, no navegador, e tá lá, já o meu vídeo, olha só, o vídeo já tá tocando aqui, e agora, tá vendo que ficou mais alto aqui, o que a gente pode fazer, lembra que eu tinha colocado um height fixo aqui na sidebar, pra que a gente pudesse já ver, então agora eu posso remover isso aqui, e pronto, a gente já tem o nosso player, e agora a altura da sidebar é definida com base na altura do player em si, então agora a gente já tá com a nossa interface praticamente pronta."
  },
  {
    "id": "f7497e19-02c2-442e-8743-ec5a8bc836cd",
    "title": "Scrollbar na sidebar",
    "transcription": "Uma coisa que a gente vai fazer aqui agora é, se a gente criar muitos módulos, por exemplo aqui na nossa sidebar, se eu copiar essa div que representa o módulo inteiro e replicar ela umas duas vezes, voltar no navegador, a gente vai ver que ela ficou maior que o player, então eu precisaria de uma sidebar aqui dentro. Só que se eu pegar aqui no meu aside e jogar aqui um overflow y scroll, salvar, ele não consegue colocar o scroll, porque como a altura desse nosso container aqui por volta está definido com base no conteúdo do container, conforme mais conteúdo eu coloco na sidebar, maior ela vai ficar. Só que eu gostaria que a sidebar tivesse, na verdade, o tamanho máximo relacionado ao tamanho do player, então o player que deveria ser a referência do tamanho máximo da sidebar. Então, uma técnica que a gente pode fazer isso é o seguinte, eu coloquei esse position relative aqui no main, porque se aqui na minha aside eu colocar um position absolute com top 0, bottom 0 e right 0 também para ficar ali na direita, veja que a altura agora da minha sidebar está com base no tamanho do player, só que como ela está com position absolute, agora o player foi para baixo da sidebar. Então, o que eu vou fazer aqui agora, pode ser nessa própria main aqui em cima, eu vou dar um padding right 80, que é o mesmo tamanho da minha sidebar, então o player não vai ocupar esse espaço aqui. Então salvo, e olha só, agora a sidebar está com o tamanho exato do meu player, na questão de altura. Só que essa sidebar, essa scrollbar aqui, do padrão do navegador, ela é muito feia, então tem um plugin do Tailwind, esse aqui, o Tailwind Scrollbar, que eu gosto de utilizar, eu vou instalar ele aqui usando o npm, e aí eu só preciso usar esse require aqui, aqui no Tailwind config, pronto, require is not defined, tem algum problema do slint aqui, provavelmente. Esse slint aqui vem instalado com o vit, react-refresh, typescript. Olha, eu vou apagar esse slint aqui, porque ele está com umas confurações que eu não queria que ele tivesse, e não quero me incomodar com o linting agora, depois a gente pode confurar o slint se a gente quiser. Mas tá, feito isso, eu posso voltar aqui na side, que é a tag onde eu botei a scrollbar, e a gente vai colocar algumas classes aqui a mais, a primeira delas é a classe scrollbar, a segunda é a scrollbar-thin, pra ela ficar fininha, eu vou botar também a scrollbar-track-zinc-950, então a gente vai ver que agora a scrollbar, o fundo dela ficou cinza bem escuro, e a scrollbar-thin-zinc-800, que é exatamente a parte onde mostra o scroll aqui. A scrollbar aqui já ficou um pouco mais bonita, acho que é isso, tá ok. Outra coisa que a gente pode ajustar aqui é o seguinte, aqui todos os módulos estão abertos, tá vendo? Só que nem todos vão estar abertos mais pra frente, por exemplo, se eu vier aqui nesse primeiro módulo, nesse primeiro que eu tenho aqui, e tirar as aulas dele, então esse nave aqui eu pego e tiro, ele ficou grudado e tá vendo que não tem nenhuma separação entre os módulos, sabe? Então eu vou fazer o seguinte, aqui na side eu vou jogar também um divide-y2, que ele vai criar uma separação dos módulos, e divide-zinc-900, então ele bota essa corzinha pra separar os módulos, acho que já fica melhor do que estava antes. Beleza, agora que a gente já deu uma melhorada em tudo, a gente vai também separar um pouco esses componentes, porque tá muito grande aqui o arquivo cheio de código."
  },
  {
    "id": "a9fcf013-6bb8-4b3b-b4c3-fe84ec84de6b",
    "title": "Separando componentes",
    "transcription": "Nessa aula, a gente vai separar nossa interface em componentes menores, então eu vou começar criando um componente header, e aqui dentro desse componente eu vou jogar exatamente essa partezinha que tem o nome da aula e o módulo, e agora eu volto aqui e uso o componente header. Eu vou criar também um componente pro player, então eu vou pegar exatamente essa div aqui e o componente do ReactPlayer aqui, então eu vou começar criando um componente, eu vou chamar ele de vídeo, pra não ficar o mesmo nome, e aqui eu vou importar o ReactPlayer, volto aqui, vídeo, só temos que importar esse do lugar certo, porque eu estou importando um ícone chamado vídeo, então o que eu vou fazer, eu vou tirar o vídeo do ícone e vou importar o vídeo do componente, e aqui agora antes de salvar, eu vou tirar também a parte de módulo, então eu vou começar criando um módulo, vamos do TSX, e aqui da página eu vou copiar exatamente essa div aqui, vou copiar uma que tem aula, então eu vou pegar essa div aqui de baixo, que tem aula também, vou copiar ela inteira, vou jogar aqui dentro de module, e aqui eu vou fazer as importações do ícone, chevron down, e do vídeo, cuidar pra importar certinho, do lucid React e não do nosso componente. Feito isso, eu salvo, volto lá no player, apago os outros módulos que eu tenho aqui dentro da div assign, da tag assign, e vou colocar aqui module, vou botar umas três vezes aqui, só pra mostrar, ver se tá certinho, beleza, tá ali os módulos, e aqui dentro do módulo eu também tenho as aulas que eu consigo criar um componente pra reaproveitar, então eu vou chamar de lesson, e aqui na minha lesson eu vou pegar exatamente este botãozinho aqui, importar o componente vídeo aqui do lucid React, volto no módulo, e agora aqui dentro, import a lesson, vou botar três vezes, legal, agora a gente vai colocar algumas propriedades que são importantes nesses elementos, então vou começar aqui na lesson, eu vou colocar apenas título e duração, por enquanto, mais pra frente a gente vai ter mais algumas propriedades, e aí no lugar aqui do fundamentos eu jogo título, e no lugar aqui eu boto duração. Beleza, volto lá no módulo, e agora eu preciso passar pras nossas lessons, título, fundamentos do Redux, e duração também, como uma string. Legal, o módulo também vai ter algumas propriedades, por enquanto eu vou botar título, amount of lessons, ou lessons amount, tanto faz, que é um número, e por enquanto tá ok, aqui eu vou pegar essas propriedades, title e amount of lessons, e aqui eu vou receber também uma outra propriedade, que vai ser o moduleIndex, que é o número, que é qual a ordem do módulo, pra eu botar esse número aqui, e aí esse número aqui vai ser moduleIndex, que vai vir aqui das propriedades, só que eu vou botar moduleIndex mais um, porque como o índice do array começa no zero, eu não quero que tenha módulo zero, aqui vai ser o meu título, e aqui, no lugar do doze, vai ser o amount of lessons. Volto lá no player agora, e a gente vai botar aqui moduleIndex, zero por exemplo, só que aí eu vou botar zero, um e dois, vamos ter o título, então vou botar desvendando o Redux, e o amount of lessons vou botar por exemplo, três. Salvo isso aqui agora, volto e pronto, já tá lá, um, dois e três, e tudo certinho aqui dentro. Beleza? Separamos os nossos componentes aqui, em mais, na verdade separamos em vários componentes aqui dentro, ainda tá tudo estático, porque a gente ainda não tá acessando os dados da API, mas show, pelo menos a gente tá com a interface aqui pronta pra gente poder agora começar a trabalhar com a API, começar a trabalhar com o Redux aqui dentro, e começar a integrar essa interface com os conceitos que a gente aprendeu de Store, Reducer, Actions, e por aí vai."
  },
  {
    "id": "1a4d09f0-81a9-404d-a90e-6c34b46ed93c",
    "title": "Radix Collapsible nos módulos",
    "transcription": "A última coisa que a gente vai fazer aqui em questão de interface antes da gente começar a trabalhar com o Redux em si é permitir que os módulos aqui o usuário possa abrir e fechar eles. Para isso eu vou usar o Collapsible do Radix. Se você nunca usou o Radix, o Radix é basicamente uma biblioteca de componentes que ela traz componentes que trazem funcionamento sem trazer estilização. Então, por exemplo, o Collapsible, que é algo que eu posso abrir e fechar, que é mais ou menos o que a gente quer. Então, eu vou instalar, vou copiar o nome aqui. Ah, ele tem aqui embaixo também o comando de install. Aqui ó, npm install, posso copiar. Vou jogar aqui dentro. E o Collapsible, ele é bem simples, ele tem um root que eu preciso botar por volta de todo elemento que vai poder ser aberto ou fechado. Então, é o módulo no caso aqui. Então, eu vou começar fazendo a importação aqui no módulo, ó, de Collapsible. Aqui tem uma importação que eu tenho que tirar. Essa div que tá por volta hoje aqui, que não tá servindo pra nada, eu vou usar o Collapsible root nela. Ele também não deixa de ser uma div. O botão que abre o módulo, eu uso o Collapsible trigger. Então, é só trocar aqui a tag. E o conteúdo onde vai aparecer as minhas aulas, eu uso o Collapsible content. Então, eu posso botar aqui no lugar do nave, acredito que já vai funcionar. Salvo isso aqui agora, volto no navegador. Só que aqui eu vou deixar o nave, na verdade, porque ele tem estilização e vou botar o Collapsible content por volta. Porque eu quero que ele suma inteiro. Agora sim, ficou tudo bem juntinho. E agora se eu clico, ele abre e eu posso abrir dois ao mesmo tempo também, já tá bem certinho. Só que, seria legal ter algum tipo de estilização, né, diferente, quando o módulo tá aberto. Então, eu vou pelo menos trocar essa flechinha aqui, né, quando tá aberto ou não. Como é que a gente pode fazer isso, tá? Aqui no Collapsible, uma coisa legal do Radix, é que se a gente for aqui no botão, ou melhor, no root, que é este carinha aqui por volta, este aqui é o Collapsible root, é este carinha aqui. O que acontece é que quando eu abro ele e fecho, ele troca aquele data state, tá vendo ali? O data state, que fica entre open e closed. Então, o Radix, ele coloca esses data attributes nos elementos, como tem aqui no button também, pra identificar quando tá aberto ou fechado, identificar o estado. E eu posso estilizar com base nisso. Por exemplo, se eu vir aqui no root e falar o seguinte, olha, class name, data, state, igual, open, ou seja, quando ele estiver aberto, eu quero botar uma borda, deixa eu ver aqui, uma borda 4, sei lá, pra botar uma borda bem grande. Então, olha só, quando ele tá aberto agora, olha só, ele bota a borda. Então, eu consigo estilizar no tailing baseado em outros atributos, principalmente no data, dessa forma. Se o data state estiver open, eu quero adicionar alguma coisa a mais. Só que eu quero estilizar esse chevron aqui. Só que se eu botar esse mesmo data no chevron, não vai funcionar. Ele não bota a borda, tá vendo? Porque a propriedade data state, ela não tá no ícone. Se eu for no ícone, o ícone tá aqui dentro do botão, aqui ó, o SVG. O SVG não tem nenhum data state, tá vendo? O data tá aqui em cima no root. Então, quando a gente usa tailing, o que a gente pode fazer é o seguinte, aqui no root eu venho e jogo uma propriedade chamada group, pra falar que isso aqui é um grupo, e agora eu consigo adicionar CSS em algum elemento baseado em atributos do grupo, que é este cara aqui. Então, eu só boto group, traço, aqui na frente. Então, agora sim, quando tá aberto, ele bota a borda no chevron. E aí, o que eu quero fazer, na verdade, aqui não é borda, né? Eu quero girar ele, então eu vou dar um rotate 180, salvo, e olha só, ele já faz o rotate. Se você quiser colocar aqui um transition no transform, pode ser legal também, ele faz uma estilizaçãozinha, né? Legal. É isso, eu acho que a gente não precisa ficar colocando muito, aqui tá dando uns erros aqui, mas não é muito problema, isso aqui é coisa do React Player, a gente não vai se preocupar com isso agora, por causa que é do plugin do player que eu tô usando aqui dentro. Mas é isso, já tá bem legal a interface, e agora sim, a gente pode continuar e agora sim, integrar isso aqui com o Redux em si."
  },
  {
    "id": "bd4fe5b1-d32e-487e-90ec-9b004ba96f60",
    "title": "Criando reducer do player",
    "transcription": "Nessa aula a gente vai começar a criar o estado que vai gerenciar toda a parte de aulas e módulos aqui da nossa aplicação. Então eu vou começar aqui dentro de store criando uma pasta chamada... aqui pode ser slices e aqui eu vou criar a nossa primeira fatia do estado que é o player em si. Então aqui dentro do player eu vou basicamente fazer o que a gente já estava fazendo antes com o todo que é criar uma player slice usando o método createSlice que vem lá do Redux Toolkit. E aqui eu preciso dar um nome, player por exemplo, e preciso obrigatoriamente passar um estado inicial e os reducers que são as ações. No estado inicial aqui eu basicamente vou ter as informações sobre as aulas, os módulos e tudo mais. Então eu vou começar criando uma propriedade aqui chamada curso e aí dentro do meu curso eu vou ter basicamente os módulos. Os meus módulos vão ser um array, claro, porque eu posso ter vários módulos, e cada objeto dentro de módulos eu vou dar um id para o módulo como se isso aqui estivesse vindo da API. Por enquanto eu não criei uma API, mas logo a gente vai criar, como se fosse a resposta da API. Então cada módulo tem um id, tem um título, por exemplo, iniciando com React, alguma coisa assim, e tem as aulas. As aulas também vão ser um array e vão ter várias informações aqui dentro, vão ter o id dessa aula, que eu posso usar o mesmo id do vídeo do YouTube, então a gente pode ir lá no componente vídeo, pegar o id do vídeo, podemos usar o mesmo, tanto faz, passar um título aqui, aqui eu posso botar qualquer título, fundamentos do Redux, só pra gente ter um exemplo. E tem que ter a duração, então eu vou botar a duração aqui, 9 e 13, acho que a gente estava usando esse aí. Perfeito, aqui como eu quero ter um pouquinho mais de módulos e um pouquinho mais de aulas, eu vou deixar pra você aqui embaixo dessa aula um array de módulos pra você botar aqui. Então você vai vir aqui e joga todo o array de módulos. Eu basicamente peguei alguns ids de vídeos do YouTube públicos da Rocketseat e criei dois módulos aqui. E não tem nada a ver o título, o nome das aulas com o nome dos módulos, não tem nada a ver, é só realmente pra gente ter um tanto de dados aqui. Então beleza, já temos o nosso initial state aqui configurado, por enquanto eu não vou criar nenhum reducer, nenhuma action aqui dentro, o que eu vou fazer aqui é exportar de dentro do nosso arquivo, do nosso slice, o nosso reducer, então eu vou exportar uma constante, eu vou chamar de player mesmo, que é igual a player.slice.reducer, isso aqui agora eu preciso importar dentro aqui do index, do meu store, aqui dentro de reducer. Então eu boto player aqui, que importa de slice.player. Como o nome é igual aqui eu posso até deixar dessa forma. Beleza, o meu useAppSelector aqui já está configurado, então agora eu posso voltar lá na minha página player, aqui dentro eu posso fazer, basicamente eu quero pegar os módulos da aplicação, então eu vou dar um useAppSelector state.player.curse.modules, que é exatamente o que eu quero. Se você preferir, você pode vir aqui e dar um return e fazer dessa forma. Uma coisa importante é que quando a gente está usando o Redux, usando esse selector O selector é um conceito bem interessante, que também acaba diferindo bastante o Redux da Context API, porque na Context API, quando a gente usa os dados do contexto dentro de um componente, independente de qual dado daquele contexto mudar, aquele componente vai atualizar. Então a gente acaba às vezes tendo uma perda de performance ali dentro. No Redux não. No Redux, o que a gente faz aqui com esse selector é o seguinte, eu extraio somente a informação que eu quero, então olha só, eu estou dentro do meu state lá do Redux, do store, indo no reducer de player, no slice de player, acessando o curso e acessando os módulos. E o que o selector vai fazer nesse componente é, ele só vai atualizar o componente, re-renderizar o componente, se mudar esta informação específica. Então isso é muito importante, a gente não pegar e retornar todo o estado, e nem fazer desestruturação aqui. A gente pegar e buscar exatamente qual informação do estado a gente quer, e se a gente quiser mais de uma informação, a gente pode pegar aqui, por exemplo, eu quero os módulos do curso e quero uma outra informação que viria ali do estado. Eu crio as duas dessa forma e retorno elas aqui embaixo, e aí agora sim eu posso desestruturar módulo e x, por exemplo. Mas não é legal eu pegar e retornar, por exemplo, um slice inteiro aqui do Redux, eu tenho que retornar somente as informações que eu quero. E agora com os módulos aqui em mãos, eu posso vir aqui embaixo e fazer um map. Então para cada módulo, eu vou retornar um carinha desse aqui, e aí posso remover isso aqui de baixo, e aí aqui, além do módulo, eu vou ter o índice desse módulo, que é o que eu vou passar aqui no módulo index, o título do módulo, então eu vou passar módulo.title, o amountOfLessons eu passo módulo.lessons.length, e aqui como eu fiz um map, deixa eu até quebrar ele em mais linhas, como eu fiz um map, eu preciso usar aqui também, que eu vou passar o módulo.id, que é a informação única que eu tenho desse módulo. Salvo aqui agora, volto lá no navegador e a gente pode ver que agora já tem aqui, iniciando com react e estrutura da aplicação. Eu já tenho exatamente aqui os módulos da minha aplicação em si. A gente pode, dentro do nosso módulo, acessar as aulas em si, então eu vou fazer aqui const lessons, para pegar as aulas desse módulo, useAppSelector, return, statePlayerCurseModule, só que agora eu quero acessar um módulo específico. Qual módulo que é esse? É o meu módulo index, eu tenho o índice do módulo, então eu posso pegar aqui o módulo index.lessons, para eu pegar as aulas desse módulo aqui. E agora, venho aqui embaixo, recorto uma aqui, lessons.map, para cada lesson eu vou retornar um carinha desse aqui. E aí no título, lesson.title, na duração, lesson.duration, e aqui, lesson.id. Vou quebrar isso aqui em uma linha, para ficar um pouquinho mais organizado, e show de bola. Se eu salvar aqui agora, a gente vai ver que eu tenho as aulas certinhas de cada um dos módulos aqui dentro. É claro que as aulas são totalmente hipotéticas, os títulos e tudo mais, mas agora o que a gente quer fazer é, ao clicar em uma dessas aulas aqui, eu mostrar o vídeo correspondente dessa aula aqui na esquerda. Então, bora começar a trabalhar um pouquinho com a parte de actions aqui dentro."
  },
  {
    "id": "b745222b-78d2-434c-9566-faa2e846f301",
    "title": "Selecionando aula atual",
    "transcription": "Nessa aula, o que a gente quer fazer é, ao clicar aqui na sidebar em alguma das aulas, a gente selecionar qual que é a aula que está sendo exibida aqui na direita e também conseguir mostrar, trocar o vídeo conforme a aula selecionada, porque hoje o vídeo ele está estático. Se a gente for aqui no vídeo, o ID dele está totalmente estático, ele não está pegando com nenhuma aula, digamos assim. E aqui o que a gente vai fazer é o seguinte, aqui dentro do nosso slice, do player, dentro do reducer, aqui dentro do initial state, hoje a gente tem apenas a informação do curso que está sendo exibido na tela. Só que eu preciso também anotar aqui dentro qual que é a aula ativa e eu posso anotar isso de diversas formas, eu poderia, por exemplo, vir aqui e botar active lesson, por exemplo, e anotar aqui o objeto da aula inteira, então, por exemplo, pegar aqui uma das aulas e colocar isso aqui dentro do active lesson, só que isso aqui não é muito legal, porque eu vou ter uma informação duplicada, eu já tenho essa informação aqui dentro, aí eu vou ter novamente a informação aqui dentro de um outro objeto, então, bom, eu poderia pegar apenas o ID, então botar aqui o ID da aula ativa, só que o ID da aula também não é o melhor dos mundos, porque o ID, pra eu pegar um array e buscar a aula por ID, eu vou ter que pegar o array de lessons, fazer um find, aí pra cada lesson encontrar a lesson onde o ID seja igual ao active lesson, ou seja, é um código muito grande. O que eu poderia fazer aqui é anotar o índice da aula ativa, então, current lesson index, e aí aqui eu vou ter apenas, por exemplo, aula 0, aula 1, aula 2, aula 3, aula 4, só que como eu tenho vários módulos, eu vou precisar também anotar qual que é o módulo atual, então, eu vou começar essas duas informações com 0, ou seja, sempre que a aplicação inicializar, eu vou mostrar o primeiro módulo, a primeira aula do primeiro módulo aqui dentro, então, agora, o que a gente vai fazer? Eu vou salvar isso aqui agora, a gente vai voltar aqui no vídeo, que é onde está mostrando o player em si, e aqui eu vou fazer o seguinte, const video=\"useAppSelector\", e aqui dentro eu preciso retornar os dados da aula atual, então, o que eu vou fazer? Olha só, de dentro do meu state, eu tenho acesso aqui no player ao current module index e ao current lesson index, então, a primeira coisa que eu vou fazer, eu vou buscar de dentro do meu player essas informações, current module index e current lesson index, e aí para pegar os dados da aula atual, basta eu acessar state.player.curse.modules no current module index.lessons no current lesson index, aqui eu posso quebrar a linha para ficar um pouquinho menor o código, e agora, se eu retornar a current lesson daqui de dentro, eu vou ter acesso aqui ao id da minha lesson, então, eu posso vir aqui no url, botar chaves para fazer interpolação com aspas, jogo aqui o nosso lesson.id, vamos testar agora, vou salvar, se eu voltar aqui, beleza, está mostrando aqui certinho, só que agora eu preciso ter uma forma de trocar esse current module index e o current lesson index aqui de dentro, então, lá no meu player, aqui no meu slice, dentro de reducers, que são as actions que podem ser feitas, eu vou criar uma action aqui dentro, chamada play, e aí eu recebo state, que é o estado atual, e action, que é a minha ação em si, e agora, aqui embaixo, eu exporto de dentro de player.slice.actions a minha ação play, vou dar um console.log, nem preciso do console.log, eu posso usar o Redux DevTools, então, vou deixar dessa forma aqui mesmo, agora, eu vou lá na minha lesson, no meu componente lesson, e aqui dentro eu vou usar o dispatch, então, é import, ou melhor, posso escrever direto, const dispatch, é igual a useDispatch, e aí eu vou fazer o seguinte, quando o usuário clicar nesse botão aqui, handlePlayLesson, vou chamar uma função, handlePlayLesson, e aí eu vou fazer dispatch, play, e aqui, eu não vou, vou enviar apenas, sei lá, teste, pra gente ver se tá funcionando, então agora, eu vou salvar isso aqui, a gente vai abrir o Redux DevTools aqui embaixo, diminuir um pouquinho o zoom, quando eu clico em uma das lessons agora, ele já mostra player barra play, se eu clico aqui, em action, eu posso ver que o payload aqui, tá teste, porém, pra eu trocar a lesson aqui dentro, qual que é a lesson atual, eu preciso dessas duas informações, o índice do módulo, e o índice da lesson em si, hoje, dentro do componente module, eu tenho o moduleIndex, certo, e aqui embaixo no lessons.map, eu consigo ter acesso aqui, ó, ao índice também, que é o lessonIndex, então, pra minha lesson, aqui eu tenho duas alternativas, né, pra minha lesson, eu posso passar o moduleIndex, que eu tenho acesso, e o lessonIndex, e pegar essas informações lá dentro, pra quando eu clicar na lesson, ele ter esses dados aqui, certo, ou, eu posso fazer uma outra estratégia, posso passar uma propriedade chamada onPlay, por exemplo, aqui dentro, tiro o dispatch, uso o onPlay, aqui no onClick, e agora, lá no módulo, onde eu tenho acesso aos dados do índice, eu faço a ação de play, então eu pego o useDispatch, e aqui embaixo, no lesson, eu passo onPlay, dispatchPlay, passando o índice do módulo, e o índice da aula, como que eu posso passar isso? Eu posso passar um array mesmo, então, passo aqui um array, ó, e mando o moduloIndex, e o lessonIndex, vou trocar o nome aqui pra ficar até mais semântico, então, o lessonIndex, dessa forma aqui, pode ser uma boa solução, né, e aqui o que que eu vou fazer agora? Vou salvar, e a gente vai testar, veja, vou clicar aqui, por exemplo, na primeira aula do primeiro módulo, veja que ele deu playerPlay com 0 e 0, se eu clico no segundo, agora 0 e 1, porque o índice 1 da aula, e o índice 0 do módulo, se eu vou no segundo módulo e clico na última aula, veja que agora é 1, porque é o segundo módulo, 3 porque é a quarta aula, e agora, aqui dentro do player, eu posso fazer o seguinte, state.currentModuleIndex é igual a action.payload na posição 0, que é o módulo, e o currentLessonIndex é o action.payload na posição 1, salvo aqui agora, e veja, agora, conforme eu clico nas aulas, ele troca o vídeo aqui automaticamente, ele tá trocando, tá, só a thumb é igual, veja o título lá em cima, ó, conforme eu vou clicando, ele vai trocando a aula, porque agora, toda vez que a gente troca, clica aqui na aula, ele tá trocando o currentModuleIndex e o currentLessonIndex do meu estado, e o meu componente vídeo, ele tá dependendo dessas informações pra mostrar, né, esse vídeo em tela, então, a gente, basicamente agora, já tá conseguindo alterar as aulas."
  },
  {
    "id": "ae195147-edad-40b9-9ee8-14bd674c785a",
    "title": "Destacando aula atual",
    "transcription": "O que a gente vai fazer nessa aula é mostrar os dados da aula ativa aqui no cabeçalho e também na sidebar, mostrar com um íconezinho diferente, uma cor diferente. Então, eu vou copiar esse mesmo useAppSelector que a gente usou aqui dentro do vídeo e a gente vai lá para o header e a gente vai botar ele aqui, vou até importar o AppSelector aqui de dentro, só que aqui eu vou... preciso também do título do módulo, então não adianta só da lesson. Então, o que eu vou fazer? Essa parte aqui do CurrentLesson, eu vou pegar toda essa parte aqui que vai até o CurrentModuleIndex, que retorna qual é o módulo, e eu vou criar uma variável chamada CurrentModule e aí eu uso esse CurrentModule aqui embaixo para minhas lessons em si. E aqui de dentro eu retorno tanto o CurrentModule quanto a CurrentLesson. E aqui em cima eu faço uma desestruturação, CurrentModule e CurrentLesson. E aí aqui dentro eu posso trocar, mostrar da CurrentLesson o título e dentro aqui das aspas duplas, CurrentModule ponto o título também. Salvo isso aqui agora, veja, utilizando estado estrutura da aplicação, que é esse aqui. Se eu clicar em iterações, ele vai trocar. Clico aqui, ele já troca o módulo e troca o título também. É legal na sidebar a gente ter algum tipo de destaque também na aula que está ativa. Então, bora fazer isso. Lá na minha lesson aqui, eu vou, ou melhor, aqui no módulo, aqui na lesson, como aqui dentro não tenho acesso ao index do módulo, eu vou receber isso via propriedade. Então, eu vou botar isCurrent como sendo booleano e vou definir que isso aqui, por padrão, é falso. E aqui dentro a gente pode, eu já vou adicionar algumas estilizações aqui dentro, mas antes eu preciso pegar essa informação lá no meu módulo TSX. Então, aqui eu vou fazer o seguinte, isCurrent, ele vai ser true, caso não. Aqui em cima eu vou precisar pegar const useAppSelector state, aqui eu preciso pegar o índice. Então, const currentModuleIndex é igual a state.player.currentModuleIndex. A gente pode até desestruturar isso aqui, fazer dessa forma. E pego também o currentLessonIndex, retorno daqui de dentro essas duas informações e desestruturo aqui em cima. E aí aqui eu vou fazer o seguinte, vou até botar aqui dentro, const isCurrent. Se o currentModuleIndex for igual ao moduleIndex, que é o índice desse módulo, e o currentLessonIndex for igual a esse lessonIndex. Então, boto aqui o isCurrent. E aqui dentro da minha lesson eu posso fazer uma estilização diferente. Então, o que eu vou fazer aqui? Pra eu não ficar fazendo if, quando eu uso o tailwind, uma das coisas que eu mais gosto de fazer pra estilizar alguma coisa baseado num estado, se tá tocando ou não tá, adicionar uma estilização baseada em uma condicional, eu gosto muito de usar os data attributes. Então, basicamente eu boto data, active, por exemplo, o nome aqui tanto faz, e passo a propriedade isCurrent, que aqui é true ou falso. E aí eu uso aquilo que eu já tinha mostrado antes, que é a estilização com base num atributo data. Eu venho aqui, data, e falo, se o data active for true, então eu vou trocar a cor do texto aqui da aula pra text emerald 400. Salvo aqui agora, e agora a aula que tá tocando, ela fica verdinha. Legal isso, né? E aí eu vou fazer o seguinte também, eu vou trocar o ícone aqui, então eu vou fazer o seguinte, se é current, eu vou mostrar o ícone playcircle, se não, eu mostro aquele que já tinha ali, que é o vídeo. Só que aqui nesse ícone playcircle, além de ter o w4 e o h4, eu vou botar text emerald 400. Salvo aqui, volto, e olha, agora a aula que tá tocando, ela fica com o ícone diferente. Se eu clico em outro, já troca automaticamente. Legal, né? O que a gente poderia botar também aqui é um hover, text, zinc 100, pra quando o usuário passa o mouse por cima ele ficar diferente. Na aula ativa eu acho que não precisaria. Então eu posso botar assim, hover. Aqui ao invés de fazer um not, eu posso fazer de uma forma melhor. Eu vou fazer o seguinte, eu tô pensando só. Porque olha só, se é aula ativa, não faz sentido o usuário clicar de novo, né? Então, eu vou fazer aqui no botão, eu vou botar um disabled caso a aula seja ativa. E aí, como tá disabled, eu não vou botar hover. Então eu vou botar hover, apenas quando tiver habilitado. Então enabled, dois pontos hover, e aí o zinc. Então agora ele só vai mostrar o hover nos que estão enabled. Legal, né? Show. Então, agora a gente já terminou aqui de estilizar baseado na aula ativa."
  },
  {
    "id": "dd84340a-8672-452c-9e6d-3262fb944da0",
    "title": "Configurando autoplay",
    "transcription": "Nessa aula, o que a gente vai fazer é o progresso, a progressão automática das aulas, então a ideia é que quando um vídeo acabe, uma aula acabe, ele passe para a próxima automaticamente. Isso vai ser bem legal de fazer, porque aqui dentro do player, do vídeo, do componente vídeo, uma das coisas legais desse React Player é que ele tem alguns eventos que eu posso utilizar. Está vendo? On... E aqui tem vários. Um deles é o onEnded, que eu consigo chamar uma função quando o vídeo acabar. E aí lá no meu player, aqui no meu reducer, eu consigo criar uma função, uma action aqui embaixo, chamada, por exemplo, next. E aqui eu posso exportar essa action. E agora, se eu voltar aqui no vídeo, pegar o dispatch, e aí criar uma função aqui até para handlePlayNext, dispatchNext, passando aqui teste. E aí eu mando essa função aqui. Veja que agora, quando o vídeo acabar, vai acabar o vídeo, ele disparou o player barra next. E a action tem o payload que a gente mandou aqui dentro. Veja que se eu tento passar um payload vazio, ele dá erro aqui, porque ele não entende muito bem o que essa função next está aguardando como payload. E aí, por isso, tem algumas coisas que a gente pode fazer aqui para deixar o nosso código um pouquinho melhor integrado com o TypeScript. A primeira delas é, aqui dentro do slice, no player, a gente pode tipar esse action aqui. Está vendo que esse action hoje, o payload dele é n. O que eu posso fazer aqui, nesse play, por exemplo, é dar um dois pontos, payload action, e passo para ele, como um generic, qual que é o tipo de dados que vem dentro do payload. Então o payload é um array com duas posições, onde a primeira é um número, que é o módulo, e a segunda também é um número, que é o módulo. Então eu falo que é um array com duas posições numéricas. Olha só. E aqui agora, se eu passo o mouse por cima de action, ele já sabe exatamente qual que é o formato do payload. No caso do next, como eu só quero tocar a próxima, eu não preciso de um action, na verdade, eu não preciso de um payload. Então eu só venho aqui e tiro. Automaticamente, ele vai entender que o next não recebe payload, que ele pode ser vazio. Legal, né? Beleza, agora a gente volta aqui para o nosso slice do player, e a gente vai trabalhar nesse next aqui, porque eu tenho que... como eu já tenho o índice do módulo e o índice da lesson que estão ativas, para eu tocar a próxima, eu só preciso aumentar um aqui na lesson, a menos que seja a última lesson. Se for a última lesson do módulo, por exemplo, se eu estou aqui na deforme de comentários e acabou a aula, eu não posso aumentar mais um, porque não tem mais lesson. Eu tenho que trocar para o próximo módulo e trocar a próxima lesson, se tiver um próximo módulo. Então são algumas verificações que eu vou ter que fazer. Então olha só, eu vou começar pegando next lesson index, que é basicamente o índice da aula atual, mais um, e eu vou verificar se existe a próxima lesson. Então const next lesson igual state.curse.modules, vou pegar o nosso módulo atual, então state.currentmodule index lessons next lesson index. Agora, se existir essa próxima lesson, então beleza, agora basta eu definir essa como a próxima lesson. Perfeito. Salvo. E olha só, se eu venho aqui na aula CSS Global, toco aqui para o final, quando ela acabar, tocou a forma de comentário. Ele não deu play sozinho, porque aqui no player, no vídeo na verdade, eu tenho uma propriedade que se chama plain, eu posso deixá-la como true, e ele vai dar auto play. Então olha só, venho aqui, CSS Global, espero um pouquinho, e quando terminou, já foi para a próxima e já começou a tocar, viu? Forma de comentários. Só que nessa forma de comentários, se eu for no final dela, botar para trocar, quando ela acabar, não vai fazer nada. Por quê? Porque não tem uma próxima aula. A próxima aula é a do próximo módulo, certo? Então, o que a gente vai fazer aqui? Else. Perfeito. Aqui, se você não gosta de utilizar else, dá um return aqui e escreve depois do if. Eu, particularmente, aqui nesse caso, não vejo problema de utilizar um else, porque só tem um cenário ou outro, né? Se não tiver próxima aula, eu vou ver se existe um próximo módulo. Então const nextModuleIndex é igual a state.currentModuleIndex, mais um. NextModule é igual a state.curse.modules no nextModuleIndex. Se existir um próximo módulo, então o currentModuleIndex vai trocar para nextModuleIndex e o currentLessonIndex vai trocar para zero, porque é a primeira aula. Então, olha só. Salvo, vou no form de comentários, boto no final. Quando acabou, já tocou a componente comment, que é a primeira do próximo módulo. Show de bola. Então, a gente já fez o autoplay automático. Uma das coisas que seria legal aqui... Bom, na verdade, acho que está show dessa forma. Acho que está bem legal dessa forma, a gente já pode continuar. Uma coisa que eu vou fazer só é deixar aberto o primeiro módulo como padrão aqui. Então aqui no module, dentro desse collapsible, eu tenho uma propriedade chamada defaultOpen e eu posso fazer o seguinte, se o moduleIndex for igual a zero, que é o primeiro, ele já vem aberto por padrão. O F5 já vem aberto aqui no começo. Legal, né? Então, agora a gente fez o autoplay aqui do nosso player."
  },
  {
    "id": "27f6ad8f-efb3-4b6f-8d21-41ac386bfa00",
    "title": "Criando hook global",
    "transcription": "Uma coisa legal de fazer aqui dentro do Redux, na minha opinião, é criar alguns atalhos de seletores. Por que? É muito comum, por exemplo, eu ter que fazer alguns tipos de seleções no estado. E quando eu digo seleção, é o componente ter que buscar alguma informação do estado, como eu estou fazendo aqui com o Selector. E, às vezes, eu tenho que fazer o mesmo tipo de seleção em vários locais da aplicação. E aí esse código todo aqui, de dentro, ele acaba ficando repetido. Então, uma das coisas que eu vou fazer, por exemplo, é copiar esse UseAppSelector, esse código que eu tenho aqui dentro do header, que vai ser muito comum, ter que ter acesso ao módulo e a aula ativa, isso aqui é muito comum. Então, eu posso copiar isso e venho aqui pra dentro do meu Slice, do Player, e eu vou exportar aqui uma constante chamada UseCurrentLesson. E isso aqui vai ser uma função que retorna a execução do UseAppSelector e retorna o CurrentModule e o CurrentLesson. Agora, aqui dentro do header, eu posso tirar tudo isso aqui e trocar por UseCurrentLesson. Legal, né? E agora, eu posso também, dentro lá do meu vídeo, mesmo que aqui eu use apenas a lesson, posso usar o mesmo código, porém pegando apenas a lesson aqui nesse caso. E eu troco aqui pra CurrentLesson. Legal, né? E agora, a gente ter esse UseCurrentLesson aqui... Pera aí que eu dei um play aqui no vídeo e começou a tocar. A gente ter esse UseCurrentLesson aqui permite a gente usar ele em vários lugares, qualquer lugar que eu queira ter acesso. Por exemplo, aqui dentro da nossa página do Player, eu posso instalar, por exemplo, o React. Como que é? React... Meu Deus, eu esqueci o nome do pacote que a gente usava no React. Meu Deus, eu esqueci totalmente. ReactHelmet. É isso, né? ReactHelmet. Eu ia digitar isso, só que por algum motivo eu achei que eu tava errado. Nossa, ele não é atualizado há muito tempo. Mas bom... Então não vamos usar ReactHelmet. Vamos fazer de uma outra forma aqui. Eu posso fazer um const. UseCurrentLesson. CurrentLesson. E posso fazer, por exemplo, um UseEffect. Toda vez que meu CurrentLesson muda, posso fazer um document.title. E aí trocar o título aqui da página pra aula que tá tocando, por exemplo. CurrentLesson.title. Assistindo. E é isso. Vou salvar aqui agora. Então, assistindo, CSS Modules. Quando eu troco, ele já troca o título da página também. Então, só um exemplo de como a gente pode utilizar esse hook que a gente acabou de criar, o UseCurrentLesson, pra ter acesso à lesson que tá sendo assistida naquele momento em qualquer lugar da nossa aplicação. Show! Bora continuar ainda que tem mais umas coisas legais pra gente fazer aqui."
  },
  {
    "id": "9050efe8-5af6-4e30-a802-567ee111ad22",
    "title": "Criando testes unitários",
    "transcription": "Uma coisa que é muito fácil fazer quando a gente está utilizando o Redux aqui, é fazer testes dentro do nosso estado. E fazer testes unitários aqui é uma boa forma de garantir que essas ações que o usuário pode disparar através da interface, elas estão funcionando, elas continuam funcionando. Principalmente essas ações que exigem algum tipo de lógica a mais, como é o caso aqui do Next. Então, o que eu vou fazer aqui agora é instalar uma ferramenta, eu vou utilizar o Vitest, que é uma ferramenta de teste bem legal, criada pelo mesmo time do Vit. Utiliza o ASBuild por baixo dos panos, e é bom porque a gente não precisa configurar muita coisa. O Jest teria que configurar toda a parte pra ele entender TypeScript, é um pouquinho mais chato. O Vitest já vem com isso pronto. E pronto, é só eu criar um arquivo de teste agora. player.spec.ts Eu gosto de usar a extensão spec, mas se você preferir utilizar teste, também pode ser o Vitest que vai entender de qualquer forma. E aí se a gente lembrar, lá quando a gente estava utilizando a extensão do Redux aqui embaixo, ele gera pra gente uns testes. Então, por exemplo, eu vou deixar essa aula chegar até o fim. O CSS Global, por exemplo. Clico no fim, dou um play nela. Quando ela chegar no fim, ele vai dar o play, o next aqui. Eu posso vir aqui no teste, e ele gera um teste meio pra mim. Isso é legal. Então, eu posso copiar esse teste pra me basear. O Vitest segue a API do Jest, então eu poderia até copiar isso aqui. Pra gente entender mais ou menos como seria o teste. Só que a gente vai fazer alguns ajustes. Então, beleza, ele só chamou o nosso reducer. Legal, vamos lá. Como é que a gente pode fazer esse teste aqui? Eu vou começar com um describe, só que aqui o describe tem que ser importado de dentro do Vitest. Então, deixa eu importar aqui do Vitest. Describe. Aí eu vou importar o it também. E aqui a gente vai botar player slice, pra categorizar, pra falar que a gente está testando a slice do player. It should be able to play. Algo bem simples, deve ser possível a gente tocar um vídeo. E aí o que a gente vai fazer aqui é importar de dentro da nossa slice o nosso reducer aqui. Que é o reducer do player. E eu vou até renomear ele pra reducer, pra ficar um pouquinho mais fácil. O reducer, assim como o reducer que a gente usa quando a gente tem o useReducer. Assim como qualquer funcionalidade que usa esse pattern chamado reducer, ele é uma função. E essa função, ela recebe, deixa eu ver se eu consigo achar a tipagem aqui do reducer. É basicamente uma função que recebe um estado e uma ação. O estado é o valor antes de acontecer a ação. E a ação, digamos, é o que eu estou querendo fazer. Então, vamos retomar aqui. Primeiro, eu preciso passar o estado. O estado eu preciso passar no formato que eu estou passando aqui pro initial state. Eu acredito que eu não consiga ter acesso a esse initial state aqui de alguma forma. Eu até nem estou exportando. Então, deixa eu exportar esse player.slice daqui de dentro. Eu vou acessar aqui o nosso player.slice. Pera aí que eu dei um play aqui sem querer. E aí eu vou fazer o seguinte. Player.slice.getInitialState. Vamos ver. Beleza, ele retornou. Aqui é uma função, então. Ele retornou. Então, eu vou chamar isso aqui de state. Passar aqui state. E eu preciso passar a minha action. A minha action que eu quero usar pra tocar, eu vou chamar ela de... Vou chamar a action play. Certo? E preciso passar o payload. Então, eu quero tocar ao payload. Então, eu vou passar o payload. E eu vou passar o payload. E eu vou passar o payload. E eu vou passar o payload. Então, eu quero tocar a aula no módulo índice 1 e a aula 2. E aí agora, eu espero... Isso aqui vai me retornar o meu estado, se eu não me engano. Então, isso aqui eu vou chamar de initial state pra não confundir. Isso aqui me retorna o meu estado. Deixa eu ver aqui. Perfeito. Então, eu espero que o meu estado.currentModuleIndex. E aí eu expecto, preciso importar do vtest também. Seja igual a 1. E o meu currentLessonIndex seja igual a 2. Certo? Salvo aqui agora. Vamos ver se ele já criou o comando de teste pra mim. Não criou. Então, crio aqui o comando de teste. Que vai rodar vtest run. E posso criar um comando de teste watch, que fica observando. Que vai rodar vtest apenas. Salvo. E agora, npm run test. E vai rodar os meus testes. E passou o meu teste. Isso aqui não é um problema, na verdade. Não vai ser um problema. Não precisa se preocupar. Então, show de bola. A gente fez o nosso primeiro teste. Vamos pro próximo teste aqui. It should be able to play next video automatically. Então, o que a gente vai fazer aqui agora? Eu tenho o estado inicial. Que é exatamente esse estado inicial. Aqui. O estado inicial aqui, ele acaba sendo um pouco confuso. Então, ao invés de a gente ficar pegando esse estado inicial toda vez pra fazer o teste, particularmente, o que eu prefiro? Eu prefiro que a gente crie o estado do total zero aqui. Então, o que eu vou fazer? Eu vou copiar o conteúdo desse initial state. E aqui no meu teste, eu vou criar uma variável chamada example state. E aqui eu vou deixar ela mais simples. Então, deixa eu pegar aqui um objeto. Vou deixar ele mais simples. Vou deixar aqui com duas aulas somente no primeiro. Com duas aulas no segundo. Algo mais simples. E aí, eu vou usar esse example state aqui embaixo, no lugar do initial state. E aí, o que eu vou fazer? Agora, pra testar se ele está tocando o próximo vídeo, por padrão, ele começa no zero e zero. Então, quando eu chamar a ação next, eu espero que ele troque pra zero e um na aula. Ou seja, pra próxima aula. Então, se eu salvar isso aqui agora, vamos rodar aqui o teste em modo de watch, pra ele ficar observando. Beleza, funcionou. Só que agora, eu quero fazer um outro teste. It should be able to jump to the next module automatically também. Então, o que eu quero fazer agora? Antes de começar esse estado aqui já na aula zero e na aula zero, o que eu vou fazer? Vou fazer o seguinte. Pode ser aqui mesmo. Eu vou copiar todo o meu example state, porém, o current lesson index eu já vou iniciar na aula um. Ou seja, já vou iniciar nessa aula aqui. Então, ele tem que pular pra esta aqui. Então, agora eu vou chamar o next e ele tem que pular pro próximo módulo na aula zero. Salvo. Beleza, rodou. Então, veja que a gente está fazendo testes aqui pra garantir que todas as condições se satisfaçam aqui dentro do nosso reducer. Vou criar mais uma, por exemplo. It should not update the module and the current module and lesson index if there is no next lesson available. Então, aqui o nome do teste tem que ser bem descritivo. Não deve alterar o índice atual do módulo ou da lesson se não tiver mais nenhuma lesson disponível. Então, o que eu vou fazer? Eu vou iniciar o current module index no um e o lesson um também, porque é a última aula que eu tenho aqui do meu estado. É essa aqui. E o que eu espero quando eu chamar o next? Que ele não faça nada. Que ele continue um e um. Então, vamos testar aqui. Vamos até apagar esse comentário que eu já tenho aqui em cima. Esse import aqui não precisa. Salvo. E beleza, o teste passou. Então, veja que criar testes aqui pra dentro dos nossos reducers é muito simples. A gente consegue escrever testes unitários que garantem que o nosso reducer está executando exatamente da maneira que a gente esperava."
  },
  {
    "id": "02cd4a3e-0dd0-4276-bd53-fde37e5517bf",
    "title": "Criando API de cursos (JSON Server)",
    "transcription": "A partir dessa aula a gente vai entender como que a gente pode conectar esse nosso estado com uma API externa. Porque hoje a gente está carregando todos os dados aqui de maneira estática. A gente só vem aqui, mas geralmente isso aqui vem da API. Então é um pouquinho mais delicado, digamos assim. Bora lá! O que eu vou fazer aqui, antes de mais nada, é como a gente precisa de uma API, e eu não vou criar uma API do zero, com Node, qualquer coisa assim, eu vou instalar um carinha chamado JSON Server, que é bem legal quando a gente está trabalhando em desenvolvimento, porque eu consigo simular uma API rodando na minha máquina. Eu vou aguardar aqui um pouquinho e eu já vou deixar criado aqui na raiz do meu projeto um server.json. Esse server.json vai ser basicamente um objeto, onde ele tem uma propriedade chamada Curses, que vai ser o nome da minha rota, e aqui dentro ele vai devolver todos os dados aqui do curso. Então eu vou simplesmente pegar aqui e botar aqui dentro. Como isso aqui é um JSON, eu vou ter que jogar aspas, todo lugar que está aspa simples eu troco por aspas duplas, e todo lugar aqui antes, toda palavra antes dos dois pontos aqui, vamos pegar aqui, só que não pode chegar a esses dois pontos aqui, então vou pegar esses dois pontos aqui. Ah, mas aí pega aqui também. Então vamos pegar todo lugar que está escrito title, todo lugar que está escrito id, todo lugar que está escrito duration, menos aqui na sidebar, não era para ter botado, todo lugar que está escrito lessons, e tirar essas vírgulas aqui que estão sobrando no final. Então a gente tem que dar uma organizadinha aqui para ser um arquivo JSON mesmo, porque ele não é igual ao Javascript. Show, salvo isso aqui agora, agora eu consigo ver aqui no meu package.json, e eu vou criar um carinha chamado server, que vai rodar json server, passando o nome do arquivo, se não me engano, server.json, deixa eu testar se isso aqui já vai funcionar, npm run server, beleza, rodou. Só que eu vou colocar também aqui uma opção traço w, que ele vai fazer um watch, ou seja, toda vez que o arquivo mudar, ele vai restartar o servidor, e vou botar uma opção de delay também, de 500 milissegundos, para simular que toda requisição está demorando um pouquinho para acontecer, assim fica mais próximo ao mundo real e também ajuda a gente a criar uma UI que mostre o loading bem certinho, isso é interessante, então eu vou salvar isso aqui agora, e agora eu posso rodar o meu servidor, se eu acessar essa rota aqui, localhost 3000 courses no navegador, ela vai me retornar todos os dados do json, deixa eu trocar o tema aqui, pode ser drácula, tanto faz, salva, volta aqui, dá F5, beleza. Então olha só, ele me retorna ali basicamente os dados do curso, com os módulos e tudo mais. A ideia agora é que quando a gente iniciar a aplicação, eu faça uma requisição, busque esses dados e traga aqui para dentro. Para buscar os dados aqui, eu gosto sempre de utilizar o Axios, então eu vou fazer o seguinte, eu vou deixar aqui tanto o front rodando quanto o servidor, vou criar aqui uma nova janela do terminal, e vou instalar o Axios aqui no nosso projeto, e aí eu vou criar uma pasta lib e dentro axios.ts, e vou exportar uma constante api igual axios.create, e aqui a url vai ser a mesma onde está rodando, ou melhor não, a base url é http://localhost3000, beleza. Salvo aqui agora e pronto, agora a gente já está com tudo pronto para carregar esses dados ali dentro da nossa aplicação."
  },
  {
    "id": "943cf73e-24ec-4991-89ab-8c405c12bf61",
    "title": "Carregando dados do curso",
    "transcription": "O que a gente vai fazer nessa aula é carregar os dados aqui dos módulos do nosso curso a partir da nossa API. E existem algumas formas de fazer isso, na verdade. Eu vou te mostrar algumas delas. Uma das formas é, por exemplo, aqui na página do player, eu posso fazer da forma mais tradicional possível do React, um useEffect, por exemplo. Fazer a chamada para a minha API, então eu pego api.get e aqui a rota, a gente tinha colocado courses, só que só tem um curso, então não sei se faz sentido dessa forma. Eu posso fazer, talvez, cursos e aí botar, tipo, com id 1 e aí eu trago o curso. Talvez... Eu acho que, na verdade, eu posso fazer da seguinte forma. Cursos, aí eu boto um array dentro, eu boto id 1 e boto os nossos módulos. E o id aqui, inclusive, dos módulos, eu vou colocá-los como número. Se eu boto como número, uma das coisas legais, até o meu servidor começou a rodar de novo aqui, uma das coisas legais é que eu consigo fazer o seguinte, eu consigo buscar o curso apenas com o id 1, então eu boto cursos barra 1, ele traz só o id com o curso com o id 1. Eu acho que para módulos aqui não vai funcionar. É, ele traz só para cursos mesmo. Então, dessa forma aqui, eu quero chamar essa URL aqui, então, para trazer os dados do curso. Então, volta lá, cursos barra 1, e aqui, .then, response, eu posso até acesso, através do response .data, aos dados do curso que eu carreguei. Então, vou dar um F5 aqui. Beleza? Olha aqui. Aqui está dando um monte de erro por causa do player, mas se a gente for ver, aqui no meio, ele trouxe aqui os dados do curso. Então, ele fez aqui a requisição, e agora eu preciso passar esses dados aqui para dentro do nosso, do Redux aqui dentro. Então, o que eu vou fazer? Aqui no initial state, o meu curso em si, eu vou falar que ele vai inicializar com nulo. Só que, veja que no momento que eu boto que ele vai inicializar como nulo, já começa a dar erro aqui embaixo, nas nossas propriedades. Então, o que eu gosto de fazer nesse caso? Eu gosto de criar uma interface aqui em cima, chamada player state, falando exatamente como vai ser o formato do estado aqui. Então, eu vou ter um curso, ou melhor, vamos começar com as coisas mais simples. Eu vou ter o current module index, que é um número. Eu vou ter uma current lesson index, que é um número. Eu vou ter o curso. O curso, ele pode ser, e aí eu vou criar uma interface separada aqui para ele, ele pode ser ou um curso ou nulo. E aí no curso aqui, eu vou falar exatamente quais são as propriedades que ele tem, que é basicamente o que a gente vai carregar aqui do server.json. Então, cursos, beleza. Então, a gente vai basicamente configurar aqui. Ele vai ter um id, que é numérico. Ele vai ter os módulos, que é um array. Quando é array de objeto, eu prefiro do que fazer, mas se você preferir, pode ser nesse formato aqui também. Não sei, acho que não fica tão didático. Os módulos, então, ele é um array com vários objetos, onde tem id, e tem título, e tem lessons, que novamente é um array de objetos que tem id, título e duração. Então, id, o id aqui no caso é uma string, e o título também, e a duração é uma string. Legal. Agora, eu venho aqui, trago esse initial state aqui pra fora, e falo que o formato dele aqui é playerState. Assim, quando eu passo ele aqui pra dentro agora, o Redux já vai saber que o nosso estado ele segue este formato aqui. E aí, mesmo assim, ele continua com o erro. Por quê? Porque as minhas actions, como o curso pode ser nulo, elas não sabem se essa informação existe ou não. Então, eu tenho que, em todo lugar que eu uso stateCurse aqui, eu vou ter que fazer uma, usar o NullishCollessingOperator. É isso, né? Acho que é. Já nem lembro mais. OptionalChaining. Exatamente. Então, a gente só faz essas ações aqui. Não deve resultar em nenhum problema. E agora, deixa eu dar F5 aqui. Como o curso iniciou como nulo, ele vai começar a dar alguns erros aqui dentro. Porque a gente está tentando acessar aqui, por exemplo, dentro da página do player, algumas informações que elas são inexistentes. Enquanto o curso é nulo, elas não existem. Então, aqui, por exemplo, novamente eu vou ter que usar, e aí o modules aqui, ele pode ser undefined, porque ele pode não existir. Então, aqui eu vou ter que fazer uma verificação. Se modules e aí eu faço o map. Mesma coisa aqui embaixo. Eu só posso fazer isso aqui caso o currentLesson tenha algum valor dentro dele, né? Porque ele também pode ser undefined agora que o meu curso pode não existir. Vamos salvar isso aqui, vamos ver se o nosso player continua funcionando. A gente talvez vai ter que fazer mais alguns ajustes, tá? Então, vamos lá nos componentes também. Então, vamos lá no vídeo. Aqui, ó, eu estou usando o currentLesson. Só que pode ser que ainda não exista, né? Então, eu vou fazer o seguinte, ó. Se não existir uma currentLesson, por enquanto eu vou retornar nulo daqui de dentro. Daqui a pouco eu vou fazer alguns ajustes mais legais aqui, tá? No module, mesma coisa. A gente pode não ter as lessons. E aí eu vou fazer uma verificação aqui embaixo. Mesma coisa na lesson não. No header também. Então, aqui no header, mesma coisa. Se não houver currentModule ou se não houver currentLesson, eu vou dar um return nulo por enquanto. Isso é só pra gente fazer a aplicação funcionar. Olha só, então agora a aplicação não tem nada e agora falta eu carregar os dados lá pra dentro. Deixa eu ver aqui, exampleState. Deixa eu ver se eu faço o seguinte. Aqui no meu state eu vou exportar essa interface. E aí aqui eu vou falar... Ah, eu já sei qual que é o problema, tá? Mas aqui eu vou falar que ele precisa seguir esse playerState, porque aqui nos ids a gente estava colocando ele como string e aqui no curso eu preciso de um id também. Acho que é isso, né? Pronto. Já resolveu os testes aqui também. E agora eu vou criar uma action aqui dentro do meu reducer, chamada start. E essa action aqui, ela vai receber basicamente os dados do meu curso. Então eu vou fazer aqui uma payload action. Ele vai receber os dados do meu curso, que é exatamente esses dados que eu criei a interface aqui, os dados da API. E eu vou fazer state.curse igual action.payload. Vou salvar aqui agora. E agora lá no meu player, aqui depois de eu fazer a requisição, eu vou chamar aqui o nosso dispatch. E agora, uma coisa que eu esqueci aqui no meu slice, é de exportar a action aqui embaixo, o start. E agora sim, aqui eu vou dar um dispatch. Start. E passando o meu response.data, que são os dados do meu curso. Agora sim, se eu salvar, voltar lá no navegador, dá um F5. Ele carregou os dados do curso. Tem alguns erros aqui embaixo. Vamos dar uma olhadinha nisso daqui a pouco. Mas pelo menos, a nossa interface já está carregando. Ela demora um pouquinho pra carregar, porque lembra que lá no meu package.json, eu falei pro nosso JSON server ter um delay, pra assim a gente ver o loading. Eu vou até aumentar um pouquinho esse delay, vou botar um segundo e restartar aqui o meu servidor da minha API, pra eu ter um delay maior. O F5 demora um segundo e aí ele mostra, pra gente começar a ver como a gente pode trabalhar com o loading. Como eu falei, isso aqui é uma das formas da gente carregar dados pra dentro do nosso reducer. Eu faço essa chamada API por dentro do componente. E aí, quando essas informações estiverem captadas, eu envio pra dentro do meu reducer. Qual seria o grande problema disso aqui, a grande limitação? A grande limitação é que eu só vou conseguir carregar os dados do meu curso, caso o usuário abra a página do player. Imagine que você queira carregar os dados do player, os dados aqui do player, do seu reducer, de vários locais, digamos, de várias origens diferentes. Nesse caso, eu teria que talvez replicar esse código em todo lugar que eu gostaria de carregar os dados do curso. Mas, pode ser que os dados do curso já estariam carregados. Eu teria que ficar fazendo if. Eu só quero carregar os dados do curso caso não tenha sido carregado anteriormente. Então, tem algumas coisinhas que isso aqui implica que não são tão legais. O melhor seria a gente conseguir talvez fazer com que esse próprio método start aqui fizesse a chamada HTTP. Assim, quando a gente chamar a action start, independente de qual componente chame essa action start aqui, ele carrega os dados do curso, preenche, ou seja, qualquer componente da nossa aplicação vai poder carregar os dados do curso. Então, é isso que a gente vai ver um pouquinho nas próximas aulas."
  },
  {
    "id": "b675cd03-35a2-43c8-a974-bd0cdac95532",
    "title": "Migrando do Redux p/ Zustand",
    "transcription": "Uma das partes mais legais aqui do Zustand, na minha opinião, é que lá no Redux, quando a gente precisa fazer alguma action ser assíncrona, a gente tem que criar esse AsyncThunk aqui, que tudo bem, funciona, a gente fez, deu tudo certo. Só que, sei lá, meio estranho de certa forma, mas é o padrão do Redux, esse é o ponto, o padrão da arquitetura Flux. Só que aqui no Zustand, olha só, a gente pode simplesmente criar um método assíncrono aqui dentro. Por exemplo, load, como eu já estava fazendo antes. Então, aqui eu vou fazê-lo seguindo a mesma ideia, usando uma arrow function, dessa forma aqui. E pronto, eu tenho um método assíncrono. E esse método aqui, ele pode fazer qualquer tipo de ação assíncrona, como por exemplo, isso aqui. Fazer uma chamada para API, então eu posso importar aqui a minha API, e fazer um set aqui no meu curso com os dados que estão vindos da API. Interessante, né? Só que outra coisa interessante aqui, é que a gente pode fazer o processo de setar essa variável do isLoading aqui dentro também. Eu não preciso fazer toda essa parte aqui de case, então eu posso vir aqui e fazer o seguinte, antes de fazer a requisição, eu digo que o isLoading é true. No final aqui, posso fazer até no mesmo set, deixa eu quebrar a linha aqui para ficar um pouquinho mais organizado, eu digo que o isLoading é falso. E pronto, eu acho muito mais organizado, muito mais fácil até de entender, do que com o Redux ali. Mas como eu falei, são os padrões do Redux, a gente precisa seguir. Como a gente criou essa função load, a gente vai tipar ela aqui também. Então load é uma função, aqui como ela é uma função assíncrona, ela obrigatoriamente devolve uma promise. E aí como ela não tem return, void. Também não recebe parâmetro. E pronto, agora sim, a gente migrou aqui para dentro tudo o que a gente precisava, e a gente já pode começar a utilizar o Zustand dentro dos nossos componentes. Então vamos lá, porque agora a ideia é a gente começar a obter os dados aqui, e acessar as funções do Zustand dentro dos nossos componentes. Então, bora lá. Primeira coisa que a gente vai fazer, claro, eu não estou rodando a minha aplicação aqui, deixa eu rodar essa aplicação para a gente testar ela certinho. Pode ver que está dando erro aqui, porque ele ainda está usando o Redux. Vamos pegar um primeiro componente e migrar aqui para utilizar o Zustand. Então, lá dentro da nossa página, aqui do player, eu vou começar a fazer o seguinte, eu vou começar a eliminar o uso do Redux. Então eu vou lá no meu app, onde eu tenho o provider do Redux. Lembra que uma das vantagens do Zustand é que eu não preciso desse provider global, porque ele não utiliza da context, então eu vou remover esse provider daqui de dentro, removo tudo que tem relação ao Redux aqui do meu app. Isso vai tirar erro na aplicação, não se preocupa. A gente vai lá na nossa página, Pages, Player, a gente também vai tirar o Redux daqui de dentro. Então, olha só, vou tirar aqui a importação do Store e do Player, e a gente vai vendo onde está sendo utilizado o Redux para remover. Então, vamos lá. Aqui dentro do Player, a gente tem esse dispatch com esse load, vamos comentar isso aqui. Vamos comentar todo lugar que a gente está utilizando os dados que estão provindos do Redux, e aí depois a gente vai consertando. Aqui embaixo, tem alguns componentes que eu uso, os dados que estão vindo aqui dentro do Zustand. O header, então eu vou comentar esse header aqui. O vídeo, eu vou comentar o vídeo daqui. E aqui embaixo, a gente está usando os módulos, então eu vou também comentar os módulos aqui dentro para não dar erro, porque eu quero começar testando se pelo menos eu estou conseguindo carregar os dados de dentro do Zustand. Então, o que a gente vai fazer aqui? Eu vou declarar um const useStore que vem de dentro do Zustand Store que a gente configurou. Então, useStore que vem de dentro do Zustand Store, importado do lugar certinho. E esse useStore aqui, diferente do Redux, ele retorna para a gente todas as informações que eu tenho lá no meu estado global. Tanto as informações que estão contidas no estado, quanto também as funções. Então, eu não preciso usar dispatch para disparar as funções e o useSelector para pegar os dados. É uma função só que retorna ambos, tanto as actions quanto os estados. Nesse caso aqui, eu preciso dos módulos. Então, aqui eu vou pegar o meu curso, dentro do curso eu vou ter os módulos. Eu preciso também da aula atual, então logo a gente já vai fazer isso. Eu vou criar uma função que vai me retornar a aula atual. E aqui, o que a gente vai fazer? Eu vou importar daqui de dentro também a função load, que vai carregar os dados do meu curso. E aqui no meu useEffect, antes a gente tinha esse dispatch load, eu vou jogar apenas load. Algo mais simples. E aqui, beleza. Então, eu já estou conseguindo carregar o curso. E agora, se eu der aqui dentro um console.log no meu curso, teoricamente, se eu rodar a aplicação, vou aqui no Inspect, no Console, deixa eu ver, NetworkError, eu não estou rodando o meu servidor HTTP. Então, deixa eu voltar aqui, npm run server, como a gente configurou, o JSON server, vou dar F5. E agora, olha só, ele demora um pouquinho para mostrar, porque lembra que a gente colocou um delay de um segundo, para ver o estado de loading, mas tudo certo. Depois de um tempo, ele vem aqui e mostra. Ele mostra algumas repetidas vezes, porque como eu estou em desenvolvimento, o React DevTools acaba gerando isso aqui de novo. E acaba que o React tem esse strict mode também que a gente tem aqui no main. Então, não se preocupe com isso, não é um problema. Então agora, eu vou começar a utilizar esses dados aqui dentro dos meus componentes. Então, desculpa, vamos lá. A gente vai aqui na listagem de módulos. Eu vou só colocar o course aqui na frente. E aqui o curso pode estar nulo, então a gente coloca esse ponto de interrogação. E aqui eu faço a mesma coisa para pegar os módulos. Beleza, teoricamente isso aqui deve funcionar. Eu vou já descomentar aqui o vídeo e vou descomentar o header. E a gente vai utilizar essas informações. O resto aqui eu vou deixar comentado, por enquanto. Isso aqui eu posso tirar. E a gente vai começar então, como eu falei, utilizar essas informações lá dentro dos nossos componentes. Então, vamos começar aqui dentro. Claro, vai bugar a aplicação, mas vamos começar no componente header aqui. Onde eu estou usando o useCurrentLesson e o useAppSelector para saber se está com o loading. Então, vamos lá. Para o loading é mais fácil. Eu vou dar um useStore do sustentStore e pego a informação isLoading. E aí eu posso usar esse isLoading aqui no lugar do isCourseLoading. Já tiro isso aqui que eu não estou mais utilizando. Para pegar o currentLesson e o currentModule, como a gente já tinha visto, eu vou criar um hook aqui adicional. Então, como a gente tinha aqui dentro do nosso store, lembra? A gente tinha esse useCurrentLesson aqui. Eu vou copiar ele e tirar ele daqui. A gente vai jogar ele aqui para dentro do nosso sustentStore. Vou jogar ele aqui embaixo mesmo. E aqui a única coisa, eu não vou usar o useAppSelector, eu vou usar o useStore. Que é exatamente esse que já está aqui em cima. Veja que não mudou, como agora não tem o player, é só eu tirar o player daqui de dentro. O resto é igual, não precisa mudar praticamente nada. Volto lá no meu header e aqui eu só troco a importação do useCurrentLesson para dentro do sustentStore. Teoricamente, o resto vai funcionar. Salvo aqui agora, a gente vem na lesson. Aqui não usa nada, beleza. Module, aqui eu uso o dispatch, então a gente vai tirar. Eu uso o currentModuleIndex e o currentLessonIndex. Vou fazer um const useStore de dentro do sustentStore. E eu vou pegar as funções que eu preciso. Primeira delas, eu preciso do currentLessonIndex e do currentModuleIndex. Já tiro isso aqui. E preciso também das minhas lessons desse módulo aqui. Para pegar as lessons, eu posso repetir o useStore de novo, não é um problema. Só tiro o player e pronto, já tenho as lessons. Eu consigo fazer ele da mesma forma de receber o state e retornar somente os dados que eu preciso. Aqui eu posso tirar esse comentário aqui em cima. E aqui ele tinha um dispatch da função play. Essa função play eu posso pegar direto do store também, dessa forma. E aqui embaixo eu só tiro o dispatch. Não preciso do dispatch quando eu estou usando o sustent em si. Salvo isso aqui agora, beleza. Estamos progredindo aqui. Vamos no vídeo. Vou tirar tudo que tem do Redux aqui em cima. E vamos lá, tiro o dispatch, não preciso. CurrentLesson eu posso importar daquele hook que a gente criou lá no sustentStore. Saber se o curso está sendo carregado. Posso pegar o useStore também do sustentStore. E pegar aqui apenas a informação isLoading. Ou poderia fazer a desestruturação como eu mostrei antes. E aqui, handlePlayNext, eu pego a função. Vou fazer até dessa forma aqui. Desestruturo, pego o isLoading e pego o next. Troco aqui para isLoading. E beleza, teoricamente 100%. Vamos ver se faltou mais alguma coisa. Aqui a gente também pega o useCurrentLesson que a gente criou lá do sustentStore. E habilita esse useEffect que troca o título da página. Acho que a gente converteu tudo. Vamos lá. F5. Teoricamente, se a gente troca aqui. Funcionando. 100%. Se eu volto no finalzinho da aula aqui, ele tem que trocar para o próximo automaticamente. Vamos ver. Trocou já o sidebar e já começou a dar play. Ou seja, a gente migrou toda a nossa aplicação do Redux aqui para dentro do sustent. E ficou perfeitinho. Aqui os errinhos que estão dando são só do iframe do próprio YouTube. A gente não precisa se preocupar. Ele está dando alguns logs porque provavelmente eu deixei um console.log aqui no código. A gente pode tirar. E perfeito. Migramos a nossa aplicação totalmente de Redux para dentro do sustent. Uma das coisas aqui que eu acabei esquecendo e é importante na verdade. Eu acabei falando de uma forma contrária do que realmente funciona. Aqui quando a gente usa o useStore, assim como no Redux, é importante que a gente nunca faça. Ou melhor, cuidado para não fazer esse useStore dessa forma sem passar nenhum parâmetro. Porque dessa forma ele fica observando todo o estado do sustent. Para qualquer alteração, ele vai renderizar esse componente. Então, como eu quero aqui ouvir apenas a informação isLoading e não todo o restante do estado. É importante que eu pegue esse store aqui e retorne somente ela. E aí eu tiro aqui a desestruturação. Então, a gente vai fazer isso tanto aqui no header. Aqui na lesson não tem. Dentro do module tem. Aqui a gente usa o useStore da mesma forma. Então, aqui a gente vai fazer da seguinte forma. Eu vou retornar apenas as informações que eu quero. Então, o currentLessonIndex que vem de dentro do store. O currentModuleIndex. E a função play. Perfeito. Aqui embaixo já está usando tudo certinho. Aqui como a gente precisa um moduleIndex. Aqui eu poderia fazer um useStore só, para não ficar com os dois. Então, aqui eu vou fazer a mesma coisa. lessons. E aí eu faço dessa forma aqui. Vou usar store mesmo ao invés de state. E aqui eu pego lessons. E pronto. Assim eu tenho um useStore apenas. Salvo. Aqui no vídeo a gente tem um useStore também. Então, vamos retornar aqui isLoading, que vem de store isLoading. E next, que vem de store next. Show de bola. Aqui no useCurrentLesson já está certinho. Ele retorna poucas informações apenas. E aqui na página a gente tem um useStore também. Aqui a gente vai retornar o curso e o método load. São os dois métodos aqui dentro. De resto, aqui agora sim, finalizado. Então, só esse único cuidado quando a gente vai usar o useStore. A gente selecionar somente as informações que a gente quer do estado."
  },
  {
    "id": "364887a2-16b1-4c65-926b-39512edd70c5",
    "title": "Utilizando Async Thunks",
    "transcription": "Uma outra estratégia que a gente tem quando a gente usa Redux e a gente quer fazer chamadas assíncronas, requisições assíncronas, isso pode ser requisições HTTP ou qualquer tipo de promise, é utilizar um conceito chamado Thunk. E aqui o Redux Toolkit tem uma função que a gente pode importar chamada createAsyncThunk. E eu vou simplesmente fazer o seguinte, eu vou exportar daqui de dentro uma constante que nada mais é do que uma função, e aqui eu vou dar um nome pra ela de, por exemplo, loadCurse, certo? E aqui eu vou simplesmente fazer um createAsyncThunk, e eu preciso passar pra esse createAsyncThunk primeiramente uma string, que é o nome da action, e lembra que eu falei que quando a gente usa o Redux aqui dentro, eu posso até abrir o inspecionário aqui com o Redux, toda action aqui tem um nome, e o Thunk é uma forma da gente conseguir ter uma action, então o Thunk continua sendo uma action, como o start, como o play, como o next, a diferença é que ele é assíncrono, porque o Redux não deixa eu ter essas actions aqui adentro do Reducer como assíncronas, eu não posso fazer isso aqui, porque essas actions aqui precisam ser funções puras, que não tem side effects, que são simples de testar, então a gente não usa nenhuma dessas funções assíncronas, então o Thunk é uma forma de eu ter uma dessas funções aqui, só que assíncrona. E aí eu dou um nome aqui pra elas, por exemplo, pode ser o próprio start, só que aqui eu gosto sempre de... não, vamos deixar start mesmo, pra gente ver como é que é, tá? E o segundo parâmetro é a função, então aqui eu vou simplesmente fazer um async dessa forma, pode ser uma function ou uma arrow function, como eu tô fazendo aqui, e aqui eu posso pegar, por exemplo, esse conteúdo que tem dentro aqui do useEffect e levar lá pra dentro, então olha só, vou pegar aqui, tirar tudo aqui que eu tenho relacionado à API, daqui de dentro do player, e eu vou levar aqui pra dentro, importo a API daqui, e peraí que começou a tocar o vídeo aqui, e agora, o que eu preciso fazer? Quando ele carregar os dados do curso, eu preciso, de alguma forma, acessar esses dados aqui e colocar dentro do meu reducer. Por enquanto, eu ainda não vou fazer isso, o que eu vou fazer? Aqui dentro, eu vou dar apenas um console.log, um response.data, pra gente ver se tá dando tudo certo, tá? Então agora, eu vou salvar isso aqui, perfeito? Volto lá no player, pode ser, na verdade, em qualquer local, tá? E agora, aqui dentro, ao invés de fazer aquele código que eu tinha antes, aqui dentro agora eu vou apenas fazer o dispatch, deletei um monte de código que eu ia utilizar, o dispatch daquela função lá, que é a loadCurse, dessa forma aqui ó. Aqui ela tá dando um errinho, deixa eu ver exatamente o que é, it's not assignable to any parameter, any action, eu acho que aqui, deixa eu ver, loadCurse, deixa eu ver o que eu tô errando, createAsyncThunk, beleza, aqui ele tá dando um errinho porque, desculpa, eu tô usando o useDispatch, que vem de dentro do React Redux, e essa funcionalidade aqui do asyncThunk não é uma funcionalidade nativa do Redux, ela usa por baixo dos panos uma outra biblioteca que se chama ReduxThunk, que é bem antiga também, da mesma época do Redux. E acontece que o Redux, por padrão, ele não entende que essa loadCurse aqui é uma action, então o que eu tenho que fazer quando eu tô usando essa funcionalidade Thunk? Agora que eu fiz esse useAppSelector aqui dentro do meu store, eu vou ter que criar uma outra chamada useAppDispatch, isso aqui tem na própria documentação do Redux do kit, e aqui ele vai ser basicamente uma função que devolve o useDispatch do Redux, só que aqui eu vou tipar ela com o seguinte, deixa eu até comentar aqui em cima, eu vou fazer um export type AppDispatch é igual a typeOfStore.Dispatch, e aí aqui embaixo eu faço ele da seguinte forma, dois pontos, aqui eu boto AppDispatch igual useDispatch, e o useDispatch tem que importar de dentro do React Redux. Agora, teoricamente, se eu voltar aqui e trocar esse useDispatch por useAppDispatch, ele já vai funcionar, veja. E aí outra coisa que é importante, já que a gente fez isso, é ir em todo lugar que a gente tá usando o useDispatch aqui, e trocar também por useAppDispatch, tá? Então salvo aqui, vamos aqui também, useAppDispatch, ele não vai mudar nada na funcionalidade, a única diferença é só o TypeScript mesmo ali, que ele vai entender isso ali. Show! Agora eu volto aqui no navegador e veja que, vamos lá, primeiro, se a gente for no console, eu diminui um pouquinho aqui o zoom só pra gente enxergar melhor, mas se a gente for no console da F5 aqui, veja que olha só, tá vendo que ele deu o console.log, esse console.log tá vindo aqui de dentro do nosso async.thunk, ou seja, o console.log tá funcionando. Só que tem uma coisa ainda mais interessante que tá acontecendo, tá? Se a gente for aqui na aba do Redux, veja que, olha só, lembra o nome que a gente deu aqui pro nosso thunk aqui, a gente tinha dado o nome pra ele de start. Até pra ficar um pouquinho mais organizado, eu vou dar o nome dele de player-load, porque player aqui já é o nome que a gente tá dando pra essa slice, então vou chamar de load aqui. Vou salvar, vou dar um novo F5, olha aqui dentro do Redux, que legal, tá vendo que ele disparou uma action aqui ó, player-load-pending, isso aqui, o que acontece é, todo async.thunk, que é uma action assíncrona do Redux, gera automaticamente três ações disparadas dentro do Redux. Como ela é uma função assíncrona e ela demora um tempinho pra executar, no momento que a gente chama esse load-curse, no momento que aqui na página a gente executa esse load-curse, a primeira coisa que ele faz é, ele dispara uma action chamada pending, isso aqui serve pra que a gente saiba que a requisição ela está pendente, ela está acontecendo, e assim a gente pode mostrar algum sinal de loading na tela, a gente já vai fazer isso. Depois que a requisição termina, das duas uma, ou ele vai retornar fulfilled, no caso da requisição ter dado certo, e aí ele retorna, aqui dentro, os dados que foram requisitados, ou ele retorna failure, no caso da requisição ter falhado. Ou seja, essas actions aqui, elas servem pra que a gente consiga, dentro do nosso reducer, mudar alguma variável aqui dentro, alguma informação, enquanto a requisição está acontecendo, ou depois que ela terminar. E uma das coisas legais é que, como eu estou usando async, aqui eu posso usar a sintaxe de await, então eu posso fazer dessa forma aqui, e se eu retornar algo daqui de dentro, qualquer coisa que eu retorne daqui de dentro, é o conteúdo que vai vir no payload aqui, do meu fulfilled, que é o que retorna quando dá sucesso, então olha só, aqui dentro do payload, tem todos os módulos, que é exatamente o que eu retornei daqui de dentro. Legal né? Show! Beleza, a gente está conseguindo chamar o loadCurse aqui, só que a gente ainda não está preenchendo o nosso reducer com as informações que estão vindo daqui de dentro. Como é que a gente faz isso agora? Será que eu venho aqui dentro e faço um dispatch, mais ou menos como a gente estava fazendo no componente, chamo aqui o start pra preencher os dados do curso? Na verdade não, quando a gente usa o asyncSync, e ele cria essas actions pra gente automaticamente, o que a gente pode fazer, eu vou tirar esse start aqui, porque a gente não vai mais usar ele, e aqui embaixo dos reducers, eu posso passar uma outra opção chamada extraReducers. Esse extraReducers aqui, é uma função que recebe esse carinha aqui chamado builder, e aí eu vou fazer da seguinte forma, builder.addCase, e passo pra ele o nome do meu asyncSync, que é loadCurse, .fulfilled, ou seja, eu quero executar alguma coisa quando a ação de fulfilled do meu asyncSync for executada, mais ou menos igual como a gente está fazendo aqui nos nossos reducers. Aqui eu quero fazer algo quando o play for executado, aqui eu estou falando que eu quero fazer algo que é uma função igual a gente tem ali em cima, state, action, da mesma forma, quando o fulfilled desse asyncSync for chamado. E aí o que eu posso fazer aqui dentro, state.curse igual action.payload, salvo isso aqui, volto na aplicação e pronto, ele já está carregando aqui o nosso curso. Então olha que interessante, até voltando aqui, o nosso fulfilled agora, quando ele foi chamado, ele fez uma alteração no nosso estado, trocando o curso de nulo para os dados que vieram do curso da nossa API. Então é bem interessante, é muito interessante o que o Redux faz, e isso, o que está acontecendo aqui por baixo dos panos, e aqui eu cliquei em alguma coisa que bugou a minha extensão do Redux, não sei o porquê, bom, acho que eu vou ter que fechar o browser e abrir de novo daqui a pouco, mas tá, por enquanto deixa assim, mas o que está se passando aqui por baixo dos panos, por que a gente criou esse extraReducers? Porque esse extraReducers é uma forma de eu fazer com que um reducer do Redux, que por exemplo aqui é o player, ouça actions, ouça disparos de ações de outros locais, que podem ser outros reducers, outras slices, ou podem ser esses nossos asyncthunks aqui. Então beleza, a gente carregou aqui os nossos dados, só que agora, como eu falei, seria legal se quando a gente desse um F5 aqui ou carregasse, a gente mostrasse alguns sinais de loading aqui na tela, enquanto a gente está carregando as informações, então bora fazer isso."
  },
  {
    "id": "bbb62135-eb78-4938-8f08-823315a36593",
    "title": "Criando interface de loading",
    "transcription": "Como eu falei, além da nossa action de fulfilled, a gente também pode criar um outro case aqui pra action de pending. E aqui não tem nenhum tipo de payload, mas a gente pode atualizar alguma informação aqui dentro do nosso estado pra dizer que o curso ainda tá carregando. Então, por exemplo, aqui em cima onde a gente tem o playerState, eu vou criar uma informação, um booleano, um isLoading, por exemplo, como sendo um booleano. Aqui no initialState esse isLoading vai iniciar como true. Ou melhor, pode ser como true. E aqui eu vou fazer o seguinte, dentro do pending eu vou novamente mudar isso aqui pra true, porque eu posso chamar a função de load duas vezes. E aqui no fulfilled eu vou voltar o isLoading pra falso. E agora, o que eu vou fazer aqui, nos locais que eu quero mostrar algum tipo de loading, só que no exemploState eu preciso sempre atualizar. Então, aqui eu vou fazer um isLoading como sendo falso. Aqui no teste, só pra ele não dar erro. Agora, lá dentro, por exemplo, do vídeo que eu quero mostrar algum tipo de loading, o que eu vou fazer aqui dentro? Eu vou fazer um const isCourseLoading igual useAppSelectorState.player.isLoading. E aí eu vou fazer o seguinte, aqui dentro, se estiver carregando eu vou mostrar alguma coisa, senão eu vou mostrar o player do vídeo. Vou botar aqui o player do vídeo. Se estiver carregando, eu vou botar uma div className flex. Vou falar pra ela ocupar toda a altura. Vou dar um itemCenter e um justifyCenter. E dentro dela eu vou colocar um spinner. Deixa eu ver se eu consigo... Loader, que vem de dentro do Lucid React. Passar um className W5, um pouco maior, W6H6. Um textZinc 400. E vou passar uma propriedade do Thaywind chamada animateSpin, que ele vai ficar girando. E aqui, o que acontece é que ele pode ainda não ter a current lesson. Então eu vou fazer o seguinte, vou botar um pontinho de interrogação aqui. Salvo aqui. F5, viu? Ficou um loadingzinho aqui. E quando carregou, já mostrou. Acho que ficou legal o loading dessa forma. E aí, acontece que a nossa sidebar acaba ficando vazia. E o nosso cabeçalho também acaba ficando vazio. Então a gente poderia fazer algo semelhante nesses dois lugares. No cabeçalho, sendo bem sincero, não tem muita coisa que dê pra fazer que vá ficar muito legal. Eu acho que teria que ter um designer aqui e não eu. O que eu posso fazer... Enquanto estiver loading aqui, eu posso... Deixa eu pensar. O que eu poderia botar aqui? Eu acho que não tem muita coisa pra colocar assim. Poderia botar um carregando só. Então, mostrar um H1 dessa forma. Carregando. Eu não vou me prender muito aos detalhes visuais. Vou ficar carregando e mostro. Porque, como eu falei, precisaria de um designer aqui pra dar um pouquinho mais de instruções. E aqui na direita, uma das coisas que talvez seriam legais. E eu deixo até como desafio pra você. No tailwind, a gente tem uma animação pronta aqui. Que é o pulse. Pra fazer aqueles skeleton screens, como por exemplo esse aqui. Então seria legal a gente criar uma skeleton screen. Como se fosse um preview de carregamento. Acho que ficaria bem legal também. Eu vou deixar isso como desafio pra você. Porque senão é muito tempo. Algo que a gente não vai aprender muita coisa relacionada aqui ao Redux. Que a gente já entendeu como é que a gente faz esse processo de mostrar um loading aqui dentro da aplicação."
  },
  {
    "id": "4f932ec4-5881-49f5-8da6-fa7300290da6",
    "title": "Setup do Zustand",
    "transcription": "Nessa aula a gente vai conhecer uma ferramenta que pode substituir o Redux, porque por mais que o Redux seja uma ferramenta muito famosa na comunidade React e grande parte dos projetos, principalmente os um pouquinho mais antigos, utilizam essa ferramenta e é super legal, super útil você saber utilizar essa ferramenta, o Redux ainda é muito verboso e ele ainda envolve, digamos, muito aprendizado novo para a gente conseguir utilizar o Redux. A gente tem que aprender o que são Thunks, como a gente utilizou aqui para funções assíncronas, entender Reducers, entender Actions, entender arquitetura Flux como eu mostrei, Slices, então tem muito conceito novo envolvido, principalmente para quem está construindo uma nova aplicação. Por isso existe uma outra biblioteca chamada Zustand, que ela ficou bem famosa de 3 anos para cá, e essa Zustand é uma ferramenta feita praticamente para substituir o Redux, inclusive boa parte da documentação dela é voltada em como que a gente migra do Redux para dentro do Zustand e ela tem exatamente o mesmo conceito do Redux, de ter um estado global, então o Redux também tem essa ideia de a gente ter um grande estado compartilhado entre toda a nossa aplicação, diferente de outras soluções de State Management, como a gente pode fazer com a Context API ou com o JTAI, por exemplo, que é uma outra ferramenta legal, onde a gente tem a ideia de estados locais, menores, e não um estado global compartilhado em toda a aplicação, mas aqui até a gente pode ver o que é o Zustand Over Redux. Então a ideia é que ele é simples e não opinado, não opinado quer dizer que você não necessariamente precisa seguir a estrutura dele, ele vem, digamos, com as funcionalidades, você cria a sua própria estrutura, e ele fala também, isso aqui é uma das coisas muito legais, é que ele não precisa fazer um wrap da sua aplicação em Context Providers, ou seja, o Zustand não usa a Context API do React, isso evita que a gente faça renderizações desnecessárias na nossa aplicação, então ele consegue ser ainda mais performático do que o Redux em si. Mas por ele não utilizar Context, ele usa por baixo dos panos, acho que é legal caso você tenha interesse em estudar, ele usa uma estratégia que a gente chama de Signals, que é uma estratégia de atualização de variáveis, onde você não observa o valor das variáveis, e sim ela avisa quando mudou. É uma ideia diferente, ao invés de você fazer um PubSub, onde você tem ali o componente do React ouvindo alterações numa variável, é um caminho inverso, então é como se o Zustand conseguisse avisar o componente que ele precisa renderizar, ao invés do componente ficar ouvindo, observando se ele precisa renderizar novamente. Então é uma ideia diferente, não necessariamente você precisa saber isso para utilizar o Zustand, a ideia do API do Zustand, como ela é muito baseada no Redux, ela veio para substituir o Redux, ela é muito escamelhante, a gente vai ver que boa parte do código que a gente criou aqui, ele pode ser reaproveitado quando a gente usa o Zustand. E para a gente não perder o que a gente já fez até agora, o que eu vou fazer aqui, ao invés de deletar a pasta Store, eu vou criar uma nova pasta chamada Zustand Store, para a gente ir migrando aos pouquinhos e entender como que a gente faz o uso dessa ferramenta. Antes de mais nada, eu vou precisar instalar o Zustand aqui dentro, e aqui é simplesmente só o Zustand, eu não vou precisar instalar nenhuma outra ferramenta aqui dentro. E agora, olha que interessante, a gente vai aqui no Zustand Store, eu vou criar um index.ts, e a gente vai começar criando o nosso primeiro Store aqui dentro da aplicação. Eu vou começar exportando uma constante chamada useStore, que é igual a create, que vem de dentro de Zustand, e esse create aqui, ele recebe uma função. Essa função, ela recebe dois parâmetros, ela tem dois parâmetros aqui dentro, que é o set e o get. E o set e o get é basicamente duas funções onde o get eu posso usar para buscar informações que estão salvas no estado, enquanto o set é uma função para eu atualizar alguma informação do estado. E isso aqui funciona quase como o estado do react, a única diferença é que no estado do react a gente não tem o get, a gente pode acessar diretamente o valor do estado através de uma variável. Aqui a gente tem que usar o get, que é uma função que retorna esse valor. E daqui de dentro, eu só preciso retornar qual que é as informações que eu quero compartilhar entre todos os componentes. Então, aqui para a gente começar, o que eu vou fazer? Eu venho aqui no meu server.json e eu vou copiar esse conteúdo, ou melhor, pode ser, eu vou copiar esse conteúdo dos cursos, ou melhor, o único curso que está aqui dentro, com o id, módulos, até o cochete fechar. E aqui dentro eu vou jogar uma variável course, ou melhor, eu vou começar o curso como nulo mesmo, assim como a gente está fazendo no estado do Redux. E outra coisa que eu posso fazer já é copiar essas informações que eu tenho aqui dentro. Então, eu vou fazer o seguinte, essas duas interfaces que eu tenho, o course e o playerState, elas vão ser reaproveitadas aqui dentro do Zustand. Então, eu vou copiar aqui para dentro. E aqui no Zustand, o que eu posso fazer? Esse método create pode receber, ele é um generic. O generic nada mais é no TypeScript como se fosse uma função que pode receber um parâmetro de tipagem, para eu falar para essa função qual que é o tipo de alguma informação que tem ali dentro dela. E basicamente o create, aqui a gente pode ver até a assinatura do método create, que o primeiro parâmetro que ela recebe é o T. O T, que eu não gosto quando usa T, porque eu acho muito genérico, mas o T ele é basicamente enviado aqui para esse stateCreator, e o T ele significa qual que é o formato do nosso estado. Eu não vou conseguir entrar aqui em todo o TypeScript, mas aqui a gente pode enviar o playerState. Então, automaticamente já começa a dar erro aqui, porque ele pede que esse return aqui dentro, que é o valor inicial do nosso estado, ele tem exatamente as informações que eu falei que estão contidas aqui na minha interface. Então, basta eu vir aqui, copiar o conteúdo do initialState, lembra? E venho aqui e jogo aqui dentro, olha só, ele já passou a parar de dar erro. Legal, né? Então, a gente já tem o nosso estado criado, e essas aqui são as informações que são compartilhadas. Só que uma coisa que a gente não fez ainda é enviar essas funções que eu tenho aqui dentro, play e next, lá pra dentro. Então, é isso que a gente vai fazer aqui agora. Eu vou começar copiando aqui o play e o next em si, e vou jogar aqui dentro, junto dentro desse return. Só que aqui a gente não vai ter nenhum parâmetro dentro de state, nenhum parâmetro aqui. Ou melhor, no play a gente até vai ter, mas só que vai ser um pouquinho diferente, mas eu vou tirar daqui, e do next também. No play, eu não vou passar aquela action, payload, nada disso. Eu vou falar diretamente aqui os parâmetros que eu recebo. Então, eu vou receber um array, certo? E aqui eu estou desestruturando esse array. Então, é basicamente um array de moduleAndLessonIndex, né? Se você preferir, você pode fazer dessa forma, e falar que ele é um array com dois números, dessa forma, e desestruturar ele aqui embaixo. Então, pode fazer, por exemplo, const moduleIndex lessonIndex, e aí a gente usa isso aqui embaixo, no lugar onde estava o action payload, porque no sustain a gente não tem esse payload, a gente recebe diretamente o parâmetro aqui dentro. E aqui embaixo, a gente não atualiza o estado usando state. A gente usa essa função aqui, set. Então, eu uso set, e aqui eu dou um ctrl espaço e ele já está tipado. Então, eu quero atualizar o currentModuleIndex, uso dois pontos aqui, e quero atualizar o currentLessonIndex, igual o setState do próprio react, que faltou uma virgulazinha. Então, pronto, a gente está atualizando essas duas variáveis. Aqui no next, a gente vai fazer algo semelhante. Porém, novamente, se eu quero acessar informações que estão contidas dentro do meu estado, como eu estou fazendo aqui, eu preciso usar o método get, o método get que vai me retornar o estado. Então, eu faço ele da seguinte forma, eu vou fazer um get, esse get aqui não recebe parâmetros, ele é um método que vai retornar todos os dados do estado, e aqui eu posso falar quais informações eu quero pegar. Nesse caso, é o currentLessonIndex, eu preciso do currentModuleIndex também, e preciso do curso. E aqui embaixo, só vou tirando o state, em todos os lugares que eu usei essas informações, eu vou tirando o state aqui também, vou tirando o state aqui também. Nos lugares que eu estou atualizando o state, a gente muda para o set, como eu já tinha mostrado antes. Então, aqui eu quero atualizar o currentLessonIndex para nextLessonIndex, aqui embaixo também. Quando são duas atualizações, posso fazer no mesmo set. Então, vem aqui para o nextModuleIndex e o currentLessonIndex para zero. O que eu errei aqui? currentModuleIndex. Ah, aqui faltou nextModuleIndex. Perfeito, olha só, já não está mais dando erro nenhum. Só que, uma das coisas importantes é que, veja que agora, esse meu return aqui de dentro do sustent, ele não tem mais só as variáveis, ele tem também esses métodos, play e next. Então, é legal também, dentro dessa minha interface do PlayerState, eu tipar essas funções. Então, falar que eu vou ter uma variável play, que ela é uma função, essa função recebe dois números. Então, eu posso botar aqui array, número, número. Ou melhor, aqui, melhor não fazer dessa forma. O que eu posso fazer aqui é fazer o seguinte, mais ou menos a mesma assinatura que eu fiz aqui embaixo, botar um nome para a variável, que é um número e um número. E ela não tem retorno, então é void. E eu vou ter uma outra função, next, que não recebe parâmetro, e o retorno é void, porque não tem nenhum return ali dentro. Então, é legal a gente deixar tipado no sustent também, os métodos. No sustent, diferente do Redux, os dados e os métodos, eles ficam exatamente dentro da mesma estrutura. Voltando aqui, a única coisa que a gente não migrou, ainda aqui para dentro do sustent, é o nosso método do load, que carrega os dados iniciais aqui do curso e essa parte do loading aqui dentro. Então, a gente vai fazer isso já, já. Mas, por enquanto, aqui já está criando forma. Logo, eu ainda não consigo testar, porque como não tem dados do curso aqui, eu poderia até preencher com dados do curso. Mas, vamos terminar aqui, depois a gente testa junto, vai dar tudo certo."
  },
  {
    "id": "dc21afe1-d011-4e09-b898-f54140622eb9",
    "title": "Testes unitários no zustand",
    "transcription": "Nessa aula, o que a gente vai fazer é migrar nossos testes unitários aqui do Redux para dentro do Zustand, utilizando também o vTest, né? E aqui, o que a gente vai começar fazendo é dentro do Zustand Store. Eu vou criar aqui um store.spec.cs, tá? E aqui a gente vai começar escrevendo os testes. E eu vou copiar mais ou menos os testes que a gente tem no Redux, né? Então, eu vou copiar esse primeiro teste aqui, ó, shouldBeAbleToPlay. Opa, era pra copiar o teste inteiro. Vamos importar a função it de dentro do vTest e o expect dentro do vTest também. E aqui no caso do Zustand, a gente não tem esse reducer aqui, né? Então, a gente vai ter que fazer um pouquinho diferente, tá? Eu vou importar, começar importando de dentro da raiz aqui mesmo, do ponto, né, que ele vai pegar do índex, a nossa função useStore. E o useStore, aqui ele tem algo legal, que é o seguinte. No useStore, se eu chamo a função, ele me retorna o estado. Então, eu consigo acessar os dados. Mas se eu não chamo a função e uso um ponto aqui, eu tenho algumas funções que eu posso utilizar. Por exemplo, getState pra pegar os dados do estado e setState pra alterar os dados do estado. E aqui eu posso fazer um set, alterando o que eu quiser de informação lá dentro. E o que eu vou fazer aqui dentro pra gente testar essa primeira função, né? Primeira coisa, o nosso estado aqui, ó, ele inicia com o valor de curso nulo, aqui embaixo. Então, se eu for testar a função play, não vai funcionar, porque, na verdade, a função play, ela nem tá validando se existe um curso, né? Ela só vai lá e troca. Então, bom, a função play vai funcionar de qualquer jeito. Então, vamos testar ela e depois a gente faz essa questão do curso, tá? Como é que a gente vai fazer aqui, ó? Eu vou dar um useStore getState, porque se eu faço só useStore, isso aqui é um hook, isso aqui só funciona dentro de componentes React. Então, quando eu tô fora de componentes React, se eu quero acessar os dados do store, eu preciso usar dessa forma, tá? E aí, aqui dentro, ele me retorna tudo. Então, eu posso pegar, inclusive, a função play. E aqui, eu vou fazer play, passo os parâmetros 1 e 2. E aí, pra validar que trocou as informações, eu vou fazer o seguinte const useStore.getState de novo, tá? E aqui eu vou pegar os dados de currentModuleIndex e currentLessonIndex. E eu valido que essas informações aqui, elas são 1 e 2, né? Então, olha, bem mais simples até o teste, né? E agora, eu rodo o npm run test, aguardo um pouquinho, e veja que aqui o nosso StoreSpec já passou. Ele tá rodando o teste também lá do Redux, porque eu não dedotei ainda a parte do Redux, né? Por isso que ainda tá funcionando. Inclusive, agora, eu acho que a gente já pode... Ah, eu não vou dedotar a parte do Redux, senão eu vou dedotar os testes que eu preciso copiar aqui, né? Beleza, o próximo teste aqui é da função next. Então, it should be able to play next video automatically. Então, nesse caso aqui da função next, uma das exigências que a gente tem é que o nosso curso, ele tem que ter algum módulo lá dentro, né? Só que ele começa como nulo. Então, o que a gente vai fazer aqui de forma diferente, né? Aqui de dentro do nosso PlayerSpec, eu não vou copiar todas essas informações do initial state. Eu vou copiar apenas o curso, o objeto aqui do curso, tá vendo? Só esse objeto grande aqui do curso, que tem um módulo id. Vou tirar daqui de dentro. Ou melhor, vou copiar daqui de dentro pra não quebrar esse teste aqui. E aí, aqui em cima, eu vou criar uma variável curso e vou jogar aqui dentro. Vou até minimizar ela aqui. E agora, antes da gente fazer o teste, nesses testes que a gente precisa ter o curso em si, né? O que eu vou fazer é o seguinte. Eu vou dar um useStore.setState substituindo o meu curso. Então, agora, se eu venho aqui e dou um console.log no useStore.getState, deixa eu comentar o restante. Veja que quando eu rodo os testes, o nosso curso vai estar lá, preenchido. Só que uma das coisas que tu vai perceber também que é ruim aqui na questão dos testes unitários é que esse primeiro teste que testa, se a gente consegue dar um play no vídeo, ele troca o módulo index e o lesson index pra 1 e 2. E aí, quando eu executo esse segundo teste aqui, ele ainda tá 1 e 2. Só que isso é ruim porque a ideia em testes unitários, uma das coisas que a gente precisa é que a cada teste que a gente execute, a nossa aplicação, ou pelo menos a função que a gente está executando, ela tem que estar rodando num ambiente isolado. Ela não pode manter estado da execução do teste anterior. Senão, isso aqui é altamente sensível, porque a ordem dos testes influencia no resultado. Isso é altamente ruim, porque se um dia eu rodar só esse teste ou só esse teste, ele pode falhar ou positivar, baseado na ordem que eles estão executando. Então, isso é ruim. E aí, uma das coisas que é legal a gente fazer é a gente reiniciar o meu estado, o estado inicial que ele tinha, antes de eu começar cada teste. Então, o que a gente vai fazer? Aqui no vTest, eu tenho uma função que se chama beforeEach, que eu consigo, ou seja, executar uma funcionalidade antes de cada teste. Então, beforeEach, quer dizer, antes de cada teste, eu quero executar o código que eu vou colocar aqui dentro. O que vai ser esse código? Olha só. Eu vou fazer um const initialState, ou melhor, isso aqui eu vou fazer aqui fora, porque eu quero executar uma única vez. Então, eu vou dar um useStore.getState. UseStore fica um nome meio estranho, quando eu não uso ele dentro de um componente. Então, aqui nesse caso, eu vou até renomear para useStore, e aí fica mais bonitinho. Eu faço dessa forma aqui. Eu pego todos os lugares que estão usando e deixo só o store. Fica mais legal dessa forma. Veja que eu botei o initialState aqui fora do beforeEach. Por quê? Porque eu quero que ele pegue o valor inicial do estado, que é quando o store inicializa, eu quero isso aqui, o dado inicial. Se eu coloco isso aqui dentro do beforeEach, ele não vai pegar o valor inicial, ele vai pegar o valor atual do estado a cada vez que essa função executar. Então, eu trago aqui para fora. E aqui no beforeEach, o que eu vou fazer é store.setState, passando o meu initialState aqui. Ou seja, isso quer dizer que a cada teste, ele vai substituir o valor do meu estado com o valor inicial que aquele estado tinha quando a aplicação inicializou. Agora, se eu rodar os testes, veja que o ModuleIndex e o LessonIndex vão estar zerados. E aí eu posso fazer o meu teste normalmente. Agora eu posso vir aqui e pegar a função next dentro de store.getState. Essa função next agora não recebe parâmetros, eu só executo ela. E aí eu faço a verificação se o meu CurrentModuleIndex e o meu CurrentLessonIndex agora são 0 e 1. Então, salvo, rodo o teste e veja que o meu teste já passou. Então, agora o que a gente vai fazer é copiar o próximo teste. Então, esse teste aqui. Esse teste aqui é basicamente verificar se ele está pulando para o próximo módulo. Então, eu vou fazer a mesma coisa, vou setar o curso. Vou pegar a função next também. E aí, antes de executar a função next, eu vou dar um store.setState CurrentLessonIndex 1, que é exatamente o que eu estou fazendo aqui. Eu já estou, digamos, colocando que a aula ativa é a aula 1. Então, quando eu executar o next agora, ele tem que trocar para o próximo módulo. Então, aqui eu vou dar um store.getState, eu pego o CurrentModuleIndex e o CurrentLessonIndex e valido que ele trocou. Fui ali atender o interfone e já voltei, mas a próxima e última função que a gente tem que testar aqui é essa aqui. Então, a gente vai copiar e vamos colocar aqui embaixo. E mais ou menos a mesma coisa, né? A gente vai fazer tudo isso aqui. É bem parecido o teste, então eu vou até copiar ele inteiro e jogar aqui embaixo. E só substituir, porque aqui no set, aqui embaixo no setState, a gente tem que setar essas duas coisas, o CurrentModule e o Lesson, diferente do teste anterior, para 1, né? E é isso. O resto a gente apaga. Ah, e o expect aqui embaixo tem que ser 1 e 1. Então, 1 e 1. Salva. Rodamos o teste. E fechou. Passou todos os testes. E agora sim, a gente pode vir aqui no store do Redux e... Explodiu o Redux. Mete aqui um... Cadê? PartyWorks? Ah, meu Deus. Tiraram o comando do Redcast? Ah, Party. Ah, tinha um comando que gerava confete. Ah não, aqui é o confete. E agora a gente testa que a nossa aplicação está funcionando, mesmo sem o Redux, para ver se não restou nenhum erro aqui, né? 5173. Beleza, está aqui rodando o app. Vamos ver se não deu nenhum console log além do vídeo, né? Não, tudo do vídeo. Fechou. Finalizamos nosso app com o Sustained."
  }
]